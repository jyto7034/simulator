This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Cargo.toml
src/main.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Cargo.toml">
[package]
name = "test_client"
version.workspace = true
edition.workspace = true
description.workspace = true

[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1.0"
futures-util = "0.3"
uuid = { version = "1", features = ["v4", "serde"] }
tokio-tungstenite = { version = "0.23", features = ["native-tls"] }
url = "2"

# Added dependencies
async-trait = "0.1.80"
anyhow = "1.0.86"

tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
</file>

<file path="src/main.rs">
use anyhow::Result;
use async_trait::async_trait;
use futures_util::{stream::SplitSink, SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::env;
use std::io;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::time::sleep;
use tokio_tungstenite::{connect_async, tungstenite::Message, MaybeTlsStream, WebSocketStream};
use tracing::{error, info, instrument, warn};
use tracing_appender::non_blocking::WorkerGuard;
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use url::Url;
use uuid::Uuid;

// --- 로거 설정 ---
pub fn setup_logger(player_id: &str) -> WorkerGuard {
    let log_filename = format!("client_{}.log", player_id);
    let file_appender = RollingFileAppender::new(Rotation::NEVER, "logs", log_filename.clone());
    let (non_blocking_file_writer, guard) = tracing_appender::non_blocking(file_appender);

    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));

    let console_layer = fmt::layer().with_writer(io::stdout).pretty();
    let file_layer = fmt::layer()
        .with_writer(non_blocking_file_writer)
        .with_ansi(false);

    tracing_subscriber::registry()
        .with(filter)
        .with(console_layer)
        .with(file_layer)
        .init();

    info!("Logger initialized. Log file: {}", log_filename);
    guard
}

// --- 메시지 정의 ---
#[derive(Serialize)]
struct ClientMessage<'a> {
    #[serde(rename = "type")]
    msg_type: &'a str,
    #[serde(skip_serializing_if = "Option::is_none")]
    player_id: Option<Uuid>,
    #[serde(skip_serializing_if = "Option::is_none")]
    game_mode: Option<&'a str>,
    #[serde(skip_serializing_if = "Option::is_none")]
    loading_session_id: Option<Uuid>,
}

#[derive(Deserialize, Debug)]
struct ServerMessage {
    #[serde(rename = "type")]
    msg_type: String,
    #[serde(default)]
    message: String,
    #[serde(default)]
    loading_session_id: Option<Uuid>,
    #[serde(default)]
    server_address: String,
    #[serde(default)]
    session_id: Option<Uuid>,
}

// --- Type alias for the WebSocket stream sink part ---
type WsSink = SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>;

// --- 플레이어 행동 정의 ---
#[async_trait]
trait PlayerBehavior {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool>;

    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool;

    fn on_match_found(&self, player_id: Uuid) -> bool {
        info!("[{}] >>> SUCCESS: MatchFound received!", player_id);
        false
    }
}

// --- 시나리오별 행동 구현 ---

struct Disconnector;
#[async_trait]
impl PlayerBehavior for Disconnector {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!("[{}] Received StartLoading. Disconnecting now!", player_id);
        ws_sink.close().await?;
        Ok(false)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        error!("[{}] Received unexpected error: {}", player_id, error_msg);
        false
    }
}

struct Victim;
#[async_trait]
impl PlayerBehavior for Victim {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        info!(
            "[{}] Received StartLoading. Sending LoadingComplete.",
            player_id
        );
        let msg = ClientMessage {
            msg_type: "loading_complete",
            loading_session_id: Some(loading_id),
            player_id: None,
            game_mode: None,
        };
        ws_sink
            .send(Message::Text(serde_json::to_string(&msg)?))
            .await?;
        Ok(true)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        if error_msg.contains("disconnected") || error_msg.contains("timed out") {
            info!(
                "[{}] >>> SUCCESS: Received expected cancellation error: {}",
                player_id, error_msg
            );
        } else {
            error!("[{}] Received unexpected error: {}", player_id, error_msg);
        }
        false
    }
}

struct TimeoutPlayer;
#[async_trait]
impl PlayerBehavior for TimeoutPlayer {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_id: Uuid,
        _ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!(
            "[{}] Received StartLoading. Waiting for 65 seconds to cause a timeout...",
            player_id
        );
        sleep(Duration::from_secs(65)).await;
        info!("[{}] Timeout period passed.", player_id);
        Ok(false)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        info!(
            "[{}] Received error (likely after timeout): {}",
            player_id, error_msg
        );
        false
    }
}

struct GhostDisconnector;
#[async_trait]
impl PlayerBehavior for GhostDisconnector {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!(
            "[{}] Received StartLoading. Disconnecting IMMEDIATELY to test race condition!",
            player_id
        );
        ws_sink.close().await?;
        Ok(false)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        error!("[{}] Received unexpected error: {}", player_id, error_msg);
        false
    }
}

// --- Enum Wrapper for Behaviors ---
enum Behavior {
    Disconnect(Disconnector),
    Victim(Victim),
    Timeout(TimeoutPlayer),
    Ghost(GhostDisconnector),
}

#[async_trait]
impl PlayerBehavior for Behavior {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        match self {
            Behavior::Disconnect(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
            Behavior::Victim(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
            Behavior::Timeout(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
            Behavior::Ghost(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
        }
    }

    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        match self {
            Behavior::Disconnect(b) => b.on_error(player_id, error_msg),
            Behavior::Victim(b) => b.on_error(player_id, error_msg),
            Behavior::Timeout(b) => b.on_error(player_id, error_msg),
            Behavior::Ghost(b) => b.on_error(player_id, error_msg),
        }
    }

    fn on_match_found(&self, player_id: Uuid) -> bool {
        match self {
            Behavior::Disconnect(b) => b.on_match_found(player_id),
            Behavior::Victim(b) => b.on_match_found(player_id),
            Behavior::Timeout(b) => b.on_match_found(player_id),
            Behavior::Ghost(b) => b.on_match_found(player_id),
        }
    }
}

// --- 플레이어 실행 로직 ---
#[instrument(skip_all, fields(player_id = %player_id))]
async fn run_player(player_id: Uuid, behavior: Behavior) -> Result<()> {
    info!("Starting player with specific behavior");

    let url = Url::parse("ws://127.0.0.1:8080/ws/")?;
    let (ws_stream, _) = connect_async(url.as_str()).await?;
    info!("Connected to server.");

    let (mut ws_sink, mut ws_stream) = ws_stream.split();

    let enqueue_msg = ClientMessage {
        msg_type: "enqueue",
        player_id: Some(player_id),
        game_mode: Some("Normal_1v1"),
        loading_session_id: None,
    };
    ws_sink
        .send(Message::Text(serde_json::to_string(&enqueue_msg)?))
        .await?;
    info!("Sent enqueue request.");

    while let Some(msg) = ws_stream.next().await {
        let msg = match msg {
            Ok(Message::Text(text)) => text,
            Ok(_) => continue,
            Err(e) => {
                warn!("WebSocket stream error: {}", e);
                break;
            }
        };

        let server_msg: ServerMessage = match serde_json::from_str(&msg) {
            Ok(m) => m,
            Err(e) => {
                warn!("Failed to parse server message: {}. Raw: {}", e, msg);
                continue;
            }
        };

        info!("Received: {:?}", server_msg);

        let continue_loop = match server_msg.msg_type.as_str() {
            "start_loading" => {
                behavior
                    .on_start_loading(
                        player_id,
                        server_msg.loading_session_id.unwrap(),
                        &mut ws_sink,
                    )
                    .await?
            }
            "error" => behavior.on_error(player_id, &server_msg.message),
            "match_found" => behavior.on_match_found(player_id),
            "queued" => true,
            _ => true,
        };

        if !continue_loop {
            break;
        }
    }

    info!("Test finished for this player.");
    Ok(())
}

// --- 시나리오 정의 및 메인 함수 ---

#[derive(Debug, PartialEq, Clone, Copy)]
enum Scenario {
    Disconnect,
    Timeout,
    Ghost,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();
    let scenario_str = args.get(1).map(|s| s.as_str()).unwrap_or("disconnect");
    let role_str = args.get(2).map(|s| s.as_str()).unwrap_or("victim");

    let player_id = Uuid::new_v4();
    let _guard = setup_logger(&player_id.to_string()[..8]);

    let scenario = match scenario_str {
        "disconnect" => Scenario::Disconnect,
        "timeout" => Scenario::Timeout,
        "ghost" => Scenario::Ghost,
        _ => {
            anyhow::bail!(
                "Unknown scenario: {}. Use: disconnect, timeout, ghost",
                scenario_str
            );
        }
    };

    info!("Selected Scenario: {:?}, Role: {}", scenario, role_str);

    let behavior = match (scenario, role_str) {
        (Scenario::Disconnect, "disconnector") => Behavior::Disconnect(Disconnector),
        (Scenario::Disconnect, "victim") => Behavior::Victim(Victim),

        (Scenario::Timeout, "timeout_player") => Behavior::Timeout(TimeoutPlayer),
        (Scenario::Timeout, "victim") => Behavior::Victim(Victim),

        (Scenario::Ghost, "disconnector") => Behavior::Ghost(GhostDisconnector),
        (Scenario::Ghost, "victim") => Behavior::Victim(Victim),

        _ => {
            anyhow::bail!("Invalid role '{}' for scenario '{:?}'", role_str, scenario);
        }
    };

    if let Err(e) = run_player(player_id, behavior).await {
        error!("Player execution failed: {:?}", e);
    }

    sleep(Duration::from_millis(200)).await;
    Ok(())
}
</file>

</files>
