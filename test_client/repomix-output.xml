This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Cargo.toml
src/main.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Cargo.toml">
[package]
name = "test_client"
version.workspace = true
edition.workspace = true
description.workspace = true

[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1.0"
futures-util = "0.3"
uuid = { version = "1", features = ["v4", "serde"] }
tokio-tungstenite = { version = "0.23", features = ["native-tls"] }
url = "2"

tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
</file>

<file path="src/main.rs">
use futures_util::{SinkExt, StreamExt};
use serde_json::{json, Value};
use std::env;
use tokio::time::{sleep, Duration};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use url::Url;
use uuid::Uuid;

use std::io;
use tracing_appender::non_blocking::WorkerGuard;
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

// --- 로거 설정 (수정됨) ---
/// 각 클라이언트 인스턴스에 대한 고유한 로거를 설정하고,
/// 로그 파일이 올바르게 기록되도록 보장하는 WorkerGuard를 반환합니다.
pub fn setup_logger(player_id: Uuid) -> WorkerGuard {
    // 로그 파일 이름에 player_id를 포함하여 고유하게 만듭니다.
    let log_filename = format!("client_{}.log", player_id);
    let file_appender = RollingFileAppender::new(Rotation::NEVER, "logs", log_filename.clone());
    let (non_blocking_file_writer, guard) = tracing_appender::non_blocking(file_appender);

    // 2. 로그 레벨 필터 설정 (환경 변수 또는 기본값 INFO)
    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")); // 기본 INFO 레벨

    // 3. 콘솔 출력 레이어 설정
    let console_layer = fmt::layer()
        .with_writer(io::stdout) // 표준 출력으로 설정
        .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
        .with_thread_ids(true) // 스레드 ID 포함
        .with_thread_names(true) // 스레드 이름 포함
        .with_file(true) // 파일 경로 포함
        .with_line_number(true) // 라인 번호 포함
        .with_target(false) // target 정보 제외 (선택 사항)
        .pretty(); // 사람이 읽기 좋은 포맷

    // 4. 파일 출력 레이어 설정
    let file_layer = fmt::layer()
        .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
        .with_ansi(false) // 파일에는 ANSI 코드 제외
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .with_target(false)
        .pretty();

    // 5. 레지스트리(Registry)에 필터와 레이어 결합
    tracing_subscriber::registry()
        .with(filter) // 필터를 먼저 적용
        .with(console_layer) // 콘솔 레이어 추가
        .with(file_layer) // 파일 레이어 추가
        .init(); // 전역 Subscriber로 설정

    tracing::info!("Logger initialized. Log file: {}", log_filename);
    guard
}

// --- 역할별 클라이언트 로직 (기존과 동일) ---

/// 역할 A: 매칭 후 로딩 중에 연결을 끊는 클라이언트
async fn run_disconnector(player_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("[{}] Starting as DISCONNECTOR", player_id);

    let url = Url::parse("ws://127.0.0.1:8080/ws/")?;
    let (mut ws_stream, _) = connect_async(url.as_str())
        .await
        .expect("Failed to connect");
    tracing::info!("[{}] Connected.", player_id);

    let enqueue_msg =
        json!({ "type": "enqueue", "player_id": player_id, "game_mode": "Normal_1v1" });
    ws_stream
        .send(Message::Text(enqueue_msg.to_string()))
        .await?;
    tracing::info!("[{}] Sent enqueue request.", player_id);

    while let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        if let Message::Text(text) = msg {
            tracing::info!("[{}] Received: {}", player_id, text);
            let server_msg: Value = serde_json::from_str(&text)?;
            if server_msg["type"].as_str() == Some("start_loading") {
                tracing::warn!("[{}] Received StartLoading. Disconnecting now!", player_id);
                ws_stream.close(None).await?;
                break;
            }
        }
    }
    tracing::info!("[{}] Test finished.", player_id);
    Ok(())
}

/// 역할 B: 매칭이 취소된 후, 유령 플레이어가 아닌 새로운 플레이어와 다시 매칭되는지 확인하는 클라이언트
async fn run_victim(player_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("[{}] Starting as VICTIM", player_id);

    let url = Url::parse("ws://127.0.0.1:8080/ws/")?;
    let (mut ws_stream, _) = connect_async(url.as_str())
        .await
        .expect("Failed to connect");
    tracing::info!("[{}] Connected.", player_id);

    let enqueue_msg =
        json!({ "type": "enqueue", "player_id": player_id, "game_mode": "Normal_1v1" });
    ws_stream
        .send(Message::Text(enqueue_msg.to_string()))
        .await?;
    tracing::info!("[{}] Sent enqueue request.", player_id);

    let mut is_requeued = false;

    while let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        if let Message::Text(text) = msg {
            tracing::info!("[{}] Received: {}", player_id, text);
            let server_msg: Value = serde_json::from_str(&text)?;
            match server_msg["type"].as_str() {
                Some("error")
                    if server_msg["message"]
                        .as_str()
                        .unwrap()
                        .contains("disconnected") =>
                {
                    tracing::info!(
                        "[{}] Match cancelled as expected. I am now back in the queue.",
                        player_id
                    );
                    is_requeued = true;
                }
                Some("start_loading") => {
                    if !is_requeued {
                        tracing::info!("[{}] First match found (with disconnector). Waiting for cancellation...", player_id);
                    } else {
                        tracing::info!(
                            "[{}] Second match found! This should be with the newcomer.",
                            player_id
                        );
                        let loading_id =
                            Uuid::parse_str(server_msg["loading_session_id"].as_str().unwrap())?;
                        tracing::info!("[{}] Simulating asset loading...", player_id);
                        sleep(Duration::from_secs(2)).await;
                        let loading_complete_msg =
                            json!({ "type": "loading_complete", "loading_session_id": loading_id });
                        ws_stream
                            .send(Message::Text(loading_complete_msg.to_string()))
                            .await?;
                        tracing::info!("[{}] Loading complete. Notified server.", player_id);
                    }
                }
                Some("match_found") => {
                    tracing::info!(
                        "[{}] Successfully received MatchFound. Bug is fixed!",
                        player_id
                    );
                    break;
                }
                _ => {}
            }
        }
    }
    tracing::info!("[{}] Test finished.", player_id);
    Ok(())
}

/// 역할 C: 앞선 매칭이 취소된 후, 대기열에 있던 플레이어와 정상적으로 매칭되는지 확인하는 클라이언트
async fn run_newcomer(player_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("[{}] Starting as NEWCOMER. Waiting 5 seconds...", player_id);
    sleep(Duration::from_secs(5)).await; // A와 B가 먼저 매칭되도록 잠시 대기

    let url = Url::parse("ws://127.0.0.1:8080/ws/")?;
    let (mut ws_stream, _) = connect_async(url.as_str())
        .await
        .expect("Failed to connect");
    tracing::info!("[{}] Connected.", player_id);

    let enqueue_msg =
        json!({ "type": "enqueue", "player_id": player_id, "game_mode": "Normal_1v1" });
    ws_stream
        .send(Message::Text(enqueue_msg.to_string()))
        .await?;
    tracing::info!("[{}] Sent enqueue request.", player_id);

    while let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        if let Message::Text(text) = msg {
            tracing::info!("[{}] Received: {}", player_id, text);
            let server_msg: Value = serde_json::from_str(&text)?;
            match server_msg["type"].as_str() {
                Some("start_loading") => {
                    tracing::info!(
                        "[{}] Match found! This should be with the victim.",
                        player_id
                    );
                    let loading_id =
                        Uuid::parse_str(server_msg["loading_session_id"].as_str().unwrap())?;
                    tracing::info!("[{}] Simulating asset loading...", player_id);
                    sleep(Duration::from_secs(2)).await;
                    let loading_complete_msg =
                        json!({ "type": "loading_complete", "loading_session_id": loading_id });
                    ws_stream
                        .send(Message::Text(loading_complete_msg.to_string()))
                        .await?;
                    tracing::info!("[{}] Loading complete. Notified server.", player_id);
                }
                Some("match_found") => {
                    tracing::info!(
                        "[{}] Successfully received MatchFound. Bug is fixed!",
                        player_id
                    );
                    break;
                }
                _ => {}
            }
        }
    }
    tracing::info!("[{}] Test finished.", player_id);
    Ok(())
}

/// 일반적인 매칭 성공 흐름을 테스트하는 기본 클라이언트
async fn run_normal(player_id: Uuid) -> Result<(), Box<dyn std::error::Error>> {
    tracing::info!("[{}] Starting in NORMAL mode", player_id);
    let url = Url::parse("ws://127.0.0.1:8080/ws/")?;
    let (mut ws_stream, _) = connect_async(url.as_str())
        .await
        .expect("Failed to connect");
    tracing::info!("[{}] Connected.", player_id);

    let enqueue_msg =
        json!({ "type": "enqueue", "player_id": player_id, "game_mode": "Normal_1v1" });
    ws_stream
        .send(Message::Text(enqueue_msg.to_string()))
        .await?;
    tracing::info!("[{}] Sent enqueue request.", player_id);

    while let Some(msg) = ws_stream.next().await {
        let msg = msg?;
        if let Message::Text(text) = msg {
            tracing::info!("[{}] Received: {}", player_id, text);
            let server_msg: Value = serde_json::from_str(&text)?;
            match server_msg["type"].as_str() {
                Some("start_loading") => {
                    let loading_id =
                        Uuid::parse_str(server_msg["loading_session_id"].as_str().unwrap())?;
                    tracing::info!("[{}] Simulating asset loading...", player_id);
                    sleep(Duration::from_secs(2)).await;
                    let loading_complete_msg =
                        json!({ "type": "loading_complete", "loading_session_id": loading_id });
                    ws_stream
                        .send(Message::Text(loading_complete_msg.to_string()))
                        .await?;
                    tracing::info!("[{}] Loading complete. Notified server.", player_id);
                }
                Some("match_found") => {
                    tracing::info!("[{}] Match found! Shutting down.", player_id);
                    break;
                }
                _ => {}
            }
        }
    }
    tracing::info!("[{}] Test finished.", player_id);
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // player_id를 먼저 생성합니다.
    let player_id = Uuid::new_v4();

    // 로거를 설정하고 guard를 받아서 main 함수가 끝날 때까지 유지합니다.
    // 이렇게 하면 프로그램 종료 직전까지 모든 로그가 파일에 기록되는 것을 보장합니다.
    let _guard = setup_logger(player_id);

    let args: Vec<String> = env::args().collect();
    let role = args.get(1).map(|s| s.as_str());

    match role {
        Some("disconnector") => run_disconnector(player_id).await?,
        Some("victim") => run_victim(player_id).await?,
        Some("newcomer") => run_newcomer(player_id).await?,
        Some("normal") | None => run_normal(player_id).await?,
        Some(other) => {
            tracing::error!("Unknown role: {}", other);
            println!("Usage: cargo run --bin test_client -- [disconnector|victim|newcomer|normal]");
        }
    }

    Ok(())
}
</file>

</files>
