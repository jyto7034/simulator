This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Cargo.toml
src/behavior.rs
src/copy.rs
src/lib.rs
src/main.rs
src/observer.rs
src/scenario.rs
tests/test.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Cargo.toml">
[package]
name = "test_client"
version.workspace = true
edition.workspace = true
description.workspace = true

[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1.0"
futures-util = "0.3"
uuid = { version = "1", features = ["v4", "serde"] }
tokio-tungstenite = { version = "0.23", features = ["native-tls"] }
url = "2"
actix-web = "4.11.0"
chrono = { version = "0.4", features = ["serde"] }

# Added dependencies
async-trait = "0.1.80"
anyhow = "1.0.86"

tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }

# Environment configuration
simulator_env = { path = "../simulator_env" }
</file>

<file path="src/behavior.rs">
use anyhow::Result;
use async_trait::async_trait;
use futures_util::{stream::SplitSink, SinkExt};
use serde::{Deserialize, Serialize};
use tokio::net::TcpStream;
use tokio_tungstenite::{tungstenite::Message, MaybeTlsStream, WebSocketStream};
use tracing::{error, info, warn};
use uuid::Uuid;

type WsSink = SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>;

// --- 메시지 정의 ---
#[derive(Serialize)]
#[serde(tag = "type")]
enum ClientMessage {
    #[serde(rename = "enqueue")]
    Enqueue { player_id: Uuid, game_mode: String },
    #[serde(rename = "loading_complete")]
    LoadingComplete { loading_session_id: Uuid },
}

#[derive(Deserialize, Debug)]
struct ServerMessage {
    #[serde(rename = "type")]
    msg_type: String,
    #[serde(default)]
    message: String,
    #[serde(default)]
    loading_session_id: Option<Uuid>,
    #[serde(default)]
    server_address: String,
    #[serde(default)]
    session_id: Option<Uuid>,
}

/// 플레이어 행동을 정의하는 trait
/// 매칭 서버와의 상호작용에서 발생하는 모든 이벤트에 대한 반응을 정의
#[async_trait]
pub trait PlayerBehavior {
    /// 0. 매칭 실패 시 (모든 단계에서 발생 가능)
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        error!("[{}] Error occurred: {}", player_id, error_msg);
        false // 기본적으로 에러 시 종료
    }

    /// 1. 매칭 시작 - 큐 진입 메시지 전송
    async fn start_match(&self, player_id: Uuid, _ws_sink: &mut WsSink) -> Result<bool> {
        info!("[{}] Starting match - sending enqueue message", player_id);
        Ok(true) // 기본적으로 계속 진행
    }

    /// 2. 매칭 성공 - 상대방이 발견되었을 때
    fn on_match_found(&self, player_id: Uuid) -> bool {
        info!("[{}] Match found - opponent discovered!", player_id);
        true // 기본적으로 로딩 단계로 진행
    }

    /// 3. 로딩 시작 - 게임 에셋 로딩 시작 알림
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_session_id: Uuid,
        _ws_sink: &mut WsSink,
    ) -> Result<bool> {
        info!(
            "[{}] Loading started - session: {}",
            player_id, loading_session_id
        );
        Ok(true) // 기본적으로 계속 진행
    }

    /// 4. 로딩 완료 - 모든 플레이어의 로딩이 완료된 후
    async fn on_loading_complete(&self, player_id: Uuid, _ws_sink: &mut WsSink) -> Result<bool> {
        info!("[{}] Loading complete - ready to start game", player_id);
        Ok(false) // 기본적으로 테스트 완료 후 종료
    }
}

// --- 구체적인 행동 구현들 ---

/// 정상적인 플레이어 - 모든 단계를 순서대로 완주
#[derive(Clone)]
pub struct NormalPlayer;

#[async_trait]
impl PlayerBehavior for NormalPlayer {
    /// client 측에서 match server 에 enqueue msg 전송.
    async fn start_match(&self, player_id: Uuid, ws_sink: &mut WsSink) -> Result<bool> {
        info!("[{}] Normal player starting match", player_id);

        let msg = ClientMessage::Enqueue {
            player_id,
            game_mode: "Normal_1v1".to_string(),
        };

        ws_sink
            .send(Message::Text(serde_json::to_string(&msg)?))
            .await?;

        info!("[{}] Enqueue message sent", player_id);
        Ok(true)
    }

    fn on_match_found(&self, player_id: Uuid) -> bool {
        info!("[{}] Normal player excited about match!", player_id);
        true
    }

    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_session_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        info!("[{}] Normal player starting to load assets", player_id);

        // 정상적으로 loading_complete 메시지 전송
        let msg = ClientMessage::LoadingComplete { loading_session_id };

        ws_sink
            .send(Message::Text(serde_json::to_string(&msg)?))
            .await?;

        info!("[{}] Normal player sent loading_complete", player_id);
        Ok(true)
    }

    async fn on_loading_complete(&self, player_id: Uuid, _ws_sink: &mut WsSink) -> Result<bool> {
        info!(
            "[{}] Normal player successfully completed the flow!",
            player_id
        );
        Ok(false) // 성공적으로 완료했으므로 종료
    }
}

/// 매칭 중 나가는 플레이어 - 큐에서 기다리다가 포기
#[derive(Clone)]
pub struct QuitDuringMatch;

#[async_trait]
impl PlayerBehavior for QuitDuringMatch {
    async fn start_match(&self, player_id: Uuid, ws_sink: &mut WsSink) -> Result<bool> {
        warn!("[{}] Impatient player - quitting during match!", player_id);
        ws_sink.close().await?;
        Ok(false) // 연결 끊고 종료
    }
}

/// 로딩 중 연결 끊는 플레이어 - 로딩 시작되자마자 나가기
#[derive(Clone)]
pub struct QuitDuringLoading;

#[async_trait]
impl PlayerBehavior for QuitDuringLoading {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_session_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!("[{}] Quitting during loading start!", player_id);
        ws_sink.close().await?;
        Ok(false)
    }
}

/// 느린 로더 - 로딩에 오랜 시간이 걸리는 플레이어
#[derive(Clone)]
pub struct SlowLoader {
    pub delay_seconds: u64,
}

#[async_trait]
impl PlayerBehavior for SlowLoader {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_session_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!(
            "[{}] Slow loader - waiting {} seconds",
            player_id, self.delay_seconds
        );

        tokio::time::sleep(tokio::time::Duration::from_secs(self.delay_seconds)).await;

        let msg = ClientMessage::LoadingComplete { loading_session_id };

        ws_sink
            .send(Message::Text(serde_json::to_string(&msg)?))
            .await?;
        info!("[{}] Slow loader finally sent loading_complete", player_id);
        Ok(true)
    }
}

/// 매칭 성공 무시 - match_found를 받아도 로딩 단계로 가지 않음
#[derive(Clone)]
pub struct IgnoreMatchFound;

#[async_trait]
impl PlayerBehavior for IgnoreMatchFound {
    fn on_match_found(&self, player_id: Uuid) -> bool {
        warn!("[{}] Ignoring match found - staying in queue", player_id);
        false // 로딩 단계로 가지 않고 종료
    }
}

// --- 연결 문제 행동들 ---
pub struct UnstableConnection; // 간헐적 연결 끊김
pub struct SlowConnection; // 네트워크 지연
pub struct SuddenDisconnect; // 갑작스런 종료
pub struct HeartbeatFailure; // 120초 하트비트 실패

// --- 로딩 단계 문제 행동들 ---
pub struct LoadingFailure; // 로딩 중 실패 보고
pub struct LoadingIgnorer; // 로딩 메시지 무시
pub struct PartialLoader; // 일부만 로딩하고 멈춤

// --- 프로토콜 위반 행동들 ---
pub struct InvalidMessageSender; // 잘못된 JSON 전송
pub struct WrongStateSender; // 잘못된 상태에서 메시지 전송
pub struct DuplicateEnqueuer; // 중복 큐 참가 시도
pub struct InvalidGameMode; // 존재하지 않는 게임 모드

// --- 악의적/스트레스 테스트 행동들 ---
pub struct Spammer; // 메시지 스팸
pub struct ConnectionFlooder; // 연결 폭탄
pub struct MalformedSender; // 의도적 잘못된 데이터
pub struct ResourceExhauster; // 리소스 고갈 유도

// --- 에지 케이스 행동들 ---
pub struct RaceConditionTester; // 동시성 문제 유발
pub struct StateTransitionAbuser; // 상태 전환 악용
pub struct TimingAttacker; // 타이밍 기반 공격
pub struct CleanupEscaper; // 정리 과정 회피

// --- Behavior Enum Wrapper ---
#[derive(Clone)]
pub enum BehaviorType {
    Normal(NormalPlayer),
    QuitDuringMatch(QuitDuringMatch),
    QuitDuringLoading(QuitDuringLoading),
    SlowLoader(SlowLoader),
    IgnoreMatchFound(IgnoreMatchFound),
}

#[async_trait]
impl PlayerBehavior for BehaviorType {
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        match self {
            BehaviorType::Normal(b) => b.on_error(player_id, error_msg),
            BehaviorType::QuitDuringMatch(b) => b.on_error(player_id, error_msg),
            BehaviorType::QuitDuringLoading(b) => b.on_error(player_id, error_msg),
            BehaviorType::SlowLoader(b) => b.on_error(player_id, error_msg),
            BehaviorType::IgnoreMatchFound(b) => b.on_error(player_id, error_msg),
        }
    }

    async fn start_match(&self, player_id: Uuid, ws_sink: &mut WsSink) -> Result<bool> {
        match self {
            BehaviorType::Normal(b) => b.start_match(player_id, ws_sink).await,
            BehaviorType::QuitDuringMatch(b) => b.start_match(player_id, ws_sink).await,
            BehaviorType::QuitDuringLoading(b) => b.start_match(player_id, ws_sink).await,
            BehaviorType::SlowLoader(b) => b.start_match(player_id, ws_sink).await,
            BehaviorType::IgnoreMatchFound(b) => b.start_match(player_id, ws_sink).await,
        }
    }

    fn on_match_found(&self, player_id: Uuid) -> bool {
        match self {
            BehaviorType::Normal(b) => b.on_match_found(player_id),
            BehaviorType::QuitDuringMatch(b) => b.on_match_found(player_id),
            BehaviorType::QuitDuringLoading(b) => b.on_match_found(player_id),
            BehaviorType::SlowLoader(b) => b.on_match_found(player_id),
            BehaviorType::IgnoreMatchFound(b) => b.on_match_found(player_id),
        }
    }

    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_session_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        match self {
            BehaviorType::Normal(b) => {
                b.on_start_loading(player_id, loading_session_id, ws_sink)
                    .await
            }
            BehaviorType::QuitDuringMatch(b) => {
                b.on_start_loading(player_id, loading_session_id, ws_sink)
                    .await
            }
            BehaviorType::QuitDuringLoading(b) => {
                b.on_start_loading(player_id, loading_session_id, ws_sink)
                    .await
            }
            BehaviorType::SlowLoader(b) => {
                b.on_start_loading(player_id, loading_session_id, ws_sink)
                    .await
            }
            BehaviorType::IgnoreMatchFound(b) => {
                b.on_start_loading(player_id, loading_session_id, ws_sink)
                    .await
            }
        }
    }

    async fn on_loading_complete(&self, player_id: Uuid, ws_sink: &mut WsSink) -> Result<bool> {
        match self {
            BehaviorType::Normal(b) => b.on_loading_complete(player_id, ws_sink).await,
            BehaviorType::QuitDuringMatch(b) => b.on_loading_complete(player_id, ws_sink).await,
            BehaviorType::QuitDuringLoading(b) => b.on_loading_complete(player_id, ws_sink).await,
            BehaviorType::SlowLoader(b) => b.on_loading_complete(player_id, ws_sink).await,
            BehaviorType::IgnoreMatchFound(b) => b.on_loading_complete(player_id, ws_sink).await,
        }
    }
}
</file>

<file path="src/copy.rs">
use anyhow::Result;
use async_trait::async_trait;
use futures_util::{stream::SplitSink, SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use std::env;
use std::io;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::time::sleep;
use tokio_tungstenite::{connect_async, tungstenite::Message, MaybeTlsStream, WebSocketStream};
use tracing::{error, info, instrument, warn};
use tracing_appender::non_blocking::WorkerGuard;
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use url::Url;
use uuid::Uuid;

// --- 로거 설정 ---
pub fn setup_logger(player_id: &str) -> WorkerGuard {
    let log_filename = format!("client_{}.log", player_id);
    let file_appender = RollingFileAppender::new(Rotation::NEVER, "logs", log_filename.clone());
    let (non_blocking_file_writer, guard) = tracing_appender::non_blocking(file_appender);

    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));

    // 3. 콘솔 출력 레이어 설정
    let console_layer = fmt::layer()
        .with_writer(io::stdout) // 표준 출력으로 설정
        .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
        .with_thread_ids(true) // 스레드 ID 포함
        .with_thread_names(true) // 스레드 이름 포함
        .with_file(true) // 파일 경로 포함
        .with_line_number(true) // 라인 번호 포함
        .with_target(false) // target 정보 제외 (선택 사항)
        .pretty(); // 사람이 읽기 좋은 포맷

    // 4. 파일 출력 레이어 설정
    let file_layer = fmt::layer()
        .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
        .with_ansi(false) // 파일에는 ANSI 코드 제외
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .with_target(false)
        .pretty();

    // 5. 레지스트리(Registry)에 필터와 레이어 결합
    tracing_subscriber::registry()
        .with(filter) // 필터를 먼저 적용
        .with(console_layer) // 콘솔 레이어 추가
        .with(file_layer) // 파일 레이어 추가
        .init(); // 전역 Subscriber로 설정

    info!("Logger initialized. Log file: {}", log_filename);
    guard
}

// --- 메시지 정의 ---
#[derive(Serialize)]
struct ClientMessage<'a> {
    #[serde(rename = "type")]
    msg_type: &'a str,
    #[serde(skip_serializing_if = "Option::is_none")]
    player_id: Option<Uuid>,
    #[serde(skip_serializing_if = "Option::is_none")]
    game_mode: Option<&'a str>,
    #[serde(skip_serializing_if = "Option::is_none")]
    loading_session_id: Option<Uuid>,
}

#[derive(Deserialize, Debug)]
struct ServerMessage {
    #[serde(rename = "type")]
    msg_type: String,
    #[serde(default)]
    message: String,
    #[serde(default)]
    loading_session_id: Option<Uuid>,
    #[serde(default)]
    server_address: String,
    #[serde(default)]
    session_id: Option<Uuid>,
}

// --- Type alias for the WebSocket stream sink part ---
type WsSink = SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>;

// --- 플레이어 행동 정의 ---
#[async_trait]
trait PlayerBehavior {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool>;

    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool;

    fn on_match_found(&self, player_id: Uuid) -> bool {
        info!("[{}] >>> SUCCESS: MatchFound received!", player_id);
        false
    }
}

// --- 시나리오별 행동 구현 ---

struct Disconnector;
#[async_trait]
impl PlayerBehavior for Disconnector {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!("[{}] Received StartLoading. Disconnecting now!", player_id);
        ws_sink.close().await?;
        Ok(false)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        error!("[{}] Received unexpected error: {}", player_id, error_msg);
        false
    }
}

struct Victim;
#[async_trait]
impl PlayerBehavior for Victim {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        info!(
            "[{}] Received StartLoading. Sending LoadingComplete.",
            player_id
        );
        let msg = ClientMessage {
            msg_type: "loading_complete",
            loading_session_id: Some(loading_id),
            player_id: None,
            game_mode: None,
        };
        ws_sink
            .send(Message::Text(serde_json::to_string(&msg)?))
            .await?;
        Ok(true)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        if error_msg.contains("disconnected") || error_msg.contains("timed out") {
            info!(
                "[{}] >>> SUCCESS: Received expected cancellation error: {}",
                player_id, error_msg
            );
        } else {
            error!("[{}] Received unexpected error: {}", player_id, error_msg);
        }
        false
    }
}

struct TimeoutPlayer;
#[async_trait]
impl PlayerBehavior for TimeoutPlayer {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_id: Uuid,
        _ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!(
            "[{}] Received StartLoading. Waiting for 65 seconds to cause a timeout...",
            player_id
        );
        sleep(Duration::from_secs(65)).await;
        info!("[{}] Timeout period passed.", player_id);
        Ok(false)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        info!(
            "[{}] Received error (likely after timeout): {}",
            player_id, error_msg
        );
        false
    }
}

struct GhostDisconnector;
#[async_trait]
impl PlayerBehavior for GhostDisconnector {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        _loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        warn!(
            "[{}] Received StartLoading. Disconnecting IMMEDIATELY to test race condition!",
            player_id
        );
        ws_sink.close().await?;
        Ok(false)
    }
    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        error!("[{}] Received unexpected error: {}", player_id, error_msg);
        false
    }
}

// --- Enum Wrapper for Behaviors ---
enum Behavior {
    Disconnect(Disconnector),
    Victim(Victim),
    Timeout(TimeoutPlayer),
    Ghost(GhostDisconnector),
}

#[async_trait]
impl PlayerBehavior for Behavior {
    async fn on_start_loading(
        &self,
        player_id: Uuid,
        loading_id: Uuid,
        ws_sink: &mut WsSink,
    ) -> Result<bool> {
        match self {
            Behavior::Disconnect(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
            Behavior::Victim(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
            Behavior::Timeout(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
            Behavior::Ghost(b) => b.on_start_loading(player_id, loading_id, ws_sink).await,
        }
    }

    fn on_error(&self, player_id: Uuid, error_msg: &str) -> bool {
        match self {
            Behavior::Disconnect(b) => b.on_error(player_id, error_msg),
            Behavior::Victim(b) => b.on_error(player_id, error_msg),
            Behavior::Timeout(b) => b.on_error(player_id, error_msg),
            Behavior::Ghost(b) => b.on_error(player_id, error_msg),
        }
    }

    fn on_match_found(&self, player_id: Uuid) -> bool {
        match self {
            Behavior::Disconnect(b) => b.on_match_found(player_id),
            Behavior::Victim(b) => b.on_match_found(player_id),
            Behavior::Timeout(b) => b.on_match_found(player_id),
            Behavior::Ghost(b) => b.on_match_found(player_id),
        }
    }
}

// --- 플레이어 실행 로직 ---
#[instrument(skip_all, fields(player_id = %player_id))]
async fn run_player(player_id: Uuid, behavior: Behavior) -> Result<()> {
    info!("Starting player with specific behavior");

    let url = Url::parse("ws://127.0.0.1:8080/ws/")?;
    let (ws_stream, _) = connect_async(url.as_str()).await?;
    info!("Connected to server.");

    let (mut ws_sink, mut ws_stream) = ws_stream.split();

    let enqueue_msg = ClientMessage {
        msg_type: "enqueue",
        player_id: Some(player_id),
        game_mode: Some("Normal_1v1"),
        loading_session_id: None,
    };
    ws_sink
        .send(Message::Text(serde_json::to_string(&enqueue_msg)?))
        .await?;
    info!("Sent enqueue request.");

    while let Some(msg) = ws_stream.next().await {
        let msg = match msg {
            Ok(Message::Text(text)) => text,
            Ok(_) => continue,
            Err(e) => {
                warn!("WebSocket stream error: {}", e);
                break;
            }
        };

        let server_msg: ServerMessage = match serde_json::from_str(&msg) {
            Ok(m) => m,
            Err(e) => {
                warn!("Failed to parse server message: {}. Raw: {}", e, msg);
                continue;
            }
        };

        info!("Received: {:?}", server_msg);

        let continue_loop = match server_msg.msg_type.as_str() {
            "start_loading" => {
                behavior
                    .on_start_loading(
                        player_id,
                        server_msg.loading_session_id.unwrap(),
                        &mut ws_sink,
                    )
                    .await?
            }
            "error" => behavior.on_error(player_id, &server_msg.message),
            "match_found" => behavior.on_match_found(player_id),
            "queued" => true,
            _ => true,
        };

        if !continue_loop {
            break;
        }
    }

    info!("Test finished for this player.");
    Ok(())
}

// --- 시나리오 정의 및 메인 함수 ---

#[derive(Debug, PartialEq, Clone, Copy)]
enum Scenario {
    Disconnect,
    Timeout,
    Ghost,
}

async fn _run() -> Result<()> {
    let args: Vec<String> = env::args().collect();
    let scenario_str = args.get(1).map(|s| s.as_str()).unwrap_or("disconnect");
    let role_str = args.get(2).map(|s| s.as_str()).unwrap_or("victim");

    let player_id = Uuid::new_v4();
    let _guard = setup_logger(&player_id.to_string()[..8]);

    let scenario = match scenario_str {
        "disconnect" => Scenario::Disconnect,
        "timeout" => Scenario::Timeout,
        "ghost" => Scenario::Ghost,
        _ => {
            anyhow::bail!(
                "Unknown scenario: {}. Use: disconnect, timeout, ghost",
                scenario_str
            );
        }
    };

    info!("Selected Scenario: {:?}, Role: {}", scenario, role_str);

    let behavior = match (scenario, role_str) {
        (Scenario::Disconnect, "disconnector") => Behavior::Disconnect(Disconnector),
        (Scenario::Disconnect, "victim") => Behavior::Victim(Victim),

        (Scenario::Timeout, "timeout_player") => Behavior::Timeout(TimeoutPlayer),
        (Scenario::Timeout, "victim") => Behavior::Victim(Victim),

        (Scenario::Ghost, "disconnector") => Behavior::Ghost(GhostDisconnector),
        (Scenario::Ghost, "victim") => Behavior::Victim(Victim),

        _ => {
            anyhow::bail!("Invalid role '{}' for scenario '{:?}'", role_str, scenario);
        }
    };

    if let Err(e) = run_player(player_id, behavior).await {
        error!("Player execution failed: {:?}", e);
    }

    sleep(Duration::from_millis(200)).await;
    Ok(())
}
</file>

<file path="src/lib.rs">
pub mod behavior;
pub mod observer;
pub mod scenario;

use std::io;
use tracing::info;
use tracing_appender::non_blocking::WorkerGuard;
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

// --- 로거 설정 ---
pub fn setup_logger(player_id: &str) -> WorkerGuard {
    let log_filename = format!("client_{}.log", player_id);
    let file_appender = RollingFileAppender::new(Rotation::NEVER, "logs", log_filename.clone());
    let (non_blocking_file_writer, guard) = tracing_appender::non_blocking(file_appender);

    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));

    // 3. 콘솔 출력 레이어 설정
    let console_layer = fmt::layer()
        .with_writer(io::stdout) // 표준 출력으로 설정
        .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
        .with_thread_ids(true) // 스레드 ID 포함
        .with_thread_names(true) // 스레드 이름 포함
        .with_file(true) // 파일 경로 포함
        .with_line_number(true) // 라인 번호 포함
        .with_target(false) // target 정보 제외 (선택 사항)
        .pretty(); // 사람이 읽기 좋은 포맷

    // 4. 파일 출력 레이어 설정
    let file_layer = fmt::layer()
        .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
        .with_ansi(false) // 파일에는 ANSI 코드 제외
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .with_target(false)
        .pretty();

    // 5. 레지스트리(Registry)에 필터와 레이어 결합
    tracing_subscriber::registry()
        .with(filter) // 필터를 먼저 적용
        .with(console_layer) // 콘솔 레이어 추가
        .with(file_layer) // 파일 레이어 추가
        .init(); // 전역 Subscriber로 설정

    info!("Logger initialized. Log file: {}", log_filename);
    guard
}
</file>

<file path="src/main.rs">
use anyhow::Result;

/// 플레이어 행동을 따라하는 객체를 만들어야함.
/// 해당 객체는
/// 1. 연결
/// 2. 부여받은 행동을 수행.
/// 3. 행동이 완료되면 종료.
/// 위와 같은 행동을 가짐.
///
/// 이 때 부여 받은 행동은 다음과 같음.
/// 0. 매칭 실패 ( on_error )
/// 1. 매칭 중 ( during_match )
/// 2. 매칭 성공 ( on_match_found )
/// 3. 로딩 중 ( on_start_loading )
/// 4. 로딩 완료 ( on_loading_complete )
///
/// 매칭 서버와 상호작용 시 가능한 플레이어의 행동

#[tokio::main]
async fn main() -> Result<()> {
    // Run example test
    // scenario::run_example_test().await?;

    Ok(())
}
</file>

<file path="src/observer.rs">
use anyhow::Result;
use chrono::{DateTime, Utc};
use futures_util::StreamExt;
use serde::{Deserialize, Serialize};
use std::time::Duration;
use tokio::time::Instant;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{error, info, warn};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct EventStreamMessage {
    pub event_type: String,
    pub player_id: Option<Uuid>,
    pub timestamp: DateTime<Utc>,
    pub data: serde_json::Value,
}

use std::fmt;

pub struct ExpectedEvent {
    pub event_type: String,
    pub player_id: Option<Uuid>,
    pub data_matcher: Box<dyn Fn(&serde_json::Value) -> bool + Send + Sync>,
    pub timeout: Duration,
}

impl fmt::Debug for ExpectedEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ExpectedEvent")
            .field("event_type", &self.event_type)
            .field("player_id", &self.player_id)
            .field("data_matcher", &"<function>")
            .field("timeout", &self.timeout)
            .finish()
    }
}

impl Clone for ExpectedEvent {
    fn clone(&self) -> Self {
        Self {
            event_type: self.event_type.clone(),
            player_id: self.player_id,
            data_matcher: Box::new(|_| true), // Default matcher for cloning
            timeout: self.timeout,
        }
    }
}

impl ExpectedEvent {
    pub fn new(
        event_type: String,
        player_id: Option<Uuid>,
        matcher: Box<dyn Fn(&serde_json::Value) -> bool + Send + Sync>,
        timeout: Duration,
    ) -> Self {
        Self {
            event_type,
            player_id,
            data_matcher: matcher,
            timeout,
        }
    }

    pub fn simple(event_type: String, player_id: Option<Uuid>) -> Self {
        Self::new(
            event_type,
            player_id,
            Box::new(|_| true),
            Duration::from_secs(10),
        )
    }

    pub fn matches(&self, event: &EventStreamMessage) -> bool {
        // Check event type
        if self.event_type != event.event_type {
            return false;
        }

        // Check player ID
        if let Some(expected_player_id) = self.player_id {
            if event.player_id != Some(expected_player_id) {
                return false;
            }
        }

        // Check data matcher
        (self.data_matcher)(&event.data)
    }
}

#[derive(Debug)]
pub struct EventObserver {
    pub match_server_url: String,
    pub expected_sequence: Vec<ExpectedEvent>,
    pub received_events: Vec<EventStreamMessage>,
    pub current_step: usize,
    pub test_name: String,
}

impl Clone for EventObserver {
    fn clone(&self) -> Self {
        Self {
            match_server_url: self.match_server_url.clone(),
            expected_sequence: self.expected_sequence.clone(),
            received_events: self.received_events.clone(),
            current_step: self.current_step,
            test_name: self.test_name.clone(),
        }
    }
}

impl EventObserver {
    pub fn new(match_server_url: String, test_name: String) -> Self {
        Self {
            match_server_url,
            expected_sequence: Vec::new(),
            received_events: Vec::new(),
            current_step: 0,
            test_name,
        }
    }

    pub fn expect_event(&mut self, event: ExpectedEvent) {
        self.expected_sequence.push(event);
    }

    pub fn expect_queued(&mut self, player_id: Uuid) {
        self.expect_event(ExpectedEvent::new(
            "server_message".to_string(),
            Some(player_id),
            Box::new(|data| data.get("Queued").is_some()),
            Duration::from_secs(5),
        ));
    }

    pub fn expect_start_loading(&mut self, player_id: Uuid) {
        self.expect_event(ExpectedEvent::new(
            "server_message".to_string(),
            Some(player_id),
            Box::new(|data| data.get("StartLoading").is_some()),
            Duration::from_secs(10),
        ));
    }

    pub fn expect_match_found(&mut self, player_id: Uuid) {
        self.expect_event(ExpectedEvent::new(
            "server_message".to_string(),
            Some(player_id),
            Box::new(|data| data.get("MatchFound").is_some()),
            Duration::from_secs(10),
        ));
    }

    pub async fn start_observation(
        &mut self,
        player_id: Option<Uuid>,
    ) -> Result<ObservationResult> {
        info!("Starting event observation for test: {}", self.test_name);

        // Build WebSocket URL with query parameters
        // match_server_url이 이미 "ws://127.0.0.1:8080" 형태
        let final_url = if let Some(pid) = player_id {
            format!("{}/events/stream?player_id={}", self.match_server_url, pid)
        } else {
            format!("{}/events/stream", self.match_server_url)
        };

        info!("Connecting to WebSocket: {}", final_url);

        // Connect to event stream
        let (ws_stream, _) = connect_async(&final_url).await?;
        let (mut _write, mut read) = ws_stream.split();

        let start_time = Instant::now();
        let mut _last_event_time = start_time;

        while self.current_step < self.expected_sequence.len() {
            let current_expected = &self.expected_sequence[self.current_step];
            let step_start = Instant::now();

            // Wait for the expected event with timeout
            loop {
                if step_start.elapsed() > current_expected.timeout {
                    return Ok(ObservationResult::timeout(
                        self.current_step,
                        format!(
                            "Timeout waiting for event: {:?}",
                            current_expected.event_type
                        ),
                        self.received_events.clone(),
                    ));
                }

                // Try to receive a message
                match tokio::time::timeout(Duration::from_millis(100), read.next()).await {
                    Ok(Some(Ok(msg))) => {
                        if let Message::Text(text) = msg {
                            match serde_json::from_str::<EventStreamMessage>(&text) {
                                Ok(event) => {
                                    info!("Received event: {:?}", event);
                                    self.received_events.push(event.clone());
                                    _last_event_time = Instant::now();

                                    if current_expected.matches(&event) {
                                        info!(
                                            "✓ Step {} matched: {}",
                                            self.current_step, event.event_type
                                        );
                                        self.current_step += 1;
                                        break;
                                    } else {
                                        warn!("Event doesn't match expected: {:?}", event);
                                    }
                                }
                                Err(e) => {
                                    error!("Failed to parse event: {}", e);
                                }
                            }
                        }
                    }
                    Ok(Some(Err(e))) => {
                        return Ok(ObservationResult::error(
                            self.current_step,
                            format!("WebSocket error: {}", e),
                            self.received_events.clone(),
                        ));
                    }
                    Ok(None) => {
                        return Ok(ObservationResult::error(
                            self.current_step,
                            "WebSocket connection closed".to_string(),
                            self.received_events.clone(),
                        ));
                    }
                    Err(_) => {
                        // Timeout, continue the loop
                        continue;
                    }
                }
            }
        }

        Ok(ObservationResult::success(
            self.received_events.clone(),
            start_time.elapsed(),
        ))
    }
}

#[derive(Debug)]
pub enum ObservationResult {
    Success {
        events: Vec<EventStreamMessage>,
        duration: Duration,
    },
    Timeout {
        failed_step: usize,
        reason: String,
        events: Vec<EventStreamMessage>,
    },
    Error {
        failed_step: usize,
        reason: String,
        events: Vec<EventStreamMessage>,
    },
}

impl ObservationResult {
    pub fn success(events: Vec<EventStreamMessage>, duration: Duration) -> Self {
        Self::Success { events, duration }
    }

    pub fn timeout(failed_step: usize, reason: String, events: Vec<EventStreamMessage>) -> Self {
        Self::Timeout {
            failed_step,
            reason,
            events,
        }
    }

    pub fn error(failed_step: usize, reason: String, events: Vec<EventStreamMessage>) -> Self {
        Self::Error {
            failed_step,
            reason,
            events,
        }
    }

    pub fn is_success(&self) -> bool {
        matches!(self, Self::Success { .. })
    }

    pub fn get_summary(&self) -> String {
        match self {
            Self::Success { events, duration } => {
                format!("✓ Test passed - {} events in {:?}", events.len(), duration)
            }
            Self::Timeout {
                failed_step,
                reason,
                events,
            } => {
                format!(
                    "✗ Test failed at step {}: {} ({} events received)",
                    failed_step,
                    reason,
                    events.len()
                )
            }
            Self::Error {
                failed_step,
                reason,
                events,
            } => {
                format!(
                    "✗ Test error at step {}: {} ({} events received)",
                    failed_step,
                    reason,
                    events.len()
                )
            }
        }
    }
}
</file>

<file path="src/scenario.rs">
use anyhow::Result;
use simulator_env::env;
use tokio::time::{sleep, Duration};
use tracing::{error, info};
use uuid::Uuid;

use crate::behavior::{BehaviorType, NormalPlayer};
use crate::observer::{EventObserver, ObservationResult};
use crate::setup_logger;

pub struct TestScenario {
    pub name: String,
    pub description: String,
    pub players: Vec<(Uuid, BehaviorType)>,
    pub observer: EventObserver,
}

impl TestScenario {
    pub fn new(name: String, description: String, match_server_url: String) -> Self {
        let _guard = setup_logger("test");
        Self {
            name: name.clone(),
            description,
            players: Vec::new(),
            observer: EventObserver::new(match_server_url, name),
        }
    }

    pub fn add_player(&mut self, player_id: Uuid, behavior: BehaviorType) {
        self.players.push((player_id, behavior));
    }

    pub fn setup_normal_match_test() -> Self {
        let mut scenario = Self::new(
            "normal_match_test".to_string(),
            "Test normal 2-player matching flow".to_string(),
            env::match_server_ws_url(), // WebSocket URL 직접 사용
        );

        let player1 = Uuid::new_v4();
        let player2 = Uuid::new_v4();

        scenario.add_player(player1, BehaviorType::Normal(NormalPlayer));
        scenario.add_player(player2, BehaviorType::Normal(NormalPlayer));

        scenario.observer.expect_queued(player1);
        scenario.observer.expect_queued(player2);
        scenario.observer.expect_start_loading(player1);
        scenario.observer.expect_start_loading(player2);
        scenario.observer.expect_match_found(player1);
        scenario.observer.expect_match_found(player2);

        scenario
    }

    pub async fn run(&mut self) -> Result<TestResult> {
        info!("Starting test scenario: {}", self.name);
        info!("Description: {}", self.description);

        let mut tasks = Vec::new();

        // Start observer
        let observer_task = {
            let mut observer = self.observer.clone();
            tokio::spawn(async move { observer.start_observation(None).await })
        };

        // Start players
        for (player_id, behavior) in &self.players {
            let player_id = *player_id;
            let behavior = behavior.clone();

            let task = tokio::spawn(async move { Self::run_player(player_id, behavior).await });

            tasks.push(task);
        }

        let mut player_results = Vec::new();
        for task in tasks {
            match task.await {
                Ok(result) => player_results.push(result),
                Err(e) => {
                    error!("Player task failed: {}", e);
                    player_results.push(Err(anyhow::anyhow!("Task join error: {}", e)));
                }
            }
        }

        let observer_result = observer_task
            .await
            .map_err(|e| anyhow::anyhow!("Observer task failed: {}", e))?;

        Ok(TestResult {
            scenario_name: self.name.clone(),
            player_results,
            observer_result: observer_result?,
        })
    }

    async fn run_player(player_id: Uuid, behavior: BehaviorType) -> Result<PlayerResult> {
        info!("Starting player {}", player_id);

        match behavior {
            BehaviorType::Normal(_player) => {
                info!("Player {} executing normal behavior", player_id);

                Ok(PlayerResult::Success { player_id })
            }
            BehaviorType::QuitDuringMatch(_) => {
                info!("Player {} executing quit during match", player_id);
                sleep(Duration::from_secs(1)).await; // Simulate connection
                sleep(Duration::from_millis(500)).await; // Quit early
                Ok(PlayerResult::Quit {
                    player_id,
                    reason: "Quit during match".to_string(),
                })
            }
            BehaviorType::QuitDuringLoading(_) => {
                info!("Player {} executing quit during loading", player_id);
                sleep(Duration::from_secs(1)).await; // Simulate connection
                sleep(Duration::from_secs(2)).await; // Simulate matching
                sleep(Duration::from_millis(100)).await; // Quit during loading
                Ok(PlayerResult::Quit {
                    player_id,
                    reason: "Quit during loading".to_string(),
                })
            }
            BehaviorType::SlowLoader(slow_loader) => {
                info!("Player {} executing slow loader behavior", player_id);
                sleep(Duration::from_secs(1)).await; // Simulate connection
                sleep(Duration::from_secs(2)).await; // Simulate matching
                sleep(Duration::from_secs(slow_loader.delay_seconds)).await; // Slow loading
                Ok(PlayerResult::Success { player_id })
            }
            BehaviorType::IgnoreMatchFound(_) => {
                info!("Player {} executing ignore match found", player_id);
                sleep(Duration::from_secs(1)).await; // Simulate connection
                sleep(Duration::from_secs(2)).await; // Simulate matching
                                                     // Ignore match found - don't proceed to loading
                Ok(PlayerResult::Failed {
                    player_id,
                    reason: "Ignored match found".to_string(),
                })
            }
        }
    }
}

#[derive(Debug)]
pub struct TestResult {
    pub scenario_name: String,
    pub player_results: Vec<Result<PlayerResult>>,
    pub observer_result: ObservationResult,
}

impl TestResult {
    pub fn is_success(&self) -> bool {
        self.observer_result.is_success()
            && self.player_results.iter().all(|r| {
                match r {
                    Ok(PlayerResult::Success { .. }) => true,
                    Ok(PlayerResult::Quit { .. }) => true, // Quit might be expected behavior
                    _ => false,
                }
            })
    }

    pub fn get_summary(&self) -> String {
        let observer_summary = self.observer_result.get_summary();
        let player_count = self.player_results.len();
        let success_count = self
            .player_results
            .iter()
            .filter(|r| matches!(r, Ok(PlayerResult::Success { .. })))
            .count();

        format!(
            "Test: {} | Players: {}/{} succeeded | Observer: {}",
            self.scenario_name, success_count, player_count, observer_summary
        )
    }
}

#[derive(Debug)]
pub enum PlayerResult {
    Success { player_id: Uuid },
    Failed { player_id: Uuid, reason: String },
    Quit { player_id: Uuid, reason: String },
}

// Example usage function
pub async fn run_example_test() -> Result<()> {
    // 환경 설정 초기화
    simulator_env::init()?;

    let mut scenario = TestScenario::setup_normal_match_test();

    let result = scenario.run().await?;
    info!("Test completed: {}", result.get_summary());

    if result.is_success() {
        info!("✓ Test passed!");
    } else {
        error!("✗ Test failed!");
    }

    Ok(())
}
</file>

<file path="tests/test.rs">
use anyhow::Result;
use test_client::scenario::TestScenario;
use tracing::{error, info};
use simulator_env;

#[actix_web::test]
pub async fn run_example_test() -> Result<()> {
    // 환경 설정 초기화
    simulator_env::init()?;
    
    // 디버깅을 위해 사용되는 URL 출력
    let match_url = simulator_env::env::match_server_url();
    let ws_url = simulator_env::env::match_server_ws_url();
    
    info!("Match server URL: {}", match_url);
    info!("Match server WebSocket URL: {}", ws_url);
    
    let mut scenario = TestScenario::setup_normal_match_test();

    let result = scenario.run().await?;
    info!("Test completed: {}", result.get_summary());

    if result.is_success() {
        info!("✓ Test passed!");
    } else {
        error!("✗ Test failed!");
    }

    Ok(())
}
</file>

</files>
