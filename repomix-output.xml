This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
Cargo.toml
simulator_core/.cargo/config.toml
simulator_core/.github/workflows/main.yml
simulator_core/.gitignore
simulator_core/.idea/.gitignore
simulator_core/.idea/discord.xml
simulator_core/.idea/modules.xml
simulator_core/.idea/simulator.iml
simulator_core/.idea/vcs.xml
simulator_core/.vscode/launch.json
simulator_core/benches/bench.rs
simulator_core/build.rs
simulator_core/Cargo.toml
simulator_core/Datas/config.json
simulator_core/Datas/game_behaivor.csv
simulator_core/Datas/mock.json
simulator_core/Datas/player1_test.json
simulator_core/Datas/player2_test.json
simulator_core/GameData/cards-json.txt
simulator_core/GameData/hero.txt
simulator_core/GameData/task.txt
simulator_core/GameData/turn-structure.txt
simulator_core/logs/app.log.2025-05-13-07
simulator_core/Resource/card_data
simulator_core/Resource/cards_id.json
simulator_core/Resource/cards.json
simulator_core/src/card_gen/builder.rs
simulator_core/src/card_gen/human.rs
simulator_core/src/card_gen/mod.rs
simulator_core/src/card_gen/monster.rs
simulator_core/src/card_gen/public.rs
simulator_core/src/card/cards.rs
simulator_core/src/card/insert.rs
simulator_core/src/card/mod.rs
simulator_core/src/card/modifier.rs
simulator_core/src/card/take.rs
simulator_core/src/card/types.rs
simulator_core/src/effect/effects.rs
simulator_core/src/effect/mod.rs
simulator_core/src/effect/types.rs
simulator_core/src/enums/mod.rs
simulator_core/src/exception/mod.rs
simulator_core/src/game_old/chain copy.rs
simulator_core/src/game_old/chain.rs
simulator_core/src/game_old/choice.rs
simulator_core/src/game_old/game_step.rs
simulator_core/src/game_old/getter.rs
simulator_core/src/game_old/helper.rs
simulator_core/src/game_old/mod.rs
simulator_core/src/game_old/phase.rs
simulator_core/src/game_old/turn_manager.rs
simulator_core/src/game/choice.rs
simulator_core/src/game/getter.rs
simulator_core/src/game/helper.rs
simulator_core/src/game/message.rs
simulator_core/src/game/mod.rs
simulator_core/src/game/phase.rs
simulator_core/src/game/turn.rs
simulator_core/src/helper.rs
simulator_core/src/lib.rs
simulator_core/src/main.rs
simulator_core/src/memo..rs
simulator_core/src/player/message.rs
simulator_core/src/player/mod.rs
simulator_core/src/resource.rs
simulator_core/src/selector/automatic.rs
simulator_core/src/selector/complex.rs
simulator_core/src/selector/mod.rs
simulator_core/src/selector/mulligan.rs
simulator_core/src/selector/multi.rs
simulator_core/src/selector/single.rs
simulator_core/src/server/actor/connection.rs
simulator_core/src/server/actor/messages.rs
simulator_core/src/server/actor/mod.rs
simulator_core/src/server/actor/types.rs
simulator_core/src/server/end_point copy
simulator_core/src/server/end_point.rs
simulator_core/src/server/helper.rs
simulator_core/src/server/input_handler.rs
simulator_core/src/server/jsons.rs
simulator_core/src/server/mod.rs
simulator_core/src/server/types.rs
simulator_core/src/test/mod.rs
simulator_core/src/unit/mod.rs
simulator_core/src/unit/player.rs
simulator_core/src/utils/json.rs
simulator_core/src/utils/mod.rs
simulator_core/src/zone/deck.rs
simulator_core/src/zone/effect.rs
simulator_core/src/zone/field.rs
simulator_core/src/zone/graveyard.rs
simulator_core/src/zone/hand.rs
simulator_core/src/zone/mod.rs
simulator_core/src/zone/zone.rs
simulator_core/tests/intergration_test.rs
simulator_core/tests/test copy
simulator_core/tests/test copy heart
simulator_core/tests/test.rs
simulator_dedicated_server/.github/workflows/main.yml
simulator_dedicated_server/.gitignore
simulator_dedicated_server/.idea/.gitignore
simulator_dedicated_server/.idea/discord.xml
simulator_dedicated_server/.idea/modules.xml
simulator_dedicated_server/.idea/simulator.iml
simulator_dedicated_server/.idea/vcs.xml
simulator_dedicated_server/.vscode/launch.json
simulator_dedicated_server/Cargo.toml
simulator_dedicated_server/src/lib.rs
simulator_match_server/.github/workflows/main.yml
simulator_match_server/.gitignore
simulator_match_server/.idea/.gitignore
simulator_match_server/.idea/discord.xml
simulator_match_server/.idea/modules.xml
simulator_match_server/.idea/simulator.iml
simulator_match_server/.idea/vcs.xml
simulator_match_server/.vscode/launch.json
simulator_match_server/Cargo.toml
simulator_match_server/src/lib.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="simulator_core/logs/app.log.2025-05-13-07">
2025-05-13T07:52:01.025086Z  INFO  starting 32 workers
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\builder.rs:272 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:01.026123Z  INFO  Player 1 connected, P1 can now receive messages.
    at simulator_core\src\game\mod.rs:84 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:01.026136Z  INFO  Player 2 connected, P2 can now receive messages.
    at simulator_core\src\game\mod.rs:89 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:01.026141Z  INFO  Both players connected. Sending SetOpponent messages.
    at simulator_core\src\game\mod.rs:91 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:01.026210Z  INFO  Actix runtime found; starting in Actix runtime
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:191 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:01.026229Z  INFO  starting service: "actix-web-service-127.0.0.1:4606", workers: 32, listening on: 127.0.0.1:4606
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:197 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:01.033902Z  INFO  멀리건 단계 핸들러 시작: player=Player2
    at simulator_core\src\server\end_point.rs:118 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player2, id: 62c9e056-d0da-42c2-8558-9e23e515f825 }, player_type: Player2

  2025-05-13T07:52:01.033902Z  INFO  멀리건 단계 핸들러 시작: player=Player1
    at simulator_core\src\server\end_point.rs:118 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player1, id: 763eca37-f1f6-46cc-863e-5a5b00fa070c }, player_type: Player1

  2025-05-13T07:52:01.034019Z  INFO  WebSocket handshake successful for player_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c
    at simulator_core\src\server\end_point.rs:128 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player1, id: 763eca37-f1f6-46cc-863e-5a5b00fa070c }, player_type: Player1

  2025-05-13T07:52:01.034020Z  INFO  WebSocket handshake successful for player_id: 62c9e056-d0da-42c2-8558-9e23e515f825
    at simulator_core\src\server\end_point.rs:128 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player2, id: 62c9e056-d0da-42c2-8558-9e23e515f825 }, player_type: Player2

  2025-05-13T07:52:01.034152Z  INFO  ConnectionActor started for player 62c9e056-d0da-42c2-8558-9e23e515f825
    at simulator_core\src\server\actor\connection.rs:139 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:01.034154Z  INFO  ConnectionActor started for player 763eca37-f1f6-46cc-863e-5a5b00fa070c
    at simulator_core\src\server\actor\connection.rs:139 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:01.034268Z  INFO  Sent initial heartbeat_connected message to player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:160 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:01.034269Z  INFO  Sent initial heartbeat_connected message to player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:160 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:06.046598Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:84 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:06.046598Z  INFO  Spawning heartbeat ping task for player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:84 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:06.046701Z  INFO  Ping sent successfully to player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:101 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:06.046704Z  INFO  Ping sent successfully to player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:101 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:06.046936Z  INFO  Received Pong from player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:232 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:06.046952Z  INFO  Initial Pong received from player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:239 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:06.046971Z  INFO  Received Pong from player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:232 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:06.046985Z  INFO  Initial Pong received from player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:239 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:06.046986Z  INFO  GAME ACTOR [19feea58-3b8e-422b-9c55-3558abc1b20f]: Handling RegisterConnection for player 62c9e056-d0da-42c2-8558-9e23e515f825
    at simulator_core\src\game\message.rs:152 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047030Z  INFO  GAME ACTOR [19feea58-3b8e-422b-9c55-3558abc1b20f]: Handling RegisterConnection for player 763eca37-f1f6-46cc-863e-5a5b00fa070c
    at simulator_core\src\game\message.rs:152 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047053Z  INFO  GAME ACTOR [19feea58-3b8e-422b-9c55-3558abc1b20f]: All players are ready
    at simulator_core\src\game\message.rs:172 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047057Z  INFO  GAME ACTOR [19feea58-3b8e-422b-9c55-3558abc1b20f]: Sending message to PlayerActor (Player2) and awaiting response.
    at simulator_core\src\game\mod.rs:191 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047102Z  INFO  GAME ACTOR [19feea58-3b8e-422b-9c55-3558abc1b20f]: All players are ready
    at simulator_core\src\game\message.rs:172 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047107Z  INFO  GAME ACTOR [19feea58-3b8e-422b-9c55-3558abc1b20f]: Sending message to PlayerActor (Player1) and awaiting response.
    at simulator_core\src\game\mod.rs:191 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047119Z  INFO  PLAYER ACTOR [Player2]: Handling GetMulliganDealCards
    at simulator_core\src\player\message.rs:74 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:06.047133Z  INFO  PLAYER ACTOR [Player1]: Handling GetMulliganDealCards
    at simulator_core\src\player\message.rs:74 on mulligan::test_mulligan_deal_cards_to_each_player_concurrently ThreadId(3)

  2025-05-13T07:52:11.044690Z  INFO  Spawning heartbeat ping task for player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:84 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:11.044725Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:84 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-05-13T07:52:11.044785Z  INFO  Ping sent successfully to player Player2 (session_id: 62c9e056-d0da-42c2-8558-9e23e515f825)
    at simulator_core\src\server\actor\connection.rs:101 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-05-13T07:52:11.044815Z  INFO  Ping sent successfully to player Player1 (session_id: 763eca37-f1f6-46cc-863e-5a5b00fa070c)
    at simulator_core\src\server\actor\connection.rs:101 on actix-rt|system:0|arbiter:0 ThreadId(4)
</file>

<file path="simulator_core/.cargo/config.toml">
[build]
rustflags = ["--cfg", "tokio_unstable"]
</file>

<file path="simulator_core/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_core/.gitignore">
/target
</file>

<file path="simulator_core/.idea/.gitignore">
# 디폴트 무시된 파일
/shelf/
/workspace.xml
# 에디터 기반 HTTP 클라이언트 요청
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
</file>

<file path="simulator_core/.idea/discord.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="PROJECT_FILES" />
    <option name="description" value="" />
    <option name="applicationTheme" value="default" />
    <option name="iconsTheme" value="default" />
    <option name="button1Title" value="" />
    <option name="button1Url" value="" />
    <option name="button2Title" value="" />
    <option name="button2Url" value="" />
    <option name="customApplicationId" value="" />
  </component>
</project>
</file>

<file path="simulator_core/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/simulator.iml" filepath="$PROJECT_DIR$/.idea/simulator.iml" />
    </modules>
  </component>
</project>
</file>

<file path="simulator_core/.idea/simulator.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="EMPTY_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="simulator_core/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
  </component>
</project>
</file>

<file path="simulator_core/.vscode/launch.json">
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'card_game'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in executable 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug integration test 'test'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--test=test",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "test",
                    "kind": "test"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</file>

<file path="simulator_core/benches/bench.rs">
use criterion::{criterion_group, criterion_main, Criterion};
use simulator_core::test::spawn_server;
use tokio::runtime::Runtime;

fn bench_spawn_server(c: &mut Criterion) {
    // Tokio 런타임 생성
    let rt = Runtime::new().unwrap();

    c.bench_function("spawn_server", |b| {
        b.iter(|| {
            // 런타임 내에서 비동기 작업 실행
            rt.block_on(async {
                let _ = spawn_server().await;
            });
        });
    });
}

criterion_group!(benches, bench_spawn_server);
criterion_main!(benches);
</file>

<file path="simulator_core/build.rs">
use std::fs;
use std::io::Write;
use std::path::Path;

pub fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("card_registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // 카드 모듈 디렉토리 스캔
    let modules = ["human", "monster", "public"];
    let mut card_registrations = Vec::new();

    for module in modules {
        let path = format!("src/card_gen/{}.rs", module);
        let content = fs::read_to_string(&path).unwrap();

        // 함수 이름 찾기 (예: HM_001, MT_001 등)
        for line in content.lines() {
            if line.contains("pub fn")
                && (line.contains("HM_") || line.contains("MT_") || line.contains("PB_"))
            {
                let func_name = line.split("fn ").nth(1).unwrap().split("(").next().unwrap();
                card_registrations.push(format!("    {}::{}", module, func_name));
            }
        }
    }

    // 매크로 호출 생성
    write!(
        f,
        r#"
        generate_card_map! {{
        {}
        }}
    "#,
        card_registrations.join(",\n")
    )
    .unwrap();
}
</file>

<file path="simulator_core/Datas/config.json">
{
  "DeckCodes": [
    {
      "code1": "",
      "code2": ""
    }
  ],
  "Attacker": 1,
  "Names": [
    {
      "name1": "player1",
      "name2": "player2"
    }
  ]
}
</file>

<file path="simulator_core/Datas/game_behaivor.csv">
PlayerType,Message
Player1
</file>

<file path="simulator_core/Datas/mock.json">
{
  "player_type": "player",
  "cards": ["CARD_UUID_1", "CARD_UUID_2", "CARD_UUID_3", "CARD_UUID_4"]
}
</file>

<file path="simulator_core/Datas/player1_test.json">
{
  "decks": [
    {
      "Hero": [
        {
          "name": "player1"
        }
      ],
      "cards": [
        {
          "id": "HM_001",
          "num": 2
        },
        {
          "id": "HM_002",
          "num": 2
        },
        {
          "id": "HM_003",
          "num": 2
        },
        {
          "id": "HM_004",
          "num": 2
        }
      ]
    }
  ]
}
</file>

<file path="simulator_core/Datas/player2_test.json">
{
  "decks": [
    {
      "Hero": [
        {
          "name": "player2"
        }
      ],
      "cards": [
        {
          "id": "HM_001",
          "num": 2
        },
        {
          "id": "HM_002",
          "num": 2
        },
        {
          "id": "HM_003",
          "num": 2
        },
        {
          "id": "HM_004",
          "num": 2
        }
      ]
    }
  ]
}
</file>

<file path="simulator_core/GameData/cards-json.txt">
datas 폴더엔 플레이어의 덱 정보가 담긴 json 파일이 있다.
구조는 다음과 같다.
[
    {
        "id": "ID",
        "num": INT
    }
]
{ } 블럭은 단일 카드에 대한 id 정보와 갯수를 포함한다.

Resource 폴더에 있는 cards.json 은 게임에 있는 모든 카드의 정보를 담는다.
구조는 위와 비슷하지만 포함하는 정보량이 다르다.
이 json 파일은 카드에 대한 모든 정보(예를 들어 공격력, 체력, 효과 등)를 담기 때문에, 덱에서 id 를 가져온 뒤 해당 json 파일에서 카드 정보를 가져오는
방식으로 한다.
</file>

<file path="simulator_core/GameData/hero.txt">
이 게임에서는 사전 구성된 덱을 가지고 플레이어가 게임에 참여한다.
이 때 덱을 구성하는 카드는 각자의 진영을 갖고 있는데,
진영을 대표하는 카드를 히어로라고 한다.

덱에서 동시에 존재할 수 있는 히어로의 갯수는 최대 2개이다.

히어로는
</file>

<file path="simulator_core/GameData/task.txt">
카드 게임에서 존재하는 모든 행동을, 함수/열거형으로 정의한다.
그리고 카드는 자신이 가진 능력과 관련된 함수들을 table 로 가진다.

모든 행동은 하나의 queue 에 task 형식으로 저장되어, 순차적으로 처리된다.

task_queue 는 후입선출 방식으로 처리한다.
</file>

<file path="simulator_core/GameData/turn-structure.txt">
턴 구조는 유희왕과 비슷하다.
</file>

<file path="simulator_core/Resource/card_data">
월인/달토끼 (MH)

링고[몬스터/달토끼] [코스트3]
스탯 1/4
상시 : 경단을 사용한 턴 2/1를 얻는다.
조건 : 소환 성공 및 공격선언 시 발동한다.
효과 : 패에 "경단" 2장을 넣는다.
디메리트 : 경단을 사용하지 않은 턴 종료시에 2의 데미지를 받는다.

경단[행동/대응]
상시 : 1턴에 1번만 발동할 수 있다.
효과 : 달토끼에게 영구적으로 1/1를 부여한다. 

악마 (DM)

소악마[행동]
① : 자신은 2장 드로우한다. 그 후 데몬 카드 1장을 버린다. 만약 버릴수 없을 경우 자신의 패를 전부 덱으로 되돌린다.

레밀리아 스칼렛[몬스터] [코스트 2]
스탯 2/3
"상시 : 이 카드의 ①, ② 효과는 1턴에 1번만 발동할 수 있다.\n① : 자신 필드에 "플랑드르 스칼렛"이 없다면 발동할 수 있다. 패, 덱, 묘지에서 "플랑드르 스칼렛" 1장을 소환한다. \n② : 자신 필드에 "플랑드르 스칼렛"이 존재하고 이 카드가 소환 되었을 경우 발동 할 수있다. 자신은 1장 드로우한다.",

플랑드르 스칼렛[몬스터] [코스트 2]
스탯 3/2
"상시 : 이 카드의 ①, ② 효과는 1턴에 1번만 발동할 수 있다.\n① : 자신 필드에 "레밀리아 스칼렛"이 없다면 발동할 수 있다. 패, 덱, 묘지에서 "레밀리아 스칼렛" 1장을 소환한다. \n② : 자신 필드에 "레밀리아 스칼렛"이 존재하고 이 카드가 소환 되었을 경우 상대 필드 카드 1장을 대상으로 발동할 수 있다. 그카드를 파괴한다.",

인간 (HM)

히에다노 아큐[필드]
① : 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.

모토오리 코스즈[필드]
"① : 자신 필드에 "인간"이 존재할 경우 발동할 수 있다. 상대 패에 존재하는 카드 1장을 자신의 패에 추가한다. \n② : 그 카드를 사용하지 않은 턴 종료시 에 발동한다. 그 카드를 상대패에 추가한다.",


이자요이 사쿠야[행동]
"① : 이 카드에 빛이 존재할 경우 발동할 수 있다. 이턴 인간 카드의 비용이 0이 된다. \n② : ①효과를 발동한 엔드페이즈에 발동한다. 자신 필드 어둠 4개를을 생성한다.",
//②효과는 강제발동이다.

파츄리 널릿지[행동]
"이 카드의 ①은 1턴에 1번만 발동할 수 있으며, 빛이 존재하지 않을 경우 무효화 된다. \n① : 자신 덱에서 "인간"진형 카드 2장을 패에 넣는다. 그 후 패 1장을 버린다.",


하쿠레이 레이무[몬스터] [코스트 1]
스탯 0/1 
"빛에 존재하는 이 카드는 대상이 되지 않는다. \n① : 이 카드를 소환했을 때 발동할 수 있다. 덱에서 "인간"진형 카드 1장을 패에 넣는다.",


우사미 스미레코[행동/대응]
"이 카드의 ①의 효과는 상대턴에도 발동 가능하다. \n① : 필드에 빛 또는 어둠이 존재할 경우 다른 필드에 대상으로 발동할 수 있다. 필드에 존재하는 빛 또는 어둠 1개만 대상으로 한 곳으로 이동한다.",


코치야 사나에[몬스터] [코스트 3]
스탯 ?/? [신]
"이카드는 자신필드에 존재하는 모든 "인간"카드를 묘지로 보내야만 소환할 수 있다.\n이 카드의 공격력과 생명력은 이카드를 소환하기 위해 보내진 "인간"카드 1장당 2/2씩 얻는다. \n① : 이 카드에 빛이 존재하고, 상대가 몬스터/행동 카드의 효과를 발동했을 때 발동할 수 있다. 이카드의 스탯 2/2를 감소시키고 그 발동을 무효로 한다. \n② : 이 카드에 어둠이 존재하고, 이카드 이외에 다른 카드가 공격대상이 되었을 경우 발동할 수 있다. 공격대상을 이카드로 바꾼다.",

엘리스 마가트로이드[몬스터] [코스트 4]
리워크 예정

후지와라노 모코우[몬스터] [코스트 2] [인형]
리워크 예정

키라사메 마리사[몬스터] [코스트 1]
리워크 예정

카미시라사와 케이네[몬스터] [코스트 6]
스탯 6/5
"이카드의 ①, ②효과는 상대턴에도 발동 할 수 있으며, 1턴에 1번만 발동할 수 있다. \n① : 이 카드에 어둠이 있을경우 발동할 수 있다. 덱에서 인간카드 1장을 패에 추가한다. \n② : 이카드에 빛이 있을경우 발동할 수 있다. 이 카드를 덱으로 되돌리고 덱에서 인간 몬스터 1장을 소환한다.",

마에리베리 한[몬스터] [코스트 10]
리워크 예정

요괴 (MT)

루미아[행동/대응]
① : 낮일 경우 발동할 수 있다. 자신 필드에 어둠 1개를 생성한다.

미스티아 로렐라이[행동/대응]
① : 어둠이 존재 할때 발동할 수 있다. 필드에 어둠 2개를 생성한다.

나즈린[행동]
① : 자신 덱에서 "요과"카드 한장을 가져온다.

이누바시리 모미지[행동]
이 카드의 ① 효과는 1턴에 1번만 발동 할 수 있다. \n① : 어둠이 존재할 경우 발동할 수 있다. 자신의 덱 맨 위에서 3장을 공개하고 그중 1장을 패에 넣는다.",
    //선택받지 못한 카드는 덱으로 간다

미야코 요시카[몬스터] [코스트 3]
스탯 3/4 [강시]
어둠에 존재하는 카드 1장당 이 카드의 스탯 1/1 상승한다.\n① : 필드에 어둠이 존재할 경우 발동할 수 있다. 필드 1개에 어둠을 생성한다.", 
//필드에 어둠이 존재하고 그 위에 다른 카드가 존재해야 이 카드의 스탯이 오름.

야쿠모 란[몬스터] [코스트 4]
스탯 3/4
① : 자신 필드에 "첸"이 존재하지 않을 경우 발동할 수 있다. 덱/묘지에서 첸을 소환한다.\n② : 필드에 첸이 존재할 경우 발동할 수 있다. 첸 아래에 존재하는 카드 1개를 묘지로 보내고 아래에 효과를 적용한다. \n몬스터 : 이번 턴 자신의 몬스터는 체력 1 미만으로 내려가지 않는다. \n행동 : 자신은 1장 드로우한다. \n대응 : 자신 묘지에 존재하는 카드 1장을 자신의 패로 가져온다. \n필드 : 이번 턴 필드의 효과는 무효화 된다.",


첸[몬스터] [코스트 2]
스탯 0/4
이카드는 이카드 아래에 존재하는 카드 1장당 0/1 스탯을 얻는다.\n① : 어둠에 이 카드가 존재할 경우 드로우 페이즈에 발동할 수 있다. 상대 덱 맨 위에 카드를 1장 이카드 아래에 둔다.",

Yukari Yakumo [몬스터] [코스트 8]
스탯 10/6 
"자신 필드에 "야쿠모 란", "첸"이 존재하지 않을경우 이카드는 소환 및 효과 발동을 할 수 없다.\n① : 상대가 몬스터/행동 효과를 발동했을 때 발동할 수 있다. "첸" 아래에 있는 카드를 1장 묘지로 보내고 그 효과를 무효로 하고 파괴한다.\n ② : 자신 필드에 "야쿠모 란", "첸", "야쿠모 유카리"만 존재할 경우 발동할 수 있다. 이 턴 종료시 까지 자신 필드의 "야쿠모 란", "첸"은 자신 필드의 "야쿠모 유카리"의 공격력과 수비력을 가진다.",

이마이즈미 카게로[몬스터] [코스트 3]
스탯 2/4
"빛에 존재하는 이 카드는 공격할 수 없다.\n어둠에 있을때 이 카드는 5/4가 된다. \n이카드는 2번 공격할 수 있다.", 

공용 (PB)

릴리 화이트[행동/대응]
필드존에 카드가 없어야 발동 할 수 있다. 덱에서 "필드카드" 1장을 필드존에 놓는다.

서니 밀크[필드]
이 카드가 존재하는 한 필드 3개를 빛으로 취급한다.
//이 효과를 발동한 플레이어만 정한다.

루나 차일드[필드]
이 카드가 존재하는 한 필드 3개를 어둠으로 취급한다.
//이 효과를 발동한 플레이어만 정한다.

아키 시즈하[행동/대응]
1턴에 1번 필드존의 카드가 존재할 경우에만 발동할 수 있다. 필드존의 카드를 파괴한다.

아키 미노리코[행동대]
1턴에 1번 "필드카드"가 존재하면 발동할 수 있다. 자신은 2장 드로우한다.

치르노[행동/대응]
리워크 예정

스타 사파이어[몬스터] [코스트 1]
리워크 예정

레티 화이트락[행동 / 대응]
1턴에 1번 패에서 이 카드를 버리고 몬스터를 대상으로 발동할 수 있다. 대상 몬스터는 효과 무효 및 공격을 할 수 없으며, 공격대상또한 되지 않는다.
</file>

<file path="simulator_core/Resource/cards_id.json">
[
  { "id": "HM_001", "dbfid": 20 },
  { "id": "HM_002", "dbfid": 21 },
  { "id": "HM_003", "dbfid": 22 },
  { "id": "HM_004", "dbfid": 23 },
  { "id": "HM_005", "dbfid": 24 },
  { "id": "HM_006", "dbfid": 25 },
  { "id": "HM_007", "dbfid": 26 },
  { "id": "HM_008", "dbfid": 27 },
  { "id": "MT_001", "dbfid": 28 },
  { "id": "MT_002", "dbfid": 29 },
  { "id": "MT_003", "dbfid": 30 },
  { "id": "MT_004", "dbfid": 31 },
  { "id": "MT_005", "dbfid": 32 },
  { "id": "MT_006", "dbfid": 33 },
  { "id": "MT_007", "dbfid": 34 },
  { "id": "MT_008", "dbfid": 35 },
  { "id": "MT_009", "dbfid": 36 },
  { "id": "MT_010", "dbfid": 37 },
  { "id": "PB_001", "dbfid": 38 },
  { "id": "PB_002", "dbfid": 39 },
  { "id": "PB_003", "dbfid": 40 },
  { "id": "PB_004", "dbfid": 41 },
  { "id": "PB_005", "dbfid": 42 },
  { "id": "PB_006", "dbfid": 43 },
  { "id": "PB_007", "dbfid": 44 },
  { "id": "PB_008", "dbfid": 45 },
  { "id": "PB_009", "dbfid": 46 },
  { "id": "PB_010", "dbfid": 47 },
  { "id": "PB_011", "dbfid": 48 },
  { "id": "PB_012", "dbfid": 49 },
  { "id": "PB_013", "dbfid": 50 },
  { "id": "PB_014", "dbfid": 51 },
  { "id": "PB_015", "dbfid": 52 },
  { "id": "PB_016", "dbfid": 53 },
  { "id": "PB_017", "dbfid": 54 }
]
</file>

<file path="simulator_core/Resource/cards.json">
[
  {
    "id": "HM_001",
    "dbfid": 20,
    "cardClass": "Human",
    "name": "Hieda no Akyuu",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "효과 : 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "HM_002",
    "dbfid": 21,
    "cardClass": "Human",
    "name": "Kosuzu Motoori",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 자신 필드에 \"인간\"이 존재할 경우 발동할 수 있다. \n효과 : 상대 패에 존재하는 카드 1장을 자신의 패에 추가한다. \n디메리트 : 그 카드를 사용하지 않은 턴 종료시 그 카드를 상대패에 추가한다.",
    "type": "Spell"
  },
  {
    "id": "HM_003",
    "dbfid": 22,
    "cardClass": "Human",
    "name": "Sakuya Izayoi",
    "attack": 0,
    "health": 2,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 이 카드에 \"빛\"이 존재할 경우 발동할 수 있다. \n효과 : 이턴 인간 카드의 비용이 0이 된다. \n디메리트 : 자신 필드 4개에 \"어둠\"을 생성한다.",
    "type": "Unit"
  },
  {
    "id": "HM_004",
    "dbfid": 23,
    "cardClass": "Human",
    "name": "Patchouli Knowledge",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "상시 : 이 카드는 1턴에 1번에만 발동할 수 있으며, 빛이 존재하지 않을 경우 무효화 된다. \n효과 : 자신 덱에서 \"인간\"진형 카드 2장을 패에 넣는다. 그 후 패 1장을 버린다.",
    "type": "Spell"
  },
  {
    "id": "HM_005",
    "dbfid": 24,
    "cardClass": "Human",
    "name": "Reimu Hakurei",
    "attack": 0,
    "health": 1,
    "cost": 1,
    "rarity": "A",
    "collectible": true,
    "text": "상시 : 빛에 존재하는 이 카드는 대상이 되지 않는다. \n조건 : 이 카드 소환시 발동할 수 있다. \n효과 : 덱에서 \"인간\"진형 카드 1장을 패에 넣는다.",
    "type": "Unit"
  },
  {
    "id": "HM_006",
    "dbfid": 25,
    "cardClass": "Human",
    "name": "Usami Sumireko",
    "attack": 2,
    "health": 3,
    "cost": 2,
    "rarity": "B",
    "collectible": true,
    "text": "조건 : 필드에 빛 또는 어둠이 존재할 경우 다른 필드에 대상으로 발동할 수 있다. [이 효과는 상대턴에도 발동 가능]\n효과 : 필드에 존재하는 빛 또는 어둠 1개만 대상으로 한 곳으로 이동한다.",
    "type": "Spell"
  },
  {
    "id": "HM_007",
    "dbfid": 26,
    "cardClass": "Human",
    "name": "Sanae Kochiya",
    "attack": 0,
    "health": 0,
    "cost": 3,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 이 카드는 자신 필드에 존재하는 모든 \"인간\"카드를 묘지로 보내야만 소환할 수 있다.\n이 카드의 공격력과 생명력은 이카드를 소환하기 위해 보내진 \"인간\"카드 1장당 2/2씩 얻는다. \n조건 1 : 이 카드에 빛이 존재하고, 상대가 몬스터/행동 카드의 효과를 발동했을 때 발동할 수 있다. \n효과 1 : 이카드의 스탯 2/2를 감소시키고 그 발동을 무효로 한다. \n조건 2 : 이 카드에 어둠이 존재하고, 이카드 이외에 다른 카드가 공격대상이 되었을 경우 발동할 수 있다. \n효과 2 : 공격대상을 이카드로 바꾼다.",
    "type": "Ace"
  },
  {
    "id": "HM_008",
    "dbfid": 27,
    "cardClass": "Human",
    "name": "Keine Kamishirasawa",
    "attack": 5,
    "health": 5,
    "cost": 6,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 이 카드의 효과는 상대턴에도 발동 할 수 있으며, 1턴에 1번만 발동할 수 있다. \n조건 1 : 이 카드에 어둠이 있을경우 발동할 수 있다. \n효과 1 : 덱에서 인간카드 1장을 패에 추가한다. \n조건 2 : 이카드에 빛이 있을경우 발동할 수 있다. \n효과 2 : 이 카드를 덱으로 되돌리고 덱에서 인간 몬스터 1장을 소환한다.",
    "type": "Ace"
  },
  {
    "id": "MT_001",
    "dbfid": 28,
    "cardClass": "Monster",
    "name": "Rumia",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 낮에만 발동할 수 있다. \n효과 : 자신 필드에 어둠을 1개 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_002",
    "dbfid": 29,
    "cardClass": "Monster",
    "name": "Mystia Lorelei",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 어둠이 있을 경우 발동할 수 있다. \n효과 : 필드에 어둠을 2개 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_003",
    "dbfid": 30,
    "cardClass": "Monster",
    "name": "Nazreen",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "효과 : 자신 덱에서 \"요과\"카드 한장을 가져온다.",
    "type": "Spell"
  },
  {
    "id": "MT_004",
    "dbfid": 31,
    "cardClass": "Monster",
    "name": "Inubashiri Momiji",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 어둠이 있을 경우 발동할 수 있다. \n효과 : 자신 덱 위에서 3장을 공개하고 그 중 1장을 패에 넣는다. 그 후 나머지 카드는 덱 맨 밑에 둔다.",
    "type": "Spell"
  },
  {
    "id": "MT_005",
    "dbfid": 32,
    "cardClass": "Monster",
    "name": "Miyako Yoshika",
    "attack": 3,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "상시 : 어둠에 존재하는 카드 1장당 이 카드의 스탯 1/1 상승한다. \n조건 : 필드에 어둠이 존재할 경우 발동할 수 있다. \n효과 : 사용하고 있지 않은 필드 1개에 어둠을 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_006",
    "dbfid": 33,
    "cardClass": "Monster",
    "name": "Ran Yakumo",
    "attack": 3,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "조건 1 : 자신 필드에 \"첸\"이 존재하지 않을 경우 발동할 수 있다. \n효과 1 : 덱/묘지에서 첸을 소환한다. \n조건 2 : 필드에 첸이 존재할 경우 발동할 수 있다. \n 효과 2 : 첸 아래에 존재하는 카드 1개를 묘지로 보내고 효과를 적용한다. \n몬스터 : 이번 턴 자신의 몬스터는 체력 1 미만으로 내려가지 않는다. \n행동 : 자신은 1장 드로우한다. \n대응 : 자신 묘지에 존재하는 카드 1장을 자신의 패로 가져온다. \n필드 : 이번 턴 필드의 효과는 무효화 된다.",
    "type": "Unit"
  },
  {
    "id": "MT_007",
    "dbfid": 34,
    "cardClass": "Monster",
    "name": "Chen",
    "attack": 0,
    "health": 4,
    "cost": 2,
    "rarity": "B",
    "collectible": true,
    "text": "상시 : 이카드는 이카드 아래에 존재하는 카드 1장당 0/1 스탯을 얻는다. \n조건 1 : 이 카드가 어둠에 존재하고 있을경우 드로우 페이즈에 발동할 수 있다. \n효과 1 : 상대 덱 맨 위에 카드를 1장 이카드 아래에 둔다.",
    "type": "Unit"
  },
  {
    "id": "MT_008",
    "dbfid": 35,
    "cardClass": "Monster",
    "name": "Yukari Yakumo",
    "attack": 0,
    "health": 0,
    "cost": 8,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 자신 필드에 \"야쿠모 란\", \"첸\"이 존재하지 않을경우 이카드는 소환 및 효과 발동을 할 수 없다. \n조건 1 : 상대가 몬스터/행동 효과를 발동했을 때 발동할 수 있다. \n효과 1 : 첸 아래에 있는 카드를 1장 묘지로 보내고 그 효과를 무효로 하고 파괴한다. \n조건 2 : 자신 필드에 \"야쿠모 란\", \"첸\", \"야쿠모 유카리\"만 존재할 경우 발동할 수 있다. \n효과 2 : 이 턴 종료시 까지 자신 필드의 \"야쿠모 란\", \"첸\"은 자신 필드의 \"야쿠모 유카리\"의 공격력과 수비력을 가진다.",
    "type": "Ace"
  },
  {
    "id": "MT_009",
    "dbfid": 36,
    "cardClass": "Monster",
    "name": "Kagerou Imaizumi",
    "attack": 2,
    "health": 4,
    "cost": 3,
    "rarity": "B",
    "collectible": true,
    "text": "상시 : 이 카드가 빛에 있을때는 이 카드는 공격할 수 없다. \n 이 카드가 어둠에 있을때 이 카드는 5/4가 된다. \n 이카드는 2번 공격할 수 있다.",
    "type": "Unit"
  },
  {
    "id": "MT_010",
    "dbfid": 37,
    "cardClass": "Monster",
    "name": "Lily White",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_001",
    "dbfid": 38,
    "cardClass": "Public",
    "name": "Lily White",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 필드존에 카드가 없어야 발동 할 수 있다. \n효과 : 덱에서 \"필드카드\" 1장을 필드존에 놓는다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_002",
    "dbfid": 39,
    "cardClass": "Public",
    "name": "Sunny Milk",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "효과 : 이 카드가 존재하는 한 자신 필드 3개를 빛으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_003",
    "dbfid": 40,
    "cardClass": "Public",
    "name": "Luna Child",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "효과 : 이 카드가 존재하는 한 자신 필드 3개를 어둠으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_004",
    "dbfid": 41,
    "cardClass": "Public",
    "name": "Minoriko Aki",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "조건 : 1턴에 1번 \"필드카드\"가 존재하면 발동할 수 있다. \n효과 : 자신은 2장 드로우한다.",
    "type": "Spell"
  },
  {
    "id": "PB_005",
    "dbfid": 42,
    "cardClass": "Public",
    "name": "Shizuha Aki",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 1턴에 1번 필드존의 카드가 존재할 경우에만 발동할 수 있다. \n효과 : 자신 필드에 어둠을 생성한다.",
    "type": "Spell"
  },
  {
    "id": "PB_006",
    "dbfid": 43,
    "cardClass": "Public",
    "name": "Hina Kagiyama",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 필드에 카드가 없어야 발동 할 수 있다. \n효과 : 자신 필드 2개를 어둠으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_007",
    "dbfid": 44,
    "cardClass": "Public",
    "name": "Nitori Kawashiro",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "S",
    "collectible": true,
    "text": "효과 : 필드를 모두 초기화한다. \n조건 1 : 상대가 어둠의 효과를 발동한 턴에 발동할 수 있다. \n조건 2 : 이 카드가 필드존에 존재해야만 발동할 수 있다. \n효과 2 : 상대 필드 필드존에 있는 어둠카드는 파괴된 어둠카드에 공격력만큼의 피해를 입힌다.",
    "type": "Spell"
  },
  {
    "id": "PB_008",
    "dbfid": 45,
    "cardClass": "Public",
    "name": "Reimu Hakurei",
    "attack": 2,
    "health": 3,
    "cost": 3,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 자신 주위의 적에게 2의 피해를 입힌다.\n조건: 필드에 다른 미니언이 없을 때 발동한다.",
    "type": "Unit",
    "behavior": "대응"
  },
  {
    "id": "PB_009",
    "dbfid": 46,
    "cardClass": "Public",
    "name": "Marisa Kirisame",
    "attack": 3,
    "health": 2,
    "cost": 3,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 적 유닛 하나에게 3의 피해와 1의 관통 피해를 준다.\n조건: 주문 카드 보유 시 발동한다.",
    "type": "Unit",
    "behavior": "돌진"
  },
  {
    "id": "PB_010",
    "dbfid": 47,
    "cardClass": "Public",
    "name": "Sakuya Izayoi",
    "attack": 2,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "효과: 상대의 다음 행동 순서를 1회 지연시킨다.\n조건: 반드시 적 미니언 한 마리를 지정해야 한다.",
    "type": "Spell",
    "behavior": "전략"
  },
  {
    "id": "PB_011",
    "dbfid": 48,
    "cardClass": "Public",
    "name": "Alice Margatroid",
    "attack": 1,
    "health": 5,
    "cost": 4,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 소환한 인형마다 주문 비용이 1 감소한다.\n조건: 인형 카드가 필드에 존재할 때 발동한다.",
    "type": "Unit",
    "behavior": "필드"
  },
  {
    "id": "PB_012",
    "dbfid": 49,
    "cardClass": "Public",
    "name": "Patchouli Knowledge",
    "attack": 0,
    "health": 4,
    "cost": 5,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 모든 주문 카드의 효과를 1턴 연기시킨다.\n조건: 필드에 마법 카드가 1장 이상 있을 때 발동한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_013",
    "dbfid": 50,
    "cardClass": "Public",
    "name": "Yuyuko Saigyouji",
    "attack": 1,
    "health": 6,
    "cost": 6,
    "rarity": "A",
    "collectible": true,
    "text": "효과: 피해를 입은 아군 미니언 한 마리를 회복시킨다.\n조건: 해당 미니언의 체력이 3 이하일 때 발동한다.",
    "type": "Unit",
    "behavior": "회복"
  },
  {
    "id": "PB_014",
    "dbfid": 51,
    "cardClass": "Public",
    "name": "Remilia Scarlet",
    "attack": 4,
    "health": 4,
    "cost": 5,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 모든 적 미니언에게 2의 피해를 준다.\n조건: 상대 턴에만 발동 가능하다.",
    "type": "Unit",
    "behavior": "광역"
  },
  {
    "id": "PB_015",
    "dbfid": 52,
    "cardClass": "Public",
    "name": "Flandre Scarlet",
    "attack": 5,
    "health": 3,
    "cost": 6,
    "rarity": "SS",
    "collectible": true,
    "text": "효과: 공격 시, 적 전장에 있는 모든 유닛에게 1의 피해를 준다.\n조건: 공격 성공 시 자동 발동한다.",
    "type": "Unit",
    "behavior": "대량"
  },
  {
    "id": "PB_016",
    "dbfid": 53,
    "cardClass": "Public",
    "name": "Nitori Kawashiro",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 필드를 모두 초기화한다.\n조건 1: 상대가 어둠의 효과를 발동한 턴에,\n조건 2: 이 카드가 필드존에 존재할 때 발동한다.\n효과 2: 상대 필드의 어둠 카드에 피해를 입힌다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_017",
    "dbfid": 54,
    "cardClass": "Public",
    "name": "Cirno",
    "attack": 3,
    "health": 3,
    "cost": 4,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 적 미니언 하나의 공격력을 1 감소시킨다.\n조건: 얼음 효과 발동 시, 대상 미니언의 공격력이 0 이하가 되지 않는다.",
    "type": "Spell",
    "behavior": "전략"
  }
]
</file>

<file path="simulator_core/src/card_gen/builder.rs">
use uuid::Uuid;

use crate::{
    card::{
        types::{CardSpecs, CardStatus, CardType, OwnerType},
        Card,
    },
    effect::{effects::EffectTiming, types::EffectSpeed, Effect},
    exception::GameError,
    utils::{self, json::CardJson},
};

pub struct CardBuilder {
    uuid: Uuid,
    name: String,
    card_type: CardType,
    effects: Vec<EffectTiming>,
    json_data: CardJson,
    owner: OwnerType,
    pub specs: CardSpecs,
    status: CardStatus,
}

impl CardBuilder {
    pub fn new(card_json: &CardJson) -> Result<Self, GameError> {
        Ok(Self {
            uuid: utils::generate_uuid().unwrap(),
            name: card_json.name.clone().ok_or(GameError::InvalidCardData)?,
            card_type: CardType::from_json(card_json)?,
            effects: vec![],
            json_data: card_json.clone(),
            owner: OwnerType::None,
            specs: CardSpecs::new(card_json),
            status: CardStatus::new(),
        })
    }

    pub fn add_effect<E: Effect + 'static>(mut self, effect: E) -> Self {
        // TODO: priority 설정
        self.effects
            .push(EffectTiming::new(1, EffectSpeed::Medium, Box::new(effect)));
        self
    }

    // // UUID 설정
    // pub fn uuid(mut self, uuid: UUID) -> Self {
    //     self.uuid = uuid;
    //     self
    // }

    // // 이름 설정
    // pub fn name(mut self, name: String) -> Self {
    //     self.name = name;
    //     self
    // }

    // // 카드 타입 설정
    // pub fn card_type(mut self, card_type: CardType) -> Self {
    //     self.card_type = card_type;
    //     self
    // }

    // // 효과 목록 한번에 설정
    // pub fn effects(mut self, effects: Vec<Box<dyn Effect>>) -> Self {
    //     self.effects = effects;
    //     self
    // }

    // // JSON 데이터 설정
    // pub fn json_data(mut self, json_data: CardJson) -> Self {
    //     self.json_data = json_data;
    //     self
    // }

    // // 소유자 설정
    // pub fn owner(mut self, owner: OwnerType) -> Self {
    //     self.owner = owner;
    //     self
    // }

    // // 스펙 설정
    // pub fn specs(mut self, specs: CardSpecs) -> Self {
    //     self.specs = specs;
    //     self
    // }

    // pub fn status(mut self, status: CardStatus) -> Self {
    //     self.status = status;
    //     self
    // }

    pub fn build(self) -> Card {
        // owner: OwnerType,
        // uuid: UUID,
        // name: String,
        // effects: Vec<Box<dyn Effect>>,
        // r#type: CardType,
        // specs: CardSpecs,
        // status: CardStatus,
        // json_data: CardJson)
        Card::new(
            self.owner,
            self.uuid,
            self.name,
            self.effects,
            self.card_type,
            self.specs,
            self.status,
            self.json_data,
        )
    }
}
</file>

<file path="simulator_core/src/card_gen/human.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;
// -------------------------------------------------- FIELD
// [HM_001] Hieda no Akyuu - COST:?? [ATK:??/HP:?]
// - Set: Human, Rarity: C
// --------------------------------------------------------
// Text: 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.
// --------------------------------------------------------
// Behaviors:
// - ListenOtherEvent
// - DrawCardFromDeck
// --------------------------------------------------------
#[allow(non_snake_case)]
pub fn HM_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

#[allow(non_snake_case)]
pub fn HM_002(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}

#[allow(non_snake_case)]
pub fn HM_003(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_004(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_005(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_006(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_007(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_008(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/mod.rs">
mod builder;
mod human;
mod monster;
mod public;

use crate::card::Card;
use crate::{utils, utils::json::CardJson};

use once_cell::sync::Lazy;
use std::collections::HashMap;

type CardGeneratorFn = fn(&CardJson, i32) -> Card;

macro_rules! generate_card_map {
    ($($module:ident :: $func:ident),* $(,)?) => {
        static CARD_GENERATORS: Lazy<HashMap<String, CardGeneratorFn>> = Lazy::new(|| {
            let mut m = HashMap::new();
            $(
                m.insert(stringify!($func).to_string(), $module::$func as CardGeneratorFn);
            )*
            m
        });
    };
}

include!(concat!(env!("OUT_DIR"), "/card_registry.rs"));

type Key = Vec<(String, i32)>;
pub struct CardGenerator {
    keys: Keys,
    card_generators: HashMap<i32, CardGeneratorFn>,
}

pub struct Keys {
    pub keys: Key,
}

impl Keys {
    pub fn new() -> Keys {
        let keys = match utils::load_card_id() {
            Ok(data) => data,
            Err(_) => panic!("Unknown Err fun: Keys initialize"),
        };
        Keys { keys }
    }

    pub fn get_usize_by_string(&self, key: &str) -> Option<i32> {
        self.keys
            .iter()
            .find(|&(item_key, _)| item_key == key)
            .map(|&(_, value)| value)
    }

    pub fn get_string_by_usize(&self, key: i32) -> Option<String> {
        self.keys
            .iter()
            .find(|&(_, item_key)| item_key == &key)
            .map(|(value, _)| value.clone())
    }
}

impl CardGenerator {
    pub fn new() -> CardGenerator {
        let keys = Keys::new();
        let mut card_generators = HashMap::new();

        for (str_id, func) in CARD_GENERATORS.iter() {
            if let Some(id) = keys.get_usize_by_string(str_id) {
                card_generators.insert(id, *func);
            }
        }

        CardGenerator {
            keys,
            card_generators,
        }
    }

    pub fn gen_card_by_id_i32(&self, id: i32, card_json: &CardJson, count: i32) -> Card {
        if let Some(generator) = self.card_generators.get(&id) {
            generator(card_json, count)
        } else {
            panic!("Unknown ID: {}", id);
        }
    }

    pub fn gen_card_by_id_string(&self, key: String, card_json: &CardJson, count: i32) -> Card {
        match self.keys.get_usize_by_string(&key[..]) {
            Some(id) => self.gen_card_by_id_i32(id, card_json, count),
            None => panic!("Unknown ID: {}", key),
        }
    }
}
</file>

<file path="simulator_core/src/card_gen/monster.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

#[allow(non_snake_case)]
pub fn MT_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

#[allow(non_snake_case)]
pub fn MT_002(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}

#[allow(non_snake_case)]
pub fn MT_003(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_004(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_005(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_006(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_007(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_008(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_009(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_010(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/public.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

#[allow(non_snake_case)]
pub fn PB_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}
#[allow(non_snake_case)]
pub fn PB_002(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_003(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_004(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_005(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_006(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_007(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_008(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_009(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_010(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_011(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_012(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_013(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_014(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_015(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_016(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_017(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
</file>

<file path="simulator_core/src/card/cards.rs">
use super::Card;
use uuid::Uuid;

/// Vec<Card> 타입의 별칭
pub type Cards = Vec<Card>;

/// Vec<Card> 확장 트레이트
pub trait CardVecExt {
    fn contains_uuid<U: Into<Uuid>>(&self, uuid: U) -> bool;
    fn find_by_uuid<U: Into<Uuid>>(&self, uuid: U) -> Option<&Card>;
    fn find_by_uuid_mut<U: Into<Uuid>>(&mut self, uuid: U) -> Option<&mut Card>;
    fn find_all<F>(&self, predicate: F) -> Vec<&Card>
    where
        F: Fn(&Card) -> bool;
    fn find_all_mut<F>(&mut self, predicate: F) -> Vec<&mut Card>
    where
        F: Fn(&Card) -> bool;
    fn shuffle(&mut self);
    fn count<F>(&self, predicate: F) -> usize
    where
        F: Fn(&Card) -> bool;
    // 새로 추가할 메소드들
    fn remove_by_uuid<U: Into<Uuid>>(&mut self, uuid: U) -> Option<Card>;
    fn remove_all<F>(&mut self, predicate: F) -> Vec<Card>
    where
        F: Fn(&Card) -> bool;
}

impl CardVecExt for Vec<Card> {
    /// 특정 UUID를 가진 카드를 찾아 벡터에서 제거하고 반환합니다.
    /// # Returns
    /// * `Some(Card)` - 해당 UUID를 가진 카드가 발견되어 제거된 경우
    /// * `None` - 해당 UUID를 가진 카드가 없는 경우
    fn remove_by_uuid<U: Into<Uuid>>(&mut self, uuid: U) -> Option<Card> {
        let uuid = uuid.into();
        let position = self.iter().position(|card| card.uuid == uuid)?;
        Some(self.remove(position))
    }

    /// 특정 조건을 만족하는 모든 카드를 벡터에서 제거하고 반환합니다.
    /// # Returns
    /// * `Vec<Card>` - 제거된 카드들의 벡터 (조건을 만족하는 카드가 없으면 빈 벡터)
    fn remove_all<F>(&mut self, predicate: F) -> Vec<Card>
    where
        F: Fn(&Card) -> bool,
    {
        // 제거할 카드 인덱스들 수집 (역순으로 정렬해야 함)
        let mut indices: Vec<usize> = self
            .iter()
            .enumerate()
            .filter(|(_, card)| predicate(card))
            .map(|(i, _)| i)
            .collect();

        // 역순으로 정렬 (뒤에서부터 제거해야 인덱스가 변하지 않음)
        indices.sort_by(|a, b| b.cmp(a));

        // 카드 제거하고 수집
        let mut removed = Vec::with_capacity(indices.len());
        for index in indices {
            removed.push(self.remove(index));
        }

        // 원래 순서대로 뒤집기
        removed.reverse();
        removed
    }
    /// Vec<Card> 에서 특정 Uuid 를 가진 Card 가 존재하는지 확인합니다.
    /// # RETURNS
    /// * `true` - 존재하는 경우
    /// * `false` - 존재하지 않는 경우
    fn contains_uuid<U: Into<Uuid>>(&self, uuid: U) -> bool {
        let uuid = uuid.into();
        self.iter().any(|card| card.uuid == uuid)
    }

    fn find_by_uuid<U: Into<Uuid>>(&self, uuid: U) -> Option<&Card> {
        let uuid = uuid.into();
        self.iter().find(|card| card.uuid == uuid)
    }

    fn find_by_uuid_mut<U: Into<Uuid>>(&mut self, uuid: U) -> Option<&mut Card> {
        let uuid = uuid.into();
        self.iter_mut().find(|card| card.uuid == uuid)
    }

    fn find_all<F>(&self, predicate: F) -> Vec<&Card>
    where
        F: Fn(&Card) -> bool,
    {
        self.iter().filter(|card| predicate(card)).collect()
    }

    fn find_all_mut<F>(&mut self, predicate: F) -> Vec<&mut Card>
    where
        F: Fn(&Card) -> bool,
    {
        self.iter_mut().filter(|card| predicate(card)).collect()
    }

    fn shuffle(&mut self) {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        self.as_mut_slice().shuffle(&mut rng);
    }

    fn count<F>(&self, predicate: F) -> usize
    where
        F: Fn(&Card) -> bool,
    {
        self.iter().filter(|card| predicate(card)).count()
    }
}
</file>

<file path="simulator_core/src/card/insert.rs">
use uuid::Uuid;

use crate::{exception::GameError, zone::zone::Zone};

use super::Card;

pub trait Insert: Send + Sync {
    /// 카드를 지정된 영역에 삽입합니다.
    ///
    /// # Arguments
    /// * `zone` - 카드를 삽입할 영역
    /// * `card` - 삽입할 카드
    ///
    /// # Returns
    /// * `Result<(), GameError>` - 삽입 성공 여부
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError>;

    /// 자기 자신의 복제본을 Box로 반환합니다.
    fn clone_box(&self) -> Box<dyn Insert>;
}
pub struct GeneralInsert;
pub struct TopInsert;
pub struct BottomInsert;
pub struct RandomInsert;
pub struct SpecificPositionInsert {
    target_card_uuid: Uuid,
    is_above: bool,
}

// Top 구현
impl Insert for TopInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인 (Zone 타입에 따라 다르게 처리할 수 있음)

        cards.push(card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(TopInsert)
    }
}

// Bottom 구현
impl Insert for BottomInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        cards.insert(0, card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(BottomInsert)
    }
}

// Random 구현
impl Insert for RandomInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        use rand::Rng;
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        let mut rng = rand::thread_rng();
        let position = rng.gen_range(0..=cards.len());
        cards.insert(position, card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(RandomInsert)
    }
}

// 특정 위치 구현
impl SpecificPositionInsert {
    pub fn new(target_card_uuid: Uuid, is_above: bool) -> Self {
        Self {
            target_card_uuid,
            is_above,
        }
    }
}

impl Insert for SpecificPositionInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        if let Some(pos) = cards
            .iter()
            .position(|c| c.get_uuid() == self.target_card_uuid)
        {
            let insert_pos = if self.is_above { pos } else { pos + 1 };
            cards.insert(insert_pos, card);
            Ok(())
        } else {
            Err(GameError::CardNotFound)
        }
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(Self {
            target_card_uuid: self.target_card_uuid,
            is_above: self.is_above,
        })
    }
}
</file>

<file path="simulator_core/src/card/mod.rs">
pub mod cards;
pub mod insert;
pub mod modifier;
pub mod take;
pub mod types;

use std::fmt;

use actix::Addr;
use types::{CardSpecs, CardStatus, OwnerType, StatType};
use uuid::Uuid;

use crate::{
    card::types::CardType,
    effect::{effects::EffectTiming, Effect},
    exception::GameError,
    game::GameActor,
    utils::json::CardJson,
};

#[derive(Clone)]
pub struct Card {
    uuid: Uuid,
    name: String,
    card_type: CardType,
    effects: Vec<EffectTiming>,
    specs: CardSpecs,
    status: CardStatus,
    owner: OwnerType,
    json_data: CardJson,
}

impl fmt::Debug for Card {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Card")
            .field("uuid", &self.uuid)
            .field("name", &self.name)
            .field("card_type", &self.card_type)
            .field("owner", &self.owner)
            // .field("effects", &self.effects)
            // .field("specs", &self.specs)
            // .field("status", &self.status)
            // .field("json_data", &self.json_data)
            .finish()
    }
}

impl PartialEq for Card {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl Eq for Card {}

impl Clone for Box<dyn Effect> {
    fn clone(&self) -> Self {
        self.clone_effect().unwrap()
    }
}

impl Card {
    pub fn new(
        owner: OwnerType,
        uuid: Uuid,
        name: String,
        effects: Vec<EffectTiming>,
        r#type: CardType,
        specs: CardSpecs,
        status: CardStatus,
        json_data: CardJson,
    ) -> Self {
        Self {
            uuid,
            name,
            card_type: r#type,
            effects,
            specs,
            status,
            owner,
            json_data,
        }
    }

    pub fn activate(&self, game: Addr<GameActor>) -> Result<(), GameError> {
        todo!()
    }

    // effect 효과로 처리
    pub fn can_be_targeted(&self) -> bool {
        todo!()
    }

    // Getter/Setter 메서드들
    pub fn get_uuid(&self) -> Uuid {
        self.uuid
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    pub fn get_type(&self) -> &CardType {
        &self.card_type
    }

    pub fn get_owner(&self) -> OwnerType {
        self.owner
    }

    pub fn set_owner(&mut self, player: OwnerType) {
        self.owner = player;
    }

    pub fn get_specs(&self) -> &CardSpecs {
        &self.specs
    }

    pub fn get_status(&self) -> &CardStatus {
        &self.status
    }

    pub fn get_status_mut(&mut self) -> &mut CardStatus {
        &mut self.status
    }

    pub fn get_prioritized_effect(&self) -> &Vec<EffectTiming> {
        &self.effects
    }

    pub fn get_prioritized_effect_mut(&mut self) -> &mut Vec<EffectTiming> {
        &mut self.effects
    }

    // 효과 추가
    pub fn add_effect<E: Effect + 'static>(&mut self, effect: E) {
        todo!()
        // self.effects.push(Box::new(effect));
    }

    pub fn modify_stat(&mut self, stat_type: StatType, amount: i32) -> Result<(), GameError> {
        Ok(())
    }

    // 카드 복사 (새로운 UUID 생성)
    pub fn clone_with_new_uuid(&self) -> Result<Self, GameError> {
        todo!()
        // Ok(Card {
        //     uuid: utils::generate_uuid()?,
        //     name: self.name.clone(),
        //     card_type: self.card_type.clone(),
        //     effects: self
        //         .effects
        //         .iter()
        //         .map(|e| e.clone_effect())
        //         .collect::<Result<Vec<_>, _>>()?,
        //     specs: self.specs.clone(),
        //     status: CardStatus::default(),
        //     owner: self.owner.clone(),
        //     json_data: self.json_data.clone(),
        // })
    }
}
</file>

<file path="simulator_core/src/card/modifier.rs">
use crate::game::phase::Phase;

use super::types::{Duration, ModifierType};

///
/// 카드의 상태를 수정하는 구조체
///
#[derive(Clone)]
pub struct Modifier {
    modifier_type: ModifierType,
    value: i32,
    duration: Duration,
    source_card: Option<String>,
    applied_turn: usize,  // 효과가 적용된 턴
    applied_phase: Phase, // 효과가 적용된 페이즈
}

impl Modifier {
    // Getters
    pub fn get_modifier_type(&self) -> ModifierType {
        self.modifier_type
    }

    pub fn get_value(&self) -> i32 {
        self.value
    }

    pub fn get_duration(&self) -> Duration {
        self.duration
    }

    pub fn get_source_card(&self) -> Option<&String> {
        self.source_card.as_ref()
    }

    pub fn get_applied_turn(&self) -> usize {
        self.applied_turn
    }

    pub fn get_applied_phase(&self) -> Phase {
        self.applied_phase
    }

    // Setters
    pub fn set_modifier_type(&mut self, modifier_type: ModifierType) {
        self.modifier_type = modifier_type;
    }

    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }

    pub fn set_duration(&mut self, duration: Duration) {
        self.duration = duration;
    }

    pub fn set_source_card(&mut self, source_card: Option<String>) {
        self.source_card = source_card;
    }

    pub fn set_applied_turn(&mut self, turn: usize) {
        self.applied_turn = turn;
    }

    pub fn set_applied_phase(&mut self, phase: Phase) {
        self.applied_phase = phase;
    }

    // 편의 메서드들
    pub fn new(
        modifier_type: ModifierType,
        value: i32,
        duration: Duration,
        source_card: Option<String>,
        applied_turn: usize,
        applied_phase: Phase,
    ) -> Self {
        Self {
            modifier_type,
            value,
            duration,
            source_card,
            applied_turn,
            applied_phase,
        }
    }

    // 수정자가 아직 유효한지 확인
    pub fn is_expired(&self, current_turn: usize, current_phase: Phase) -> bool {
        match self.duration {
            Duration::Permanent => true,
            Duration::UntilEndOfTurn => current_turn == self.applied_turn,
            Duration::UntilEndOfPhase => {
                current_turn == self.applied_turn && current_phase == self.applied_phase
            }
            Duration::ForXTurns(turns) => current_turn <= self.applied_turn + turns,
        }
    }

    // 수정자의 남은 지속 시간 계산
    pub fn remaining_duration(&self, current_turn: usize) -> Option<usize> {
        match self.duration {
            Duration::Permanent => None,
            Duration::UntilEndOfTurn => {
                if current_turn > self.applied_turn {
                    Some(0)
                } else {
                    Some(1)
                }
            }
            Duration::UntilEndOfPhase => Some(if current_turn > self.applied_turn {
                0
            } else {
                1
            }),
            Duration::ForXTurns(turns) => {
                Some(turns.saturating_sub(current_turn - self.applied_turn))
            }
        }
    }

    // 수정자 복사본 생성 (다른 턴/페이즈에 적용)
    pub fn copy_with_new_timing(&self, turn: usize, phase: Phase) -> Self {
        let mut new = self.clone();
        new.set_applied_turn(turn);
        new.set_applied_phase(phase);
        new
    }

    // 수정자 값 변경
    pub fn modify_value(&mut self, delta: i32) {
        self.value += delta;
    }

    // 지속 시간 연장
    pub fn extend_duration(&mut self, additional: Duration) {
        self.duration = match (self.duration, additional) {
            (Duration::ForXTurns(t1), Duration::ForXTurns(t2)) => Duration::ForXTurns(t1 + t2),
            (Duration::Permanent, _) => Duration::Permanent,
            _ => self.duration,
        };
    }
}
</file>

<file path="simulator_core/src/card/take.rs">
use uuid::Uuid;

use crate::{exception::GameError, selector::TargetCount, zone::zone::Zone};

use super::Card;
use crate::card::cards::CardVecExt;

pub trait Take: Send + Sync {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError>;
    fn clone_box(&self) -> Box<dyn Take>;
}

// TopTake: 덱/존의 위에서 카드를 가져옴
#[derive(Clone)]
pub struct TopTake(pub TargetCount);

impl Take for TopTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::InternalServerError);
        }

        // drain은 앞에서부터 제거하므로, 뒤에서부터 가져오려면 인덱스 계산 필요
        let start_index = available.saturating_sub(count);
        Ok(cards.drain(start_index..).collect()) // drain은 역순으로 반환하지 않음, 순서 유지됨
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone()) // Clone을 이용해 간단히 구현
    }
}

// BottomTake: 덱/존의 아래에서 카드를 가져옴
#[derive(Clone)]
pub struct BottomTake(pub TargetCount);

impl Take for BottomTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::InternalServerError);
        }

        // 앞에서부터 count만큼 제거
        Ok(cards.drain(0..count).collect())
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// RandomTake: 덱/존에서 무작위로 카드를 가져옴
#[derive(Clone)]
pub struct RandomTake(pub TargetCount);

impl Take for RandomTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::InternalServerError);
        }

        // 1. 무작위 인덱스를 count만큼 중복 없이 뽑기
        let mut rng = rand::thread_rng();
        let indices_to_take: Vec<usize> =
            rand::seq::index::sample(&mut rng, available, count).into_vec();

        // 2. 인덱스를 내림차순으로 정렬하여 제거 시 다른 인덱스에 영향을 주지 않도록 함
        let mut sorted_indices = indices_to_take;
        sorted_indices.sort_unstable_by(|a, b| b.cmp(a)); // 내림차순 정렬

        // 3. 정렬된 인덱스를 사용하여 카드 제거 및 수집
        let mut taken_cards = Vec::with_capacity(count);
        for index in sorted_indices {
            // remove는 요소를 제거하고 뒤의 요소들을 앞으로 당김
            taken_cards.push(cards.remove(index));
        }

        // 4. 원래 뽑힌 순서대로 돌려주려면 taken_cards를 reverse 해야 함 (선택적)
        // 현재는 제거된 순서의 역순으로 반환됨. 무작위 선택이므로 순서가 중요하지 않을 수 있음.
        // taken_cards.reverse();

        Ok(taken_cards)
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// SpecificTake: 특정 UUID의 카드를 가져옴
#[derive(Clone)]
pub struct SpecificTake(pub Uuid);

impl Take for SpecificTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();

        match cards.remove_by_uuid(self.0) {
            Some(card) => Ok(vec![card]),
            None => Err(GameError::CardNotFound),
        }
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// --- Helper Function ---

/// 가져올 카드의 수를 계산하는 헬퍼 함수
fn calculate_take_count(target_count: TargetCount, available: usize) -> Result<usize, GameError> {
    use std::cmp::min; // 함수 내에서만 사용

    match target_count {
        TargetCount::Exact(n) => {
            if n > available {
                // 정확히 n개를 가져와야 하는데 부족한 경우 -> 에러 처리 또는 정책 결정 필요
                // 여기서는 일단 에러로 처리 (혹은 0개를 반환할 수도 있음)
                Err(GameError::NotEnoughCards) // 더 구체적인 에러 타입 정의 필요
            } else {
                Ok(n)
            }
        }
        TargetCount::Range(low, high) => {
            if available < low {
                // 최소 요구량보다 적으면 에러 또는 0 반환
                Err(GameError::NotEnoughCards) // 또는 Ok(0)
            } else {
                // low 이상 high 이하, 그리고 available 이하의 값을 반환
                Ok(min(high, available))
            }
        }
        TargetCount::Any => {
            // 가능한 모든 카드
            Ok(available)
        }
        TargetCount::None => {
            // 0개
            Ok(0)
        }
    }
}

// --- 새로운 에러 타입 정의 (선택적) ---
// exception/mod.rs 에 추가
// #[derive(Debug, PartialEq, Clone)]
// pub enum GameError {
//     // ... 기존 에러들 ...
//     NotEnoughCards(usize, usize), // 필요한 카드 수, 실제 있는 카드 수
//     // ...
// }
//
// impl fmt::Display for GameError {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self {
//             // ...
//             Self::NotEnoughCards(needed, available) => write!(f, "Not enough cards: needed {}, available {}", needed, available),
//             // ...
//         }
//     }
// }
</file>

<file path="simulator_core/src/effect/effects.rs">
use actix::Addr;

use crate::{card::Card, game::GameActor};

use super::{types::EffectSpeed, Effect};

// Effect 에 우선순위를 부여하는건 장기적으로 좋음.
pub struct Effects {
    // 항상 정렬 상태를 보장해야함.
    prioritized_effects: Vec<EffectTiming>,
}

impl Effects {
    pub fn new() -> Self {
        Self {
            prioritized_effects: vec![],
        }
    }

    pub fn add_effect(&mut self, effect: EffectTiming) {
        self.prioritized_effects.push(effect);
        self.prioritized_effects.sort_by_key(|e| e.get_priority());
    }

    pub fn get_effects(&self) -> Vec<&Box<dyn Effect>> {
        self.prioritized_effects
            .iter()
            .map(|e| e.get_effect())
            .collect::<Vec<_>>()
    }

    pub fn get_effects_mut(&mut self) -> Vec<&mut Box<dyn Effect>> {
        self.prioritized_effects
            .iter_mut()
            .map(|e| e.get_effect_mut())
            .collect::<Vec<_>>()
    }

    // 특정 조건을 만족하는 효과만 필터링 (조건을 클로저로 전달)
    pub fn filter_effects<F>(&self, filter: F) -> Vec<&EffectTiming>
    where
        F: Fn(&EffectTiming) -> bool,
    {
        self.prioritized_effects
            .iter()
            .filter(|e| filter(e))
            .collect()
    }

    // 체인 상태에서 추가 가능한 효과만 필터링
    pub fn get_chainable_effects(&self, current_chain_level: EffectSpeed) -> Vec<&EffectTiming> {
        self.prioritized_effects
            .iter()
            .filter(|e| {
                let timing = e.get_effect().get_speed();
                if timing >= current_chain_level {
                    return true;
                } else {
                    return false;
                }
            })
            .collect()
    }

    // 발동 가능한 효과만 필터링
    pub fn get_activatable_effects(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Vec<&EffectTiming> {
        todo!()
        // self.prioritized_effects
        //     .iter()
        //     .filter(|e| e.get_effect().can_activate(game, source))
        //     .collect()
    }
}

#[derive(Clone)]
pub struct EffectTiming {
    priority: u8, // 낮을수록 높은 우선순위
    speed: EffectSpeed,
    is_used: bool, // 효과가 사용되었는지 여부
    effect: Box<dyn Effect>,
}

impl EffectTiming {
    pub fn new(priority: u8, speed: EffectSpeed, effect: Box<dyn Effect>) -> Self {
        Self {
            priority,
            effect,
            speed,
            is_used: false,
        }
    }

    pub fn get_priority(&self) -> u8 {
        self.priority
    }

    pub fn get_speed(&self) -> EffectSpeed {
        self.speed
    }

    pub fn get_effect(&self) -> &Box<dyn Effect> {
        &self.effect
    }

    pub fn get_effect_mut(&mut self) -> &mut Box<dyn Effect> {
        &mut self.effect
    }
}
</file>

<file path="simulator_core/src/effect/types.rs">
use uuid::Uuid;

use crate::{enums::ZoneType, server::input_handler::InputRequest};

pub struct EffectInfo {
    pub effect_id: Uuid,
    pub effect_type: EffectType,
    pub from_location: ZoneType,
    pub to_location: ZoneType,
}

impl EffectInfo {
    pub fn new(
        effect_id: Uuid,
        effect_type: EffectType,
        from_location: ZoneType,
        to_location: ZoneType,
    ) -> Self {
        Self {
            effect_id,
            effect_type,
            from_location,
            to_location,
        }
    }
}

pub enum EffectResult {
    // 효과가 완전히 실행됨
    Completed,

    // 사용자 입력이 필요함
    NeedsInput { inner: InputRequest },
}

#[derive(PartialEq, Eq, PartialOrd, Clone, Copy)]
pub enum EffectSpeed {
    Quick = 3,  // 스피드 3
    Medium = 2, // 스피드 2
    Slow = 1,   // 스피드 1
}

impl EffectSpeed {
    pub fn is_faster_than(&self, other: EffectSpeed) -> bool {
        self > &other
    }
    pub fn is_slower_than(&self, other: EffectSpeed) -> bool {
        self < &other
    }
    pub fn is_equal_to(&self, other: EffectSpeed) -> bool {
        self == &other
    }
    pub fn can_it_chain(&self, other: EffectSpeed) -> bool {
        self.is_faster_than(other) || self.is_equal_to(other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EffectType {
    Dig,
    Draw,
    ModifyStat,
}

#[derive(Debug, Clone, Copy)]
pub enum EffectProcessPhase {
    ImmediatePhase, // 즉발 효과 처리 중
    ChainPhase,     // 체인 효과 처리 중
    InputWaiting,   // 사용자 입력 대기 중
}
</file>

<file path="simulator_core/src/enums/mod.rs">
use std::fmt::Display;

use uuid::Uuid;

pub const CARD_ID_JSON_PATH: &str = "Resource/cards_id.json";
pub const CARD_JSON_PATH: &str = "Resource/cards.json";
pub const DECK_JSON_PATH_P1: &str = "Datas/player1_test.json";
pub const DECK_JSON_PATH_P2: &str = "Datas/player2_test.json";
pub const UUID_GENERATOR_PATH: &str = "Resource/uuidgen";
pub const GAME_CONFIG_JSON_PATH: &str = "Datas/config.json";

#[derive(Clone, Debug, PartialEq, Eq, Hash, Copy)]
pub enum ZoneType {
    Hand,
    Deck,
    Graveyard,
    Effect,
    Field,
    None,
}

impl ZoneType {
    pub fn to_string(&self) -> String {
        match self {
            ZoneType::Hand => "Hand".to_string(),
            ZoneType::Deck => "Deck".to_string(),
            ZoneType::Graveyard => "Graveyard".to_string(),
            ZoneType::Effect => "Effect".to_string(),
            ZoneType::Field => "Field".to_string(),
            ZoneType::None => "None".to_string(),
        }
    }
}

impl Display for ZoneType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_string())
    }
}

pub const MAX_CARD_SIZE: usize = 30;

pub type CardsUuid = Vec<Uuid>;

pub const COUNT_OF_CARDS: usize = 30;
pub const COUNT_OF_MULLIGAN_CARDS: usize = 5;
pub const PLAYER_1: usize = 0;
pub const PLAYER_2: usize = 1;

pub const UNIT_ZONE_SIZE: usize = 12;
pub const DECK_ZONE_SIZE: usize = 30;
pub const HAND_ZONE_SIZE: usize = 10;

pub const HEARTBEAT_INTERVAL: u64 = 5;
pub const CLIENT_TIMEOUT: u64 = 20; // 20초 동안 응답 없으면 연결 끊김
</file>

<file path="simulator_core/src/game_old/chain copy.rs">
use crate::{
    card::{
        effect::{Effect, EffectResult},
        types::PlayerType,
        Card, PrioritizedEffect,
    },
    exception::GameError,
    server::input_handler::InputAnswer,
};
use std::collections::HashSet;
use tracing::info;
use uuid::Uuid;

use super::{game_step::PlayCardResult, Game};

// 체인 처리 단계
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChainPhase {
    Building,  // 체인 구성 중 (효과 추가 가능)
    Resolving, // 체인 해결 중 (효과 실행 단계)
    Waiting,   // 사용자 입력 대기 중
    Completed, // 체인 처리 완료
}

impl Default for ChainPhase {
    fn default() -> Self {
        todo!()
    }
}

// 체인 아이템 구조체 (효과와 소스 카드 연결)
#[derive(Clone)]
pub struct ChainLink {
    effect: Box<dyn Effect>,
    source_card: Card,
}

#[derive(Clone, Default)]
pub struct Chain {
    // 체인 큐 (LIFO 방식으로 처리)
    links: Vec<ChainLink>,

    // 현재 체인 처리 단계
    current_phase: ChainPhase,

    // 현재 처리 중인 카드 (입력 대기 중일 때 사용)
    pending_card: Option<Card>,

    // 처리 대기 중인 효과들 (입력 후 체인에 추가 예정)
    pending_effects: Vec<PrioritizedEffect>,

    // 이미 처리된 효과 ID
    processed_effect_ids: HashSet<Uuid>,

    // 유저 입력 대기 정보
    waiting_effect_index: Option<usize>,
    waiting_input: Option<InputAnswer>,
}

impl Chain {
    pub fn new() -> Self {
        Self {
            links: Vec::new(),
            current_phase: ChainPhase::Completed, // 초기 상태는 완료
            pending_card: None,
            pending_effects: Vec::new(),
            processed_effect_ids: HashSet::new(),
            waiting_effect_index: None,
            waiting_input: None,
        }
    }

    /// 카드의 모든 효과를 처리합니다
    pub async fn process_card_effects(
        &mut self,
        game: &mut Game,
        player_type: PlayerType,
        card: Card,
    ) -> Result<PlayCardResult, GameError> {
        info!(
            "카드 효과 처리: player={:?}, card={:?}",
            player_type,
            card.get_uuid()
        );

        // 효과 처리 준비
        let effects = card.get_prioritized_effect();

        // 1. 즉발 효과 처리
        let result = self
            .process_immediate_effects(game, &card, &effects)
            .await?;

        // 2. 체인 효과 처리
        self.add_chain_effects(game, &card, &effects)?;

        // 3. 체인 해결
        if self.has_effects() {
            match self.resolve(game)? {
                ChainResolutionResult::Completed => Ok(PlayCardResult::Success),
                ChainResolutionResult::WaitingForInput(result) => Ok(result),
            }
        } else {
            Ok(PlayCardResult::Success)
        }
    }

    /// 즉발 효과 처리
    async fn process_immediate_effects(
        &mut self,
        game: &mut Game,
        card: &Card,
        effects: &[PrioritizedEffect],
    ) -> Result<Option<PlayCardResult>, GameError> {
        // 즉발 효과 수집
        let immediate_effects: Vec<_> = effects
            .iter()
            .filter(|e| e.get_effect().get_timing() == EffectLevel::Immediate)
            .collect();

        // let result = vec![];

        // 효과 처리
        for prioritized_effect in immediate_effects {
            // 이미 처리된 효과는 건너뛰기
            let effect_id = prioritized_effect.get_effect().get_id().into();
            if self.processed_effect_ids.contains(&effect_id) {
                continue;
            }

            if let Ok(effect_clone) = prioritized_effect.get_effect().clone_effect() {
                let result = effect_clone.begin_effect(game, card)?;

                match result {
                    EffectResult::Completed => {
                        // 효과 완료, 처리된 효과로 표시
                        self.processed_effect_ids.insert(effect_id);
                    }
                    EffectResult::NeedsInput { inner, handler } => {
                        let rx = game.get_input_waiter_mut().wait_for_input(inner).await?;
                        return Ok(Some(PlayCardResult::NeedInput(rx, handler)));
                    }
                }
            }
        }

        // 모든 즉발 효과가 완료됨
        Ok(None)
    }

    /// 체인 효과 추가
    fn add_chain_effects(
        &mut self,
        game: &mut Game,
        card: &Card,
        effects: &[PrioritizedEffect],
    ) -> Result<(), GameError> {
        // 체인 효과 수집
        let chain_effects: Vec<_> = effects
            .iter()
            .filter(|e| e.get_effect().get_timing() == EffectLevel::Chain)
            .collect();

        // 체인에 효과 추가
        for prioritized_effect in chain_effects {
            // 이미 처리된 효과는 건너뛰기
            let effect_id = prioritized_effect.get_effect().get_id().into();
            if self.processed_effect_ids.contains(&effect_id) {
                continue;
            }

            if let Ok(effect_clone) = prioritized_effect.get_effect().clone_effect() {
                self.add_effect(card.clone(), effect_clone);
            }
        }

        Ok(())
    }

    pub fn has_effects(&self) -> bool {
        !self.links.is_empty()
    }

    /// 체인에 효과 추가
    pub fn add_effect(&mut self, card: Card, effect: Box<dyn Effect>) {
        // 체인 구성 단계가 아니면 효과 추가 불가
        if self.current_phase != ChainPhase::Building {
            self.start_building(); // 새 체인 시작
        }

        // 효과를 체인 링크로 래핑하여 추가
        self.links.push(ChainLink {
            effect,
            source_card: card,
        });
    }

    /// 보류 중인 효과들을 체인에 추가
    pub fn pending_chain_effects(&mut self, card: Card, effects: Vec<PrioritizedEffect>) {
        // 입력 대기 상태로 변경
        self.current_phase = ChainPhase::Waiting;
        self.pending_card = Some(card);
        self.pending_effects = effects;
    }

    /// 사용자 입력 처리 후 보류 중인 효과 추가
    pub fn add_pending_effects_after_input(&mut self) -> Result<(), GameError> {
        if self.current_phase != ChainPhase::Waiting || self.pending_card.is_none() {
            return Err(GameError::InvalidChainState);
        }

        // 준비 단계로 전환
        self.current_phase = ChainPhase::Building;
        let card = self.pending_card.take().unwrap();

        // 벡터 소유권 가져오기
        let pending_effects = std::mem::take(&mut self.pending_effects);

        // 소유권을 가진 벡터 처리
        for prioritized_effect in pending_effects {
            let effect_id = prioritized_effect.get_effect().get_id();
            if !self.processed_effect_ids.contains(&effect_id.into()) {
                if let Ok(effect) = prioritized_effect.get_effect().clone_effect() {
                    self.add_effect(card.clone(), effect);
                }
            }
        }

        Ok(())
    }

    /// 체인 구성 시작
    pub fn start_building(&mut self) {
        // 이전 체인 상태 정리
        if self.current_phase == ChainPhase::Building || self.current_phase == ChainPhase::Resolving
        {
            // 이미 활성화된 체인이 있으면 처리 완료해야 함
            // 여기서는 간단히 초기화만 수행
            self.links.clear();
        }

        self.current_phase = ChainPhase::Building;
    }

    /// 체인 해결 시작
    pub fn start_resolving(&mut self) -> Result<(), GameError> {
        if self.links.is_empty() {
            return Ok(()); // 체인이 비어있으면 아무것도 안 함
        }

        self.current_phase = ChainPhase::Resolving;
        Ok(())
    }

    /// 체인의 모든 효과 해결
    pub fn resolve(&mut self, game: &mut Game) -> Result<ChainResolutionResult, GameError> {
        // 체인이 구성 중이면 해결 단계로 전환
        if self.current_phase == ChainPhase::Building {
            self.start_resolving()?;
        }

        // 해결 단계가 아니면 에러
        if self.current_phase != ChainPhase::Resolving {
            return Err(GameError::InvalidChainState);
        }

        // 대기 중인 입력이 있으면 처리
        if let Some(index) = self.waiting_effect_index {
            if let Some(input) = self.waiting_input.take() {
                let link = &self.links[index];
                let result = link.effect.handle_input(game, &link.source_card, input)?;

                match result {
                    EffectResult::Completed => {
                        // 효과 완료, 처리된 효과로 표시
                        self.processed_effect_ids
                            .insert(link.effect.get_id().into());
                        self.waiting_effect_index = None;
                    }
                    EffectResult::NeedsInput { inner, handler } => {
                        // 여전히 입력 필요
                        // return Ok(ChainResolutionResult::WaitingForInput(inner));
                    }
                }
            } else {
                // 대기 중인데 입력이 없으면 에러
                return Err(GameError::MissingInput);
            }
        }

        // LIFO 방식으로 체인 해결 (뒤에서부터 처리)
        while !self.links.is_empty() {
            let index = self.links.len() - 1;
            let link = &self.links[index];
            let effect_id = link.effect.get_id();

            // 이미 처리된 효과는 건너뛰기
            if self.processed_effect_ids.contains(&effect_id.into()) {
                self.links.pop();
                continue;
            }

            // 효과 실행
            let result = link.effect.begin_effect(game, &link.source_card)?;

            match result {
                EffectResult::Completed => {
                    // 효과 완료, 체인에서 제거
                    self.processed_effect_ids.insert(effect_id.into());
                    self.links.pop();
                }
                EffectResult::NeedsInput { inner, handler } => {
                    // 입력 대기 상태로 전환
                    self.waiting_effect_index = Some(index);
                    self.current_phase = ChainPhase::Waiting;
                    // return Ok(ChainResolutionResult::WaitingForInput(inner));
                }
            }
        }

        // 모든 효과 처리 완료
        self.current_phase = ChainPhase::Completed;
        Ok(ChainResolutionResult::Completed)
    }
}

impl Chain {
    /// 현재 체인 처리 단계 반환
    pub fn phase(&self) -> ChainPhase {
        self.current_phase
    }

    /// 현재 처리 중인 카드 참조 반환
    pub fn pending_card(&self) -> Option<&Card> {
        self.pending_card.as_ref()
    }

    /// 처리 대기 중인 효과들 참조 반환
    pub fn pending_effects(&self) -> &[PrioritizedEffect] {
        &self.pending_effects
    }

    /// 이미 처리된 효과 ID 목록 참조 반환
    // TODO: 사용된 효과는 특정 조건에 따라 다시 복구될 수 있어야함.
    pub fn processed_effect_ids(&self) -> &HashSet<Uuid> {
        &self.processed_effect_ids
    }

    /// 대기 중인 효과 인덱스 반환
    pub fn waiting_effect_index(&self) -> Option<usize> {
        self.waiting_effect_index
    }

    /// 대기 중인 사용자 입력 참조 반환
    pub fn waiting_input(&self) -> Option<&InputAnswer> {
        self.waiting_input.as_ref()
    }

    //
    // Setter 메서드 (필요한 필드만)
    //

    /// 체인 처리 단계 설정
    pub fn set_phase(&mut self, phase: ChainPhase) {
        self.current_phase = phase;
    }

    /// 처리 중인 카드 설정
    pub fn set_pending_card(&mut self, card: Option<Card>) {
        self.pending_card = card;
    }

    /// 대기 중인 효과들 설정
    pub fn set_pending_effects(&mut self, effects: Vec<PrioritizedEffect>) {
        self.pending_effects = effects;
    }

    /// 처리된 효과 ID 추가
    pub fn add_processed_effect_id(&mut self, effect_id: Uuid) {
        self.processed_effect_ids.insert(effect_id);
    }

    /// 처리된 효과 ID 목록 초기화
    pub fn clear_processed_effect_ids(&mut self) {
        self.processed_effect_ids.clear();
    }

    /// 효과가 이미 처리되었는지 확인
    pub fn is_effect_processed(&self, effect_id: &Uuid) -> bool {
        self.processed_effect_ids.contains(effect_id)
    }

    /// 대기 중인 효과 인덱스 설정
    pub fn set_waiting_effect_index(&mut self, index: Option<usize>) {
        self.waiting_effect_index = index;
    }

    /// 대기 중인 사용자 입력 설정
    pub fn set_waiting_input(&mut self, input: Option<InputAnswer>) {
        self.waiting_input = input;
    }

    //
    // 유틸리티 메서드
    //

    /// 대기 중인 효과 및 입력 정보 초기화
    pub fn clear_waiting_state(&mut self) {
        self.waiting_effect_index = None;
        self.waiting_input = None;
    }

    /// 모든 상태 초기화 (새 체인 시작용)
    pub fn reset(&mut self) {
        self.links.clear();
        self.current_phase = ChainPhase::Completed;
        self.pending_card = None;
        self.pending_effects.clear();
        self.processed_effect_ids.clear();
        self.clear_waiting_state();
    }
}

// 체인 해결 결과
pub enum ChainResolutionResult {
    Completed,                       // 모든 효과 처리 완료
    WaitingForInput(PlayCardResult), // 사용자 입력 대기
}
</file>

<file path="simulator_core/src/game_old/chain.rs">
use crate::{
    card::{types::PlayerType, Card},
    effect::{
        effects::EffectTiming,
        types::{EffectResult, EffectSpeed, HandlerType},
    },
    exception::GameError,
    server::input_handler::{InputAnswer, InputRequest},
};
use std::collections::HashSet;
use tracing::info;
use uuid::Uuid;

use super::{game_step::PlayCardResult, Game};

// 체인 처리 단계
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChainPhase {
    Idle,      // 대기 중 (새로운 체인 생서 가능)
    Building,  // 체인 구성 중 (효과 추가 가능)
    Resolving, // 체인 해결 중 (효과 실행 단계)
    Waiting,   // 사용자 입력 대기 중
    Completed, // 체인 처리 완료
}

impl Default for ChainPhase {
    fn default() -> Self {
        todo!()
    }
}

// 체인 아이템 구조체 (효과와 소스 카드 연결)
#[derive(Clone)]
pub struct ChainLink {
    effect: EffectTiming,
    source_card: Card,
}

#[derive(Clone, Default)]
pub struct Chain {
    // 체인 큐 (LIFO 방식으로 처리)
    links: Vec<ChainLink>,

    // 현재 체인 처리 단계
    current_phase: ChainPhase,

    // 이미 처리된 효과 ID
    processed_effect_ids: HashSet<Uuid>,
}

impl Chain {
    pub fn new() -> Self {
        Self {
            links: Vec::new(),
            current_phase: ChainPhase::Completed, // 초기 상태는 완료
            processed_effect_ids: HashSet::new(),
        }
    }

    /// 카드의 모든 효과를 처리합니다
    pub async fn process_card_effects(
        &mut self,
        game: &mut Game,
        player_type: PlayerType,
        card: Card,
    ) -> Result<PlayCardResult, GameError> {
        info!(
            "카드 효과 처리: player={:?}, card={:?}",
            player_type,
            card.get_uuid()
        );

        // 카드는 효과를 여러개 가질 수 있음.
        // 1. 카드의 효과는 각 게임 상태에 따라 발동 여부가 결정됨
        // 2. 개중에는 동시에 발동할 수 있는 효과도 있음 ( 이런 경우, 사용자가 무슨 효과를 발동할 지 선택함. )
        // 효과 중 이미 처리된 효과는 제외 해야함.
        // 이 때 이미 사용되었다고 해서 무조건 GameError 을 발생시키면 안됨.

        // 현재 입력된 카드의 효과를 가져옵니다.
        let effects = card.get_prioritized_effect().clone();

        // 발동 가능한 효과를 필터링 합니다.
        let activable_effects = effects
            .iter()
            .filter(|e| e.get_effect().can_activate(game, &card))
            .collect::<Vec<_>>();

        if activable_effects.is_empty() {
            // 발동 가능한 효과가 없으면 종료합니다.
            return Err(GameError::NoActivatableEffect);
        }

        // 발동 가능한 효과가 두 개 이상일 경우, 사용자로부터 선택을 받아야 합니다.
        if activable_effects.len() >= 2 {
            let rx = game
                .get_input_waiter_mut()
                .wait_for_input(InputRequest::SelectEffect {
                    source_card: card.get_uuid(),
                    potential_effects: activable_effects
                        .iter()
                        .map(|e| e.get_effect().get_id())
                        .collect(),
                })
                .await?;
            // TODO: HandlerType 넘겨서 외부 처리를 기대하는 패턴은 잘못된 것 같음.
            // 소유권, 생명 주기 관리가 어렵다
            // handle_input 에서 처리하거나 
            return Ok(PlayCardResult::NeedInput(
                rx,
                HandlerType::General(Box::new(
                    move |game: &mut Game,
                          source: &Card,
                          input: InputAnswer|
                          -> Result<EffectResult, GameError> {
                        Ok(EffectResult::Completed)
                    },
                )),
            ));
            // TODO: 무슨 효과를 발동할 지 선택 받아야함.
        }

        // 최종적으로 선택된 효과 하나를 가져옵니다.
        let activable_effect = *activable_effects.last().unwrap();

        match self.current_phase {
            // 체인이 대기 상태일 때
            ChainPhase::Idle => {
                // 바로 체인에 추가합니다.
                self.add_link_to_chain(activable_effect.clone(), card.clone());

                self.current_phase = ChainPhase::Building; // 체인 상태를 변경합니다.
            }
            // 체인이 구성 중일 때.
            ChainPhase::Building => {
                // 이전 체인 스피드를 확인하여 체인을 이어갈 수 있는지 확인합니다.
                // 체인 스피드가 같거나 빠른 경우에만 체인에 추가합니다.
                let last_effect = self.links.last().unwrap().effect.clone();

                // 현재 처리중인 효과의 이펙트 스피드가 체인보다 느릴 경우,
                if last_effect
                    .get_speed()
                    .can_it_chain(activable_effect.get_speed())
                    == false
                {
                    return Err(GameError::InvalidChainSpeed);
                }

                self.add_link_to_chain(activable_effect.clone(), card.clone());
            }
            _ => {
                // 체인 처리 중일 때는 추가할 수 없습니다.
                return Err(GameError::InvalidChainPhase);
            }
        }

        // 카드의 효과 중 발동될 수 있는 효과를 필터링 합니다.
        // 이 때 확인 사항은
        // 1. 효과가 발동될 수 있는 게임 상태인가?
        // 2. 아직 사용되지 않은 효과인가?

        todo!()
    }

    pub fn add_link_to_chain(&mut self, effect: EffectTiming, card: Card) {
        // 체인에 링크를 추가합니다.
        self.links.push(ChainLink {
            effect,
            source_card: card,
        });
    }

    pub fn can_add_to_chain(&self, effect_speed: EffectSpeed) -> bool {
        match self.current_phase {
            ChainPhase::Idle => true,
            ChainPhase::Building => {
                if let Some(last_link) = self.links.last() {
                    // 마지막 링크의 스피드와 비교하여 체인 가능 여부를 판단합니다.
                    return last_link.effect.get_speed().can_it_chain(effect_speed);
                } else {
                    // 체인이 비어있다면 추가 가능
                    return true;
                }
            }
            _ => false,
        }
    }
}

// 체인 해결 결과
pub enum ChainResolutionResult {
    Completed,                       // 모든 효과 처리 완료
    WaitingForInput(PlayCardResult), // 사용자 입력 대기
}
</file>

<file path="simulator_core/src/game_old/choice.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    card::types::PlayerType, enums::ZoneType, exception::GameError, server::jsons::game_features,
};

// ChoiceType 은 카드 선택의 종류를 나타냄
// 클라이언트 단으로 전달할 때, 게임 진행을 위한 정보가 여럿 포함되어 있는데.
// 이러한 정보들은 effect 로부터 얻어와야함.
// 대표적으로 DigEffect 의 경우, src, dest 정보가 필요함.
// src 의 경우 selector 에서 얻어오고
// dst 의 경우 insert 에서 얻어오면 될 듯?
// 근데 take, insert 는 카드를 어디서 가져오는지 정보를 가지고 있지 않음.
// 그러한 정보는 외부에서 저장되어있음.
// 그래서 Effect 자체에서 가지고 있는게 나을듯?
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChoiceType {
    Dig,          // 덱에서 카드 탐색
    Discard,      // 핸드에서 버릴 카드 선택
    SelectTarget, // 대상 선택 (유닛, 플레이어 등)
    Sacrifice,    // 희생할 카드 선택
    Rearrange,    // 카드 재배치/순서 변경
    RevealChoice, // 공개된 카드 중 선택
    MultiZone,    // 여러 영역에서 선택
}

impl ChoiceType {
    pub fn to_string(&self) -> String {
        match self {
            ChoiceType::Dig => "Dig".to_string(),
            ChoiceType::Discard => "Discard".to_string(),
            ChoiceType::SelectTarget => "SelectTarget".to_string(),
            ChoiceType::Sacrifice => "Sacrifice".to_string(),
            ChoiceType::Rearrange => "Rearrange".to_string(),
            ChoiceType::RevealChoice => "RevealChoice".to_string(),
            ChoiceType::MultiZone => "MultiZone".to_string(),
        }
    }
}

// 사용자
#[derive(Debug, Clone)]
pub struct ChoiceState {
    // 기본 정보
    player: PlayerType,
    choice_type: ChoiceType,

    // 소스 및 대상 정보
    source_card_id: Option<Uuid>,   // 선택 효과를 발동한 카드
    source_effect_id: Option<Uuid>, // 선택을 요청한 효과

    // 선택 제한 설정
    min_selections: usize, // 최소 선택 개수
    max_selections: usize, // 최대 선택 개수
    destination: ZoneType, // 선택 후 카드 목적지

    // 상태 관리
    is_open: bool,      // 선택이 활성화되어 있는지
    is_mandatory: bool, // 필수 선택 여부 (취소 불가)

    is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
}

impl Default for ChoiceState {
    fn default() -> Self {
        Self {
            player: PlayerType::Player1,
            choice_type: ChoiceType::Dig,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: true,
            is_mandatory: true,
            is_hidden_from_opponent: false,
        }
    }
}

impl ChoiceState {
    pub fn builder(player: PlayerType, choice_type: ChoiceType) -> ChoiceStateBuilder {
        ChoiceStateBuilder::new(player, choice_type)
    }

    pub fn new(
        player: PlayerType,
        choice_type: ChoiceType,
        source_card_id: Option<Uuid>,
        source_effect_id: Option<Uuid>,
        min_selections: usize,
        max_selections: usize,
        destination: ZoneType,
        is_open: bool,
        is_mandatory: bool,
        is_hidden_from_opponent: bool,
    ) -> Self {
        Self {
            player,
            choice_type,
            source_card_id,
            source_effect_id,
            min_selections,
            max_selections,
            destination,
            is_open,
            is_mandatory,
            is_hidden_from_opponent,
        }
    }

    pub fn serialize_message(&self) -> Result<String, GameError> {
        // ChoiceState의 정보를 ChoiceCardPayload로 변환
        let message = game_features::ChoiceCardRequestPayload {
            player: self.player.to_string(), // PlayerType을 문자열로 변환
            choice_type: self.choice_type.to_string(), // ChoiceType을 문자열로 변환
            source_card_id: self.source_card_id.unwrap(),
            min_selections: self.min_selections,
            max_selections: self.max_selections,
            destination: self.destination.to_string(),
            is_open: self.is_open,
            is_hidden_from_opponent: self.is_hidden_from_opponent,
        };

        // JSON 문자열로 직렬화
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

pub struct ChoiceStateBuilder {
    player: PlayerType,
    choice_type: ChoiceType,
    source_card_id: Option<Uuid>,
    source_effect_id: Option<Uuid>,
    min_selections: usize,
    max_selections: usize,
    destination: ZoneType,
    is_open: bool,
    is_mandatory: bool,
    is_hidden_from_opponent: bool,
}

impl ChoiceStateBuilder {
    pub fn new(player: PlayerType, choice_type: ChoiceType) -> Self {
        Self {
            player,
            choice_type,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: false,
            is_mandatory: false,
            is_hidden_from_opponent: false,
        }
    }

    pub fn source_card(mut self, card_id: impl Into<Option<Uuid>>) -> Self {
        self.source_card_id = card_id.into();
        self
    }

    pub fn source_effect(mut self, effect_id: impl Into<Option<Uuid>>) -> Self {
        self.source_effect_id = effect_id.into();
        self
    }

    pub fn selections(mut self, min: usize, max: usize) -> Self {
        self.min_selections = min;
        self.max_selections = max;
        self
    }

    pub fn destination(mut self, destination: ZoneType) -> Self {
        self.destination = destination;
        self
    }

    pub fn open(mut self, is_open: bool) -> Self {
        self.is_open = is_open;
        self
    }

    pub fn mandatory(mut self, is_mandatory: bool) -> Self {
        self.is_mandatory = is_mandatory;
        self
    }

    pub fn hidden_from_opponent(mut self, is_hidden: bool) -> Self {
        self.is_hidden_from_opponent = is_hidden;
        self
    }

    pub fn build(self) -> ChoiceState {
        ChoiceState::new(
            self.player,
            self.choice_type,
            self.source_card_id,
            self.source_effect_id,
            self.min_selections,
            self.max_selections,
            self.destination,
            self.is_open,
            self.is_mandatory,
            self.is_hidden_from_opponent,
        )
    }
}
</file>

<file path="simulator_core/src/game_old/game_step.rs">
use std::fmt;

use tokio::sync::oneshot::Receiver;
use uuid::Uuid;

use tracing::{debug, error, info, instrument, trace, warn};

use crate::{
    card::{insert::TopInsert, take::TopTake, types::PlayerType},
    effect::types::HandlerType,
    exception::GameError,
    selector::TargetCount,
    server::input_handler::InputAnswer,
    zone::zone::Zone,
    LogExt,
};

use super::Game;

pub enum PhaseResult {
    Mulligan,
    DrawPhase,
    StandbyPhase,
    MainPhaseStart,
    MainPhase1,
    BattlePhaseStart,
    BattleStep,
    BattleDamageStepStart,
    BattleDamageStepCalculationBefore,
    BattleDamageStepCalculationStart,
    BattleDamageStepCalculationEnd,
    BattleDamageStepEnd,
    BattlePhaseEnd,
    MainPhase2,
    EndPhase,
}

type PhaseResultType = Result<PhaseResult, GameError>;

// mulligan 에 필요한 게임 함수들.
pub mod mulligan {
    use super::*;
    impl Game {
        #[instrument(skip(self), fields(player_type = ?player_type.into()))]
        pub fn get_mulligan_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            count: usize,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            debug!(
                "멀리건 카드 뽑기 시도: player={:?}, count={}",
                player_type, count
            );

            let result = self
                .get_player_by_type(player_type)
                .get()
                .get_deck_mut()
                .take_card(Box::new(TopTake(TargetCount::Exact(count))));

            match &result {
                Ok(cards) => {
                    debug!(
                        "덱에서 카드 추출 성공: player={:?}, count={}",
                        player_type,
                        cards.len()
                    );
                }
                Err(e) => {
                    // 에러 로깅 추가
                    error!(
                        "덱에서 카드 추출 실패: player={:?}, error={:?}",
                        player_type, e
                    );
                }
            }

            // 성공 시 UUID 변환
            let cards = result?
                .iter()
                .map(|card| card.get_uuid())
                .collect::<Vec<_>>();
            debug!(
                "멀리건 카드 뽑기 완료: player={:?}, card_count={}",
                player_type,
                cards.len()
            );

            Ok(cards)
        }

        #[instrument(skip(self), fields(player_type = ?player_type.into()))]
        pub fn add_select_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            cards: Vec<Uuid>,
            player_type: T,
        ) {
            let player_type = player_type.into();
            debug!(
                "멀리건 상태에 카드 추가 시작: player={:?}, cards={:?}",
                player_type, cards
            );

            let mut player = self.get_player_by_type(player_type).get();

            player
                .get_mulligan_state_mut()
                .add_select_cards(cards.clone());
            debug!("멀리건 상태에 카드 추가 완료: player={:?}", player_type);
        }

        pub fn add_reroll_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            payload_cards: Vec<Uuid>,
            rerolled_cards: Vec<Uuid>,
        ) {
            let player_type = player_type.into();
            debug!("선택 카드 제거: player={:?}", player_type);
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .remove_select_cards(payload_cards);

            debug!("리롤된 카드 추가: player={:?}", player_type);
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .add_select_cards(rerolled_cards);
        }

        pub fn reroll_request<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            cards: Vec<Uuid>,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            // 플레이어가 이미 준비 상태인 경우
            if self
                .get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .is_ready()
            {
                warn!("플레이어가 이미 준비 상태: player={:?}", player_type);
                return Err(GameError::AlreadyReady);
                // try_send_error!(session, GameError::AlreadyReady, retry 3);
            }

            // 플레이어가 선택한 카드가 유효한지 확인합니다.
            debug!("선택한 카드 유효성 검사: player={:?}", player_type);
            if let Err(e) = self.get_cards_by_uuids(cards.clone()) {
                error!("유효하지 않은 카드 선택: player={:?}", player_type);
                return Err(e);
            }

            // 기존 카드를 덱의 최하단에 위치 시킨 뒤, 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장하고 json 으로 변환하여 전송합니다.
            info!("카드 리롤 시작: player={:?}", player_type);
            let rerolled_card = match self.restore_then_reroll_mulligan_cards(player_type, cards) {
                Ok(cards) => {
                    debug!("카드 리롤 성공: card_count={}", cards.len());
                    cards
                }
                Err(e) => {
                    error!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
                    panic!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
                }
            };

            Ok(rerolled_card)
        }

        /// 멀리건 완료 처리 함수
        /// - 게임 객체를 받아서, 플레이어의 멀리건 상태를 완료로 변경하고, 선택한 카드들을 손으로 이동시킵니다.
        /// - 선택한 카드들의 UUID를 반환합니다.
        /// # Arguments
        /// * `game` - 게임 객체
        /// * `player_type` - 플레이어 타입
        /// # Returns
        /// * `Vec<Uuid>` - 선택한 카드들의 UUID

        pub fn process_mulligan_completion<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();

            // 선택된 멀리건 카드들의 UUID 를 얻습니다.
            let selected_cards = self
                .get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .get_select_cards();

            // UUID -> Card 객체로 변환하는 과정입니다.
            let cards = self.get_cards_by_uuids(selected_cards.clone())?;

            // add_card 함수를 통해 선택된 카드들을 손으로 이동시킵니다.
            self.get_player_by_type(player_type)
                .get()
                .get_hand_mut()
                .add_card(cards, Box::new(TopInsert))
                .map_err(|_| GameError::InternalServerError)?;

            // 멀리건 상태를 "완료" 상태로 변경합니다.
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .confirm_selection();

            // 그런 뒤, 선택한 카드들을 반환합니다.
            Ok(selected_cards)
        }

        pub fn check_player_ready_state<T: Into<PlayerType> + Copy>(&self, player_type: T) -> bool {
            let player_type = player_type.into();
            self.get_player_by_type(player_type.reverse())
                .get()
                .get_mulligan_state_mut()
                .is_ready()
        }
    }
}

pub enum PlayCardResult {
    Success,
    NeedInput(Receiver<InputAnswer>, HandlerType),
    Fail(GameError),
}

impl fmt::Debug for PlayCardResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PlayCardResult::Success => write!(f, "PlayCardResult::Success"),
            PlayCardResult::NeedInput(rx, _) => {
                write!(f, "PlayCardResult::NeedInput({:?}, <function>)", rx)
            }
            PlayCardResult::Fail(err) => write!(f, "PlayCardResult::Fail({:?})", err),
        }
    }
}

pub mod main_phase1 {

    use super::*;
    impl Game {
        // 카드를 처리하는 함수인데
        // 외부 ( end point ) 에서 사용하는 함수라서 카드 처리 함수는 이 함수로 유일해야함.

        // 카드의 효과 발동 방법은 다음과 같이 2 가지 유형으로 나뉘어짐.
        // 1. 카드 플레이 ( 핸드에서 필드로 카드를 낸 경우 )
        // 2. 특정 조건을 만족한 경우, 효과 발동 ( 카드 위치는 상관 없이 )
        // 이 함수는 1 번에 대해서만 처리하는 함수임.
        pub async fn proceed_card<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            card_uuid: Uuid,
        ) -> Result<PlayCardResult, GameError> {
            let player_type = player_type.into();
            info!(
                "카드 처리 시작: player={:?}, card_uuid={:?}",
                player_type, card_uuid
            );

            // 카드 조회 및 활성화 가능 여부 확인
            let card = self.get_cards_by_uuid(card_uuid)?;
            // card.can_activate(&self)?;

            // 효과 처리 다시 작업해야함.
            // 카드의 종료는 다음과 같음.
            // 1 . 프리체인 ( 체인에 안걸리고 바로 발동하는 효과들 )
            // 2 . 체인에 걸리는 효과들 ( 카드 효과들 )

            // 체인 형성 중 일반 카드 ( 일반 소환 등 )는 사용할 수 없음.
            // 카드 효과 유발에 레벨을 개념을 적용시켜야함.
            // 스펠 스피드 1, 2, 3 등으로 나눔.
            // 스펠 스피드 1 은 가장 느린 스피드를 가지는 효과로써, 체인을 이어갈 수 없음.
            // 스펠 스피드 2 는 스피드 1, 2에 효과에 대해 체인을 이어갈 수 있음.
            // 스펠 스피드 3 은 스피드 1, 2, 3에 효과에 대해 체인을 이어갈 수 있음.

            // Chain에 카드 효과 처리 위임
            let mut chain = std::mem::take(self.get_chain_mut());
            let result = chain.process_card_effects(self, player_type, card).await;
            *self.get_chain_mut() = chain;

            result
        }
    }
}

pub mod gmae_effects_funcs {

    use crate::{card::Card, effect::DigEffect};

    use super::*;

    impl Game {
        /// 카드 탐색(Digging) 기능을 수행합니다.
        ///
        /// # Arguments
        /// * `player_type` - 카드를 탐색하는 플레이어
        /// * `effect_id` - 사용할 탐색 효과의 ID
        /// * `card_uuid` - 탐색 효과가 있는 소스 카드의 UUID
        ///
        /// # Returns
        /// * `Result<Vec<Uuid>, GameError>` - 탐색 가능한 카드들의 UUID 목록
        pub fn digging_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            effect_id: Uuid,
            card_uuid: Uuid,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            info!(
                "카드 탐색 시작: player={:?}, effect_id={:?}, card={}",
                player_type, effect_id, card_uuid
            );

            // 1. 소스 카드 찾기
            let source_card = self.get_cards_by_uuid(card_uuid)?;

            // 2. 카드에서 해당 Dig 효과 찾기
            let dig_effect = self.find_dig_effect(&source_card, effect_id)?;

            // 3. 선택 가능한 카드들 찾기
            let selectable_cards = dig_effect
                .get_selector()
                .select_targets(self, &source_card)
                .map_err(|e| {
                    error!("대상 선택 실패: {:?}", e);
                    GameError::InvalidTarget
                })?;

            // 4. 선택 가능한 카드가 없는 경우 처리
            if selectable_cards.is_empty() {
                warn!("선택 가능한 카드가 없음: player={:?}", player_type);
                return Err(GameError::NoValidTargets);
            }

            // 5. UUID 목록 생성
            let card_uuids: Vec<Uuid> = selectable_cards
                .iter()
                .map(|card| card.get_uuid())
                .collect();

            debug!(
                "탐색 가능한 카드: count={}, uuids={:?}",
                card_uuids.len(),
                card_uuids
            );

            Ok(card_uuids)
        }

        /// 카드에서 특정 ID를 가진 DigEffect를 찾습니다.
        fn find_dig_effect<'a>(
            &mut self,
            card: &'a Card,
            effect_id: Uuid,
        ) -> Result<&'a DigEffect, GameError> {
            // 효과 찾기
            let effect = card
                .get_prioritized_effect()
                .iter()
                .find(|e| e.get_effect().get_id() == effect_id)
                .ok_or_else(|| {
                    error!("효과를 찾을 수 없음: effect_id={:?}", effect_id);
                    GameError::EffectNotFound
                })?;

            // DigEffect로 다운캐스팅
            effect
                .get_effect()
                .as_any()
                .downcast_ref::<DigEffect>()
                .ok_or_else(|| {
                    error!(
                        "잘못된 효과 타입: expected=DigEffect, effect_id={:?}",
                        effect_id
                    );
                    GameError::InvalidEffectType
                })
        }
    }
}

impl Game {
    // pub fn handle_phase_start(&mut self) -> PhaseResultType {
    //     match self.get_phase() {
    //         Phase::Mulligan => Ok(PhaseResult::Mulligan),
    //         Phase::DrawPhase => Ok(PhaseResult::DrawPhase),
    //         Phase::StandbyPhase => self.handle_standby_phase(),
    //         Phase::MainPhaseStart => self.handle_main_phase_start(),
    //         Phase::MainPhase1 => self.handle_main_phase_1(),
    //         Phase::BattlePhaseStart => self.handle_battle_phase_start(),
    //         Phase::BattleStep => self.handle_battle_step(),
    //         Phase::BattleDamageStepStart => self.handle_damage_step_start(),
    //         Phase::BattleDamageStepCalculationBefore => self.handle_before_damage_calculation(),
    //         Phase::BattleDamageStepCalculationStart => self.handle_damage_calculation(),
    //         Phase::BattleDamageStepCalculationEnd => self.handle_after_damage_calculation(),
    //         Phase::BattleDamageStepEnd => self.handle_damage_step_end(),
    //         Phase::BattlePhaseEnd => self.handle_battle_phase_end(),
    //         Phase::MainPhase2 => self.handle_main_phase_2(),
    //         Phase::EndPhase => self.handle_end_phase(),
    //     }
    // }

    pub fn handle_muliigan_phase(&mut self) {
        // 멀리건 페이즈 시작
        info!("멀리건 페이즈 시작");

        // 멀리건 페이즈 종료
        info!("멀리건 페이즈 종료");
    }

    #[instrument(skip(self), fields(player_type = ?player_type.into()))]
    pub fn handle_draw_phase<T: Into<PlayerType> + Copy>(
        &mut self,
        player_type: T,
    ) -> Result<Uuid, GameError> {
        let player_type = player_type.into();
        info!("드로우 페이즈 시작: player={:?}", player_type);

        trace!("드로우 페이즈 효과 발동 중...");
        // self.trigger_draw_phase_effects()?;
        debug!("드로우 페이즈 효과 발동 완료");

        let card = self
            .draw_card(player_type)
            .log_ok(|| debug!("카드 드로우 성공: player={:?}", player_type,))
            .map_err(|e| {
                error!("카드 드로우 실패: player={:?}, error={:?}", player_type, e);
                e
            })?;

        debug!(
            "카드 드로우 성공: player={:?}, card_uuid={}",
            player_type,
            card.get_uuid()
        );

        trace!("핸드에 카드 추가 시작: player={:?}", player_type);
        let mut player = self.get_player_by_type(player_type).get();

        player
            .get_hand_mut()
            .add_card(vec![card.clone()], Box::new(TopInsert))
            .log_ok(|| debug!("핸드에 카드 추가 성공: player={:?}", player_type))
            .log_err(|e| {
                warn!(
                    "핸드에 카드 추가 중 문제 발생: player={:?}, error={:?}",
                    player_type, e
                )
            })?;

        info!(
            "드로우 페이즈 완료: player={:?}, card_uuid={}",
            player_type,
            card.get_uuid()
        );
        Ok(card.get_uuid())
    }

    pub fn handle_standby_phase(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈에서 발동하는 효과들 처리
        self.trigger_standby_effects()?;
        todo!()
    }

    pub fn handle_main_phase_start(&mut self) -> PhaseResultType {
        // 메인 페이즈 1 개시시 효과 처리
        self.trigger_main_phase_start_effects()?;
        todo!()
    }

    fn handle_main_phase_1(&mut self) -> PhaseResultType {
        // 메인 페이즈 1 진입 처리
        todo!()
    }

    fn handle_battle_phase_start(&mut self) -> PhaseResultType {
        // 배틀 페이즈 개시시 효과 처리
        self.trigger_battle_phase_start_effects()?;
        todo!()
    }

    fn handle_battle_step(&mut self) -> PhaseResultType {
        // 배틀 스텝 처리
        todo!()
    }

    fn handle_damage_step_start(&mut self) -> PhaseResultType {
        // 데미지 스텝 시작 처리
        self.trigger_damage_step_start_effects()?;
        todo!()
    }

    fn handle_before_damage_calculation(&mut self) -> PhaseResultType {
        // 데미지 계산 전 효과 처리
        todo!()
    }

    fn handle_damage_calculation(&mut self) -> PhaseResultType {
        // 실제 데미지 계산 처리
        self.calculate_battle_damage()?;
        todo!()
    }

    fn handle_after_damage_calculation(&mut self) -> PhaseResultType {
        // 데미지 계산 후 효과 처리
        todo!()
    }

    fn handle_damage_step_end(&mut self) -> PhaseResultType {
        // 데미지 스텝 종료 처리
        todo!()
    }

    fn handle_battle_phase_end(&mut self) -> PhaseResultType {
        // 배틀 페이즈 종료 처리
        todo!()
    }

    fn handle_main_phase_2(&mut self) -> PhaseResultType {
        // 메인 페이즈 2 처리
        todo!()
    }

    fn handle_end_phase(&mut self) -> PhaseResultType {
        // 턴 종료 처리
        self.handle_turn_end()?;
        todo!()
    }

    /// 페이즈 종료 시 처리
    fn handle_phase_end(&mut self) -> PhaseResultType {
        // 현재 페이즈 종료 시 필요한 처리
        todo!()
    }

    /// 턴 종료 처리
    fn handle_turn_end(&mut self) -> PhaseResultType {
        todo!()
    }

    //
    fn trigger_draw_phase_effects(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈 효과 발동
        todo!()
    }

    // 유틸리티 메서드들
    fn trigger_standby_effects(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈 효과 발동
        todo!()
    }

    fn trigger_main_phase_start_effects(&mut self) -> PhaseResultType {
        // 메인 페이즈 개시시 효과 발동
        todo!()
    }

    fn trigger_battle_phase_start_effects(&mut self) -> PhaseResultType {
        // 배틀 페이즈 개시시 효과 발동
        todo!()
    }

    fn trigger_damage_step_start_effects(&mut self) -> PhaseResultType {
        // 데미지 스텝 개시시 효과 발동
        todo!()
    }

    fn calculate_battle_damage(&mut self) -> PhaseResultType {
        // 전투 데미지 계산
        todo!()
    }

    fn check_hand_limit(&mut self) -> PhaseResultType {
        // 손 카드 제한(10장) 체크
        todo!()
    }
}
</file>

<file path="simulator_core/src/game_old/getter.rs">
use crate::{
    card::{types::PlayerType, Card},
    enums::ZoneType,
    zone::zone::Zone,
};

use super::Game;

impl Game {
    pub fn get_cards_by_player_and_zone_type(
        &self,
        player_type: PlayerType,
        zone_type: ZoneType,
    ) -> Vec<Card> {
        match (player_type, zone_type) {
            (PlayerType::Player1, ZoneType::Hand) => self.get_player_hand_cards(),
            (PlayerType::Player1, ZoneType::Field) => self.get_player_field_cards(),
            (PlayerType::Player1, ZoneType::Deck) => self.get_player_deck_cards(),
            (PlayerType::Player1, ZoneType::Graveyard) => self.get_player_graveyard_cards(),

            (PlayerType::Player2, ZoneType::Hand) => self.get_opponent_hand_cards(),
            (PlayerType::Player2, ZoneType::Field) => self.get_opponent_field_cards(),
            (PlayerType::Player2, ZoneType::Deck) => self.get_opponent_deck_cards(),
            (PlayerType::Player2, ZoneType::Graveyard) => self.get_opponent_graveyard_cards(),

            (_, ZoneType::Effect) => todo!(),
            (_, ZoneType::None) => panic!("Zone type is not allowed to be None"),
        }
    }

    pub fn get_player_field_cards(&self) -> Vec<Card> {
        self.get_player().get().get_field().get_cards().clone()
    }

    pub fn with_player_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_field_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_field_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_field().get_cards().clone()
    }

    pub fn with_opponent_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_field_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 핸드 카드
    pub fn get_player_hand_cards(&self) -> Vec<Card> {
        self.get_player().get().get_hand().get_cards().clone()
    }

    pub fn with_player_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_hand_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_hand_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_hand().get_cards().clone()
    }

    pub fn with_opponent_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_hand_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 묘지 카드
    pub fn get_player_graveyard_cards(&self) -> Vec<Card> {
        self.get_player().get().get_graveyard().get_cards().clone()
    }

    pub fn with_player_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_graveyard_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_graveyard_cards(&self) -> Vec<Card> {
        self.get_opponent()
            .get()
            .get_graveyard()
            .get_cards()
            .clone()
    }

    pub fn with_opponent_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_graveyard_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 덱 카드
    pub fn get_player_deck_cards(&self) -> Vec<Card> {
        self.get_player().get().get_deck().get_cards().clone()
    }

    pub fn with_player_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_deck_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_deck().get_cards().clone()
    }

    pub fn with_opponent_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }
}
</file>

<file path="simulator_core/src/game_old/helper.rs">
use uuid::Uuid;

use crate::{card::types::PlayerType, exception::GameError};

use super::Game;

impl Game {
    pub fn restore_then_reroll_mulligan_cards<T: Into<PlayerType>>(
        &mut self,
        player_type: T,
        exclude_cards: Vec<Uuid>,
    ) -> Result<Vec<Uuid>, GameError> {
        let player_type = player_type.into();
        self.restore_card(player_type, &exclude_cards)?;
        let new_cards = self.get_mulligan_cards(player_type, exclude_cards.len())?;
        Ok(new_cards)
    }
}

#[macro_export]
macro_rules! downcast_effect {
    ($effect:expr, $target_type:ty) => {
        if $effect.get_effect_type() == <$target_type>::static_effect_type() {
            if let Some(specific) = $effect.as_any().downcast_ref::<$target_type>() {
                Some(specific)
            } else {
                None
            }
        } else {
            None
        }
    };
}

pub async fn wait_for_input() -> Result<(), GameError> {
    todo!()
}
</file>

<file path="simulator_core/src/game_old/mod.rs">
pub mod chain;
pub mod choice;
pub mod game_step;
mod getter;
mod helper;
pub mod phase;
pub mod turn_manager;

use std::collections::HashMap;

use chain::Chain;
use phase::{Phase, PhaseState};
use turn_manager::Turn;
use uuid::Uuid;

use crate::{
    card::{cards::CardVecExt, insert::BottomInsert, take::BottomTake, types::PlayerType, Card},
    enums::DeckCode,
    exception::GameError,
    selector::TargetCount,
    server::input_handler::InputWaiter,
    unit::player::{Player, Resoruce},
    utils::deckcode_to_cards,
    zone::zone::Zone,
    OptArc,
};

pub struct GameConfig {
    /// Player's Deckcode
    pub player_1_deckcode: DeckCode,
    pub player_2_deckcode: DeckCode,

    /// 1 : Player 1,
    /// 2 : Player 2
    pub attacker: usize,
}

/// 게임의 상태를 관리/저장 하는 구조체
/// Card 로 인한 모든 변경 사항은 Task 로써 저장되며,
/// 그것을 담은 Tasks 를 Procedure 에게 전달하여 게임 결과를 계산한다.
#[derive(Clone)]
pub struct Game {
    pub player1: OptArc<Player>,
    pub player2: OptArc<Player>,
    pub phase_state: PhaseState,
    pub turn: Turn,
    pub chain: Chain,
    pub input_waiter: InputWaiter,
}

/// initialize 함수에 GameConfig 을 넣음으로써 두 플레이어의 Cards 을 설정한다.
impl Game {
    pub fn initialize(&mut self, _config: GameConfig) -> Result<(), GameError> {
        let cards = deckcode_to_cards(_config.player_1_deckcode, _config.player_2_deckcode)?;

        // TODO: Limit 을 const 로 빼야함.
        let cost = Resoruce::new(0, 10);
        let mana = Resoruce::new(0, 3);
        self.player1 = OptArc::new(Player::new(
            OptArc::none(),
            PlayerType::Player1,
            cards[0].clone(),
            cost.clone(),
            mana.clone(),
        ));
        self.player2 = OptArc::new(Player::new(
            OptArc::none(),
            PlayerType::Player2,
            cards[1].clone(),
            cost,
            mana,
        ));

        self.player1
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .extend(cards[0].clone());
        self.player2
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .extend(cards[1].clone());
        Ok(())
    }
}

impl Game {
    pub fn get_player_by_type<T: Into<PlayerType> + Copy>(
        &self,
        player_type: T,
    ) -> &OptArc<Player> {
        match player_type.into() {
            PlayerType::Player1 => &self.player1,
            PlayerType::Player2 => &self.player2,
        }
    }

    pub fn get_turn(&self) -> &Turn {
        &self.turn
    }

    pub fn get_phase(&self) -> Phase {
        self.phase_state.get_phase()
    }

    pub fn get_phase_state_mut(&mut self) -> &mut PhaseState {
        &mut self.phase_state
    }

    pub fn get_phase_state(&mut self) -> &PhaseState {
        &self.phase_state
    }

    pub fn get_turn_mut(&mut self) -> &mut Turn {
        &mut self.turn
    }

    pub fn move_phase(&mut self) {
        self.phase_state.get_phase().move_to_next_phase();
    }

    pub fn get_player(&self) -> &OptArc<Player> {
        &self.player1
    }

    pub fn get_opponent(&self) -> &OptArc<Player> {
        &self.player2
    }

    pub fn get_chain_mut(&mut self) -> &mut Chain {
        &mut self.chain
    }

    pub fn get_input_waiter_mut(&mut self) -> &mut InputWaiter {
        &mut self.input_waiter
    }

    // pub fn resolve_chain(&mut self) -> Result<(), GameError> {
    //     self.chain.resolve(self)?;
    //     Ok(())
    // }

    pub fn get_chain(&self) -> &Chain {
        &self.chain
    }

    /// 플레이어의 덱에서 카드를 뽑아 손에 추가합니다.
    /// # Parameters
    /// * `player_type` - 덱에서 카드를 뽑을 플레이어의 종류입니다.
    /// # Returns
    /// * 뽑은 카드를 반환합니다.
    /// # Errors
    /// * 덱에 카드가 없을 경우 NoCardsLeft 에러를 반환합니다.
    pub fn draw_card(&mut self, player_type: PlayerType) -> Result<Card, GameError> {
        let result = self
            .get_player_by_type(player_type)
            .get()
            .get_deck_mut()
            .take_card(Box::new(BottomTake(TargetCount::Exact(1))))?;

        // TODO: 이 확인이 필요한가?
        if result.is_empty() {
            return Err(GameError::NoCardsLeft);
        }

        Ok(result[0].clone())
    }

    /// 파라미터로 들어오는 카드들을 덱의 맨 밑으로 복원합니다.
    ///
    /// # Parameters
    /// * `player_type` - 카드를 복원할 플레이어 타입
    /// * `src_cards` - 복원할 카드들의 UUID 목록
    ///
    /// # Returns
    /// * `Ok(())` - 모든 카드가 성공적으로 덱의 맨 밑에 추가됨
    /// * `Err(GameError)` - 카드 복원 중 오류 발생
    ///
    /// # Errors
    /// * `GameError::CardNotFound` - 지정된 UUID를 가진 카드를 플레이어가 소유하지 않은 경우
    /// * `GameError::ExceededCardLimit` - 덱에 자리가 없어 카드를 추가할 수 없는 경우
    ///
    pub fn restore_card(
        &mut self,
        player_type: PlayerType,
        src_cards: &Vec<Uuid>,
    ) -> Result<(), GameError> {
        for card_uuid in src_cards {
            let card = {
                let player = self.get_player_by_type(player_type).get();
                match player.get_cards().find_by_uuid(card_uuid.clone()) {
                    Some(card) => card.clone(),
                    None => return Err(GameError::CardNotFound),
                }
            };
            self.get_player_by_type(player_type)
                .get()
                .get_deck_mut()
                .add_card(vec![card.clone()], Box::new(BottomInsert))?;
        }
        Ok(())
    }

    /// 두 플레이어의 카드 목록에서 입력받은 UUID에 해당하는 카드를 순서대로 찾아 반환합니다.
    ///
    /// # 설명
    /// - 플레이어와 상대방의 모든 카드 목록을 합쳐서, 각 카드의 고유한 UUID를 key로 하는 HashMap을 생성합니다.
    /// - 입력받은 UUID 리스트의 순서대로 해당 카드들을 찾아 Vec<Card>로 반환합니다.
    ///
    /// # Parameters
    /// - `uuids`: 찾고자 하는 카드의 고유 식별자(UUID)들이 담긴 벡터입니다.
    ///             각 UUID는 고유하다고 가정합니다.
    ///
    /// # Returns
    /// - 입력받은 순서대로 찾은 카드들을 담은 Vec<Card>를 반환합니다.
    ///
    /// # Panics
    /// - 만약 입력받은 UUID 중 하나라도 플레이어와 상대방의 카드 목록에서 찾지 못하면,
    ///   GameError::CardsNotFound 에러를 반환합니다.
    pub fn get_cards_by_uuids(&self, uuids: Vec<Uuid>) -> Result<Vec<Card>, GameError> {
        let player = self.get_player().get();
        let opponent = self.get_opponent().get();

        // 두 카드 리스트를 하나의 iterator로 합칩니다.
        // UUID가 고유하다고 가정하므로, (uuid, card) 쌍을 HashMap에 저장할 수 있습니다.
        let card_map: HashMap<Uuid, Card> = player
            .get_cards()
            .iter()
            .chain(opponent.get_cards().iter())
            .map(|card| (card.get_uuid(), card.clone()))
            .collect();

        // 입력한 uuid 순서대로 카드들을 찾아서 반환합니다.
        // 입력 uuid 중 하나라도 매칭되는 카드가 없으면 panic! 합니다.
        let mut results = Vec::with_capacity(uuids.len());
        for uuid in uuids {
            if let Some(card) = card_map.get(&uuid) {
                results.push(card.clone());
            } else {
                return Err(GameError::CardsNotFound);
            }
        }
        Ok(results)
    }

    /// 두 플레이어의 카드 목록에서 입력받은 UUID에 해당하는 카드를 순서대로 찾아 반환합니다.
    ///
    /// # 설명
    /// - 플레이어와 상대방의 모든 카드 목록을 합쳐서, 각 카드의 고유한 UUID를 key로 하는 HashMap을 생성합니다.
    /// - 입력받은 UUID 리스트의 순서대로 해당 카드들을 찾아 Card로 반환합니다.
    ///
    /// # Parameters
    /// - `uuids`: 찾고자 하는 카드의 고유 식별자(UUID)들이 담긴 벡터입니다.
    ///             각 UUID는 고유하다고 가정합니다.
    ///
    /// # Returns
    /// - 입력받은 순서대로 찾은 카드들을 담은 Card를 반환합니다.
    ///
    /// # Panics
    /// - 만약 입력받은 UUID 를 가지고 플레이어와 상대방의 카드 목록에서 찾지 못하면,
    ///   GameError::CardNotFound 에러를 반환합니다.
    pub fn get_cards_by_uuid(&self, uuid: Uuid) -> Result<Card, GameError> {
        let player = self.get_player().get();
        let opponent = self.get_opponent().get();

        // 두 카드 리스트를 하나의 iterator로 합칩니다.
        // UUID가 고유하다고 가정하므로, (uuid, card) 쌍을 HashMap에 저장할 수 있습니다.
        let card_map: HashMap<Uuid, Card> = player
            .get_cards()
            .iter()
            .chain(opponent.get_cards().iter())
            .map(|card| (card.get_uuid(), card.clone()))
            .collect();

        // 입력한 uuid 순서대로 카드들을 찾아서 반환합니다.
        // 입력 uuid 중 하나라도 매칭되는 카드가 없으면 panic! 합니다.
        card_map.get(&uuid).cloned().ok_or(GameError::CardNotFound)
    }
}

// TODO: 게임의 상태를 hash 로 변환해서 제공해야함.
</file>

<file path="simulator_core/src/game_old/phase.rs">
use std::collections::HashSet;

use crate::card::types::PlayerType;

#[derive(Clone)]
pub struct PhaseState {
    current_phase: Phase,
    completed_players: HashSet<PlayerType>,
}

impl PhaseState {
    pub fn new(phase: Phase) -> Self {
        Self {
            current_phase: phase,
            completed_players: HashSet::new(),
        }
    }

    pub fn has_player_completed(&self, player_type: PlayerType) -> bool {
        self.completed_players.contains(&player_type)
    }

    pub fn mark_player_completed(&mut self, player_type: PlayerType) {
        self.completed_players.insert(player_type);
    }

    pub fn reset_player_completed(&mut self, player_type: PlayerType) {
        self.completed_players.remove(&player_type);
    }

    pub fn reset(&mut self) {
        self.completed_players.clear();
    }

    pub fn get_phase(&self) -> Phase {
        self.current_phase
    }

    pub fn set_phase(&mut self, phase: Phase) {
        self.current_phase = phase;
    }
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum Phase {
    Heartbeat,

    Mulligan,

    // 가장 먼저 시작되는 드로우 페이즈 ( 기타 자원 등 증가함. )
    DrawPhase,

    // 메인 페이즈 진입 전 시작되는 페이즈
    StandbyPhase,

    // 메인 페이즈 개시시
    MainPhaseStart,
    // 메인 페이즈 개시중
    MainPhase1,

    // 배틀 페이즈 진입
    BattlePhaseStart,
    // 배틀 페이즈 중
    BattleStep,
    // 데미지 스텝 개시시
    BattleDamageStepStart,
    // 데미지 계산 전
    BattleDamageStepCalculationBefore,
    // 데미지 계산 중
    BattleDamageStepCalculationStart,
    // 데미지 계산 후
    BattleDamageStepCalculationEnd,
    // 데미지 스텝 종료시
    BattleDamageStepEnd,
    // 데미지 페이즈 종료
    BattlePhaseEnd,

    // 메인 페이즈2 시작
    MainPhase2,

    // 턴 종료
    EndPhase,
}

impl From<String> for Phase {
    fn from(value: String) -> Self {
        match value.to_lowercase().as_str() {
            "mulligan" => Phase::Mulligan,
            "drawphase" => Phase::DrawPhase,
            "standbyphase" => Phase::StandbyPhase,
            "mainphasestart" => Phase::MainPhaseStart,
            "mainphase1" => Phase::MainPhase1,
            "battlephasestart" => Phase::BattlePhaseStart,
            "battlestep" => Phase::BattleStep,
            "battledamagestepstart" => Phase::BattleDamageStepStart,
            "battledamagestepcalculationbefore" => Phase::BattleDamageStepCalculationBefore,
            "battledamagestepcalculationstart" => Phase::BattleDamageStepCalculationStart,
            "battledamagestepcalculationend" => Phase::BattleDamageStepCalculationEnd,
            "battledamagestepend" => Phase::BattleDamageStepEnd,
            "battlephaseend" => Phase::BattlePhaseEnd,
            "mainphase2" => Phase::MainPhase2,
            "endphase" => Phase::EndPhase,
            "heartbeat" => Phase::Heartbeat,
            _ => panic!("Invalid Phase string: {}", value),
        }
    }
}

impl PartialOrd for Phase {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Phase {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.order().cmp(&other.order())
    }
}

impl Phase {
    fn order(&self) -> u8 {
        match self {
            Phase::Mulligan => 0,
            Phase::DrawPhase => 1,
            Phase::StandbyPhase => 2,
            Phase::MainPhaseStart => 3,
            Phase::MainPhase1 => 4,
            Phase::BattlePhaseStart => 5,
            Phase::BattleStep => 6,
            Phase::BattleDamageStepStart => 7,
            Phase::BattleDamageStepCalculationBefore => 8,
            Phase::BattleDamageStepCalculationStart => 9,
            Phase::BattleDamageStepCalculationEnd => 10,
            Phase::BattleDamageStepEnd => 11,
            Phase::BattlePhaseEnd => 12,
            Phase::MainPhase2 => 13,
            Phase::EndPhase => 14,
            Phase::Heartbeat => 15,
        }
    }

    /// 현재 페이즈가 드로우 페이즈인지 확인
    pub fn is_draw_phase(&self) -> bool {
        matches!(self, Phase::DrawPhase)
    }

    /// 현재 페이즈가 스탠바이 페이즈인지 확인
    pub fn is_standby_phase(&self) -> bool {
        matches!(self, Phase::StandbyPhase)
    }

    /// 메인 페이즈 1 관련 체크
    pub fn is_main_phase_1(&self) -> bool {
        matches!(self, Phase::MainPhase1)
    }

    pub fn is_main_phase_1_start(&self) -> bool {
        matches!(self, Phase::MainPhaseStart)
    }

    /// 배틀 페이즈 관련 체크
    pub fn is_battle_phase(&self) -> bool {
        matches!(
            self,
            Phase::BattlePhaseStart
                | Phase::BattleStep
                | Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
                | Phase::BattlePhaseEnd
        )
    }

    pub fn is_battle_step(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    pub fn is_damage_step(&self) -> bool {
        matches!(
            self,
            Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
        )
    }

    pub fn is_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationStart)
    }

    pub fn is_before_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationBefore)
    }

    pub fn is_after_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationEnd)
    }

    /// 메인 페이즈 2 체크
    pub fn is_main_phase_2(&self) -> bool {
        matches!(self, Phase::MainPhase2)
    }

    /// 엔드 페이즈 체크
    pub fn is_end_phase(&self) -> bool {
        matches!(self, Phase::EndPhase)
    }

    /// 메인 페이즈 체크 (1과 2 모두)
    pub fn is_main_phase(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::MainPhase1 | Phase::MainPhase2
        )
    }

    /// 일반 소환이 가능한 페이즈인지 체크
    pub fn can_normal_summon(&self) -> bool {
        matches!(self, Phase::MainPhase1 | Phase::MainPhase2)
    }

    /// 공격이 가능한 페이즈인지 체크
    pub fn can_attack(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    /// 현재 페이즈가 개시시인지 체크
    pub fn is_phase_start(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::BattlePhaseStart | Phase::BattleDamageStepStart
        )
    }

    /// 다음 페이즈 반환
    pub fn next_phase(&self) -> Phase {
        match self {
            Phase::Mulligan => Phase::DrawPhase,
            Phase::DrawPhase => Phase::StandbyPhase,
            Phase::StandbyPhase => Phase::MainPhaseStart,
            Phase::MainPhaseStart => Phase::MainPhase1,
            Phase::MainPhase1 => Phase::BattlePhaseStart,
            Phase::BattlePhaseStart => Phase::BattleStep,
            Phase::BattleStep => Phase::BattleDamageStepStart,
            Phase::BattleDamageStepStart => Phase::BattleDamageStepCalculationBefore,
            Phase::BattleDamageStepCalculationBefore => Phase::BattleDamageStepCalculationStart,
            Phase::BattleDamageStepCalculationStart => Phase::BattleDamageStepCalculationEnd,
            Phase::BattleDamageStepCalculationEnd => Phase::BattleDamageStepEnd,
            Phase::BattleDamageStepEnd => Phase::BattlePhaseEnd,
            Phase::BattlePhaseEnd => Phase::MainPhase2,
            Phase::MainPhase2 => Phase::EndPhase,
            Phase::EndPhase => Phase::DrawPhase,
            Phase::Heartbeat => Phase::Mulligan,
        }
    }

    pub fn move_to_next_phase(&mut self) {
        *self = self.next_phase();
    }

    pub fn set_phase(&mut self, phase: Phase) {
        *self = phase;
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            Phase::Mulligan => "Mulligan",
            Phase::DrawPhase => "DrawPhase",
            Phase::StandbyPhase => "StandbyPhase",
            Phase::MainPhaseStart => "MainPhaseStart",
            Phase::MainPhase1 => "MainPhase1",
            Phase::BattlePhaseStart => "BattlePhaseStart",
            Phase::BattleStep => "BattleStep",
            Phase::BattleDamageStepStart => "BattleDamageStepStart",
            Phase::BattleDamageStepCalculationBefore => "BattleDamageStepCalculationBefore",
            Phase::BattleDamageStepCalculationStart => "BattleDamageStepCalculationStart",
            Phase::BattleDamageStepCalculationEnd => "BattleDamageStepCalculationEnd",
            Phase::BattleDamageStepEnd => "BattleDamageStepEnd",
            Phase::BattlePhaseEnd => "BattlePhaseEnd",
            Phase::MainPhase2 => "MainPhase2",
            Phase::EndPhase => "EndPhase",
            Phase::Heartbeat => "Heartbeat",
        }
    }
}
</file>

<file path="simulator_core/src/game_old/turn_manager.rs">
use crate::card::types::PlayerType;

#[derive(Clone)]
pub struct Turn {
    current_turn: PlayerType,
    turn_count: usize,
}

impl Turn {
    pub fn new() -> Self {
        Turn {
            current_turn: PlayerType::Player1,
            turn_count: 0,
        }
    }

    pub fn get_turn_count(&self) -> usize {
        self.turn_count
    }

    pub fn increase_turn_count(&mut self) -> usize {
        self.turn_count += 1;
        self.turn_count
    }

    pub fn current_turn(&self) -> PlayerType {
        self.current_turn
    }

    pub fn change_turn(&mut self) -> PlayerType {
        self.current_turn = match self.current_turn {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        };
        self.current_turn
    }

    pub fn is_player_turn(&self) -> bool {
        self.current_turn == PlayerType::Player1
    }

    pub fn is_opponent_turn(&self) -> bool {
        self.current_turn == PlayerType::Player2
    }

    pub fn get_opponent_turn(&self) -> PlayerType {
        match self.current_turn {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        }
    }

    // 특정 플레이어의 턴으로 강제 설정
    pub fn set_turn(&mut self, player: PlayerType) {
        self.current_turn = player;
    }
}
</file>

<file path="simulator_core/src/game/getter.rs">
// use crate::{
//     card::{types::PlayerType, Card},
//     enums::ZoneType,
//     zone::zone::Zone,
// };

// impl Game {
//     pub fn get_cards_by_player_and_zone_type(
//         &self,
//         player_type: PlayerType,
//         zone_type: ZoneType,
//     ) -> Vec<Card> {
//         match (player_type, zone_type) {
//             (PlayerType::Player1, ZoneType::Hand) => self.get_player_hand_cards(),
//             (PlayerType::Player1, ZoneType::Field) => self.get_player_field_cards(),
//             (PlayerType::Player1, ZoneType::Deck) => self.get_player_deck_cards(),
//             (PlayerType::Player1, ZoneType::Graveyard) => self.get_player_graveyard_cards(),

//             (PlayerType::Player2, ZoneType::Hand) => self.get_opponent_hand_cards(),
//             (PlayerType::Player2, ZoneType::Field) => self.get_opponent_field_cards(),
//             (PlayerType::Player2, ZoneType::Deck) => self.get_opponent_deck_cards(),
//             (PlayerType::Player2, ZoneType::Graveyard) => self.get_opponent_graveyard_cards(),

//             (_, ZoneType::Effect) => todo!(),
//             (_, ZoneType::None) => panic!("Zone type is not allowed to be None"),
//         }
//     }

//     pub fn get_player_field_cards(&self) -> Vec<Card> {
//         self.get_player().get().get_field().get_cards().clone()
//     }

//     pub fn with_player_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_player()
//             .get()
//             .get_field_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     pub fn get_opponent_field_cards(&self) -> Vec<Card> {
//         self.get_opponent().get().get_field().get_cards().clone()
//     }

//     pub fn with_opponent_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_opponent()
//             .get()
//             .get_field_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     // 핸드 카드
//     pub fn get_player_hand_cards(&self) -> Vec<Card> {
//         self.get_player().get().get_hand().get_cards().clone()
//     }

//     pub fn with_player_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_player()
//             .get()
//             .get_hand_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     pub fn get_opponent_hand_cards(&self) -> Vec<Card> {
//         self.get_opponent().get().get_hand().get_cards().clone()
//     }

//     pub fn with_opponent_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_opponent()
//             .get()
//             .get_hand_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     // 묘지 카드
//     pub fn get_player_graveyard_cards(&self) -> Vec<Card> {
//         self.get_player().get().get_graveyard().get_cards().clone()
//     }

//     pub fn with_player_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_player()
//             .get()
//             .get_graveyard_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     pub fn get_opponent_graveyard_cards(&self) -> Vec<Card> {
//         self.get_opponent()
//             .get()
//             .get_graveyard()
//             .get_cards()
//             .clone()
//     }

//     pub fn with_opponent_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_opponent()
//             .get()
//             .get_graveyard_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     // 덱 카드
//     pub fn get_player_deck_cards(&self) -> Vec<Card> {
//         self.get_player().get().get_deck().get_cards().clone()
//     }

//     pub fn with_player_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_player()
//             .get()
//             .get_deck_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }

//     pub fn get_opponent_deck_cards(&self) -> Vec<Card> {
//         self.get_opponent().get().get_deck().get_cards().clone()
//     }

//     pub fn with_opponent_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
//     where
//         C: FnMut(&Card) -> bool,
//         F: FnMut(&mut Card),
//     {
//         self.get_opponent()
//             .get()
//             .get_deck_mut()
//             .get_cards_mut()
//             .iter_mut()
//             .filter(|card| condition(card))
//             .for_each(modifier);
//     }
// }
</file>

<file path="simulator_core/src/helper.rs">
pub fn is_trait_implemented<T: ?Sized + 'static>() -> bool {
    let type_id = std::any::TypeId::of::<T>();
    let debug_type_id = std::any::TypeId::of::<dyn std::fmt::Debug>();
    type_id == debug_type_id
}
</file>

<file path="simulator_core/src/lib.rs">
#![allow(unused_variables, unused_labels, dead_code)]

use std::{
    collections::HashMap,
    sync::{Arc, Mutex, MutexGuard},
};

use card::types::{PlayerIdentity, PlayerKind};
use exception::GameError;
use tracing::Level;
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::EnvFilter;
use uuid::Uuid;

pub mod card;
pub mod card_gen;
pub mod effect;
pub mod enums;
pub mod exception;
pub mod game;
pub mod helper;
pub mod player;
pub mod resource;
pub mod selector;
pub mod server;
pub mod test;
pub mod unit;
pub mod utils;
pub mod zone;

extern crate lazy_static;

use std::sync::Once;
static INIT: Once = Once::new();
static mut GUARD: Option<tracing_appender::non_blocking::WorkerGuard> = None;
pub fn setup_logger() {
    INIT.call_once(|| {
        let file_appender = RollingFileAppender::new(Rotation::HOURLY, "logs", "app.log");

        let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);

        tracing_subscriber::fmt()
            .with_env_filter(EnvFilter::from_default_env().add_directive(Level::INFO.into()))
            .with_thread_ids(true)
            .with_ansi(false)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .with_writer(non_blocking)
            .pretty()
            .init();

        unsafe {
            GUARD = Some(_guard);
        }
    });
}

#[derive(Clone)]
pub struct OptArc<T>(Option<ArcMutex<T>>);

impl<T> OptArc<T> {
    // 생성자들
    pub fn new(value: T) -> Self {
        Self(Some(ArcMutex::new(value)))
    }

    pub fn none() -> Self {
        Self(None)
    }

    pub fn from_option(opt: Option<T>) -> Self {
        opt.map(ArcMutex::new).into()
    }

    pub fn get(&self) -> MutexGuard<T> {
        self.0.as_ref().unwrap().get()
    }

    // Option 관련 메서드들
    pub fn is_some(&self) -> bool {
        self.0.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.0.is_none()
    }

    pub fn as_ref(&self) -> Option<&ArcMutex<T>> {
        self.0.as_ref()
    }

    pub fn take(&mut self) -> Option<ArcMutex<T>> {
        self.0.take()
    }

    pub fn replace(&mut self, value: T) -> Option<ArcMutex<T>> {
        self.0.replace(ArcMutex::new(value))
    }
}

impl<T> From<Option<ArcMutex<T>>> for OptArc<T> {
    fn from(opt: Option<ArcMutex<T>>) -> Self {
        Self(opt)
    }
}

impl<T> From<Option<T>> for OptArc<T> {
    fn from(opt: Option<T>) -> Self {
        Self(opt.map(ArcMutex::new))
    }
}

impl<T> From<T> for OptArc<T> {
    fn from(value: T) -> Self {
        Self::new(value)
    }
}

// RcRef 구현 (스레드 안전 버전)
#[derive(Clone)]
pub struct ArcMutex<T>(Arc<Mutex<T>>);

impl<T> ArcMutex<T> {
    pub fn new(value: T) -> Self {
        Self(Arc::new(Mutex::new(value)))
    }

    pub fn get(&self) -> MutexGuard<T> {
        self.0.lock().unwrap()
    }
}

pub trait StringUuidExt {
    fn to_uuid(&self) -> Result<Uuid, GameError>;
}

impl StringUuidExt for String {
    fn to_uuid(&self) -> Result<Uuid, GameError> {
        Uuid::parse_str(self).map_err(|_| GameError::ParseError)
    }
}

pub trait VecUuidExt {
    fn to_vec_string(&self) -> Vec<String>;
}

impl VecUuidExt for Vec<Uuid> {
    fn to_vec_string(&self) -> Vec<String> {
        self.iter()
            .map(|uuid| uuid.to_string())
            .collect::<Vec<String>>()
    }
}

pub trait VecStringExt {
    fn to_vec_uuid(&self) -> Result<Vec<Uuid>, GameError>;
}

impl VecStringExt for Vec<String> {
    fn to_vec_uuid(&self) -> Result<Vec<Uuid>, GameError> {
        self.iter()
            .map(|uuid| Uuid::parse_str(uuid).map_err(|_| return GameError::ParseError))
            .collect::<Result<Vec<Uuid>, GameError>>()
    }
}

pub trait LogExt<T, E> {
    fn log_ok(self, f: impl FnOnce()) -> Self;
    fn log_err(self, f: impl FnOnce(&E)) -> Self;
}

impl<T, E> LogExt<T, E> for Result<T, E> {
    fn log_ok(self, f: impl FnOnce()) -> Self {
        if self.is_ok() {
            f()
        }
        self
    }

    fn log_err(self, f: impl FnOnce(&E)) -> Self {
        if let Err(ref e) = self {
            f(e);
        }
        self
    }
}
pub trait PlayerHashMapExt<V> {
    fn get_by_uuid(&self, uuid_key: &Uuid) -> Option<&V>;
    fn get_by_kind(&self, kind_key: PlayerKind) -> Option<&V>;
}

impl<V> PlayerHashMapExt<V> for HashMap<PlayerIdentity, V> {
    fn get_by_uuid(&self, uuid_key: &Uuid) -> Option<&V> {
        self.iter()
            .find(|(player_identity_key, _value)| player_identity_key.id == *uuid_key)
            .map(|(_player_identity_key, value)| value)
    }

    fn get_by_kind(&self, kind_key: PlayerKind) -> Option<&V> {
        self.iter()
            .find(|(player_identity_key, _value)| player_identity_key.kind == kind_key)
            .map(|(_player_identity_key, value)| value)
    }
}
</file>

<file path="simulator_core/src/memo..rs">
use actix::clock::{sleep, Instant};
use actix::prelude::*;
use std::collections::HashMap;
use std::time::Duration;
use uuid::Uuid;

// --- 메시지 정의 ---

#[derive(Message, Clone, Debug)]
#[rtype(result = "()")]
struct AuctionStatus {
    item: String,
    highest_bid: u64,
    highest_bidder: Option<Uuid>,
    time_remaining_secs: u64,
    is_open: bool,
    winner: Option<Uuid>, // 경매 종료 시 사용
}

#[derive(Message)]
#[rtype(result = "Result<(), String>")]
struct StartAuction {
    item: String,
    starting_bid: u64,
    duration_secs: u64,
}

#[derive(Message)]
#[rtype(result = "Result<(), String>")] // 성공 또는 에러 메시지 반환
struct PlaceBid {
    bidder_id: Uuid,
    amount: u64,
}

#[derive(Message)]
#[rtype(result = "AuctionStatus")]
struct GetStatus;

#[derive(Message)]
#[rtype(result = "()")]
struct AuctionEnded {
    item: String,
    winner: Option<Uuid>,
    winning_bid: u64,
}

// 내부 타이머 메시지
#[derive(Message)]
#[rtype(result = "()")]
struct InternalTimerTick;

// --- Auctioneer 액터 정의 ---

struct AuctioneerActor {
    item: Option<String>,
    starting_bid: u64,
    highest_bid: u64,
    highest_bidder: Option<Uuid>,
    bidders: HashMap<Uuid, Recipient<AuctionStatus>>, // 참여 입찰자 (상태 업데이트 수신용)
    is_open: bool,
    end_time: Option<Instant>,         // Instant 사용으로 변경
    timer_handle: Option<SpawnHandle>, // 타이머 핸들 관리
}

impl AuctioneerActor {
    fn new() -> Self {
        AuctioneerActor {
            item: None,
            starting_bid: 0,
            highest_bid: 0,
            highest_bidder: None,
            bidders: HashMap::new(),
            is_open: false,
            end_time: None,
            timer_handle: None,
        }
    }

    // 현재 경매 상태를 담은 메시지 생성
    fn get_current_status(&self) -> AuctionStatus {
        let time_remaining = if let Some(et) = self.end_time {
            // Instant::now() 대신 Context::clock() 사용 가능 (테스트 용이)
            et.saturating_duration_since(Instant::now()).as_secs()
        } else {
            0
        };

        AuctionStatus {
            item: self.item.clone().unwrap_or_default(),
            highest_bid: self.highest_bid,
            highest_bidder: self.highest_bidder,
            time_remaining_secs: time_remaining,
            is_open: self.is_open,
            winner: if !self.is_open {
                self.highest_bidder
            } else {
                None
            },
        }
    }

    // 모든 참여자에게 상태 브로드캐스트
    fn broadcast_status(&self, _ctx: &mut Context<Self>) {
        if !self.is_open && self.timer_handle.is_some() {
            println!("AUCTIONEER: Attempted to broadcast status but auction is closed or ending.");
            return; // 경매가 막 종료되었거나 시작되지 않았으면 브로드캐스트 안 함
        }

        let status = self.get_current_status();
        println!("AUCTIONEER: Broadcasting status: {:?}", status);
        for recipient in self.bidders.values() {
            println!("AUCTIONEER: Sending status to recipient.");
            recipient.do_send(status.clone());
        }
    }

    // 경매 종료 처리
    fn end_auction(&mut self, ctx: &mut Context<Self>) {
        if !self.is_open {
            return;
        } // 이미 종료됨

        println!(
            "AUCTIONEER: Auction for '{}' ended.",
            self.item.as_ref().unwrap_or(&"N/A".to_string())
        );
        self.is_open = false;

        // 타이머 중지
        if let Some(handle) = self.timer_handle.take() {
            ctx.cancel_future(handle);
            println!("AUCTIONEER: Timer cancelled.");
        }

        let final_status = self.get_current_status(); // winner 정보 포함
        println!("AUCTIONEER: Final Status: {:?}", final_status);

        // 최종 결과 브로드캐스트
        for recipient in self.bidders.values() {
            recipient.do_send(final_status.clone());
        }

        // 경매 상태 초기화 (다음 경매 준비) - 선택적
        // self.item = None;
        // self.highest_bid = 0;
        // self.highest_bidder = None;
        // self.end_time = None;
        // self.bidders.clear(); // 참여자 목록 초기화 여부는 정책에 따라 다름
    }
}

impl Actor for AuctioneerActor {
    type Context = Context<Self>;

    fn started(&mut self, _ctx: &mut Self::Context) {
        println!("AuctioneerActor started.");
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        println!("AuctioneerActor stopped.");
    }
}

// --- 메시지 핸들러 구현 ---

impl Handler<StartAuction> for AuctioneerActor {
    type Result = Result<(), String>;

    fn handle(&mut self, msg: StartAuction, ctx: &mut Context<Self>) -> Self::Result {
        if self.is_open {
            return Err("Another auction is already in progress.".to_string());
        }

        println!(
            "AUCTIONEER: Starting auction for '{}', starting bid: {}, duration: {}s",
            msg.item, msg.starting_bid, msg.duration_secs
        );

        self.item = Some(msg.item);
        self.starting_bid = msg.starting_bid;
        self.highest_bid = msg.starting_bid; // 시작가를 초기 최고가로 설정
        self.highest_bidder = None;
        self.is_open = true;
        self.end_time = Some(Instant::now() + Duration::from_secs(msg.duration_secs));
        self.bidders.clear(); // 새 경매 시작 시 참여자 초기화

        // 기존 타이머 취소 (혹시 모르니)
        if let Some(handle) = self.timer_handle.take() {
            ctx.cancel_future(handle);
        }

        // 1초마다 InternalTimerTick 메시지를 자신에게 보내는 타이머 설정
        self.timer_handle = Some(ctx.run_interval(Duration::from_secs(1), |act, ctx| {
            // 타이머가 만료되었는지 확인
            if let Some(et) = act.end_time {
                if Instant::now() >= et {
                    println!("AUCTIONEER: Timer expired.");
                    act.end_auction(ctx); // 타이머 만료 시 경매 종료
                } else {
                    // 아직 진행 중이면 상태 브로드캐스트 (선택적: 너무 자주 보낼 수 있음)
                    // act.broadcast_status(ctx);
                    // 대신 InternalTimerTick 메시지를 보내서 처리하게 할 수도 있음
                    ctx.notify(InternalTimerTick);
                }
            } else {
                // 종료 시간이 없으면 타이머 중지 (이론상 발생하면 안 됨)
                println!("AUCTIONEER: ERROR - Timer running without end_time!");
                if let Some(handle) = act.timer_handle.take() {
                    ctx.cancel_future(handle);
                }
            }
        }));
        println!("AUCTIONEER: Timer started.");

        // 즉시 상태 브로드캐스트
        self.broadcast_status(ctx);

        Ok(())
    }
}

// 입찰자 등록 및 입찰 처리
impl Handler<PlaceBid> for AuctioneerActor {
    type Result = Result<(), String>;

    fn handle(&mut self, msg: PlaceBid, ctx: &mut Context<Self>) -> Self::Result {
        if !self.is_open {
            return Err("Auction is not open.".to_string());
        }
        if Instant::now() >= self.end_time.unwrap() {
            return Err("Auction has already ended.".to_string());
        }

        // 입찰자가 처음 입찰하는 경우 등록 (Recipient 필요)
        // 실제로는 BidderActor의 Addr를 받아서 Recipient를 만들어야 함.
        // if !self.bidders.contains_key(&msg.bidder_id) {
        //     // self.bidders.insert(msg.bidder_id, bidder_recipient);
        //     println!("AUCTIONEER: Bidder {} registered.", msg.bidder_id);
        // }

        // 입찰가 유효성 검사
        if msg.amount <= self.highest_bid {
            return Err(format!(
                "Your bid ({}) must be higher than the current highest bid ({}).",
                msg.amount, self.highest_bid
            ));
        }

        println!(
            "AUCTIONEER: Bid received from {}: {}",
            msg.bidder_id, msg.amount
        );
        self.highest_bid = msg.amount;
        self.highest_bidder = Some(msg.bidder_id);

        // 새로운 최고가 발생 시 상태 브로드캐스트
        self.broadcast_status(ctx);

        Ok(())
    }
}

impl Handler<GetStatus> for AuctioneerActor {
    type Result = MessageResult<GetStatus>;

    fn handle(&mut self, _msg: GetStatus, _ctx: &mut Context<Self>) -> Self::Result {
        println!("AUCTIONEER: GetStatus request received.");
        MessageResult(self.get_current_status())
    }
}

// 내부 타이머 틱 처리 (선택적: 상태 업데이트용)
impl Handler<InternalTimerTick> for AuctioneerActor {
    type Result = ();
    fn handle(&mut self, _msg: InternalTimerTick, ctx: &mut Context<Self>) -> Self::Result {
        // 타이머 틱마다 상태를 브로드캐스트 할 수 있음
        // run_interval 클로저 대신 여기서 처리하면 로직 분리 가능
        if self.is_open {
            self.broadcast_status(ctx);
        }
    }
}

// --- Bidder 액터 정의 (간단화) ---
struct BidderActor {
    id: Uuid,
    name: String,
    auctioneer_addr: Addr<AuctioneerActor>,
    last_status: Option<AuctionStatus>,
}

impl Actor for BidderActor {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        println!("BIDDER [{} / {}]: Started.", self.name, self.id);
        // 시작 시 경매 상태 요청
        self.request_status(ctx);
    }
}

// AuctionStatus 메시지 핸들러 (Auctioneer로부터 받음)
impl Handler<AuctionStatus> for BidderActor {
    type Result = ();
    fn handle(&mut self, msg: AuctionStatus, _ctx: &mut Context<Self>) -> Self::Result {
        println!("BIDDER [{} / {}]: Received Status - Item: '{}', Highest Bid: {}, Bidder: {:?}, Time Left: {}s, Open: {}, Winner: {:?}",
                 self.name, self.id, msg.item, msg.highest_bid, msg.highest_bidder, msg.time_remaining_secs, msg.is_open, msg.winner);
        self.last_status = Some(msg);

        // TODO: 여기에 입찰 결정 로직 추가 가능
        // 예: if status.is_open && status.highest_bidder != Some(self.id) { self.place_bid(...) }
    }
}

// 입찰 로직 (헬퍼 함수)
impl BidderActor {
    fn place_bid(&self, ctx: &mut Context<Self>, amount: u64) {
        println!(
            "BIDDER [{} / {}]: Attempting to bid {}.",
            self.name, self.id, amount
        );
        // Auctioneer에게 PlaceBid 메시지 보내기
        let bid_msg = PlaceBid {
            bidder_id: self.id,
            amount,
        };
        self.auctioneer_addr
            .send(bid_msg)
            .into_actor(self) // 결과를 이 액터의 컨텍스트에서 처리하도록 함
            .then(|res, _act, _ctx| {
                // 결과 처리 클로저
                match res {
                    Ok(Ok(())) => println!("BIDDER [{}]: Bid successful!", _act.name),
                    Ok(Err(e)) => println!("BIDDER [{}]: Bid failed - {}", _act.name, e),
                    Err(e) => println!("BIDDER [{}]: MailboxError sending bid: {}", _act.name, e),
                }
                fut::ready(()) // Future 완료
            })
            .wait(ctx); // Future가 완료될 때까지 기다리지 않고, 완료되면 실행되도록 등록
                        // wait()는 현재 메시지 처리를 중단시키지 않음
    }

    fn request_status(&self, ctx: &mut Context<Self>) {
        println!(
            "BIDDER [{} / {}]: Requesting auction status.",
            self.name, self.id
        );
        self.auctioneer_addr
            .send(GetStatus)
            .into_actor(self)
            .then(|res, act, _ctx| {
                match res {
                    Ok(status) => {
                        println!(
                            "BIDDER [{}]: Received status on request: {:?}",
                            act.name, status
                        );
                        act.last_status = Some(status);
                    }
                    Err(e) => println!("BIDDER [{}]: Failed to get status: {}", act.name, e),
                }
                fut::ready(())
            })
            .wait(ctx);
    }
}

// --- 메인 함수 (테스트용) ---
#[actix_web::main]
async fn main() {
    println!("--- Starting Auction System ---");

    // Auctioneer 시작
    let auctioneer_addr = AuctioneerActor::new().start();

    // Bidder 시작
    let bidder1_id = Uuid::new_v4();
    let bidder1_addr = BidderActor {
        id: bidder1_id,
        name: "Alice".to_string(),
        auctioneer_addr: auctioneer_addr.clone(),
        last_status: None,
    }
    .start();

    let bidder2_id = Uuid::new_v4();
    let bidder2_addr = BidderActor {
        id: bidder2_id,
        name: "Bob".to_string(),
        auctioneer_addr: auctioneer_addr.clone(),
        last_status: None,
    }
    .start();

    // Auctioneer에게 Bidder Recipient 등록 (원래는 Bidder가 Join 같은 메시지를 보내야 함)
    println!("\n--- Manually Registering Bidders (for simplicity) ---");
    // 실제로는 Auctioneer가 직접 상태를 수정하는 대신 메시지를 사용해야 함.
    // auctioneer_addr.do_send(RegisterBidder { id: bidder1_id, recipient: bidder1_addr.recipient() });
    // auctioneer_addr.do_send(RegisterBidder { id: bidder2_id, recipient: bidder2_addr.recipient() });
    // 위와 같이 직접 등록하는 대신, StartAuction 핸들러에서 bidders 맵을 초기화하고,
    // PlaceBid 핸들러에서 처음 입찰하는 bidder를 등록하도록 수정했습니다.
    // (단, Recipient를 얻으려면 BidderActor의 Addr가 필요하므로, PlaceBid에 Addr를 포함시키거나
    //  별도의 Register 메시지를 구현해야 합니다. 이 예제에서는 단순화를 위해 Recipient 등록 생략)

    // 경매 시작
    println!("\n--- Starting Auction ---");
    let start_res = auctioneer_addr
        .send(StartAuction {
            item: "Rare Pepe".to_string(),
            starting_bid: 100,
            duration_secs: 5, // 짧은 시간 설정
        })
        .await;
    println!("StartAuction Result: {:?}", start_res);

    // Bidder에게 Recipient 전달 (실제로는 Join 응답 등으로 받아야 함)
    // 이 예제에서는 BidderActor 생성 시 auctioneer_addr를 전달받음.
    // 상태 업데이트를 받으려면 Auctioneer가 Bidder의 Recipient를 알아야 함.
    // 이 부분은 예제의 한계입니다. 실제로는 등록 과정이 필요합니다.

    // 입찰 시뮬레이션
    println!("\n--- Bidding Simulation ---");
    // Alice 입찰 (BidderActor 내부에서 place_bid 호출하도록 수정 필요)
    bidder1_addr.do_send(PlaceBidInternal(110)); // Actor 내부에서 호출하도록 메시지 추가
    sleep(Duration::from_millis(500)).await;

    // Bob 입찰
    bidder2_addr.do_send(PlaceBidInternal(120));
    sleep(Duration::from_millis(500)).await;

    // Alice 다시 입찰
    bidder1_addr.do_send(PlaceBidInternal(150));
    sleep(Duration::from_millis(500)).await;

    println!("\n--- Waiting for auction to end ({} seconds) ---", 5);
    sleep(Duration::from_secs(6)).await; // 경매 시간 + 여유 시간

    println!("\n--- Requesting final status ---");
    bidder1_addr.do_send(RequestStatusInternal);
    bidder2_addr.do_send(RequestStatusInternal);

    sleep(Duration::from_millis(100)).await; // 상태 요청 처리 시간

    println!("\n--- Stopping System ---");
    System::current().stop();
}

// --- Bidder 내부 로직 호출을 위한 메시지 ---
#[derive(Message)]
#[rtype(result = "()")]
struct PlaceBidInternal(u64);

impl Handler<PlaceBidInternal> for BidderActor {
    type Result = ();
    fn handle(&mut self, msg: PlaceBidInternal, ctx: &mut Context<Self>) -> Self::Result {
        self.place_bid(ctx, msg.0);
    }
}

#[derive(Message)]
#[rtype(result = "()")]
struct RequestStatusInternal;

impl Handler<RequestStatusInternal> for BidderActor {
    type Result = ();
    fn handle(&mut self, _msg: RequestStatusInternal, ctx: &mut Context<Self>) -> Self::Result {
        self.request_status(ctx);
    }
}
</file>

<file path="simulator_core/src/resource.rs">
///
/// 수정 가능한 자원에 대해서 증감 및 관련 편의 메소드를 제공하는 trait
///

pub trait Resource {
    /// 현재 값을 가져옴
    fn get_value(&self) -> i32;

    /// 기본 값을 가져옴
    fn get_base_value(&self) -> i32;

    /// 현재 값을 설정
    fn set_value(&mut self, value: i32);

    /// 값을 증가
    fn increase(&mut self, amount: i32) {
        self.set_value(self.get_value() + amount);
    }

    /// 값을 감소
    fn decrease(&mut self, amount: i32) {
        self.set_value(self.get_value() - amount);
    }

    /// 최소값 제한
    fn get_min_value(&self) -> Option<i32> {
        None // 기본적으로는 제한 없음
    }

    /// 최대값 제한
    fn get_max_value(&self) -> Option<i32> {
        None // 기본적으로는 제한 없음
    }

    /// 제한을 고려한 값 설정
    fn set_value_with_limits(&mut self, value: i32) {
        let value = if let Some(min) = self.get_min_value() {
            value.max(min)
        } else {
            value
        };

        let value = if let Some(max) = self.get_max_value() {
            value.min(max)
        } else {
            value
        };

        self.set_value(value);
    }

    /// 퍼센트 기반 증가
    fn increase_percent(&mut self, percent: f32) {
        let increase = (self.get_base_value() as f32 * percent).round() as i32;
        self.increase(increase);
    }
}

pub trait ResourceExtension: Resource {
    /// 기본값으로 초기화
    fn reset_to_base(&mut self) {
        self.set_value(self.get_base_value());
    }

    /// 현재 값이 기본값보다 높은지 확인
    fn is_buffed(&self) -> bool {
        self.get_value() > self.get_base_value()
    }

    /// 현재 값이 기본값보다 낮은지 확인
    fn is_debuffed(&self) -> bool {
        self.get_value() < self.get_base_value()
    }

    /// 현재 값이 기본값과 다른지 확인
    fn is_modified(&self) -> bool {
        self.get_value() != self.get_base_value()
    }

    /// 버프/디버프의 차이값 반환
    fn get_modification_amount(&self) -> i32 {
        self.get_value() - self.get_base_value()
    }
}

#[derive(Clone)]
pub struct CardSpecsResource {
    value: i32,
    base: i32,
}

impl Resource for CardSpecsResource {
    fn get_value(&self) -> i32 {
        self.value
    }

    fn get_base_value(&self) -> i32 {
        self.base
    }

    fn set_value(&mut self, value: i32) {
        self.value = value;
    }
}

impl ResourceExtension for CardSpecsResource {}

impl CardSpecsResource {
    pub fn new(value: i32) -> Self {
        Self { value, base: value }
    }
}
</file>

<file path="simulator_core/src/selector/automatic.rs">
use super::TargetCondition;

pub enum AutoSelectType {
    Weakest,
    Strongest,
    Random,
    All,
}

// 자동 선택기 (가장 약한 카드, 가장 강한 카드 등)
pub struct AutomaticSelector {
    condition: TargetCondition,
    selection_type: AutoSelectType,
}
</file>

<file path="simulator_core/src/selector/complex.rs">
use super::{SelectorLogic, TargetCondition};

pub struct ComplexSelector {
    conditions: Vec<TargetCondition>,
    logic: SelectorLogic,
}
</file>

<file path="simulator_core/src/selector/mod.rs">
use std::sync::Arc;

pub mod automatic;
pub mod complex;
pub mod mulligan;
pub mod multi;
pub mod single;

use actix::Addr;

use crate::{
    card::{
        types::{CardType, OwnerType},
        Card,
    },
    enums::ZoneType,
    exception::GameError,
    game::GameActor,
};

pub trait TargetSelector: Send + Sync {
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError>;
    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool;
    fn get_target_count(&self) -> TargetCount;
    fn clone_selector(&self) -> Box<dyn TargetSelector>;

    fn get_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> Vec<Card> {
        // let mut valid_targets = Vec::new();

        // for location in self.get_locations() {
        //     let cards = game.get_cards_by_player_and_zone_type(self.get_owner().into(), location);

        //     for card in cards {
        //         if self.is_valid_target(&card, game, source) {
        //             valid_targets.push(card);
        //         }
        //     }
        // }

        // valid_targets
        todo!()
    }

    fn get_owner(&self) -> OwnerType;

    fn get_locations(&self) -> Vec<ZoneType>;

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool;
}

#[derive(Clone, Copy)]
pub enum TargetCount {
    Exact(usize),
    Range(usize, usize),
    Any,
    None,
}

/// 카드 선택 조건
/// - location: 카드의 위치
/// - owner: 카드의 소유자
/// - card_type: 카드의 타입
/// - custom_filter: 카드에 대한 사용자 정의 필터
#[derive(Clone)]
pub struct TargetCondition {
    location: Vec<ZoneType>,
    owner: OwnerType,
    card_type: Option<CardType>,
    custom_filter: Option<Arc<dyn Fn(&Card) -> bool + Send + Sync>>,
}

pub enum SelectorLogic {
    And,
    Or,
    Not(Box<dyn TargetSelector>),
}
</file>

<file path="simulator_core/src/selector/mulligan.rs">
use uuid::Uuid;

#[derive(Clone)]
pub struct MulliganState {
    player_ready: bool,
    select_cards: Vec<Uuid>,
}

impl MulliganState {
    pub fn new() -> Self {
        Self {
            player_ready: false,
            select_cards: vec![],
        }
    }

    pub fn confirm_selection(&mut self) {
        self.player_ready = true;
    }

    pub fn get_select_cards(&self) -> Vec<Uuid> {
        self.select_cards.clone()
    }

    pub fn add_select_cards(&mut self, cards: Vec<Uuid>) {
        self.select_cards.extend(cards);
    }

    pub fn remove_select_cards(&mut self, cards: Vec<Uuid>) {
        self.select_cards.retain(|x| !cards.contains(x));
    }

    pub fn is_ready(&self) -> bool {
        self.player_ready
    }
}
</file>

<file path="simulator_core/src/selector/multi.rs">
use actix::Addr;

use crate::{
    card::{types::OwnerType, Card},
    exception::GameError,
    game::GameActor,
};

use super::{TargetCondition, TargetCount, TargetSelector};

// 다중 카드 선택기
pub struct MultiCardSelector {
    condition: TargetCondition,
    count: TargetCount,
}

impl TargetSelector for MultiCardSelector {
    /// 다중 카드 선택기 생성자
    ///
    /// # Parameters
    /// * `game` - 게임 객체
    /// * `source` - 이벤트를 발생시킨 카드
    ///
    /// # Returns
    /// * `Ok(Vec<Card>)` - 선택된 카드 목록
    /// * `Err(GameError)` - 카드 선택 중 오류 발생
    ///
    /// # Errors
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError> {
        todo!()
    }

    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }

    fn get_target_count(&self) -> TargetCount {
        todo!()
    }

    fn clone_selector(&self) -> Box<dyn TargetSelector> {
        todo!()
    }

    fn get_owner(&self) -> OwnerType {
        todo!()
    }

    fn get_locations(&self) -> Vec<crate::enums::ZoneType> {
        todo!()
    }

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }
}
</file>

<file path="simulator_core/src/selector/single.rs">
use std::sync::Arc;

use actix::Addr;

use crate::{
    card::{
        types::{CardType, OwnerType},
        Card,
    },
    enums::ZoneType,
    exception::GameError,
    game::GameActor,
};

use super::{TargetCondition, TargetCount, TargetSelector};

pub struct SingleCardSelector {
    condition: TargetCondition,
}

impl SingleCardSelector {
    pub fn new(location: ZoneType, owner: OwnerType) -> Self {
        Self {
            condition: TargetCondition {
                location: vec![location],
                owner,
                card_type: None,
                custom_filter: None,
            },
        }
    }

    pub fn with_card_type(mut self, card_type: CardType) -> Self {
        self.condition.card_type = Some(card_type);
        self
    }

    pub fn with_filter<F>(mut self, filter: F) -> Self
    where
        F: Fn(&Card) -> bool + Send + Sync + 'static,
    {
        self.condition.custom_filter = Some(Arc::new(filter));
        self
    }
}

impl TargetSelector for SingleCardSelector {
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError> {
        // let valid_targets = self.get_valid_targets(game, source);

        // if valid_targets.is_empty() {
        //     return Err(GameError::NoValidTargets);
        // }

        // // 실제 게임에서는 플레이어가 선택
        // Ok(vec![valid_targets[0].clone()])
        todo!()
    }

    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool {
        // !self.get_valid_targets(game, source).is_empty()
        todo!()
    }

    fn get_target_count(&self) -> TargetCount {
        // TargetCount::Exact(1)
        todo!()
    }

    fn clone_selector(&self) -> Box<dyn TargetSelector> {
        // Box::new(Self {
        //     condition: self.condition.clone(),
        // })
        todo!()
    }

    fn get_owner(&self) -> OwnerType {
        todo!()
    }

    fn get_locations(&self) -> Vec<ZoneType> {
        todo!()
    }

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }
}
</file>

<file path="simulator_core/src/server/end_point copy">
use std::pin::Pin;
use std::time::{Duration, Instant};

use actix_web::{get, web, FromRequest, HttpRequest, HttpResponse};
use actix_ws::{handle, CloseCode, CloseReason, Message};
use futures_util::StreamExt;
use serde_json::json;
use std::future::Future;
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

use crate::enums::{CLIENT_TIMEOUT, COUNT_OF_MULLIGAN_CARDS, HEARTBEAT_INTERVAL};
use crate::exception::MessageProcessResult;
use crate::server::helper::{send_error_and_check, MessageHandler};
use crate::server::jsons::draw::serialize_draw_answer_message;
use crate::server::jsons::mulligan::{
    self, serialize_complete_message, serialize_deal_message, serialize_reroll_answer,
};
use crate::server::jsons::{game_features, main_phase1, ValidationPayload};
use crate::{card::types::PlayerType, exception::GameError};
use crate::{try_send_error, StringUuidExt, VecStringExt};

use super::types::ServerState;

#[derive(Debug, Clone, Copy)]
pub struct AuthPlayer {
    ptype: PlayerType,
    session_id: Uuid,
}

impl AuthPlayer {
    fn new(ptype: PlayerType, session_id: Uuid) -> Self {
        Self { ptype, session_id }
    }
}

impl AuthPlayer {
    fn reverse(&self) -> PlayerType {
        match self.ptype {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        }
    }
}

impl FromRequest for AuthPlayer {
    type Error = GameError;
    type Future = Pin<Box<dyn Future<Output = Result<Self, Self::Error>>>>;

    fn from_request(req: &HttpRequest, payload: &mut actix_web::dev::Payload) -> Self::Future {
        let req = req.clone();
        Box::pin(async move {
            debug!("AuthPlayer::from_request 시작: 인증 처리 중...");

            let Some(player_name) = req.cookie("user_id") else {
                error!("쿠키 누락: 'user_id' 쿠키를 찾을 수 없음");
                return Err(GameError::CookieNotFound);
            };
            let Some(game_step) = req.cookie("game_step") else {
                error!("쿠키 누락: 'game_step' 쿠키를 찾을 수 없음");
                return Err(GameError::CookieNotFound);
            };

            let player_name = player_name.to_string().replace("user_id=", "");
            let game_step = game_step.to_string().replace("game_step=", "");
            debug!(
                "쿠키 파싱 완료: player_name={}, game_step={}",
                player_name, game_step
            );

            if let Some(state) = req.app_data::<web::Data<ServerState>>() {
                let game = state.game.lock().await;
                let current_phase = game.get_phase().as_str().to_lowercase();

                if current_phase != game_step {
                    warn!(
                        "페이즈 불일치: 요청된 페이즈={}, 현재 게임 페이즈={}",
                        game_step, current_phase
                    );
                    return Err(GameError::WrongPhase);
                }
                debug!("페이즈 검증 성공: {}", current_phase);

                let player_name_str = player_name.to_string();
                let p1_key = state.player_cookie.0.as_str();
                let p2_key = state.opponent_cookie.0.as_str();

                let player_type = match player_name_str.as_str() {
                    key if key == p1_key => {
                        debug!("플레이어1로 인증됨");
                        PlayerType::Player1
                    }
                    key if key == p2_key => {
                        debug!("플레이어2로 인증됨");
                        PlayerType::Player2
                    }
                    _ => {
                        error!("잘못된 플레이어 키: {}", player_name_str);
                        return Err(GameError::InternalServerError);
                    }
                };

                debug!(
                    "세션 등록 시작: player_type={:?}, game_step={}",
                    player_type, game_step
                );
                let session_id = state
                    .session_manager
                    .register_session(player_type, game_step.clone().into())
                    .await;
                debug!("세션 등록 완료: session_id={}", session_id);

                // 다른 엔드포인트에 이미 유효한 세션이 있는지 확인
                if !state
                    .session_manager
                    .is_valid_session(player_type, session_id, game_step.into())
                    .await
                {
                    warn!(
                        "중복 세션 감지: player_type={:?}, session_id={}",
                        player_type, session_id
                    );
                    return Err(GameError::ActiveSessionExists);
                }

                info!(
                    "인증 성공: player_type={:?}, session_id={}",
                    player_type, session_id
                );
                Ok(AuthPlayer::new(player_type, session_id))
            } else {
                error!("서버 상태 객체를 찾을 수 없음");
                Err(GameError::ServerStateNotFound)
            }
        })
    }
}

impl From<AuthPlayer> for PlayerType {
    fn from(value: AuthPlayer) -> Self {
        value.ptype
    }
}

impl From<AuthPlayer> for String {
    fn from(value: AuthPlayer) -> Self {
        value.ptype.into()
    }
}

// 최초로 연결되어야하는 엔드포인트.
#[get("/heartbeat")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype, session_id = ?player.session_id))]
pub async fn heartbeat(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    let player_type = player.ptype;
    let session_id = player.session_id;

    debug!("WebSocket 연결 업그레이드 시작");

    // WebSocket 연결 설정
    let (response, session, mut stream) = match handle(&req, payload) {
        Ok(result) => {
            info!("WebSocket 연결 성공: player={:?}", player_type);
            result
        }
        Err(e) => {
            error!(
                "WebSocket 핸들링 실패: player={:?}, error={:?}",
                player_type, e
            );
            return Err(GameError::HandleFailed);
        }
    };

    let mut session_clone = session.clone();
    let heartbeat_session_manager = state.session_manager.clone();

    // 하트비트 처리를 위한 별도 태스크 생성
    info!(
        "하트비트 태스크 시작: player={:?}, session_id={}",
        player_type, session_id
    );

    actix_web::rt::spawn(async move {
        debug!("하트비트 인터벌 설정: {}초", HEARTBEAT_INTERVAL);
        let mut interval = tokio::time::interval(Duration::from_secs(HEARTBEAT_INTERVAL));
        let mut last_pong = Instant::now();

        // 클라이언트에게 초기 메시지 전송 (선택사항)
        if let Err(e) = session_clone
            .text(
                json!({
                    "type": "connection_established",
                    "player": format!("{:?}", player_type),
                    "session_id": session_id.to_string(),
                })
                .to_string(),
            )
            .await
        {
            error!(
                "초기 메시지 전송 실패: player={:?}, error={:?}",
                player_type, e
            );
            return;
        }

        loop {
            tokio::select! {
                // 주기적인 핑 전송
                _ = interval.tick() => {
                    // 마지막 pong 으로부터 너무 오랜 시간이 지났으면 연결 종료
                    if last_pong.elapsed() > Duration::from_secs(CLIENT_TIMEOUT) {
                        error!(
                            "클라이언트 타임아웃: player={:?}, 마지막 응답으로부터 {:?}초 경과",
                            player_type, last_pong.elapsed().as_secs()
                        );
                        break;
                    }

                    // 핑 메시지 전송
                    debug!("하트비트 ping 전송: player={:?}", player_type);
                    if let Err(e) = session_clone.ping(b"heartbeat").await {
                        error!("하트비트 ping 실패: player={:?}, error={:?}", player_type, e);
                        break;
                    }
                },

                // 클라이언트로부터 메시지 수신
                Some(msg) = stream.next() => {
                    match msg {
                        Ok(Message::Pong(_)) => {
                            debug!("하트비트 pong 응답 수신: player={:?}", player_type);
                            last_pong = Instant::now();
                        },
                        Ok(Message::Close(reason)) => {
                            info!("클라이언트가 연결 종료 요청: player={:?}, reason={:?}", player_type, reason);
                            break;
                        },
                        Err(e) => {
                            error!("WebSocket 메시지 에러: player={:?}, error={:?}", player_type, e);
                            break;
                        }
                        _ => {
                            info!("클라이언트로부터 다른 메시지 수신: player={:?}", player_type);
                        }
                    }
                }
            }
        }

        // 하트비트 태스크 종료시 세션 정리
        info!(
            "하트비트 태스크 종료, 세션 정리: player={:?}, session_id={}",
            player_type, session_id
        );

        // 세션 종료 처리
        heartbeat_session_manager
            .end_session(player_type, session_id)
            .await;

        info!("세션 정리 성공");

        // 웹소켓 연결 종료
        if let Err(e) = session_clone
            .close(Some(CloseReason {
                code: CloseCode::Normal,
                description: Some("세션 종료".to_string()),
            }))
            .await
        {
            error!("세션 종료 실패: player={:?}, error={:?}", player_type, e);
        } else {
            debug!("세션 종료 성공: player={:?}", player_type);
        }

        info!(
            "하트비트 태스크 종료: player={:?}, session_id={}",
            player_type, session_id
        );
    });

    Ok(response)
}

/// mulligan 단계를 처리하는 end point 입니다.
///
/// AuthPlayer Request Guard 을 통해 접근을 제한합니다.
///
/// 각 플레이어는 게임 시작 시 해당 end point 에 접속하여 WebSocket 연결을 수립하게 됩니다.
/// WebSocket 연결이 성공적으로 수립되면 서버측에서 get_mulligan_cards 함수를 통해 플레이어에게 멀리건 카드를 전송합니다.
/// 이 때 서버측에서 플레이어에게 전송하는 json 규격은 아래와 같습니다
///
/// ```
///     use serde_json::json;
///     json!
///     ({
///         "action": "deal",
///         "payload": {
///             "player": "player",
///             "cards": ["CARD_UUID_1", "CARD_UUID_2", "CARD_UUID_3", "CARD_UUID_4"]
///         }
///     });
/// ```
///
///
/// 멀리건 카드를 받은 플레이어는 다시 뽑을 카드를 선택하여 서버로 전송합니다.
/// 이 때 플레이어가 서버로 전송하는 json 규격은 아래와 같습니다.
///
/// ```
///     use serde_json::json;
///     json!
///     ({
///         "action": "reroll-request",
///         "payload": {
///             "player": "player",
///             "cards": ["CARD_UUID_1", "CARD_UUID_2"]
///         }
///     });
/// ```
///
///
/// 서버는 플레이어가 전송한 카드를 덱의 맨 아래에 위치 시킨 뒤, 새로운 카드를 뽑아서 플레이어에게 전송합니다.
/// 이 때 서버측에서 플레이어에게 전송하는 json 규격은 아래와 같습니다.
///
/// ```
///     use serde_json::json;
///     json!
///     ({
///         "action": "complete",
///         "payload": {
///             "player": "player",
///             "cards": ["CARD_UUID_3", "CARD_UUID_4"]
///         }
///     });
/// ```
///
/// 재추첨을 요청하지 않고 카드 선택을 완료한 경우, 플레이어는 서버에게 complete 메시지를 전송합니다.
/// complete 메세지를 받은 서버는 플레이어에게 Complete json 을 전송합니다.
/// 이 때 서버측에서 플레이어에게 전송하는 json 규격은 아래와 같습니다.
///
/// ```
///     use serde_json::json;
///     json!
///     ({
///         "action": "complete",
///         "payload": {
///             "player": "player",
///             "cards": ["CARD_UUID_3", "CARD_UUID_4"]
///         }
///     });
/// ```
///
/// 재추첨 카드들은 덱의 맨 아래에 위치하게 됩니다.
/// 위 일련의 과정이 모두 완료 되면 MulliganState 의 confirm_selection() 함수를 호출하여 선택을 확정합니다.
/// 해당 함수 호출 후, 다른 플레이어의 MulliganState 의 is_ready 함수를 통해 준비 상태를 확인합니다.
/// 두 플레이어가 모두 준비되면 다음 단계로 넘어갑니다.

// TODO: 네트워크 이슈가 발생하여 재연결이 필요한 경우 처리가 필요함.
// TODO: 게임 로직을 end point 가 아니라 Game 내부에다가 구현 해야함.
#[get("/mulligan_phase")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype, session_id = ?player.session_id))]
pub async fn mulligan_phase(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    info!("멀리건 단계 핸들러 시작: player={:?}", player.ptype);
    // 멀리건 수행 중 연결이 끊힌 경우, 재진입을 허용해야 하는데, 아직 뚜렷한 방법이 떠오르진 않음.

    // 플레이어가 재진입을 시도하는 경우
    {
        let game = state.game.lock().await;
        debug!("게임 상태 잠금 획득: 재진입 확인");

        // TODO: 일관성 있게, PhaseState 를 사용하여 처리하는 것이 좋을 것 같음.
        if !game
            .get_player_by_type(player.ptype)
            .get()
            .get_mulligan_state_mut()
            .get_select_cards()
            .is_empty()
        {
            error!("플레이어가 이미 멀리건을 시작함: player={:?}", player.ptype);
            return Err(GameError::NotAllowedReEntry);
        }
    }

    let player_type = player.ptype;
    debug!("플레이어 타입 설정: {:?}", player_type);

    // Http 업그레이드: 이때 session과 stream이 반환됩니다.
    debug!("WebSocket 연결 업그레이드 시작");
    let (resp, mut session, mut stream) = match handle(&req, payload) {
        Ok(result) => {
            info!("WebSocket 연결 성공: player={:?}", player_type);
            result
        }
        Err(e) => {
            error!(
                "WebSocket 핸들링 실패: player={:?}, error={:?}",
                player_type, e
            );
            return Err(GameError::HandleFailed);
        }
    };

    // Mulligan deal 단계 수행 코드입니다.
    // 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장 한 뒤, json 형태로 변환하여 전송합니다.
    let new_cards = {
        let mut game = state.game.lock().await;
        debug!("게임 상태 잠금 획득: 멀리건 카드 처리");

        info!(
            "멀리건 카드 뽑기 시작: player={:?}, count={}",
            player_type, COUNT_OF_MULLIGAN_CARDS
        );
        let cards = match game.get_mulligan_cards(player_type, COUNT_OF_MULLIGAN_CARDS) {
            Ok(cards) => {
                debug!("멀리건 카드 뽑기 성공: card_count={}", cards.len());
                cards
            }
            Err(e) => {
                error!(
                    "멀리건 카드 뽑기 실패: player={:?}, error={:?}",
                    player_type, e
                );
                return Err(e);
            }
        };

        game.add_select_cards(cards.clone(), player_type);
        debug!("플레이어 멀리건 상태에 선택 카드 추가 완료");

        cards
    };

    debug!("멀리건 딜 메시지 직렬화 시작");
    let new_cards_json = match serialize_deal_message(player_type, new_cards) {
        Ok(json) => {
            debug!("멀리건 딜 메시지 직렬화 성공");
            json
        }
        Err(e) => {
            error!("멀리건 메시지 직렬화 실패: error={:?}", e);
            return Err(e);
        }
    };

    debug!("멀리건 딜 메시지 전송 시작");
    if let Err(e) = session.text(new_cards_json).await {
        error!("멀리건 딜 메시지 전송 실패: error={:?}", e);
        return Err(GameError::InternalServerError);
    }
    info!("멀리건 딜 메시지 전송 완료");

    let mulligan_session_id = player.session_id;
    let mulligan_session_manager = state.session_manager.clone();

    // 이후, 스레드 내에서 클라이언트와의 상호작용을 계속하기 위해 필요한 state를 클론합니다.
    // WebSocket 메시지 수신 등 후속 처리는 별도 spawn된 작업에서 진행합니다.
    info!(
        "멀리건 메시지 처리 태스크 시작: player={:?}, session_id={}",
        player_type, mulligan_session_id
    );
    actix_web::rt::spawn(async move {
        debug!("메시지 핸들러 생성");
        let mut handler = MessageHandler::new();

        while let Some(data) = stream.next().await {
            match data {
                // 클라이언트에서 받은 메시지를 분석합니다.
                Ok(Message::Text(json)) => {
                    debug!("클라이언트 메시지 수신: player={:?}", player_type);

                    let result = handler
                        .process_message::<mulligan::ClientMessage>(
                            &mut session,
                            &json,
                            mulligan_session_id,
                            player_type,
                        )
                        .await;

                    match result {
                        MessageProcessResult::SystemHandled(msg) => {
                            // TODO: 작성해야함.
                            debug!("시스템 메시지 처리: player={:?}", player_type);
                        }
                        MessageProcessResult::Success(msg) => {
                            info!(
                                "메시지 처리 성공: player={:?}, message_type={}",
                                player_type,
                                std::any::type_name::<mulligan::ClientMessage>()
                            );

                            match msg {
                                mulligan::ClientMessage::RerollRequest(payload) => {
                                    debug!("리롤 요청 처리: player={:?}", player_type);

                                    if !matches!(payload.player.as_str(), "player1" | "player2") {
                                        error!("유효하지 않은 플레이어: {}", payload.player);
                                        try_send_error!(session, GameError::InvalidPlayer, retry 3);
                                    }

                                    let player_type = AuthPlayer::new(
                                        payload.player.clone().into(),
                                        mulligan_session_id,
                                    );

                                    if let Err(e) = payload.cards.to_vec_uuid() {
                                        error!("카드 UUID 변환 실패: error={:?}", e);
                                        try_send_error!(session, GameError::InvalidCards, retry 3);
                                    }
                                    let payload_cards = payload.cards.to_vec_uuid().unwrap();

                                    debug!(
                                        "리롤 요청 처리: player={:?}, cards={:?}",
                                        player_type, payload_cards
                                    );

                                    let mut game = state.game.lock().await;
                                    debug!("게임 상태 잠금 획득: 리롤 요청 처리");

                                    let result =
                                        game.reroll_request(player_type, payload_cards.clone());

                                    if let Err(e) = &result {
                                        error!(
                                            "리롤 요청 처리 실패: player={:?}, error={:?}",
                                            player_type, e
                                        );
                                        try_send_error!(session, e.clone(), retry 3);
                                    }

                                    let rerolled_cards = result.unwrap();

                                    // 플레이어가 선택한 카드를 select_cards 에서 삭제하고 Reroll 된 카드를 추가합니다.
                                    game.add_reroll_cards(
                                        player_type,
                                        payload_cards.clone(),
                                        rerolled_cards,
                                    );

                                    // 멀리건 완료 단계를 수행합니다.
                                    info!("멀리건 완료 처리: player={:?}", player_type);
                                    let selected_cards =
                                        match game.process_mulligan_completion(player_type) {
                                            Ok(selected_cards) => {
                                                debug!("멀리건 완료 처리 성공");
                                                selected_cards
                                            }
                                            Err(e) => {
                                                error!(
                                                "멀리건 완료 처리 실패: player={:?}, error={:?}",
                                                player_type, e
                                            );
                                                break;
                                            }
                                        };

                                    // 상대 플레이어의 준비 상태 확인

                                    if game.check_player_ready_state(player_type.reverse()) {
                                        info!("양 플레이어 모두 준비 완료: 다음 단계 전환 예정");

                                        // TODO: 다음 단계로 넘어가는 코드 작성
                                        game.move_phase();
                                    }

                                    debug!("리롤 응답 메시지 직렬화 시작");
                                    let selected_cards_json = match serialize_reroll_answer(
                                        player_type,
                                        selected_cards,
                                    ) {
                                        Ok(json) => {
                                            debug!("리롤 응답 메시지 직렬화 성공");
                                            json
                                        }
                                        Err(e) => {
                                            error!("리롤 응답 메시지 직렬화 실패: error={:?}", e);
                                            break;
                                        }
                                    };

                                    debug!("리롤 응답 메시지 전송 시작");
                                    if let Err(e) = session.text(selected_cards_json).await {
                                        error!("리롤 응답 메시지 전송 실패: error={:?}", e);
                                        break;
                                    }
                                    info!("리롤 응답 메시지 전송 완료");

                                    info!(
                                        "멀리건 세션 종료: player={:?}, session_id={}",
                                        player_type, mulligan_session_id
                                    );
                                    mulligan_session_manager
                                        .end_session(player_type, mulligan_session_id)
                                        .await;
                                }
                                mulligan::ClientMessage::Complete(payload) => {
                                    debug!("멀리건 완료 요청 처리: player={:?}", player_type);

                                    if !matches!(payload.player.as_str(), "player1" | "player2") {
                                        error!("유효하지 않은 플레이어: {}", payload.player);
                                        try_send_error!(session, GameError::InvalidPlayer, retry 3);
                                    }

                                    let player_type = AuthPlayer::new(
                                        payload.player.clone().into(),
                                        mulligan_session_id,
                                    );

                                    let mut game = state.game.lock().await;
                                    debug!("게임 상태 잠금 획득: 멀리건 완료 요청 처리");

                                    // 이미 준비가 되어있다면 send_error_and_check 함수를 통해 에러 메시지를 전송하고 종료합니다.
                                    if game
                                        .get_player_by_type(player_type)
                                        .get()
                                        .get_mulligan_state_mut()
                                        .is_ready()
                                    {
                                        warn!(
                                            "플레이어가 이미 준비 상태: player={:?}",
                                            player_type
                                        );
                                        try_send_error!(session, GameError::InvalidApproach, retry 3);
                                    }

                                    // 페이로드의 cards 를 확인하여 유효성 검사를 진행합니다.
                                    debug!("선택한 카드 유효성 검사: player={:?}", player_type);
                                    if payload.validate(
                                        game.get_player_by_type(player_type).get().get_cards(),
                                    ) == None
                                    {
                                        error!("유효하지 않은 카드 선택: player={:?}", player_type);
                                        try_send_error!(session, GameError::InvalidCards, retry 3);
                                    }

                                    // player 의 mulligan 상태를 완료 상태로 변경 후 상대의 mulligan 상태를 확인합니다.
                                    // 만약 상대도 완료 상태이라면, mulligan step 을 종료하고 다음 step 으로 진행합니다.
                                    info!("멀리건 완료 처리: player={:?}", player_type);
                                    let selected_cards =
                                        match game.process_mulligan_completion(player_type) {
                                            Ok(selected_cards) => {
                                                debug!("멀리건 완료 처리 성공");
                                                selected_cards
                                            }
                                            Err(e) => {
                                                error!(
                                                "멀리건 완료 처리 실패: player={:?}, error={:?}",
                                                player_type, e
                                            );
                                                break;
                                            }
                                        };

                                    // 상대 플레이어의 준비 상태 확인
                                    if game.check_player_ready_state(player_type.reverse()) {
                                        info!("양 플레이어 모두 준비 완료: 다음 단계 전환 예정");
                                        // 다음 페이즈로 이동하는 코드
                                        game.move_phase();
                                    }

                                    debug!("완료 메시지 직렬화 시작");
                                    if let Err(e) =
                                        serialize_complete_message(player, selected_cards)
                                    {
                                        error!("완료 메시지 직렬화 실패: error={:?}", e);
                                        break;
                                    }
                                    debug!("완료 메시지 직렬화 성공");

                                    debug!("완료 메시지 전송 시작");
                                    if let Err(e) = session.text(json).await {
                                        error!("완료 메시지 전송 실패: error={:?}", e);
                                        break;
                                    }
                                    info!("완료 메시지 전송 완료");

                                    info!(
                                        "멀리건 세션 종료: player={:?}, session_id={}",
                                        player_type, mulligan_session_id
                                    );
                                    mulligan_session_manager
                                        .end_session(player_type, mulligan_session_id)
                                        .await;
                                }
                            }
                        }
                        MessageProcessResult::NeedRetry => {
                            warn!("메시지 처리 재시도 필요: player={:?}", player_type);
                            try_send_error!(session, GameError::InvalidApproach, retry 3);
                            continue;
                        }
                        MessageProcessResult::TerminateSession(server_error) => {
                            error!(
                                "세션 종료 필요: player={:?}, error={:?}",
                                player_type, server_error
                            );
                            mulligan_session_manager
                                .end_session(player_type, mulligan_session_id)
                                .await;
                        }
                    }
                }
                Ok(Message::Close(reason)) => {
                    info!(
                        "WebSocket 종료 메시지 수신: player={:?}, reason={:?}",
                        player_type, reason
                    );
                    break;
                }
                Ok(msg) => {
                    debug!(
                        "기타 WebSocket 메시지 수신: player={:?}, type={:?}",
                        player_type, msg
                    );
                }
                Err(e) => {
                    error!(
                        "WebSocket 메시지 수신 오류: player={:?}, error={:?}",
                        player_type, e
                    );
                    break;
                }
            }
        }

        if let Err(close_err) = session
            .close(Some(CloseReason {
                code: CloseCode::Normal,
                description: Some("종료".into()),
            }))
            .await
        {
            error!(
                "WebSocket 연결 종료 실패: player={:?}, error={:?}",
                player_type, close_err
            );
            panic!("WebSocket 연결 종료 실패");
        }
        info!("WebSocket 메시지 처리 루프 종료: player={:?}", player_type);
    });

    info!("멀리건 핸들러 완료: player={:?}", player_type);
    Ok(resp)
}

#[get("/draw_phase")]
#[instrument(skip(state), fields(player_type = ?player.ptype))]
pub async fn draw_phase(
    player: AuthPlayer,
    state: web::Data<ServerState>,
) -> Result<HttpResponse, GameError> {
    let player_type = player.ptype;
    info!("드로우 단계 처리 시작: player={:?}", player_type);

    let drawn_card = {
        let mut game = state.game.lock().await;
        debug!("게임 상태 잠금 획득");

        // 플레이어가 이미 카드를 뽑은 경우를 확인함
        if game.phase_state.has_player_completed(player_type) {
            error!("플레이어가 이미 드로우를 완료함: player={:?}", player_type);
            return Err(GameError::NotAllowedReEntry);
        }

        game.phase_state.mark_player_completed(player_type);
        debug!("플레이어 드로우 완료 표시: player={:?}", player_type);

        // 에러가 발생할 경우 mark 를 reset 함.
        let result = game.handle_draw_phase(player_type).inspect_err(|e| {
            game.phase_state.reset_player_completed(player_type);
        })?;

        // 다음 페이즈로 이동
        game.move_phase();

        result
    };

    debug!(
        "응답 JSON 구성 중: player={:?}, card_uuid={}",
        player_type, drawn_card
    );
    let response_data = match serialize_draw_answer_message(player_type, drawn_card) {
        Ok(data) => data,
        Err(e) => {
            error!("JSON 직렬화 실패: player={:?}, error={:?}", player_type, e);
            return Err(e);
        }
    };

    // JSON 응답 반환
    info!(
        "드로우 단계 처리 완료: player={:?}, card_uuid={}",
        player_type, drawn_card
    );
    Ok(HttpResponse::Ok()
        .content_type("application/json")
        .body(response_data.to_string()))
}

#[get("/standby_phase")]
#[instrument(skip(state), fields(player_type = ?player.ptype))]
pub async fn standby_phase(
    player: AuthPlayer,
    state: web::Data<ServerState>,
) -> Result<HttpResponse, GameError> {
    /*
        Standby 페이즈.
        유희왕 룰에 따르면 플레이어가 반드시 실시해야하는 행위는 없음

        해당 페이즈를 구현하기 위해서는 제대로 된 덱이 하나 있어야함.
        때문에 그 전까지는 미구현 상태로 둠.
    */
    todo!()
}

#[get("/main_phase_start_phase")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype))]
pub async fn main_phase_start_phase(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    info!(
        "메인 페이즈1 개시시 단계 핸들러 시작: player={:?}",
        player.ptype
    );

    let player_type = player.ptype;

    // 플레이어가 재진입을 시도하는 경우
    debug!("게임 상태 잠금 획득: 재진입 확인");
    // TODO: 플레이어가 이미 메인 페이즈1 개시시 단계 진입한 경우 처리가 필요함.

    // Http 업그레이드: 이때 session과 stream이 반환됩니다.
    debug!("WebSocket 연결 업그레이드 시작");
    let (resp, session, stream) = match handle(&req, payload) {
        Ok(result) => {
            info!("WebSocket 연결 성공: player={:?}", player_type);
            result
        }
        Err(e) => {
            error!(
                "WebSocket 핸들링 실패: player={:?}, error={:?}",
                player_type, e
            );
            return Err(GameError::HandleFailed);
        }
    };
    /*
        MainPhaseStart 페이즈.
        메인 페이즈에서 플레이어가 아무 행동도 하지 않은 상태를 의미함.

        이 페이즈에서만 수행 가능한 카드들이 있음.
        [ 메인 페이즈1 개시시 ] 이라는 키워드를 가진 카드들은 해당 페이즈에서 발동 가능함.
        현재 턴의 플레이어의 카드들을 순회해서 해당 효과를 발동시킬건지 플레이어에게 물어보고 입력을 대기해야함.

        이 때문에 WebSocket 연결을 수립해야함.
    */
    todo!()
}

#[get("/main_phase_1_phase")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype))]
pub async fn main_phase_1_phase(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    /*
        MainPhase1 페이즈.
    */
    info!("메인 페이즈1 페이즈 시작: player={:?}", player.ptype);

    let player_type = player.ptype;
    {
        let mut game = state.game.lock().await;
        debug!("게임 상태 잠금 획득: 재진입 확인");

        if game.phase_state.has_player_completed(player_type) {
            error!(
                "플레이어가 해당 페이즈를 이미 진행중임.: player={:?}",
                player_type
            );
            return Err(GameError::NotAllowedReEntry);
        }

        game.phase_state.mark_player_completed(player_type);
        debug!("플레이어 페이즈 진입 표시: player={:?}", player_type);
    };

    // Http 업그레이드: 이때 session과 stream이 반환됩니다.
    debug!("WebSocket 연결 업그레이드 시작");
    let (resp, mut session, mut stream) = match handle(&req, payload) {
        Ok(result) => {
            info!("WebSocket 연결 성공: player={:?}", player_type);
            result
        }
        Err(e) => {
            error!(
                "WebSocket 핸들링 실패: player={:?}, error={:?}",
                player_type, e
            );
            return Err(GameError::HandleFailed);
        }
    };
    debug!("메시지 핸들러 생성");

    let mut handler = MessageHandler::new();

    let session_id = player.session_id;
    let session_manager = state.session_manager.clone();

    // actix_web::rt::spawn(async move {
    //     while let Some(data) = stream.next().await {
    //         match data {
    //             // 클라이언트에서 받은 메시지를 분석합니다.
    //             Ok(Message::Text(json)) => {
    //                 debug!("클라이언트 메시지 수신: player={:?}", player_type);

    //                 let result = handler
    //                     .process_message::<main_phase1::ClientMessage>(
    //                         &mut session,
    //                         &json,
    //                         session_id,
    //                         player_type,
    //                     )
    //                     .await;

    //                 match result {
    //                     MessageProcessResult::SystemHandled(msg) => {
    //                         info!(
    //                             "메시지 처리 성공: player={:?}, message_type={}",
    //                             player_type,
    //                             std::any::type_name::<game_features::ClientMessage>()
    //                         );

    //                         match msg {
    //                             game_features::ClientMessage::EndPhase(end_phase_payload) => {
    //                                 todo!()
    //                             }
    //                             game_features::ClientMessage::Surrender(player_payload) => todo!(),
    //                             game_features::ClientMessage::ChoiceCardAnswer(
    //                                 choice_card_answer_payload,
    //                             ) => {
    //                                 // 사용자 입력은 여기서 처리하게 됨.
    //                                 todo!()
    //                             }
    //                         }
    //                     }
    //                     MessageProcessResult::Success(msg) => {
    //                         info!(
    //                             "메시지 처리 성공: player={:?}, message_type={}",
    //                             player_type,
    //                             std::any::type_name::<mulligan::ClientMessage>()
    //                         );

    //                         match msg {
    //                             main_phase1::ClientMessage::PlayCard(payload) => {
    //                                 debug!("카드 플레이 요청 처리: player={:?}", player_type);

    //                                 if !matches!(payload.player.as_str(), "player1" | "player2") {
    //                                     error!("유효하지 않은 플레이어: {}", payload.player);
    //                                     try_send_error!(session, GameError::InvalidPlayer, retry 3);
    //                                 }

    //                                 let player_type =
    //                                     AuthPlayer::new(payload.player.clone().into(), session_id);

    //                                 if let Err(e) = payload.card.to_uuid() {
    //                                     error!("카드 UUID 변환 실패: error={:?}", e);
    //                                     try_send_error!(session, GameError::InvalidCards, retry 3);
    //                                 }
    //                                 let mut game = state.game.lock().await;
    //                                 debug!("게임 상태 잠금 획득: 리롤 요청 처리");

    //                                 let payload_cards_uuid = payload.card.to_uuid().unwrap();
    //                                 let payload_cards =
    //                                     game.get_cards_by_uuid(payload_cards_uuid.clone()).unwrap();

    //                                 // 사용자 입력 대기의 경우
    //                                 // proceed_card
    //                                 let result = game
    //                                     .proceed_card(player_type, payload_cards_uuid.clone())
    //                                     .await;
    //                                 if let Ok(inner_result) = result {
    //                                     match inner_result {
    //                                         PlayCardResult::Success => break,
    //                                         PlayCardResult::Fail(game_error) => todo!(),
    //                                         PlayCardResult::NeedInput(receiver, fn_once) => todo!(),
    //                                     }
    //                                 } else {
    //                                     error!(
    //                                         "카드 플레이 실패: player={:?}, error={:?}",
    //                                         player_type,
    //                                         result.unwrap_err()
    //                                     );
    //                                     try_send_error!(session, GameError::InvalidCards, retry 3);
    //                                 }
    //                             }
    //                         }
    //                     }
    //                     MessageProcessResult::NeedRetry => {
    //                         warn!("메시지 처리 재시도 필요: player={:?}", player_type);
    //                         try_send_error!(session, GameError::InvalidApproach, retry 3);
    //                         continue;
    //                     }
    //                     MessageProcessResult::TerminateSession(server_error) => {
    //                         error!(
    //                             "세션 종료 필요: player={:?}, error={:?}",
    //                             player_type, server_error
    //                         );
    //                         session_manager.end_session(player_type, session_id).await;
    //                     }
    //                 }
    //             }
    //             Ok(Message::Close(reason)) => {
    //                 info!(
    //                     "WebSocket 종료 메시지 수신: player={:?}, reason={:?}",
    //                     player_type, reason
    //                 );
    //                 break;
    //             }
    //             Ok(msg) => {
    //                 debug!(
    //                     "기타 WebSocket 메시지 수신: player={:?}, type={:?}",
    //                     player_type, msg
    //                 );
    //             }
    //             Err(e) => {
    //                 error!(
    //                     "WebSocket 메시지 수신 오류: player={:?}, error={:?}",
    //                     player_type, e
    //                 );
    //                 break;
    //             }
    //         }
    //     }
    // });
    // if let Err(close_err) = session
    //     .close(Some(CloseReason {
    //         code: CloseCode::Normal,
    //         description: Some("종료".into()),
    //     }))
    //     .await
    // {
    //     error!(
    //         "WebSocket 연결 종료 실패: player={:?}, error={:?}",
    //         player_type, close_err
    //     );
    //     panic!("WebSocket 연결 종료 실패");
    // }
    // info!("WebSocket 메시지 처리 루프 종료: player={:?}", player_type);

    Ok(resp)
}
</file>

<file path="simulator_core/src/server/input_handler.rs">
use crate::exception::GameError;
use std::collections::HashMap;
use std::result::Result;
use std::sync::Arc;
use tokio::sync::{oneshot, Mutex};
use uuid::Uuid;

#[derive(Debug, Clone)]
pub enum InputRequest {
    Dig {
        source_card: Uuid,
        source_effect_uuid: Uuid,
        potential_cards: Vec<Uuid>,
    },
    SelectEffect {
        source_card: Uuid,
        potential_effects: Vec<Uuid>,
    },
}

#[derive(Debug, Clone)]
pub enum InputAnswer {
    Dig(Vec<Uuid>),
    SelectEffect(Uuid),
}

#[derive(Debug)]
pub struct PendingInput {
    request: InputRequest,
    response: Option<InputAnswer>,
}

#[derive(Clone)]
pub struct InputWaiter {
    state: Arc<Mutex<HashMap<Uuid, PendingInput>>>,
}

impl InputWaiter {
    pub fn new() -> Self {
        InputWaiter {
            state: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub async fn wait_for_input(
        &self,
        request: InputRequest,
    ) -> Result<oneshot::Receiver<InputAnswer>, GameError> {
        let request_id = Uuid::new_v4();
        let (tx, rx) = oneshot::channel();

        {
            // 잠금 획득
            let mut state: tokio::sync::MutexGuard<'_, HashMap<Uuid, PendingInput>> =
                self.state.lock().await;

            // 요청 상태를 추가
            state.insert(
                request_id,
                PendingInput {
                    request: request.clone(),
                    response: None,
                },
            );
        }

        Ok(rx)
    }

    // 엔드포인트에서 대기 중인 입력 요청 확인
    pub async fn get_pending_requests(&self) -> Vec<(Uuid, InputRequest)> {
        let state = self.state.lock().await;
        state
            .iter()
            .map(|(id, pending)| (*id, pending.request.clone()))
            .collect()
    }

    // 엔드포인트에서 입력 응답 처리
    pub async fn submit_input(
        &self,
        request_id: Uuid,
        response: InputAnswer,
    ) -> Result<(), GameError> {
        let mut state = self.state.lock().await;

        if let Some(pending) = state.get_mut(&request_id) {
            pending.response = Some(response);

            Ok(())
        } else {
            Err(GameError::InvalidRequestId)
        }
    }
}
</file>

<file path="simulator_core/src/server/jsons.rs">
use std::any::Any;
use uuid::Uuid;

use crate::{
    card::cards::{CardVecExt, Cards},
    exception::GameError,
};

use serde::{Deserialize, Serialize};

/// 모든 메시지 페이로드가 구현해야 하는 기본 트레이트
pub trait MessagePayload: Serialize + for<'de> Deserialize<'de> + Clone + std::fmt::Debug {}

/// 모든 검증 가능한 페이로드가 구현해야 하는 트레이트
pub trait ValidationPayload {
    fn validate(&self, context: &dyn Any) -> Option<()>;
}

/// 모든 메시지가 구현해야 하는 마커 트레이트
// 서버와 클라이언트의 json 구조체가 분리된 시점에서 불필요할 수 도 있음.
pub trait Message: Serialize + for<'de> Deserialize<'de> + std::fmt::Debug {}

/// 공용 에러 메세지 페이로드
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ErrorPayload {
    pub message: String,
}

/// 서버에서 클라이언트로 전송되는 에러 메시지
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "action", content = "payload")]
pub enum ErrorMessage {
    #[serde(rename = "error")]
    Error(ErrorPayload),
}

//------------------------------------------------------------------------------
// Game 관련 메시지 정의
//------------------------------------------------------------------------------
pub mod game_features {
    use super::*;
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ChoiceCardRequestPayload {
        pub player: String,
        pub choice_type: String,

        pub source_card_id: Uuid,

        // 선택 제한 설정
        pub min_selections: usize, // 최소 선택 개수
        pub max_selections: usize, // 최대 선택 개수
        pub destination: String,

        // 상태 관리
        pub is_open: bool,                 // 선택이 활성화되어 있는지
        pub is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
    }

    impl MessagePayload for ChoiceCardRequestPayload {}

    impl ValidationPayload for ChoiceCardRequestPayload {
        fn validate(&self, _context: &dyn Any) -> Option<()> {
            if !matches!(self.player.as_str(), "player1" | "player2") {
                return None;
            }

            Some(())
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct ChoiceCardAnswerPayload {
        pub player: String,
        pub carsd: Vec<String>,
    }

    impl MessagePayload for ChoiceCardAnswerPayload {}

    impl ValidationPayload for ChoiceCardAnswerPayload {
        fn validate(&self, _context: &dyn Any) -> Option<()> {
            if !matches!(self.player.as_str(), "player1" | "player2") {
                return None;
            }

            Some(())
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct EndPhasePayload {
        pub player: String,
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct PlayerPayload {
        pub player: String,
    }

    impl MessagePayload for EndPhasePayload {}

    impl ValidationPayload for EndPhasePayload {
        fn validate(&self, _context: &dyn Any) -> Option<()> {
            if !matches!(self.player.as_str(), "player1" | "player2") {
                return None;
            }

            Some(())
        }
    }

    impl MessagePayload for PlayerPayload {}

    impl ValidationPayload for PlayerPayload {
        fn validate(&self, _context: &dyn Any) -> Option<()> {
            if !matches!(self.player.as_str(), "player1" | "player2") {
                return None;
            }

            Some(())
        }
    }

    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ClientMessage {
        #[serde(rename = "end-phase")]
        EndPhase(EndPhasePayload),
        #[serde(rename = "surrender")]
        Surrender(PlayerPayload),
        #[serde(rename = "choice-card")]
        ChoiceCardAnswer(ChoiceCardAnswerPayload),
    }

    impl Message for ClientMessage {}

    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ServerMessage {
        #[serde(rename = "end-phase")]
        EndPhase(EndPhasePayload),
        #[serde(rename = "surrender")]
        Surrender(PlayerPayload),
        #[serde(rename = "choice-card")]
        ChoiceCardRequest(ChoiceCardRequestPayload),
    }

    impl Message for ServerMessage {}
}

//------------------------------------------------------------------------------
// Mulligan 관련 메시지 정의
//------------------------------------------------------------------------------
pub mod mulligan {
    use super::*;

    /// 멀리건 관련 페이로드
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct MulliganPayload {
        pub player: String,
        pub cards: Vec<String>,
    }

    impl MulliganPayload {
        fn new(player: String, cards: Vec<Uuid>) -> Self {
            MulliganPayload {
                player,
                cards: cards.iter().map(|uuid| uuid.to_string()).collect(),
            }
        }
    }

    impl MessagePayload for MulliganPayload {}

    impl ValidationPayload for MulliganPayload {
        fn validate(&self, context: &dyn Any) -> Option<()> {
            if let Some(player_cards) = context.downcast_ref::<Cards>() {
                // self.cards가 비어 있으면 무조건 유효함
                if self.cards.is_empty() {
                    return Some(());
                }

                // 카드 UUID 유효성 검사
                // TODO: Unwrap 대신 match를 사용하여 안전하게 처리할 수 있도록 수정
                if !self.cards.iter().all(|uuid| {
                    player_cards.contains_uuid(Uuid::parse_str(uuid).unwrap_or_else(|e| {
                        // TODO: Log 함수 사용
                        Uuid::nil()
                    }))
                }) {
                    return None;
                }

                // 플레이어 ID 유효성 검사
                if !matches!(self.player.as_str(), "player1" | "player2") {
                    return None;
                }

                Some(())
            } else {
                None // 잘못된 컨텍스트 타입
            }
        }
    }

    impl MessagePayload for ErrorPayload {}

    /// 클라이언트에서 서버로 전송되는 멀리건 메시지
    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ClientMessage {
        #[serde(rename = "reroll-request")]
        RerollRequest(MulliganPayload),
        #[serde(rename = "complete")]
        Complete(MulliganPayload),
    }

    impl Message for ClientMessage {}

    /// 서버에서 클라이언트로 전송되는 멀리건 메시지
    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ServerMessage {
        #[serde(rename = "deal")]
        Deal(MulliganPayload),
        #[serde(rename = "reroll-answer")]
        RerollAnswer(MulliganPayload),
    }

    impl Message for ServerMessage {}

    /// 서버에서 클라이언트로 특정 카드들을 제공하는 메시지를 직렬화합니다.
    pub fn serialize_deal_message<T: Into<String>>(
        player: T,
        cards: Vec<Uuid>,
    ) -> Result<String, GameError> {
        let message = ServerMessage::Deal(MulliganPayload::new(player.into(), cards));
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }

    /// 리리롤 응답 메시지를 직렬화합니다.
    pub fn serialize_reroll_answer<T: Into<String>>(
        player: T,
        cards: Vec<Uuid>,
    ) -> Result<String, GameError> {
        let message = ServerMessage::RerollAnswer(MulliganPayload::new(player.into(), cards));
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }

    /// 완료 응답 메시지를 직렬화합니다.
    pub fn serialize_complete_message<T: Into<String>>(
        player: T,
        cards: Vec<Uuid>,
    ) -> Result<String, GameError> {
        let message = ClientMessage::Complete(MulliganPayload::new(player.into(), cards));
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

//------------------------------------------------------------------------------
// Draw 관련 메시지 정의
//------------------------------------------------------------------------------
pub mod draw {
    use super::*;

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct DrawPayload {
        pub player: String,
        pub cards: String,
    }

    impl MessagePayload for DrawPayload {}

    impl ValidationPayload for DrawPayload {
        fn validate(&self, context: &dyn Any) -> Option<()> {
            if let Some(player_cards) = context.downcast_ref::<Cards>() {
                // 카드 UUID 유효성 검사
                if player_cards.contains_uuid(Uuid::parse_str(&self.cards).ok()?) {
                    return None;
                }

                // 플레이어 ID 유효성 검사
                if !matches!(self.player.as_str(), "player1" | "player2") {
                    return None;
                }

                Some(())
            } else {
                None // 잘못된 컨텍스트 타입
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    struct ErrorPayload {
        pub message: String,
    }

    impl MessagePayload for ErrorPayload {}

    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ClientMessage {
        #[serde(rename = "draw-request")]
        DrawRequest(DrawPayload),
    }

    impl Message for ClientMessage {}

    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ServerMessage {
        #[serde(rename = "draw-answer")]
        DrawAnswer(DrawPayload),
    }

    impl Message for ServerMessage {}

    /// 클라이언트로 전송할 Draw 카드의 정보가 담긴 메세지를 직렬화합니다.
    pub fn serialize_draw_answer_message<T: Into<String>>(
        player: T,
        cards: Uuid,
    ) -> Result<String, GameError> {
        let message = ServerMessage::DrawAnswer(DrawPayload {
            player: player.into(),
            cards: cards.to_string(),
        });
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }

    /// 클라이언트로 전송할 Draw 카드의 정보가 담긴 메세지를 직렬화합니다.
    pub fn serialize_draw_request_message<T: Into<String>>(
        player: T,
        cards: Uuid,
    ) -> Result<String, GameError> {
        let message = ClientMessage::DrawRequest(DrawPayload {
            player: player.into(),
            cards: cards.to_string(),
        });
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

//------------------------------------------------------------------------------
// Main Phase1 관련 메시지 정의
//------------------------------------------------------------------------------
pub mod main_phase1 {
    use crate::StringUuidExt;

    use super::*;

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct MainPase1Payload {
        pub player: String,
        pub card: String,
    }

    impl MessagePayload for MainPase1Payload {}

    impl ValidationPayload for MainPase1Payload {
        fn validate(&self, context: &dyn Any) -> Option<()> {
            if let Some(player_cards) = context.downcast_ref::<Cards>() {
                // 카드 UUID 유효성 검사
                // TODO: Unwrap 대신 match를 사용하여 안전하게 처리할 수 있도록 수정
                if let Err(_) = self.card.to_uuid() {
                    return None;
                }

                // 플레이어 ID 유효성 검사
                if !matches!(self.player.as_str(), "player1" | "player2") {
                    return None;
                }

                Some(())
            } else {
                None // 잘못된 컨텍스트 타입
            }
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    struct ErrorPayload {
        pub message: String,
    }

    impl MessagePayload for ErrorPayload {}

    /// 클라이언트에서 서버로 전송되는 메인 페이즈1 메시지
    /// - 메인 페이즈1 에서는 아래와 같은 행동이 가능함.
    /// # Behavior
    /// * `PlayCard` - 카드를 선택하여 플레이함 ( 이때 카드의 효과가 발동 될 수 있음. )
    /// * `EndTurn` - 턴을 종료함.
    /// * `Surrender` - 게임을 포기함.
    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ClientMessage {
        #[serde(rename = "play-card")]
        PlayCard(MainPase1Payload),
    }

    impl Message for ClientMessage {}

    #[derive(Serialize, Deserialize, Debug)]
    #[serde(tag = "action", content = "payload")]
    pub enum ServerMessage {
        #[serde(rename = "draw-answer")]
        PlayCardAnswer(MainPase1Payload),
    }

    impl Message for ServerMessage {}

    /// 클라이언트로 전송할 Draw 카드의 정보가 담긴 메세지를 직렬화합니다.
    pub fn serialize_dig_message<T: Into<String>>(
        player: T,
        cards: Uuid,
    ) -> Result<String, GameError> {
        let message = ServerMessage::PlayCardAnswer(MainPase1Payload {
            player: todo!(),
            card: todo!(),
        });
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

//------------------------------------------------------------------------------
// 메시지 매크로 및 유틸리티 함수
//------------------------------------------------------------------------------

/// 에러 메시지 직렬화를 위한 매크로
#[macro_export]
macro_rules! serialize_error {
    ($error_msg:expr) => {{
        let message =
            $crate::server::jsons::ErrorMessage::Error($crate::server::jsons::ErrorPayload {
                message: $error_msg.to_string(),
            });
        serde_json::to_string(&message)
            .map_err(|_| $crate::exception::GameError::InternalServerError)
    }};
    ($module:ident, $error_msg:expr) => {{
        let message = $crate::server::jsons::$module::ServerMessage::Error {
            message: $error_msg.to_string(),
        };
        serde_json::to_string(&message)
            .map_err(|_| $crate::exception::GameError::InternalServerError)
    }};
}
</file>

<file path="simulator_core/src/unit/mod.rs">
pub mod player;
</file>

<file path="simulator_core/src/utils/json.rs">
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Item {
    pub id: String,
    pub dbfid: i32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Card {
    pub id: String,
    pub num: i32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Hero {
    pub name: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize, Serialize)]
pub struct Deck {
    pub Hero: Vec<Hero>,
    pub cards: Vec<Card>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Decks {
    pub decks: Vec<Deck>,
}

#[derive(Debug, Deserialize)]
pub struct Names {
    pub name1: String,
    pub name2: String,
}

#[derive(Debug, Deserialize)]
pub struct DeckCodes {
    pub code1: String,
    pub code2: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct GameConfigJson {
    pub DeckCodes: Vec<DeckCodes>,
    pub Attacker: i32,
    pub Names: Vec<Names>,
}

/*
    "id": "AT_010",
    "attack": 3,
    "health": 3,
    "cost": 5,
    "rarity": "RARE",
    "collectible": true,
    "name": "Ram Wrangler",
    "text": "<b>Battlecry:</b> If you have a Beast, summon a\nrandom Beast.",
    "type": "Agent"
*/
#[derive(Debug, Deserialize, Serialize, Clone, Eq, PartialEq, Hash)]
pub struct CardJson {
    pub id: Option<String>,
    pub dbfid: Option<i32>,
    pub cost: Option<i32>,
    pub name: Option<String>,
    pub text: Option<String>,
    pub attack: Option<i32>,
    pub health: Option<i32>,
    pub collectible: Option<bool>,
    pub r#type: Option<String>,
}

impl CardJson {
    pub fn new() -> CardJson {
        CardJson {
            id: None,
            dbfid: None,
            cost: None,
            name: None,
            text: None,
            attack: None,
            health: None,
            collectible: None,
            r#type: None,
        }
    }
}
</file>

<file path="simulator_core/src/zone/deck.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, insert::Insert, take::Take, Card},
    enums::DECK_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Deck {
    zone_cards: Cards,
    zone_size: usize,
}

impl Deck {
    pub fn new() -> Deck {
        Deck {
            zone_cards: Cards::new(),
            zone_size: DECK_ZONE_SIZE,
        }
    }

    /// 현재 Zone 에 카드를 추가 합니다.
    /// TODO: 무슨 방식으로(eg. 랜덤, 맨 위, 맨 아래) 넣을지 구현해야함.

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Deck {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        &mut self.zone_cards
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError> {
        for card in cards {
            insert.insert(self, card)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, mut take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        take_type.as_mut().take(self)
    }
}
</file>

<file path="simulator_core/src/zone/effect.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Effect {
    zone_cards: Cards,
    zone_size: usize,
}

impl Effect {
    pub fn new() -> Effect {
        Effect {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Effect {
    fn get_cards(&self) -> &Cards {
        todo!()
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/field.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Field {
    zone_cards: Cards,
    zone_size: usize,
}

impl Zone for Field {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}

impl Field {
    pub fn new() -> Field {
        Field {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }
}
</file>

<file path="simulator_core/src/zone/graveyard.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Graveyard {
    zone_cards: Cards,
    zone_size: usize,
}

impl Graveyard {
    pub fn new() -> Graveyard {
        Graveyard {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Graveyard {
    fn get_cards(&self) -> &Cards {
        todo!()
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/hand.rs">
use uuid::Uuid;

use crate::{
    card::{
        cards::{CardVecExt, Cards},
        insert::Insert,
        take::Take,
        Card,
    },
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Hand {
    zone_cards: Cards,
    zone_size: usize,
}

impl Hand {
    pub fn new() -> Hand {
        Hand {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, card: Card) -> Result<(), GameError> {
        self.zone_cards
            .remove_by_uuid(card.get_uuid())
            .map(|_| ())
            .ok_or(GameError::CardNotFound)
    }
}

impl Zone for Hand {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError> {
        for card in cards {
            insert.insert(self, card)?;
        }
        Ok(())
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/mod.rs">
pub mod deck;
pub mod effect;
pub mod field;
pub mod graveyard;
pub mod hand;
pub mod zone;
</file>

<file path="simulator_core/src/zone/zone.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, insert::Insert, take::Take, Card},
    exception::GameError,
};

pub trait Zone {
    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError>;

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError>;

    fn remove_card(&mut self, uuid: Uuid);

    fn get_cards(&self) -> &Cards;

    fn get_cards_mut(&mut self) -> &mut Cards;

    fn len(&self) -> usize;
}
</file>

<file path="simulator_core/tests/intergration_test.rs">
pub mod game_effect {
    #[test]
    fn test_proceed_card() {}
}
</file>

<file path="simulator_core/tests/test copy">
#[cfg(test)]
pub mod heartbeat {
    use std::time::Duration;

    use async_tungstenite::{
        tokio::connect_async,
        tungstenite::{self, http::Request, Message},
    };
    use card_game::{
        card::types::PlayerType,
        enums::CLIENT_TIMEOUT,
        game_old::phase::Phase,
        test::{spawn_server, WebSocketTest},
    };
    use futures::StreamExt;
    use serde::{Deserialize, Serialize};
    use tracing::info;
    use uuid::Uuid;

    #[actix_web::test]
    #[should_panic]
    async fn test_heartbeat_connection_timeout() {
        // 서버 인스턴스 생성
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/heartbeat", addr);
        let cookie = format!("user_id={}; game_step={}", player_type, "heartbeat");

        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::Heartbeat);
        }

        // WebSocket 연결 수립
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();
        info!("하트비트 WebSocket 연결 성공");

        // 연결 안정성 테스트 - 메시지 전송
        #[derive(Serialize)]
        struct TestMessage {
            #[serde(rename = "type")]
            msg_type: String,
            content: String,
        }

        let test_msg = TestMessage {
            msg_type: "test".to_string(),
            content: "heartbeat test".to_string(),
        };

        // 메시지 전송
        ws.send(Message::Text(serde_json::to_string(&test_msg).unwrap()))
            .await
            .unwrap();
        info!("테스트 메시지 전송 완료");

        // 충분한 시간 대기하여 서버가 연결을 유지하는지 확인
        tokio::time::sleep(Duration::from_secs(CLIENT_TIMEOUT + 1)).await;

        // 여전히 메시지를 보낼 수 있다면 연결이 유지되고 있는 것
        let keepalive_msg = TestMessage {
            msg_type: "keepalive".to_string(),
            content: "still connected".to_string(),
        };

        match ws
            .send(Message::Text(
                serde_json::to_string(&keepalive_msg).unwrap(),
            ))
            .await
        {
            Ok(_) => info!("연결이 유지되고 있음 확인"),
            Err(e) => panic!("연결이 끊김: {:?}", e),
        }

        // 정상 종료
        ws.send(Message::Close(None)).await.unwrap();
    }

    #[actix_web::test]
    async fn test_heartbeat_connection() {
        // 서버 인스턴스 생성
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/heartbeat", addr);
        let cookie = format!("user_id={}; game_step={}", player_type, "heartbeat");

        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::Heartbeat);
        }

        // WebSocket 연결 수립
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();
        info!("하트비트 WebSocket 연결 성공");

        // 연결 안정성 테스트 - 메시지 전송
        #[derive(Serialize)]
        struct TestMessage {
            #[serde(rename = "type")]
            msg_type: String,
            content: String,
        }

        let test_msg = TestMessage {
            msg_type: "test".to_string(),
            content: "heartbeat test".to_string(),
        };

        // 메시지 전송
        ws.send(Message::Text(serde_json::to_string(&test_msg).unwrap()))
            .await
            .unwrap();
        info!("테스트 메시지 전송 완료");

        // 충분한 시간 대기하여 서버가 연결을 유지하는지 확인
        tokio::time::sleep(Duration::from_secs(CLIENT_TIMEOUT + 1)).await;

        // 여전히 메시지를 보낼 수 있다면 연결이 유지되고 있는 것
        let keepalive_msg = TestMessage {
            msg_type: "keepalive".to_string(),
            content: "still connected".to_string(),
        };

        info!("연결 유지 확인을 위한 keepalive 메시지 전송 시도");

        // keepalive 메시지는 전송이 되는데, CloseMsg Send 는 또 실패함.
        // 로그 순서상 keepalive 메시지도 전송이 실패되어야 하는 것 같은데
        // match 분기문으로 더 상세한 로그 찍어야할 듯

        let result = ws
            .send(Message::Text(
                serde_json::to_string(&keepalive_msg).unwrap(),
            ))
            .await;

        match result {
            Ok(_) => match ws.send(Message::Close(None)).await {
                Ok(_) => info!("연결이 유지되고 있음 확인"),
                Err(_) => info!("연결이 끊김 확인"),
            },
            Err(e) => {
                match ws.send(Message::Close(None)).await {
                    Ok(_) => info!("연결이 유지되고 있음 확인"),
                    Err(_) => info!("연결이 끊김 확인"),
                }
                info!("예상 못 한 분기점: {}", e);
            }
        }
    }

    #[actix_web::test]
    async fn test_heartbeat_session_management() {
        // 서버 인스턴스 생성
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();

        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::Heartbeat);
        }

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/heartbeat", addr);
        let cookie = format!("user_id={}; game_step={}", player_type, "heartbeat");

        // 첫 번째 세션 생성
        let mut ws1 = WebSocketTest::connect(url.clone(), cookie.clone())
            .await
            .unwrap();
        info!("첫 번째 WebSocket 연결 생성");

        // 세션 ID 확인을 위한 초기 메시지 수신
        #[derive(Deserialize)]
        struct ConnectionMessage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            msg_type: String,
            #[allow(dead_code)]
            player: String,
            session_id: String,
        }

        let session_id = ws1
            .expect_message(|msg: ConnectionMessage| msg.session_id)
            .await
            .parse::<Uuid>()
            .unwrap();
        info!("첫 번째 세션 ID: {}", session_id);

        // 첫 번째 세션이 활성화되었는지 확인
        assert!(
            state
                .session_manager
                .is_valid_session(PlayerType::Player1, session_id, Phase::Heartbeat)
                .await
        );

        // 첫 번째 세션 종료
        ws1.send(Message::Close(None)).await.unwrap();

        // 세션이 종료되었는지 확인하기 위한 충분한 시간 대기
        tokio::time::sleep(Duration::from_millis(500)).await;

        // 첫 번째 세션이 종료되었는지 확인
        assert!(
            !state
                .session_manager
                .is_valid_session(PlayerType::Player1, session_id, Phase::Heartbeat)
                .await
        );

        // 두 번째 세션 생성이 가능한지 확인
        let mut ws2 = WebSocketTest::connect(url, cookie).await.unwrap();
        info!("두 번째 WebSocket 연결 생성");

        let new_session_id = ws2
            .expect_message(|msg: ConnectionMessage| msg.session_id)
            .await;
        info!("두 번째 세션 ID: {}", new_session_id);

        // 새 세션 ID가 다른지 확인
        assert_ne!(session_id.to_string(), new_session_id);

        // 두 번째 세션이 활성화되었는지 확인
        assert!(
            state
                .session_manager
                .is_valid_session(
                    PlayerType::Player1,
                    new_session_id.parse::<Uuid>().unwrap(),
                    Phase::Heartbeat
                )
                .await
        );
    }

    #[actix_web::test]
    async fn test_heartbeat_ping_pong() {
        // 서버 인스턴스 생성
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();

        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::Heartbeat);
        }

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/heartbeat", addr);
        let cookie = format!("user_id={}; game_step={}", player_type, "heartbeat");

        // 커스텀 WebSocket 클라이언트 생성
        let request = Request::builder()
            .uri(&url)
            .header("Cookie", cookie)
            .header("Host", url.split('/').nth(2).unwrap_or("localhost"))
            .header("Sec-WebSocket-Key", "dGhlIHNhbXBsZSBub25jZQ==")
            .header("Upgrade", "websocket")
            .header("Connection", "Upgrade")
            .header("Sec-WebSocket-Version", "13")
            .body(())
            .unwrap();

        let (mut stream, response) = connect_async(request).await.unwrap();
        assert_eq!(
            response.status(),
            tungstenite::http::StatusCode::SWITCHING_PROTOCOLS
        );
        info!("타임아웃 테스트용 WebSocket 연결 성공");

        // ping 메시지 수신 응답
        match stream.next().await {
            Some(Ok(Message::Ping(_))) => {
                info!("Ping 메시지 수신됨");
                // Pong으로 응답
                info!("Pong 메시지 전송 시도");
                stream
                    .send(Message::Pong(Vec::new()))
                    .await
                    .expect("Failed to send pong message");
            }
            Some(Ok(msg)) => info!("Ping 아닌 다른 메시지 수신됨: {:?}", msg),
            Some(Err(e)) => panic!("메시지 수신 오류: {:?}", e),
            None => panic!("Ping 메시지 대기 중 타임아웃"),
        }

        match stream.next().await {
            Some(Ok(Message::Ping(_))) => info!("Ping 메시지 수신됨"),
            Some(Ok(_)) => {
                panic!("Ping 아닌 다른 메시지 수신됨");
            }
            Some(Err(e)) => info!("연결 오류 발생: {:?}", e),
            None => panic!("서버가 연결을 종료함"),
        }
    }
}

#[cfg(test)]
pub mod draw {
    use std::{collections::HashSet, net::SocketAddr};

    use card_game::{
        card::{cards::CardVecExt, types::PlayerType},
        enums::HAND_ZONE_SIZE,
        exception::*,
        game_old::phase::Phase,
        server::jsons::draw,
        test::{spawn_server, RequestTest},
        zone::zone::Zone,
    };
    use uuid::Uuid;

    #[actix_web::test]
    async fn test_draw_concurrency() {
        // 서버 설정
        let (addr, state, _) = spawn_server().await;

        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::DrawPhase);
        }

        // 플레이어별 쿠키 설정
        let player1_cookie = format!(
            "user_id={}; game_step=drawphase",
            PlayerType::Player1.as_str()
        );
        let player2_cookie = format!(
            "user_id={}; game_step=drawphase",
            PlayerType::Player2.as_str()
        );

        // 두 플레이어가 동시에 드로우하는 테스트 함수
        async fn draw_card(addr: SocketAddr, cookie: String) -> (PlayerType, Uuid) {
            let mut response = RequestTest::connect("draw_phase", addr, cookie.clone())
                .await
                .expect("Failed to connect");

            // 플레이어 타입 확인
            let player_type = if cookie.contains("player1") {
                PlayerType::Player1
            } else {
                PlayerType::Player2
            };

            // 드로우된 카드 UUID 반환
            (player_type, response.expect_draw_card())
        }

        // 두 요청을 동시에 실행
        let mut tasks = Vec::new();

        // 각 플레이어가 5번씩 요청을 보냄
        let addr_clone = addr.clone();
        let p1_cookie = player1_cookie.clone();
        let p2_cookie = player2_cookie.clone();

        // Player1 태스크
        let task1 = tokio::spawn(async move { draw_card(addr_clone.clone(), p1_cookie).await });
        tasks.push(task1);

        // Player2 태스크
        let task2 = tokio::spawn(async move { draw_card(addr_clone, p2_cookie).await });
        tasks.push(task2);

        // 모든 태스크가 완료될 때까지 기다림
        let results = futures::future::join_all(tasks).await;

        // 결과 검증
        let mut player1_cards = Vec::new();
        let mut player2_cards = Vec::new();

        for result in results {
            // 각 태스크의 결과 확인
            match result {
                Ok((player_type, card_uuid)) => {
                    if player_type == PlayerType::Player1 {
                        player1_cards.push(card_uuid);
                    } else {
                        player2_cards.push(card_uuid);
                    }
                }
                Err(e) => panic!("Task failed: {:?}", e),
            }
        }

        // 두 플레이어가 모두 카드를 받았는지 확인
        assert_eq!(player1_cards.len(), 1);
        assert_eq!(player2_cards.len(), 1);

        // 각 플레이어가 받은 카드가 중복되지 않는지 확인
        let all_cards: HashSet<_> = player1_cards.iter().chain(player2_cards.iter()).collect();
        assert_eq!(all_cards.len(), player1_cards.len() + player2_cards.len());

        // 게임 상태 검증
        {
            let game = state.game.lock().await;

            // Player1의 모든 카드가 핸드에 있는지 확인
            let player1 = game.get_player_by_type(PlayerType::Player1).get();
            for &uuid in &player1_cards {
                assert!(player1.get_hand().get_cards().contains_uuid(uuid));
                assert!(!player1.get_deck().get_cards().contains_uuid(uuid));
            }

            // Player2의 모든 카드가 핸드에 있는지 확인
            let player2 = game.get_player_by_type(PlayerType::Player2).get();
            for &uuid in &player2_cards {
                assert!(player2.get_hand().get_cards().contains_uuid(uuid));
                assert!(!player2.get_deck().get_cards().contains_uuid(uuid));
            }
        }

        println!("플레이어1 드로우 카드: {:?}", player1_cards);
        println!("플레이어2 드로우 카드: {:?}", player2_cards);
    }
    #[actix_web::test]
    async fn test_draw_hand_is_full() {
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();
        let cookie = format!("user_id={}; game_step=drawphase", player_type);
        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::DrawPhase);
        }

        // HAND_ZONE_SIZE + 1 회 반복하여 카드를 뽑는다.
        for _ in 0..HAND_ZONE_SIZE + 1 {
            let response = RequestTest::connect("draw_phase", addr, cookie.clone())
                .await
                .expect("Failed to connect");

            // 카드를 예상하되, 만약 parse error 발생 시, body.contains 을 통해 No Card Left ( 혹은 다른 오류 ) 오류 인지 확인함.
            let result = serde_json::from_str::<draw::ServerMessage>(&response.response.as_str());

            // Draw 메시지가 아닌 경우.
            // EXCEEDED_CARD_LIMIT 메시지가 포함되어 있는지 확인한다.
            if result.is_err() {
                assert!(response.response.contains(EXCEEDED_CARD_LIMIT));
            } else {
                let draw::ServerMessage::DrawAnswer(payload) = result.unwrap();
                let card_uuid = payload.cards.parse::<Uuid>().unwrap();
                // 검증 단계
                {
                    let game = state.game.lock().await;
                    let player = game.get_player_by_type(player_type).get();
                    let deck = player.get_deck();
                    if deck.get_cards().contains_uuid(card_uuid) {
                        panic!("Card is not removed from deck");
                    }

                    let hand = player.get_hand();
                    if !hand.get_cards().contains_uuid(card_uuid) {
                        panic!("Card is not added to hand");
                    }
                }

                // draw 상태 초기화
                {
                    let mut game = state.game.lock().await;

                    game.get_phase_state_mut()
                        .reset_player_completed(player_type.into());
                }
            }
        }
    }

    #[actix_web::test]
    async fn test_draw_re_entry() {
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();
        let cookie = format!("user_id={}; game_step=drawphase", player_type);
        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::DrawPhase);
        }

        let _ = RequestTest::connect("draw_phase", addr, cookie.clone())
            .await
            .expect("Failed to connect");

        let rt = RequestTest::connect("draw_phase", addr, cookie.clone())
            .await
            .expect("Failed to connect");

        assert!(rt.response.contains(NOT_ALLOWED_RE_ENTRY));
    }

    #[actix_web::test]
    async fn test_draw_no_card_left() {
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();
        let cookie = format!("user_id={}; game_step=drawphase", player_type);
        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::DrawPhase);
        }

        // 31회 반복하여 카드를 뽑는다.
        for _ in 0..31 {
            let response = RequestTest::connect("draw_phase", addr, cookie.clone())
                .await
                .expect("Failed to connect");

            // 카드를 예상하되, 만약 parse error 발생 시, body.contains 을 통해 No Card Left ( 혹은 다른 오류 ) 오류 인지 확인함.
            let result = serde_json::from_str::<draw::ServerMessage>(&response.response.as_str());

            // Draw 메시지가 아닌 경우.
            // No Card Left 메시지가 포함되어 있는지 확인한다.
            if result.is_err() {
                assert!(response.response.contains(NO_CARDS_LEFT));
            } else {
                let draw::ServerMessage::DrawAnswer(payload) = result.unwrap();
                let card_uuid = payload.cards.parse::<Uuid>().unwrap();
                // 검증 단계
                {
                    let game = state.game.lock().await;
                    let player = game.get_player_by_type(player_type).get();
                    let deck = player.get_deck();
                    if deck.get_cards().contains_uuid(card_uuid) {
                        panic!("Card is not removed from deck");
                    }

                    let hand = player.get_hand();
                    if !hand.get_cards().contains_uuid(card_uuid) {
                        panic!("Card is not added to hand");
                    }
                }

                // draw 상태 초기화 및 Hand 카드 삭제
                {
                    let mut game = state.game.lock().await;

                    game.get_phase_state_mut()
                        .reset_player_completed(player_type.into());

                    // HAND_ZONE_SIZE 를 임의로 수정할 수 없으므로
                    // Hand 카드를 삭제하는 방법으로
                    let card = game
                        .get_cards_by_uuid(card_uuid)
                        .clone()
                        .expect("Card not found");

                    game.get_player_by_type(player_type)
                        .get()
                        .get_hand_mut()
                        .remove_card(card)
                        .expect("Failed to remove card");
                }
            }
        }
    }

    #[actix_web::test]
    async fn test_draw_card() {
        let (addr, state, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();
        let cookie = format!("user_id={}; game_step=drawphase", player_type);
        {
            state
                .game
                .lock()
                .await
                .get_phase_state_mut()
                .set_phase(Phase::DrawPhase);
        }

        let mut response = RequestTest::connect("draw_phase", addr, cookie)
            .await
            .expect("Failed to connect");

        let card_uuid = response.expect_draw_card();

        // 검증 단계
        {
            let game = state.game.lock().await;
            let player = game.get_player_by_type(player_type).get();
            let deck = player.get_deck();
            if deck.get_cards().contains_uuid(card_uuid) {
                panic!("Card is not removed from deck");
            }

            let hand = player.get_hand();
            if !hand.get_cards().contains_uuid(card_uuid) {
                panic!("Card is not added to hand");
            }
        }
    }

    #[actix_web::test]
    async fn test_draw_wrong_phase() {
        let (addr, _, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();
        let cookie = format!("user_id={}; game_step=drawphase", player_type);

        let response = RequestTest::connect("draw_phase", addr, cookie)
            .await
            .expect("Failed to connect");

        assert!(response.response.contains(WRONG_PHASE));
    }
}

#[cfg(test)]
pub mod mulligan {
    use actix_web::{dev::ServerHandle, web::Data};
    use async_tungstenite::tungstenite::Message;
    use card_game::{
        card::types::PlayerType,
        enums::COUNT_OF_MULLIGAN_CARDS,
        exception::*,
        server::types::ServerState,
        test::{spawn_server, verify_mulligan_cards, WebSocketTest},
        zone::zone::Zone,
        VecUuidExt,
    };
    use core::panic;
    use once_cell::sync::Lazy;
    use rand::Rng;
    use serde_json::json;
    use std::{net::SocketAddr, time::Duration};
    use tokio::{sync::Mutex, time::sleep};

    static GLOBAL_SERVER: Lazy<Mutex<Option<(SocketAddr, Data<ServerState>, ServerHandle)>>> =
        Lazy::new(|| Mutex::new(None));

    async fn setup_shared_server() -> (SocketAddr, Data<ServerState>, ServerHandle) {
        let mut global = GLOBAL_SERVER.lock().await;
        if let Some((addr, ref mut server_state, ref handle)) = *global {
            server_state.reset().await;
            (addr, server_state.clone(), handle.clone())
        } else {
            let server = spawn_server().await;
            *global = Some(server.clone());
            server
        }
    }

    /// 잘못된 mulligan 시나리오에 대해 서버가 반환한 에러 메시지를 리턴합니다.
    async fn test_mulligan_invalid_scenario(json_payload: serde_json::Value) -> String {
        let (addr, _, _) = spawn_server().await;

        // WebSocketTest 객체를 사용하여 훨씬 더 간결한 코드 작성
        let url = format!("ws://{}/mulligan_phase", addr);
        let cookie = format!(
            "user_id={}; game_step={}",
            PlayerType::Player1.as_str(),
            "mulligan"
        );

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 초기 카드 받기
        let _ = ws.expect_mulligan_deal().await;

        // 에러 발생시키는 메시지 전송
        ws.send(Message::Text(json_payload.to_string()))
            .await
            .expect("Failed to send message");

        // 에러 응답 기다리기
        ws.expect_error().await
    }

    #[actix_web::test]
    async fn test_mulligan_invalid_player() {
        let json = json!({
            "action": "reroll-request",
            "payload": {
                "player": "wrong-player",
                "cards": []
            }
        });
        let error = test_mulligan_invalid_scenario(json).await;
        assert_eq!(error, INVALID_PLAYER);
    }

    #[actix_web::test]
    async fn test_mulligan_invalid_approach() {
        let json = json!({
            "action": "reroll-wrong",
            "payload": {
                "player": "player1",
                "cards": []
            }
        });
        let error = test_mulligan_invalid_scenario(json).await;
        assert_eq!(error, INVALID_APPROACH);
    }

    #[actix_web::test]
    async fn test_mulligan_invalid_cards() {
        let json = json!({
            "action": "reroll-request",
            "payload": {
                "player": "player1",
                "cards": ["wrong", "cards"]
            }
        });
        let error = test_mulligan_invalid_scenario(json).await;
        assert_eq!(error, INVALID_CARDS);
    }

    #[actix_web::test]
    async fn test_mulligan_wrong_phase() {
        // HTTP 기반 잘못된 접근은 WebSocket 테스트가 아니므로 따로 검증합니다.
        let (addr, _, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();

        let client = reqwest::Client::new();
        let response = client
            .get(format!("http://{}/mulligan_phase", addr))
            .header("Cookie", format!("user_id={}; game_step=draw", player_type))
            .send()
            .await
            .expect("request failed");

        let status = response.status();
        let body = response.text().await.expect("Failed to read response body");

        assert_eq!(status.as_u16(), 500);

        assert!(body.contains(WRONG_PHASE));
    }

    #[actix_web::test]
    async fn test_mulligan_is_session_close() {
        panic!("Not implemented yet");
    }

    // 이 테스트 뭔가 문제가 많음
    // TODO: 테스트 마저 작성해야함.
    #[actix_web::test]
    async fn test_mulligan_already_ready() {
        // HTTP 기반 잘못된 접근은 WebSocket 테스트가 아니므로 따로 검증합니다.
        let (addr, _, _) = spawn_server().await;
        let player_type = PlayerType::Player1.as_str();

        let client = reqwest::Client::new();
        let response = client
            .get(format!("http://{}/mulligan_phase", addr))
            .header("Cookie", format!("user_id={}; game_step=draw", player_type))
            .send()
            .await
            .expect("request failed");

        let status = response.status();
        let body = response.text().await.expect("Failed to read response body");

        assert_eq!(status.as_u16(), 500);

        assert!(body.contains(ALREADY_READY));
    }

    #[actix_web::test]
    #[should_panic]
    async fn test_mulligan_re_entry() {
        let (addr, _, _) = spawn_server().await;

        let url = format!("ws://{}/mulligan_phase", addr);
        let cookie = format!(
            "user_id={}; game_step={}",
            PlayerType::Player1.as_str(),
            "mulligan"
        );

        let mut ws = WebSocketTest::connect(url.clone(), cookie.clone())
            .await
            .unwrap();

        // 초기 카드 받기
        let _ = ws.expect_mulligan_deal().await;

        // 엔드포인트 재진입
        let _ = WebSocketTest::connect(url, cookie)
            .await
            .expect("Re-entry is not allowed");
    }

    #[actix_web::test]
    async fn test_mulligan_reroll_restore_variants() -> std::io::Result<()> {
        enum MulliganAction {
            RerollRequest,
            Complete,
        }

        impl MulliganAction {
            pub fn as_str(&self) -> &str {
                match self {
                    MulliganAction::RerollRequest => "reroll-request",
                    MulliganAction::Complete => "complete",
                }
            }
        }

        async fn run_mulligan_case(reroll_count: usize) -> std::io::Result<()> {
            async fn run_mulligan_case_each_player(
                reroll_count: usize,
                player_type: &str,
                addr: SocketAddr,
                server_state: Data<ServerState>,
            ) -> std::io::Result<()> {
                let url = format!("ws://{}/mulligan_phase", addr);
                let cookie = format!("user_id={}; game_step={}", player_type, "mulligan");
                let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

                let mut deal_cards = ws.expect_mulligan_deal().await;

                // 나머지 테스트 로직...
                deal_cards.truncate(reroll_count);

                // TODO: 모든 가능한 수에 대해서 static 하게 테스트 하는게 맞는데
                // 일단 킵
                let action = if rand::thread_rng().gen_bool(0.5) {
                    MulliganAction::RerollRequest
                } else {
                    MulliganAction::Complete
                };

                println!("Player: {}, Action: {}", player_type, action.as_str());

                let json = json!({
                    "action": action.as_str(),
                    "payload": {
                        "player": player_type,
                        "cards": deal_cards.to_vec_string()
                    }
                });

                ws.send(Message::Text(json.to_string()))
                    .await
                    .expect("Failed to send message");

                if let MulliganAction::RerollRequest = action {
                    let cards = ws.expect_mulligan_answer().await;
                    // RerollRequest일 때는 이전 카드들이 덱에 복원되었는지 검증
                    verify_mulligan_cards(
                        &server_state,
                        player_type.into(),
                        &cards,
                        Some(&deal_cards),
                        reroll_count,
                    );
                } else {
                    let cards = ws.expect_mulligan_complete().await;
                    // Complete일 때는 복원 검증 없이 뽑은 카드만 검증
                    verify_mulligan_cards(
                        &server_state,
                        player_type.into(),
                        &cards,
                        None,
                        reroll_count,
                    );
                };
                Ok(())
            }

            let (addr, server_state, _handle) = setup_shared_server().await;
            sleep(Duration::from_millis(100)).await;

            for player_type_str in [PlayerType::Player1, PlayerType::Player2] {
                run_mulligan_case_each_player(
                    reroll_count,
                    player_type_str.as_str(),
                    addr,
                    server_state.clone(),
                )
                .await?;
            }

            // 각 플레이어의 손패 갯수를 검증합니다.
            // 각 플레이어의 손패 갯수는 5개씩이어야 합니다.
            {
                let game = server_state.game.lock().await;
                let player = game.get_player().get();
                let opponent = game.get_opponent().get();
                let p_cards = player.get_hand().get_cards();
                let o_cards = opponent.get_hand().get_cards();
                if p_cards.len() + o_cards.len() != COUNT_OF_MULLIGAN_CARDS * 2 {
                    panic!("There are not enough mulligan cards")
                }
            }

            // 각 플레이어가 준비 상태인지 검증합니다.
            // 각 플레이어가 준비 상태가 되었다면 테스트를 통과합니다.
            {
                let game = server_state.game.lock().await;
                let mut player = game.get_player().get();
                let mut opponent = game.get_opponent().get();
                if !player.get_mulligan_state_mut().is_ready()
                    && !opponent.get_mulligan_state_mut().is_ready()
                {
                    panic!("Each players are not ready - FAILED");
                } else {
                    println!("Testing mulligan with each players. - PASSED",);
                }
            }

            Ok(())
        }

        for reroll_count in (1..=5).rev() {
            run_mulligan_case(reroll_count).await?;
        }
        Ok(())
    }
}
</file>

<file path="simulator_core/tests/test copy heart">
// tests/heartbeat_actor_direct_test.rs (또는 기존 test.rs 내 모듈)

#[cfg(test)]
mod heartbeat_actor_direct_tests {
    use actix::{Actor, Addr};
    use actix_web::{
        dev::ServerHandle, web, App, Error as ActixError, HttpRequest, HttpResponse, HttpServer,
    };
    use async_tungstenite::{
        tokio::{connect_async, TokioAdapter},
        tungstenite::{self, http::Request as WsRequest, protocol::Message},
    };
    use card_game::{
        card::types::PlayerType,
        enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
        game::phase::Phase,
        server::{session::PlayerSessionManager, ws_actor::heartbeat::HeartbeatActor},
    };

    use futures_util::StreamExt;
    use serde::Deserialize;
    use std::{
        net::{SocketAddr, TcpListener},
        time::Duration,
    };
    use tokio::time::sleep;
    use tracing::{error, info, warn};
    use uuid::Uuid;

    #[derive(Clone)]
    struct MinimalTestState {
        session_manager: PlayerSessionManager,
    }

    // --- 테스트용 핸들러 ---
    // 이 핸들러는 인증/페이즈 검사 없이 직접 액터를 시작합니다.
    async fn test_heartbeat_handler(
        state: web::Data<MinimalTestState>, // 수정된 상태 사용
        req: HttpRequest,
        payload: web::Payload,
    ) -> Result<HttpResponse, ActixError> {
        // 표준 Actix 에러 반환
        // 테스트 편의상 PlayerType과 SessionId를 핸들러 내에서 결정
        let player_type = PlayerType::Player1; // 예시: 고정 값 사용
        let session_id = Uuid::new_v4(); // 매번 새로운 ID 생성
        let session_manager = state.session_manager.clone();

        info!(
            "[Test Handler] Handling request. Assigned player {:?} with session_id {}",
            player_type, session_id
        );

        // WebSocket 업그레이드 시도
        match actix_ws::handle(&req, payload) {
            Ok((response, session, _stream)) => {
                info!("[Test Handler] WebSocket upgrade successful. Starting actor...");

                // 세션 관리자에 세션 등록 (액터 시작 *전* 에 등록)
                // register_session이 생성된/업데이트된 세션 ID를 반환한다고 가정
                let registered_session_id = session_manager
                    .register_session(player_type, Phase::Heartbeat) // 액터는 Heartbeat 로직을 따름
                    .await
                    .unwrap();

                // 핸들러에서 생성한 ID와 관리자에 등록된 ID가 일치하는지 확인 (선택적)
                if registered_session_id != session_id {
                    warn!(
                        "[Test Handler] Generated session ID {} differs from registered ID {}",
                        session_id, registered_session_id
                    );
                    // 테스트 시나리오에 따라 여기서 에러 처리 또는 ID 통일 필요
                }

                // HeartbeatActor 생성 및 시작
                let actor = HeartbeatActor::new(
                    player_type,
                    session_id, // 핸들러에서 생성한 ID 사용
                    session_manager,
                    session, // 업그레이드된 세션 전달
                );
                let _actor_addr: Addr<HeartbeatActor> = actor.start(); // 액터 시작

                info!(
                    "[Test Handler] HeartbeatActor started for player {:?} (session_id: {})",
                    player_type, session_id
                );

                // 성공적인 업그레이드 응답 반환
                Ok(response)
            }
            Err(e) => {
                error!("[Test Handler] WebSocket handling failed: {:?}", e);
                // ProtocolError를 ActixError로 변환 (간단한 예시)
                Ok(HttpResponse::InternalServerError()
                    .body(format!("WebSocket upgrade failed: {}", e)))
            }
        }
    }

    // 테스트 서버 설정 함수 (테스트 핸들러 사용)
    async fn setup_heartbeat_test_server() -> (SocketAddr, web::Data<MinimalTestState>, ServerHandle)
    {
        let listener = TcpListener::bind("127.0.0.1:0").expect("Failed to bind random port");
        let addr = listener.local_addr().unwrap();
        info!("Test server listening on {}", addr);

        let state = web::Data::new(MinimalTestState {
            session_manager: PlayerSessionManager::new(),
        });
        let state_clone = state.clone();

        let server = HttpServer::new(move || {
            App::new()
                .app_data(state_clone.clone())
                // 테스트 핸들러를 특정 경로에 등록
                .route("/test_heartbeat", web::get().to(test_heartbeat_handler))
        })
        .listen(listener)
        .expect("Failed to start test server")
        .run();

        let handle = server.handle();
        tokio::spawn(server);

        (addr, state, handle)
    }

    // WebSocket 연결 함수 (raw client, 쿠키 제거)
    async fn connect_raw_ws(
        url: &str, // URL은 이제 "ws://..." 형태여야 함
    ) -> Result<
        (
            async_tungstenite::WebSocketStream<TokioAdapter<tokio::net::TcpStream>>,
            tungstenite::http::Response<Option<Vec<u8>>>,
        ),
        tungstenite::Error,
    > {
        let host = url
            .strip_prefix("ws://")
            .unwrap_or(url) // "ws://" 제거
            .split('/') // 경로 제거 (호스트 부분만)
            .next()
            .unwrap_or("localhost");

        let request = WsRequest::builder()
            .uri(url) // 전체 URL 사용
            .header("Host", host)
            // .header("Cookie", cookie) // 쿠키 제거
            .header("Upgrade", "websocket")
            .header("Connection", "Upgrade")
            .header(
                "Sec-WebSocket-Key",
                tungstenite::handshake::client::generate_key(),
            )
            .header("Sec-WebSocket-Version", "13")
            .body(())?;

        connect_async(request).await
    }

    // 초기 연결 메시지 파싱용 구조체 (동일)
    #[derive(Deserialize, Debug)]
    struct HeartbeatConnectedMessage {
        #[serde(rename = "type")]
        msg_type: String,
        player: String,
        session_id: String,
    }

    // --- 테스트 케이스들 (쿠키 제거 및 URL 수정) ---

    #[actix_web::test]
    async fn test_heartbeat_actor_connect_and_initial_message() {
        let (addr, state, _handle) = setup_heartbeat_test_server().await;
        let player_type = PlayerType::Player1; // 테스트 핸들러가 Player1으로 고정

        let url = format!("ws://{}/test_heartbeat", addr); // 수정된 경로 및 스킴

        info!("Attempting raw WebSocket connection to {}", url);
        let (mut ws_stream, response) = connect_raw_ws(&url) // 쿠키 전달 제거
            .await
            .expect("Raw WebSocket connection failed");
        info!(
            "Raw WebSocket connection successful, response status: {}",
            response.status()
        );

        assert_eq!(
            response.status(),
            tungstenite::http::StatusCode::SWITCHING_PROTOCOLS
        );

        info!("Waiting for initial message from HeartbeatActor...");
        // 초기 메시지 검증 (이전과 유사, PlayerType 확인)
        let initial_msg = ws_stream
            .next()
            .await
            .expect("Stream ended before initial message")
            .expect("Stream error receiving initial message");

        let received_session_id = match initial_msg {
            Message::Text(text) => {
                info!("Received initial text message: {}", text);
                let parsed: HeartbeatConnectedMessage =
                    serde_json::from_str(&text).expect("Failed to parse initial message JSON");
                assert_eq!(parsed.msg_type, "heartbeat_connected");
                assert_eq!(parsed.player, player_type.to_string()); // Player1 검증

                parsed
                    .session_id
                    .parse::<Uuid>()
                    .expect("Invalid session UUID")
            }
            _ => panic!("Expected initial Text message, got {:?}", initial_msg),
        };
        info!("Parsed session ID: {}", received_session_id);

        // 세션 관리자에서 세션 확인
        assert!(
            state
                .session_manager
                .is_valid_session(player_type, received_session_id, Phase::Heartbeat)
                .await,
            "Session not found or invalid in session manager"
        );
        info!("Session verified in manager");

        // 클라이언트 측에서 연결 종료
        info!("Sending Close frame");
        ws_stream
            .close(None)
            .await
            .expect("Failed to send close frame");

        // 액터가 종료되고 세션이 정리될 시간 주기
        sleep(Duration::from_millis(300)).await; // 시간 약간 늘림

        // 세션 정리 확인
        assert!(
            !state
                .session_manager
                .is_valid_session(player_type, received_session_id, Phase::Heartbeat)
                .await,
            "Session was not cleaned up in session manager"
        );
        info!("Session cleanup verified");
    }

    #[actix_web::test]
    async fn test_heartbeat_actor_ping_pong_keepalive() {
        let (addr, _state, _handle) = setup_heartbeat_test_server().await;
        let url = format!("ws://{}/test_heartbeat", addr);

        let (mut ws_stream, _) = connect_raw_ws(&url) // 쿠키 제거
            .await
            .expect("Raw WebSocket connection failed");
        info!("Connected. Consuming initial message.");

        // 초기 메시지 소비
        let _ = ws_stream.next().await.unwrap().unwrap();

        let wait_duration = Duration::from_secs(HEARTBEAT_INTERVAL + 1);
        let test_duration = Duration::from_secs(CLIENT_TIMEOUT - HEARTBEAT_INTERVAL);

        info!("Waiting for {:?}, responding to pings...", test_duration);
        let start_time = std::time::Instant::now();
        let mut pings_received = 0; // 핑 수신 횟수 카운트

        while start_time.elapsed() < test_duration {
            match tokio::time::timeout(wait_duration, ws_stream.next()).await {
                Ok(Some(Ok(Message::Ping(ping_data)))) => {
                    info!("Received Ping #{}, sending Pong.", pings_received + 1);
                    pings_received += 1;
                    ws_stream
                        .send(Message::Pong(ping_data))
                        .await
                        .expect("Failed to send Pong");
                }
                Ok(Some(Ok(Message::Text(t)))) => {
                    error!("Received unexpected Text message during keepalive: {}", t);
                }
                Ok(Some(Ok(msg))) => {
                    info!("Received other message type during keepalive: {:?}", msg);
                    break;
                }
                Ok(Some(Err(e))) => {
                    error!("WebSocket error during keepalive wait: {:?}", e);
                    break;
                }
                Ok(None) => {
                    error!("WebSocket stream ended unexpectedly during keepalive wait.");
                    break;
                }
                Err(_) => {
                    info!("No message received in interval, continuing wait.");
                }
            }
            sleep(Duration::from_millis(100)).await;
            if start_time.elapsed() >= test_duration {
                break;
            }
        }

        assert!(
            pings_received > 0,
            "Did not receive any Ping messages during the keepalive test"
        );
        info!("Received {} Ping messages.", pings_received);

        info!("Keepalive wait finished. Sending test message.");
        let test_msg = "Keepalive test";
        match ws_stream.send(Message::Text(test_msg.to_string())).await {
            Ok(_) => info!("Successfully sent message after keepalive duration."),
            Err(e) => panic!("Failed to send message, connection likely closed: {:?}", e),
        }

        ws_stream.close(None).await.ok();
    }

    #[actix_web::test]
    #[should_panic(expected = "Connection should be closed by server after timeout")] // 패닉 메시지 수정
    async fn test_heartbeat_actor_timeout_without_pong() {
        let (addr, _state, _handle) = setup_heartbeat_test_server().await;
        let url = format!("ws://{}/test_heartbeat", addr);

        let (mut ws_stream, _) = connect_raw_ws(&url) // 쿠키 제거
            .await
            .expect("Raw WebSocket connection failed");
        info!("Connected. Consuming initial message.");

        // 초기 메시지 소비
        let _ = ws_stream.next().await.unwrap().unwrap();

        let timeout_duration = Duration::from_secs(CLIENT_TIMEOUT + 3); // 버퍼 늘림
        info!(
            "Waiting for {:?} without sending Pongs...",
            timeout_duration
        );

        let start_time = std::time::Instant::now();
        let mut server_closed = false; // 서버가 연결을 닫았는지 추적

        while start_time.elapsed() < timeout_duration {
            match tokio::time::timeout(Duration::from_millis(500), ws_stream.next()).await {
                Ok(Some(Ok(Message::Ping(_)))) => {
                    info!("Received Ping, IGNORING (not sending Pong).");
                }
                Ok(Some(Ok(Message::Close(_)))) => {
                    info!("Server closed connection as expected due to timeout.");
                    server_closed = true;
                    break; // 서버가 닫았으므로 루프 종료
                }
                Ok(Some(Ok(msg))) => {
                    warn!("Received unexpected message during timeout wait: {:?}", msg);
                }
                Ok(Some(Err(e))) => {
                    info!(
                        "WebSocket error during timeout wait (may indicate closure): {:?}",
                        e
                    );
                    server_closed = true; // 에러도 연결 종료로 간주
                    break;
                }
                Ok(None) => {
                    info!("WebSocket stream ended during timeout wait.");
                    server_closed = true; // 스트림 종료도 연결 종료로 간주
                    break;
                }
                Err(_) => {
                    // 메시지 대기 시간 초과, 계속 대기
                }
            }
            // 서버가 닫지 않았으면 계속 대기
            if server_closed {
                break;
            }
        }

        info!("Timeout wait finished.");

        // 서버가 연결을 닫았는지 명시적으로 확인
        if !server_closed {
            // 서버가 연결을 닫지 않았다면, 추가 읽기 시도 없이 바로 패닉
            panic!("Connection should be closed by server after timeout, but it wasn't.");
        } else {
            info!("Server connection appears closed as expected.");
            // should_panic 테스트이므로, 여기서 정상 종료되면 테스트 실패
            // 의도적으로 패닉을 유발하지 않고, should_panic이 감지하도록 둠
        }

        // 만약 should_panic이 제대로 동작하지 않는다면, 아래 assert!로 실패 유발 가능
        // assert!(!server_closed, "Connection should be closed by server after timeout");
    }

    // wrong_phase 테스트는 AuthPlayer 가드가 없으므로 제거됨
    // #[actix_web::test]
    // async fn test_heartbeat_wrong_phase_http_rejection() { ... }
}
</file>

<file path="simulator_dedicated_server/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_dedicated_server/.gitignore">
/target
</file>

<file path="simulator_dedicated_server/.idea/.gitignore">
# 디폴트 무시된 파일
/shelf/
/workspace.xml
# 에디터 기반 HTTP 클라이언트 요청
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
</file>

<file path="simulator_dedicated_server/.idea/discord.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="PROJECT_FILES" />
    <option name="description" value="" />
    <option name="applicationTheme" value="default" />
    <option name="iconsTheme" value="default" />
    <option name="button1Title" value="" />
    <option name="button1Url" value="" />
    <option name="button2Title" value="" />
    <option name="button2Url" value="" />
    <option name="customApplicationId" value="" />
  </component>
</project>
</file>

<file path="simulator_dedicated_server/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/simulator.iml" filepath="$PROJECT_DIR$/.idea/simulator.iml" />
    </modules>
  </component>
</project>
</file>

<file path="simulator_dedicated_server/.idea/simulator.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="EMPTY_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="simulator_dedicated_server/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
  </component>
</project>
</file>

<file path="simulator_dedicated_server/.vscode/launch.json">
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'card_game'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in executable 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug integration test 'test'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--test=test",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "test",
                    "kind": "test"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</file>

<file path="simulator_dedicated_server/Cargo.toml">
[package]
name = "dedicated_server"
version = "0.1.0"
edition = "2021"
description = "card backend"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</file>

<file path="simulator_dedicated_server/src/lib.rs">

</file>

<file path="simulator_match_server/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_match_server/.gitignore">
/target
</file>

<file path="simulator_match_server/.idea/.gitignore">
# 디폴트 무시된 파일
/shelf/
/workspace.xml
# 에디터 기반 HTTP 클라이언트 요청
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
</file>

<file path="simulator_match_server/.idea/discord.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="PROJECT_FILES" />
    <option name="description" value="" />
    <option name="applicationTheme" value="default" />
    <option name="iconsTheme" value="default" />
    <option name="button1Title" value="" />
    <option name="button1Url" value="" />
    <option name="button2Title" value="" />
    <option name="button2Url" value="" />
    <option name="customApplicationId" value="" />
  </component>
</project>
</file>

<file path="simulator_match_server/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/simulator.iml" filepath="$PROJECT_DIR$/.idea/simulator.iml" />
    </modules>
  </component>
</project>
</file>

<file path="simulator_match_server/.idea/simulator.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="EMPTY_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="simulator_match_server/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
  </component>
</project>
</file>

<file path="simulator_match_server/.vscode/launch.json">
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'card_game'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in executable 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug integration test 'test'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--test=test",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "test",
                    "kind": "test"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</file>

<file path="simulator_match_server/Cargo.toml">
[package]
name = "match_server"
version = "0.1.0"
edition = "2021"
description = "card backend"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</file>

<file path="simulator_match_server/src/lib.rs">

</file>

<file path=".gitignore">
/target
</file>

<file path="simulator_core/Cargo.toml">
[package]
name = "simulator_core"
version = "0.1.0"
edition = "2021"
description = "card backend"
build = "build.rs"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[build-dependencies]

[[bench]]
name = "bench"
harness = false

[dependencies]
rand_core = "0.6"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.18.0"
base64 = "0.13.1"
byteorder = "1.5.0"
rayon = "1.8.0"
clap = {version="4.5.26", features = ["derive"]}
ctor = "0.4.1"

actix-web = "4.9.0"
actix = "=0.13.5"
actix-ws = "0.3.0"
async-tungstenite = {version="0.28.2", features = ["tokio-runtime"]}
reqwest = "0.12.12"

futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
argon2 = "0.5.3"
dotenv = "0.15.0"

gnuplot = "0.0.45"
criterion = "0.5.1"
url = "2.5.4"


tokio = { version = "1.15", features = ["full", "tracing"] }
tokio-console = "0.1.13"
console-subscriber = "0.4.1"

uuid = { version = "1.14.0", features = ["v4", "serde"] }
lazy_static = "1.5.0"
structopt = "=0.3.26"
rand = "0.8.5"
hex = "0.4.3"
parking_lot = "0.12.3"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
paste = "1.0.15"
cargo-llvm-cov = "0.6.16"

serial_test = "3.2.0"
</file>

<file path="simulator_core/src/card/types.rs">
use std::fmt::{self, Display};
use std::hash::{Hash, Hasher};

use actix::Addr;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    exception::GameError, game::GameActor, resource::CardSpecsResource, utils::json::CardJson,
};

use super::modifier::Modifier;

#[derive(Clone)]
pub struct CardSpecs {
    attack: CardSpecsResource,
    defense: CardSpecsResource,
    cost: i32,
}

impl CardSpecs {
    pub fn new(json: &CardJson) -> Self {
        Self {
            attack: CardSpecsResource::new(json.attack.unwrap()),
            defense: CardSpecsResource::new(json.health.unwrap()),
            cost: json.cost.unwrap(),
        }
    }
}

// CardStatus 구조체 (카드의 현재 상태)
#[derive(Clone, Default)]
pub struct CardStatus {
    is_negated: bool,
    is_disabled: bool,
    modifiers: Vec<Modifier>,
}

impl CardStatus {
    pub fn new() -> Self {
        Self {
            is_negated: false,
            is_disabled: false,
            modifiers: vec![],
        }
    }

    pub fn is_negated(&self) -> bool {
        self.is_negated
    }

    pub fn is_disabled(&self) -> bool {
        self.is_disabled
    }
}

#[derive(Clone, PartialEq, Eq, Copy)]
pub enum ModifierType {
    AttackBoost,
    DefenseBoost,
    CostChange,
    EffectNegation,
    AttributeChange,
}

#[derive(Clone, Copy)]
pub enum Duration {
    Permanent,
    UntilEndOfTurn,
    UntilEndOfPhase,
    ForXTurns(usize),
}

impl CardStatus {
    // 수정자 추가
    pub fn add_modifier(&mut self, modifier: Modifier) {
        self.modifiers.push(modifier);
    }

    // 수정자 제거
    pub fn remove_modifier(&mut self, index: usize) {
        self.modifiers.remove(index);
    }

    // 특정 타입의 수정자 모두 제거
    pub fn remove_modifiers_of_type(&mut self, modifier_type: ModifierType) {
        self.modifiers
            .retain(|m| m.get_modifier_type() != modifier_type);
    }

    // 만료된 수정자 제거
    pub fn cleanup_expired_modifiers(&mut self, game: Addr<GameActor>) {
        todo!()
        // self.modifiers.retain(|modifier| {
        //     !modifier.is_expired(game.get_turn().get_turn_count(), game.get_phase())
        // });
    }

    // 특정 타입의 수정자 총합 계산
    pub fn get_total_modifier(&self, modifier_type: ModifierType) -> i32 {
        self.modifiers
            .iter()
            .filter(|m| m.get_modifier_type() == modifier_type)
            .map(|m| m.get_value())
            .sum()
    }
}

#[derive(Debug, PartialEq, Clone, Eq, Copy, Hash)]
pub enum SpellType {
    SlowSpell,
    FastSpell,
}

#[derive(Eq, PartialEq, Hash, Clone, Copy)]
pub enum CardType {
    Dummy,
    Unit,
    Spell,
    Field,
    Ace,
    Trap,
    Game,
    Any,
}

impl CardType {
    pub fn from_json(json: &CardJson) -> Result<Self, GameError> {
        match &json.r#type {
            Some(type_str) => match type_str.as_str() {
                "Dummy" => Ok(CardType::Dummy),
                "Unit" => Ok(CardType::Unit),
                "Spell" => Ok(CardType::Spell),
                "Field" => Ok(CardType::Field),
                "Ace" => Ok(CardType::Ace),
                "Trap" => Ok(CardType::Trap),
                "Game" => Ok(CardType::Game),
                _ => Err(GameError::InvalidCardType),
            },
            None => Err(GameError::InvalidCardType),
        }
    }

    // 추가 유틸리티 메서드들
    pub fn to_string(&self) -> &'static str {
        match self {
            CardType::Dummy => "Dummy",
            CardType::Unit => "Unit",
            CardType::Spell => "Spell",
            CardType::Field => "Field",
            CardType::Ace => "Ace",
            CardType::Trap => "Trap",
            CardType::Game => "Game",
            CardType::Any => "Any",
        }
    }

    pub fn is_unit(&self) -> bool {
        matches!(self, CardType::Unit)
    }

    pub fn is_spell(&self) -> bool {
        matches!(self, CardType::Spell)
    }

    pub fn is_field(&self) -> bool {
        matches!(self, CardType::Field)
    }

    pub fn is_trap(&self) -> bool {
        matches!(self, CardType::Trap)
    }
    // 카드 타입별 특성 확인
    pub fn can_be_played_as_action(&self) -> bool {
        matches!(self, CardType::Spell | CardType::Trap)
    }

    pub fn stays_on_field(&self) -> bool {
        matches!(self, CardType::Unit | CardType::Field)
    }

    pub fn is_permanent(&self) -> bool {
        matches!(self, CardType::Field | CardType::Game)
    }

    // 카드 타입별 제한사항
    pub fn max_copies_allowed(&self) -> i32 {
        match self {
            CardType::Ace => 1,
            CardType::Game => 1,
            _ => 3,
        }
    }
}

impl fmt::Display for CardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            CardType::Dummy => "Dummy",
            CardType::Unit => "Unit",
            CardType::Spell => "Spell",
            CardType::Field => "Field",
            CardType::Ace => "Ace",
            CardType::Trap => "Trap",
            CardType::Game => "Game",
            CardType::Any => "Any",
        };
        write!(f, "{}", s)
    }
}

impl fmt::Debug for CardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Debug 구현 시 Display 구현을 재사용합니다.
        write!(f, "{}", self)
    }
}

#[derive(Copy, Clone)]
pub enum StatType {
    Attack,
    Defense,
}

///
/// 백엔드을 실행하는건 Host 역할을 부여 받은 플레이어쪽임.
/// 백엔드에서 Host 는 Player1 혹은 Self_ 로 취급되고
/// Client 는 Player2 혹은 Opponent 로 취급함.
///

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OwnerType {
    Self_,    // 자신 (현재 턴 플레이어)
    Opponent, // 상대방
    Any,      // 아무나 (자신 또는 상대)
    None,     // 소유자 없음
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PlayerKind {
    Player1,
    Player2,
}

impl Display for PlayerKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl PlayerKind {
    pub fn as_str(&self) -> &'static str {
        match self {
            PlayerKind::Player1 => "Player1",
            PlayerKind::Player2 => "Player2",
        }
    }

    pub fn to_string(&self) -> String {
        match self {
            PlayerKind::Player1 => "Player1".to_string(),
            PlayerKind::Player2 => "Player2".to_string(),
        }
    }

    pub fn reverse(&self) -> Self {
        match self {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }
}

impl From<String> for PlayerKind {
    fn from(s: String) -> Self {
        match s.as_str() {
            "Player1" => PlayerKind::Player1,
            "Player2" => PlayerKind::Player2,
            _ => panic!("Invalid PlayerKind string"),
        }
    }
}

impl From<PlayerKind> for String {
    fn from(player_kind: PlayerKind) -> Self {
        player_kind.to_string()
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct PlayerIdentity {
    pub id: Uuid,
    pub kind: PlayerKind,
}

impl Hash for PlayerIdentity {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        self.kind.hash(state);
    }
}
</file>

<file path="simulator_core/src/effect/mod.rs">
pub mod effects;
pub mod types;
use std::any::Any;

use actix::Addr;
use types::{EffectInfo, EffectResult, EffectSpeed, EffectType};
use uuid::Uuid;

use crate::{
    card::{insert::Insert, take::Take, types::StatType, Card},
    exception::GameError,
    game::GameActor,
    selector::TargetSelector,
    server::input_handler::InputAnswer,
};

// 이 카드명의 "카드"는 1턴에 1장밖에 "발동"할 수 없다.
// 이 카드명의 "효과"는 1턴에 1장밖에 "사용"할 수 없다.
pub trait Effect: Send + Sync {
    /// 효과를 발동합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `Result<EffectResult, GameError>`
    /// # Errors
    /// * `GameError` - 효과 적용에 실패한 경우.
    fn begin_effect(&self, game: Addr<GameActor>, source: &Card)
        -> Result<EffectResult, GameError>;

    /// 효과를 발동할 수 있는지 확인합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `bool`
    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool;

    fn handle_input(
        &self,
        game: Addr<GameActor>,
        source: &Card,
        input: InputAnswer,
    ) -> Result<EffectResult, GameError> {
        Err(GameError::InputNotExpected)
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError>;

    fn get_effect_type(&self) -> EffectType;

    fn as_any(&self) -> &dyn Any;

    fn as_any_mut(&mut self) -> &mut dyn Any;

    fn get_id(&self) -> Uuid;

    fn get_speed(&self) -> EffectSpeed;
}

pub struct DigEffect {
    pub selector: Box<dyn TargetSelector>,
    pub insert: Box<dyn Insert>,
    pub take: Box<dyn Take>,
    pub info: EffectInfo,
}

impl DigEffect {
    pub fn new(
        selector: Box<dyn TargetSelector>,
        insert: Box<dyn Insert>,
        take: Box<dyn Take>,
        info: EffectInfo,
    ) -> Self {
        Self {
            selector,
            insert,
            take,
            info,
        }
    }

    pub fn get_selector(&self) -> &Box<dyn TargetSelector> {
        &self.selector
    }

    pub fn get_selector_mut(&mut self) -> &mut Box<dyn TargetSelector> {
        &mut self.selector
    }

    pub fn get_effect_type(&self) -> EffectType {
        EffectType::Dig
    }
}

impl Effect for DigEffect {
    /// dig 효과를 발동합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `Result<EffectResult, GameError>`
    /// # Errors
    /// * `GameError` - 효과 적용에 실패한 경우.
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        // // select_targets 으로 대상 카드를 가져옵니다.
        // let potential_targets = self.selector.select_targets(game, source)?;

        // if potential_targets.is_empty() {
        //     // 파낼 카드가 없으면 효과 종료 (또는 다른 처리)
        //     return Ok(EffectResult::Completed);
        // }

        // // Vec<Card> -> Vec<Uuid> 변환
        // let potential_targets_uuids = potential_targets
        //     .iter()
        //     .map(|card| card.get_uuid())
        //     .collect::<Vec<Uuid>>();

        // Ok(EffectResult::NeedsInput {
        //     inner: InputRequest::Dig {
        //         source_card: source.get_uuid(),
        //         source_effect_uuid: self.info.effect_id,
        //         potential_cards: potential_targets_uuids,
        //     },
        //     handler: HandlerType::General(Box::new(move |game, source, input| {
        //         Ok(EffectResult::Completed)
        //     })),
        // })
        todo!()
    }
    fn handle_input(
        &self,
        game: Addr<GameActor>,
        source: &Card,
        input: InputAnswer,
    ) -> Result<EffectResult, GameError> {
        todo!()
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        todo!()
    }

    fn get_effect_type(&self) -> EffectType {
        EffectType::Dig
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }

    fn get_id(&self) -> Uuid {
        self.info.effect_id
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}

pub struct DrawEffect {
    pub count: usize,
}

impl Effect for DrawEffect {
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        todo!()
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
        // game.get_player_by_type(source.get_owner())
        //     .get()
        //     .get_deck()
        //     .len()
        //     >= self.count
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        Ok(Box::new(Self { count: self.count }))
    }

    fn get_effect_type(&self) -> EffectType {
        todo!()
    }

    fn as_any(&self) -> &dyn Any {
        todo!()
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        todo!()
    }

    fn get_id(&self) -> Uuid {
        todo!()
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}

pub struct ModifyStatEffect {
    pub stat_type: StatType,
    pub amount: i32,
    pub target_selector: Box<dyn TargetSelector>,
}

impl Effect for ModifyStatEffect {
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        todo!()
        // let targets = self.target_selector.select_targets(game, source)?;
        // for mut target in targets {
        //     target.modify_stat(self.stat_type, self.amount)?;
        // }
        // Ok(())
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        self.target_selector.has_valid_targets(game, source)
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        Ok(Box::new(Self {
            stat_type: self.stat_type,
            amount: self.amount,
            target_selector: self.target_selector.clone_selector(),
        }))
    }

    fn get_effect_type(&self) -> EffectType {
        todo!()
    }

    fn as_any(&self) -> &dyn Any {
        todo!()
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        todo!()
    }

    fn get_id(&self) -> Uuid {
        todo!()
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}
</file>

<file path="simulator_core/src/exception/mod.rs">
use crate::{card::types::PlayerKind, server::jsons::game_features};
use actix::MailboxError;
use actix_web::{http::StatusCode, HttpResponse, ResponseError};
use std::fmt;

// 에러 메시지를 상수로 정의
pub const PLAYER_INITIALIZE_FAILED: &str = "PLAYER_INITIALIZE_FAILED";
pub const PLAYER_DATA_NOT_INTEGRITY: &str = "PLAYER_DATA_NOT_INTEGRITY";
pub const GENERATE_UUID_FAILED: &str = "GENERATE_UUID_FAILED";
pub const JSON_PARSE_FAILED: &str = "JSON_PARSE_FAILED";
pub const DECK_PARSE: &str = "DECK_PARSE";
pub const PATH_NOT_EXIST: &str = "PATH_NOT_EXIST";
pub const CARD_ERORR: &str = "CARD_ERORR";
pub const UNKNOWN: &str = "UNKNOWN";
pub const WRONG_PHASE: &str = "WRONG_PHASE";
pub const NOT_FOUND: &str = "NOT_FOUND";
pub const HANDLE_FAILED: &str = "HANDLE_FAILED";
pub const INTERNAL_SERVER: &str = "INTERNAL_SERVER";
pub const COOKIE_NOT_FOUND: &str = "COOKIE_NOT_FOUND";
pub const SERVER_STATE_NOT_FOUND: &str = "SERVER_STATE_NOT_FOUND";
pub const INVALID_PAYLOAD: &str = "INVALID_PAYLOAD";
pub const ACTIVE_SESSION_EXISTS: &str = "ACTIVE_SESSION_EXISTS";
pub const UNEXPECTED_MESSAGE: &str = "UNEXPECTED_MESSAGE";
pub const INVALID_APPROACH: &str = "INVALID_APPROACH";
pub const INVALID_CARDS: &str = "INVALID_CARDS";
pub const PARSE: &str = "PARSE";
pub const INVALID_PLAYER: &str = "INVALID_PLAYER";
pub const NOT_ALLOWED_RE_ENTRY: &str = "NOT_ALLOWED_RE_ENTRY";
pub const ALREADY_READY: &str = "ALREADY_READY";
pub const INVALID_OPERATION: &str = "INVALID_OPERATION";
pub const NO_CARDS_LEFT: &str = "NO_CARDS_LEFT";
pub const UNKNOWN_OCCURRED: &str = "AN_UNKNOWN_OCCURRED";
pub const INTERNAL_SERVER_MSG: &str = "INTERNAL_SERVER_MSG";
pub const PARSE_MSG: &str = "PARSE_MSG";
pub const EXCEEDED_CARD_LIMIT: &str = "EXCCED_CARD_LIMIT";

#[derive(Debug, PartialEq, Clone)]
pub enum GameError {
    CardCannotActivate,
    InputNotExpected,
    InvalidTarget,
    InvalidChainState,
    MissingInput,
    EffectNotFound,
    AlreadySelected,
    InvalidSelection,
    TooManySelections,
    SelectionClosed,
    InvalidEffectType,
    InvalidRequestId,
    InvalidChainPhase,
    InvalidChainSpeed,
    NoActivatableEffect,
    PlayerNotFound,
    NotEnoughCards,
    MailboxError,
    PlayerNotReady,

    InvalidTargetCount,
    NoValidTargets,
    CannotActivate,
    DeckCodeIsMissing(PlayerKind),
    PlayerInitializeFailed,
    PlayerDataNotIntegrity,
    PathNotExist,
    CardsNotFound,
    GameInitializeFailed,
    DifferentCardTypes,
    GenerateUUIDFaild,
    CardNotFound,
    ExceededCardLimit,
    FailedToDrawCard,
    NothingToRemove,
    InvalidCardData,
    NotAuthenticated,
    InvalidCardType,
    InvalidPlayerType,
    InvalidOperation,
    InvalidCards,
    JsonParseFailed,
    InvalidPlayer,
    DecodeError,
    DeckParseError,
    ReadFileFailed,
    NoCardsLeft,
    CardError,
    Unknown,
    WrongPhase,
    AlreadyReady,
    HandleFailed,
    NotAllowedReEntry,
    InternalServerError,
    UnexpectedMessage,
    CookieNotFound,
    ServerStateNotFound,
    ActiveSessionExists,
    ParseError,
    InvalidPayload,
    InvalidApproach,
}

impl fmt::Display for GameError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::PlayerInitializeFailed => write!(f, "{}", PLAYER_INITIALIZE_FAILED),
            Self::PlayerDataNotIntegrity => write!(f, "{}", PLAYER_DATA_NOT_INTEGRITY),
            Self::GenerateUUIDFaild => write!(f, "{}", GENERATE_UUID_FAILED),
            Self::JsonParseFailed => write!(f, "{}", JSON_PARSE_FAILED),
            Self::DeckParseError => write!(f, "{}", DECK_PARSE),
            Self::PathNotExist => write!(f, "{}", PATH_NOT_EXIST),
            Self::CardError => write!(f, "{}", CARD_ERORR),
            Self::Unknown => write!(f, "{}", UNKNOWN),
            Self::WrongPhase => write!(f, "{}", WRONG_PHASE),
            Self::HandleFailed => write!(f, "{}", HANDLE_FAILED),
            Self::InternalServerError => write!(f, "{}", INTERNAL_SERVER),
            Self::CookieNotFound => write!(f, "{}", COOKIE_NOT_FOUND),
            Self::ServerStateNotFound => write!(f, "{}", SERVER_STATE_NOT_FOUND),
            Self::InvalidPayload => write!(f, "{}", INVALID_PAYLOAD),
            Self::ActiveSessionExists => write!(f, "{}", ACTIVE_SESSION_EXISTS),
            Self::UnexpectedMessage => write!(f, "{}", UNEXPECTED_MESSAGE),
            Self::InvalidApproach => write!(f, "{}", INVALID_APPROACH),
            Self::InvalidCards => write!(f, "{}", INVALID_CARDS),
            Self::ParseError => write!(f, "{}", PARSE),
            Self::InvalidPlayer => write!(f, "{}", INVALID_PLAYER),
            Self::NotAllowedReEntry => write!(f, "{}", NOT_ALLOWED_RE_ENTRY),
            Self::AlreadyReady => write!(f, "{}", ALREADY_READY),
            Self::InvalidOperation => write!(f, "{}", INVALID_OPERATION),
            Self::NoCardsLeft => write!(f, "{}", NO_CARDS_LEFT),
            Self::ExceededCardLimit => write!(f, "{}", EXCEEDED_CARD_LIMIT),
            _ => write!(f, ""),
        }
    }
}

impl ResponseError for GameError {
    fn error_response(&self) -> HttpResponse {
        match self {
            Self::Unknown => {
                HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR).body(UNKNOWN_OCCURRED)
            }
            Self::WrongPhase => {
                HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR).body(WRONG_PHASE)
            }
            Self::HandleFailed => {
                HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR).body(UNKNOWN_OCCURRED)
            }
            Self::InternalServerError => {
                HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR).body(INTERNAL_SERVER_MSG)
            }
            Self::CookieNotFound => {
                HttpResponse::build(StatusCode::NOT_FOUND).body(COOKIE_NOT_FOUND)
            }
            Self::ServerStateNotFound => {
                HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR).body(SERVER_STATE_NOT_FOUND)
            }
            Self::InvalidPayload => {
                HttpResponse::build(StatusCode::BAD_REQUEST).body(INVALID_PAYLOAD)
            }
            Self::ActiveSessionExists => {
                HttpResponse::build(StatusCode::CONFLICT).body(ACTIVE_SESSION_EXISTS)
            }
            Self::ParseError => HttpResponse::build(StatusCode::BAD_REQUEST).body(PARSE_MSG),
            Self::UnexpectedMessage => {
                HttpResponse::build(StatusCode::BAD_REQUEST).body(UNEXPECTED_MESSAGE)
            }
            Self::InvalidCards => HttpResponse::build(StatusCode::BAD_REQUEST).body(INVALID_CARDS),
            Self::InvalidPlayer => {
                HttpResponse::build(StatusCode::UNAUTHORIZED).body(INVALID_PLAYER)
            }
            Self::InvalidApproach => {
                HttpResponse::build(StatusCode::BAD_REQUEST).body(INVALID_APPROACH)
            }
            Self::NotAllowedReEntry => {
                HttpResponse::build(StatusCode::CONFLICT).body(NOT_ALLOWED_RE_ENTRY)
            }
            Self::AlreadyReady => HttpResponse::build(StatusCode::CONFLICT).body(ALREADY_READY),
            Self::InvalidOperation => {
                HttpResponse::build(StatusCode::BAD_REQUEST).body(INVALID_OPERATION)
            }
            Self::NoCardsLeft => HttpResponse::build(StatusCode::BAD_REQUEST).body(NO_CARDS_LEFT),
            // TODO: draw_no_cards_left 테스트 작성중이었음.
            Self::ExceededCardLimit => {
                HttpResponse::build(StatusCode::BAD_REQUEST).body(EXCEEDED_CARD_LIMIT)
            }
            _ => HttpResponse::build(StatusCode::INTERNAL_SERVER_ERROR).body(UNKNOWN_OCCURRED),
        }
    }

    fn status_code(&self) -> StatusCode {
        match self {
            Self::Unknown => StatusCode::INTERNAL_SERVER_ERROR,
            Self::WrongPhase => StatusCode::INTERNAL_SERVER_ERROR,
            Self::HandleFailed => StatusCode::INTERNAL_SERVER_ERROR,
            Self::InternalServerError => StatusCode::INTERNAL_SERVER_ERROR,
            Self::CookieNotFound => StatusCode::NOT_FOUND,
            Self::ServerStateNotFound => StatusCode::INTERNAL_SERVER_ERROR,
            Self::InvalidPayload => StatusCode::BAD_REQUEST,
            Self::ActiveSessionExists => StatusCode::CONFLICT,
            Self::ParseError => StatusCode::BAD_REQUEST,
            Self::UnexpectedMessage => StatusCode::BAD_REQUEST,
            Self::InvalidCards => StatusCode::BAD_REQUEST,
            Self::InvalidPlayer => StatusCode::UNAUTHORIZED,
            Self::InvalidApproach => StatusCode::BAD_REQUEST,
            Self::NotAllowedReEntry => StatusCode::CONFLICT,
            Self::AlreadyReady => StatusCode::CONFLICT,
            Self::InvalidOperation => StatusCode::BAD_REQUEST,
            Self::NoCardsLeft => StatusCode::BAD_REQUEST,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}

pub enum MessageProcessResult<T> {
    Success(T),                                  // 성공적으로 메시지 처리
    SystemHandled(game_features::ClientMessage), // 게임 시스템에서 처리하는 메시지
    NeedRetry,                                   // 에러가 발생했지만 재시도 가능
    TerminateSession(GameError),                 // 세션 종료 필요
}

impl From<MailboxError> for GameError {
    fn from(_: MailboxError) -> Self {
        GameError::InternalServerError
    }
}
</file>

<file path="simulator_core/src/game/choice.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind, enums::ZoneType, exception::GameError, server::jsons::game_features,
};

// ChoiceType 은 카드 선택의 종류를 나타냄
// 클라이언트 단으로 전달할 때, 게임 진행을 위한 정보가 여럿 포함되어 있는데.
// 이러한 정보들은 effect 로부터 얻어와야함.
// 대표적으로 DigEffect 의 경우, src, dest 정보가 필요함.
// src 의 경우 selector 에서 얻어오고
// dst 의 경우 insert 에서 얻어오면 될 듯?
// 근데 take, insert 는 카드를 어디서 가져오는지 정보를 가지고 있지 않음.
// 그러한 정보는 외부에서 저장되어있음.
// 그래서 Effect 자체에서 가지고 있는게 나을듯?
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChoiceType {
    Dig,          // 덱에서 카드 탐색
    Discard,      // 핸드에서 버릴 카드 선택
    SelectTarget, // 대상 선택 (유닛, 플레이어 등)
    Sacrifice,    // 희생할 카드 선택
    Rearrange,    // 카드 재배치/순서 변경
    RevealChoice, // 공개된 카드 중 선택
    MultiZone,    // 여러 영역에서 선택
}

impl ChoiceType {
    pub fn to_string(&self) -> String {
        match self {
            ChoiceType::Dig => "Dig".to_string(),
            ChoiceType::Discard => "Discard".to_string(),
            ChoiceType::SelectTarget => "SelectTarget".to_string(),
            ChoiceType::Sacrifice => "Sacrifice".to_string(),
            ChoiceType::Rearrange => "Rearrange".to_string(),
            ChoiceType::RevealChoice => "RevealChoice".to_string(),
            ChoiceType::MultiZone => "MultiZone".to_string(),
        }
    }
}

// 사용자
#[derive(Debug, Clone)]
pub struct ChoiceState {
    // 기본 정보
    player: PlayerKind,
    choice_type: ChoiceType,

    // 소스 및 대상 정보
    source_card_id: Option<Uuid>,   // 선택 효과를 발동한 카드
    source_effect_id: Option<Uuid>, // 선택을 요청한 효과

    // 선택 제한 설정
    min_selections: usize, // 최소 선택 개수
    max_selections: usize, // 최대 선택 개수
    destination: ZoneType, // 선택 후 카드 목적지

    // 상태 관리
    is_open: bool,      // 선택이 활성화되어 있는지
    is_mandatory: bool, // 필수 선택 여부 (취소 불가)

    is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
}

impl Default for ChoiceState {
    fn default() -> Self {
        Self {
            player: PlayerKind::Player1,
            choice_type: ChoiceType::Dig,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: true,
            is_mandatory: true,
            is_hidden_from_opponent: false,
        }
    }
}

impl ChoiceState {
    pub fn builder(player: PlayerKind, choice_type: ChoiceType) -> ChoiceStateBuilder {
        ChoiceStateBuilder::new(player, choice_type)
    }

    pub fn new(
        player: PlayerKind,
        choice_type: ChoiceType,
        source_card_id: Option<Uuid>,
        source_effect_id: Option<Uuid>,
        min_selections: usize,
        max_selections: usize,
        destination: ZoneType,
        is_open: bool,
        is_mandatory: bool,
        is_hidden_from_opponent: bool,
    ) -> Self {
        Self {
            player,
            choice_type,
            source_card_id,
            source_effect_id,
            min_selections,
            max_selections,
            destination,
            is_open,
            is_mandatory,
            is_hidden_from_opponent,
        }
    }

    pub fn serialize_message(&self) -> Result<String, GameError> {
        // ChoiceState의 정보를 ChoiceCardPayload로 변환
        let message = game_features::ChoiceCardRequestPayload {
            player: self.player.to_string(), // PlayerType을 문자열로 변환
            choice_type: self.choice_type.to_string(), // ChoiceType을 문자열로 변환
            source_card_id: self.source_card_id.unwrap(),
            min_selections: self.min_selections,
            max_selections: self.max_selections,
            destination: self.destination.to_string(),
            is_open: self.is_open,
            is_hidden_from_opponent: self.is_hidden_from_opponent,
        };

        // JSON 문자열로 직렬화
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

pub struct ChoiceStateBuilder {
    player: PlayerKind,
    choice_type: ChoiceType,
    source_card_id: Option<Uuid>,
    source_effect_id: Option<Uuid>,
    min_selections: usize,
    max_selections: usize,
    destination: ZoneType,
    is_open: bool,
    is_mandatory: bool,
    is_hidden_from_opponent: bool,
}

impl ChoiceStateBuilder {
    pub fn new(player: PlayerKind, choice_type: ChoiceType) -> Self {
        Self {
            player,
            choice_type,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: false,
            is_mandatory: false,
            is_hidden_from_opponent: false,
        }
    }

    pub fn source_card(mut self, card_id: impl Into<Option<Uuid>>) -> Self {
        self.source_card_id = card_id.into();
        self
    }

    pub fn source_effect(mut self, effect_id: impl Into<Option<Uuid>>) -> Self {
        self.source_effect_id = effect_id.into();
        self
    }

    pub fn selections(mut self, min: usize, max: usize) -> Self {
        self.min_selections = min;
        self.max_selections = max;
        self
    }

    pub fn destination(mut self, destination: ZoneType) -> Self {
        self.destination = destination;
        self
    }

    pub fn open(mut self, is_open: bool) -> Self {
        self.is_open = is_open;
        self
    }

    pub fn mandatory(mut self, is_mandatory: bool) -> Self {
        self.is_mandatory = is_mandatory;
        self
    }

    pub fn hidden_from_opponent(mut self, is_hidden: bool) -> Self {
        self.is_hidden_from_opponent = is_hidden;
        self
    }

    pub fn build(self) -> ChoiceState {
        ChoiceState::new(
            self.player,
            self.choice_type,
            self.source_card_id,
            self.source_effect_id,
            self.min_selections,
            self.max_selections,
            self.destination,
            self.is_open,
            self.is_mandatory,
            self.is_hidden_from_opponent,
        )
    }
}
</file>

<file path="simulator_core/src/game/phase.rs">
use std::collections::HashMap;

use crate::card::types::PlayerKind;

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum PlayerPhaseProgress {
    NotStarted,         // 아직 해당 페이즈 시작 안 함
    Entered,            // 페이즈에 막 진입했거나 기본적인 작업 대기 중
    ActionTaken,        // 페이즈 내 주요 액션 수행 (예: 드로우 완료, 공격 선언 완료)
    WaitingForOpponent, // 자신의 액션은 끝났고 상대방 대기 중
    Completed,          // 해당 페이즈 완전히 종료 (양쪽 동의)
}

#[derive(Clone)]
pub struct PhaseState {
    current_phase: Phase,
    // 플레이어별 진행 상태 저장
    player_progress: HashMap<PlayerKind, PlayerPhaseProgress>,
}

impl PhaseState {
    pub fn new(phase: Phase) -> Self {
        let mut progress = HashMap::new();
        // 초기 상태는 NotStarted 또는 Entered
        progress.insert(PlayerKind::Player1, PlayerPhaseProgress::NotStarted);
        progress.insert(PlayerKind::Player2, PlayerPhaseProgress::NotStarted);
        Self {
            current_phase: phase,
            player_progress: progress,
        }
    }

    pub fn get_phase(&self) -> Phase {
        self.current_phase
    }

    pub fn set_phase(&mut self, phase: Phase) {
        self.current_phase = phase;
        // 페이즈 전환 시 플레이어 상태 초기화
        self.reset_progress();
    }

    // 플레이어 진행 상태 가져오기
    pub fn get_player_progress(&self, player: PlayerKind) -> PlayerPhaseProgress {
        self.player_progress
            .get(&player)
            .cloned()
            .unwrap_or(PlayerPhaseProgress::NotStarted)
    }

    // 플레이어 진행 상태 업데이트
    pub fn update_player_progress(&mut self, player: PlayerKind, progress: PlayerPhaseProgress) {
        println!("PhaseState Update: Player {:?} -> {:?}", player, progress); // 로그 추가
        self.player_progress.insert(player, progress);
    }

    // 페이즈 전환 시 상태 초기화
    pub fn reset_progress(&mut self) {
        for progress in self.player_progress.values_mut() {
            *progress = PlayerPhaseProgress::Entered; // 새 페이즈는 Entered 상태로 시작
        }
        println!(
            "PhaseState Reset: All players progress set to Entered for phase {:?}",
            self.current_phase
        );
    }

    // 특정 상태인 플레이어가 있는지 확인 (예: 둘 다 Completed 인지)
    pub fn both_players_in_progress(&self, progress: PlayerPhaseProgress) -> bool {
        self.player_progress.len() == 2 && self.player_progress.values().all(|p| *p == progress)
    }
}
#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum Phase {
    Mulligan,

    // 가장 먼저 시작되는 드로우 페이즈 ( 기타 자원 등 증가함. )
    DrawPhase,

    // 메인 페이즈 진입 전 시작되는 페이즈
    StandbyPhase,

    // 메인 페이즈 개시시
    MainPhaseStart,
    // 메인 페이즈 개시중
    MainPhase1,

    // 배틀 페이즈 진입
    BattlePhaseStart,
    // 배틀 페이즈 중
    BattleStep,
    // 데미지 스텝 개시시
    BattleDamageStepStart,
    // 데미지 계산 전
    BattleDamageStepCalculationBefore,
    // 데미지 계산 중
    BattleDamageStepCalculationStart,
    // 데미지 계산 후
    BattleDamageStepCalculationEnd,
    // 데미지 스텝 종료시
    BattleDamageStepEnd,
    // 데미지 페이즈 종료
    BattlePhaseEnd,

    // 메인 페이즈2 시작
    MainPhase2,

    // 턴 종료
    EndPhase,
}

impl From<String> for Phase {
    fn from(value: String) -> Self {
        match value.to_lowercase().as_str() {
            "mulligan" => Phase::Mulligan,
            "drawphase" => Phase::DrawPhase,
            "standbyphase" => Phase::StandbyPhase,
            "mainphasestart" => Phase::MainPhaseStart,
            "mainphase1" => Phase::MainPhase1,
            "battlephasestart" => Phase::BattlePhaseStart,
            "battlestep" => Phase::BattleStep,
            "battledamagestepstart" => Phase::BattleDamageStepStart,
            "battledamagestepcalculationbefore" => Phase::BattleDamageStepCalculationBefore,
            "battledamagestepcalculationstart" => Phase::BattleDamageStepCalculationStart,
            "battledamagestepcalculationend" => Phase::BattleDamageStepCalculationEnd,
            "battledamagestepend" => Phase::BattleDamageStepEnd,
            "battlephaseend" => Phase::BattlePhaseEnd,
            "mainphase2" => Phase::MainPhase2,
            "endphase" => Phase::EndPhase,
            _ => panic!("Invalid Phase string: {}", value),
        }
    }
}

impl PartialOrd for Phase {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Phase {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.order().cmp(&other.order())
    }
}

impl Phase {
    fn order(&self) -> u8 {
        match self {
            Phase::Mulligan => 0,
            Phase::DrawPhase => 1,
            Phase::StandbyPhase => 2,
            Phase::MainPhaseStart => 3,
            Phase::MainPhase1 => 4,
            Phase::BattlePhaseStart => 5,
            Phase::BattleStep => 6,
            Phase::BattleDamageStepStart => 7,
            Phase::BattleDamageStepCalculationBefore => 8,
            Phase::BattleDamageStepCalculationStart => 9,
            Phase::BattleDamageStepCalculationEnd => 10,
            Phase::BattleDamageStepEnd => 11,
            Phase::BattlePhaseEnd => 12,
            Phase::MainPhase2 => 13,
            Phase::EndPhase => 14,
        }
    }

    /// 현재 페이즈가 드로우 페이즈인지 확인
    pub fn is_draw_phase(&self) -> bool {
        matches!(self, Phase::DrawPhase)
    }

    /// 현재 페이즈가 스탠바이 페이즈인지 확인
    pub fn is_standby_phase(&self) -> bool {
        matches!(self, Phase::StandbyPhase)
    }

    /// 메인 페이즈 1 관련 체크
    pub fn is_main_phase_1(&self) -> bool {
        matches!(self, Phase::MainPhase1)
    }

    pub fn is_main_phase_1_start(&self) -> bool {
        matches!(self, Phase::MainPhaseStart)
    }

    /// 배틀 페이즈 관련 체크
    pub fn is_battle_phase(&self) -> bool {
        matches!(
            self,
            Phase::BattlePhaseStart
                | Phase::BattleStep
                | Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
                | Phase::BattlePhaseEnd
        )
    }

    pub fn is_battle_step(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    pub fn is_damage_step(&self) -> bool {
        matches!(
            self,
            Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
        )
    }

    pub fn is_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationStart)
    }

    pub fn is_before_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationBefore)
    }

    pub fn is_after_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationEnd)
    }

    /// 메인 페이즈 2 체크
    pub fn is_main_phase_2(&self) -> bool {
        matches!(self, Phase::MainPhase2)
    }

    /// 엔드 페이즈 체크
    pub fn is_end_phase(&self) -> bool {
        matches!(self, Phase::EndPhase)
    }

    /// 메인 페이즈 체크 (1과 2 모두)
    pub fn is_main_phase(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::MainPhase1 | Phase::MainPhase2
        )
    }

    /// 일반 소환이 가능한 페이즈인지 체크
    pub fn can_normal_summon(&self) -> bool {
        matches!(self, Phase::MainPhase1 | Phase::MainPhase2)
    }

    /// 공격이 가능한 페이즈인지 체크
    pub fn can_attack(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    /// 현재 페이즈가 개시시인지 체크
    pub fn is_phase_start(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::BattlePhaseStart | Phase::BattleDamageStepStart
        )
    }

    /// 다음 페이즈 반환
    pub fn next_phase(&self) -> Phase {
        match self {
            Phase::Mulligan => Phase::DrawPhase,
            Phase::DrawPhase => Phase::StandbyPhase,
            Phase::StandbyPhase => Phase::MainPhaseStart,
            Phase::MainPhaseStart => Phase::MainPhase1,
            Phase::MainPhase1 => Phase::BattlePhaseStart,
            Phase::BattlePhaseStart => Phase::BattleStep,
            Phase::BattleStep => Phase::BattleDamageStepStart,
            Phase::BattleDamageStepStart => Phase::BattleDamageStepCalculationBefore,
            Phase::BattleDamageStepCalculationBefore => Phase::BattleDamageStepCalculationStart,
            Phase::BattleDamageStepCalculationStart => Phase::BattleDamageStepCalculationEnd,
            Phase::BattleDamageStepCalculationEnd => Phase::BattleDamageStepEnd,
            Phase::BattleDamageStepEnd => Phase::BattlePhaseEnd,
            Phase::BattlePhaseEnd => Phase::MainPhase2,
            Phase::MainPhase2 => Phase::EndPhase,
            Phase::EndPhase => Phase::DrawPhase,
        }
    }

    pub fn move_to_next_phase(&mut self) {
        *self = self.next_phase();
    }

    pub fn set_phase(&mut self, phase: Phase) {
        *self = phase;
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            Phase::Mulligan => "Mulligan",
            Phase::DrawPhase => "DrawPhase",
            Phase::StandbyPhase => "StandbyPhase",
            Phase::MainPhaseStart => "MainPhaseStart",
            Phase::MainPhase1 => "MainPhase1",
            Phase::BattlePhaseStart => "BattlePhaseStart",
            Phase::BattleStep => "BattleStep",
            Phase::BattleDamageStepStart => "BattleDamageStepStart",
            Phase::BattleDamageStepCalculationBefore => "BattleDamageStepCalculationBefore",
            Phase::BattleDamageStepCalculationStart => "BattleDamageStepCalculationStart",
            Phase::BattleDamageStepCalculationEnd => "BattleDamageStepCalculationEnd",
            Phase::BattleDamageStepEnd => "BattleDamageStepEnd",
            Phase::BattlePhaseEnd => "BattlePhaseEnd",
            Phase::MainPhase2 => "MainPhase2",
            Phase::EndPhase => "EndPhase",
        }
    }
}
</file>

<file path="simulator_core/src/game/turn.rs">
use crate::card::types::PlayerKind;

#[derive(Clone)]
pub struct Turn {
    current_turn: PlayerKind,
    turn_count: usize,
}

impl Turn {
    pub fn new() -> Self {
        Turn {
            current_turn: PlayerKind::Player1,
            turn_count: 0,
        }
    }

    pub fn get_turn_count(&self) -> usize {
        self.turn_count
    }

    pub fn increase_turn_count(&mut self) -> usize {
        self.turn_count += 1;
        self.turn_count
    }

    pub fn current_turn(&self) -> PlayerKind {
        self.current_turn
    }

    pub fn change_turn(&mut self) -> PlayerKind {
        self.current_turn = match self.current_turn {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        };
        self.current_turn
    }

    pub fn is_player_turn(&self) -> bool {
        self.current_turn == PlayerKind::Player1
    }

    pub fn is_opponent_turn(&self) -> bool {
        self.current_turn == PlayerKind::Player2
    }

    pub fn get_opponent_turn(&self) -> PlayerKind {
        match self.current_turn {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }

    // 특정 플레이어의 턴으로 강제 설정
    pub fn set_turn(&mut self, player: PlayerKind) {
        self.current_turn = player;
    }
}
</file>

<file path="simulator_core/src/main.rs">
use std::fs;
use std::io::Write;
use std::path::Path;

use actix_web::{App, HttpServer};
use simulator_core::setup_logger;

use clap::Parser;
use uuid::Uuid;

// main
#[derive(Parser)]
#[command(
    name = "card game backend",           // 프로그램 이름
    author = env!("CARGO_PKG_AUTHORS"),       // 작성자
    version = env!("CARGO_PKG_VERSION"),           // 버전
    about = env!("CARGO_PKG_DESCRIPTION"),   // 짧은 설명
    long_about = None,         // 긴 설명 (None은 미사용)
)]
struct Args {
    #[arg(long = "p1_deck")]
    #[arg(required = true)]
    player_1_deckcode: String,

    #[arg(long = "p2_deck")]
    #[arg(required = true)]
    player_2_deckcode: String,

    #[arg(required = true)]
    attacker: usize,
}

// TODO: 매칭으로 만난 두 플레이어의 닉네임을 받은 뒤, 게임 공용 서버인 valid server 에 전송하여 실제 플레이어가 맞는지 확인 후, key 값을 리턴 받음.
pub fn check_session(_nick1: String, _nick2: String) -> (Uuid, Uuid) {
    todo!()
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("card_registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // 카드 모듈 디렉토리 스캔
    let modules = ["human", "monster", "public"];
    let mut card_registrations = Vec::new();

    for module in modules {
        let path = format!("src/card_gen/{}.rs", module);
        let content = fs::read_to_string(&path).unwrap();

        // 함수 이름 찾기
        for line in content.lines() {
            if line.contains("pub fn")
                && (line.contains("HM_") || line.contains("MT_") || line.contains("PB_"))
            {
                let func_name = line.split("fn ").nth(1).unwrap().split("(").next().unwrap();
                card_registrations.push(format!("    {}::{}", module, func_name));
            }
        }
    }

    // 매크로 호출 생성
    write!(
        f,
        r#"
        // 자동 생성된 카드 레지스트리
        generate_card_map! {{
            {}
        }}
        "#,
        card_registrations.join(",\n")
    )
    .unwrap();

    // let (deck_json, _) = generate_random_deck_json();
    // let (deck_json2, _) = generate_random_deck_json();

    // // 2. JSON을 덱 코드로 변환
    // let deck_codes = parse_json_to_deck_code(Some(deck_json), Some(deck_json2))
    //     .expect("Failed to parse deck code");

    // let app = initialize_app(deck_codes.0, deck_codes.1, 0);

    // let session_keys = check_session("".to_string(), "".to_string());

    // let state = web::Data::new(ServerState {
    //     game: Mutex::new(app.game),
    //     player_cookie: session_keys.0,
    //     opponent_cookie: session_keys.1,
    //     session_manager: PlayerSessionManager::new(CLIENT_TIMEOUT),
    // });

    setup_logger();
    HttpServer::new(move || {
        App::new()
        // .app_data(state.clone())
        // .service(mulligan_phase)
        // .service(draw_phase)
        // .service(standby_phase)
        // .service(main_phase_start_phase)
        // .service(heartbeat)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
</file>

<file path="simulator_core/src/player/mod.rs">
use actix::{Actor, Addr, Context};
use tracing::{debug, instrument};
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::TopTake, types::PlayerKind, Card},
    enums::ZoneType,
    exception::GameError,
    selector::{mulligan::MulliganState, TargetCount},
    unit::player::Resoruce,
    zone::{
        deck::Deck, effect::Effect, field::Field, graveyard::Graveyard, hand::Hand, zone::Zone,
    },
};

pub mod message;

pub struct PlayerActor {
    opponent: Option<Addr<PlayerActor>>,
    player_type: PlayerKind,
    mulligan_state: MulliganState,
    cards: Cards,
    cost: Resoruce,
    mana: Resoruce,

    hand: Hand,
    deck: Deck,
    graveyard: Graveyard,
    effect: Effect,
    field: Field,
}

impl Actor for PlayerActor {
    type Context = Context<Self>;
}

impl PlayerActor {
    pub fn new(player_type: PlayerKind) -> Self {
        Self {
            player_type,
            opponent: None,
            mulligan_state: MulliganState::new(),
            cards: Cards::new(),
            cost: Resoruce::new(0, 0),
            mana: Resoruce::new(0, 0),
            hand: Hand::new(),
            deck: Deck::new(),
            graveyard: Graveyard::new(),
            effect: Effect::new(),
            field: Field::new(),
        }
    }

    pub fn restore_cards(&mut self, card: &[Card], target_zone: ZoneType) -> Result<(), GameError> {
        match target_zone {
            ZoneType::Hand => todo!(),
            ZoneType::Deck => todo!(),
            ZoneType::Graveyard => todo!(),
            ZoneType::Effect => todo!(),
            ZoneType::Field => todo!(),
            ZoneType::None => todo!(),
        }
    }

    pub fn get_cards_by_uuids(&self, uuids: &[Uuid]) -> Result<Vec<Card>, GameError> {
        todo!()
    }

    #[instrument(skip(self), fields(player_type = ?player_type.into()))]
    pub fn get_new_mulligan_cards<T: Into<PlayerKind> + Copy>(
        &mut self,
        player_type: T,
        count: usize,
    ) -> Result<Vec<Uuid>, GameError> {
        let player_type = player_type.into();
        debug!(
            "멀리건 카드 뽑기 시도: player={:?}, count={}",
            player_type, count
        );

        let take_result = self
            .deck
            .take_card(Box::new(TopTake(TargetCount::Exact(count))))?;

        let uuids = take_result
            .iter()
            .map(|card| card.get_uuid())
            .collect::<Vec<_>>();

        debug!(
            "멀리건 카드 뽑기 완료: player={:?}, card_count={}",
            player_type,
            uuids.len()
        );

        Ok(uuids)
    }

    pub fn get_cards_mut(&mut self) -> &mut Cards {
        &mut self.cards
    }

    pub fn get_cards(&self) -> &Cards {
        &self.cards
    }
}

//         #[instrument(skip(self), fields(player_type = ?player_type.into()))]
//         pub fn add_select_cards<T: Into<PlayerType> + Copy>(
//             &mut self,
//             cards: Vec<Uuid>,
//             player_type: T,
//         ) {
//             let player_type = player_type.into();
//             debug!(
//                 "멀리건 상태에 카드 추가 시작: player={:?}, cards={:?}",
//                 player_type, cards
//             );

//             let mut player = self.get_player_by_type(player_type).get();

//             player
//                 .get_mulligan_state_mut()
//                 .add_select_cards(cards.clone());
//             debug!("멀리건 상태에 카드 추가 완료: player={:?}", player_type);
//         }

//         pub fn add_reroll_cards<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//             payload_cards: Vec<Uuid>,
//             rerolled_cards: Vec<Uuid>,
//         ) {
//             let player_type = player_type.into();
//             debug!("선택 카드 제거: player={:?}", player_type);
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .remove_select_cards(payload_cards);

//             debug!("리롤된 카드 추가: player={:?}", player_type);
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .add_select_cards(rerolled_cards);
//         }

//         pub fn reroll_request<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//             cards: Vec<Uuid>,
//         ) -> Result<Vec<Uuid>, GameError> {
//             let player_type = player_type.into();
//             // 플레이어가 이미 준비 상태인 경우
//             if self
//                 .get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .is_ready()
//             {
//                 warn!("플레이어가 이미 준비 상태: player={:?}", player_type);
//                 return Err(GameError::AlreadyReady);
//                 // try_send_error!(session, GameError::AlreadyReady, retry 3);
//             }

//             // 플레이어가 선택한 카드가 유효한지 확인합니다.
//             debug!("선택한 카드 유효성 검사: player={:?}", player_type);
//             if let Err(e) = self.get_cards_by_uuids(cards.clone()) {
//                 error!("유효하지 않은 카드 선택: player={:?}", player_type);
//                 return Err(e);
//             }

//             // 기존 카드를 덱의 최하단에 위치 시킨 뒤, 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장하고 json 으로 변환하여 전송합니다.
//             info!("카드 리롤 시작: player={:?}", player_type);
//             let rerolled_card = match self.restore_then_reroll_mulligan_cards(player_type, cards) {
//                 Ok(cards) => {
//                     debug!("카드 리롤 성공: card_count={}", cards.len());
//                     cards
//                 }
//                 Err(e) => {
//                     error!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
//                     panic!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
//                 }
//             };

//             Ok(rerolled_card)
//         }

//         /// 멀리건 완료 처리 함수
//         /// - 게임 객체를 받아서, 플레이어의 멀리건 상태를 완료로 변경하고, 선택한 카드들을 손으로 이동시킵니다.
//         /// - 선택한 카드들의 UUID를 반환합니다.
//         /// # Arguments
//         /// * `game` - 게임 객체
//         /// * `player_type` - 플레이어 타입
//         /// # Returns
//         /// * `Vec<Uuid>` - 선택한 카드들의 UUID

//         pub fn process_mulligan_completion<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//         ) -> Result<Vec<Uuid>, GameError> {
//             let player_type = player_type.into();

//             // 선택된 멀리건 카드들의 UUID 를 얻습니다.
//             let selected_cards = self
//                 .get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .get_select_cards();

//             // UUID -> Card 객체로 변환하는 과정입니다.
//             let cards = self.get_cards_by_uuids(selected_cards.clone())?;

//             // add_card 함수를 통해 선택된 카드들을 손으로 이동시킵니다.
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_hand_mut()
//                 .add_card(cards, Box::new(TopInsert))
//                 .map_err(|_| GameError::InternalServerError)?;

//             // 멀리건 상태를 "완료" 상태로 변경합니다.
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .confirm_selection();

//             // 그런 뒤, 선택한 카드들을 반환합니다.
//             Ok(selected_cards)
//         }

//         pub fn check_player_ready_state<T: Into<PlayerType> + Copy>(&self, player_type: T) -> bool {
//             let player_type = player_type.into();
//             self.get_player_by_type(player_type.reverse())
//                 .get()
//                 .get_mulligan_state_mut()
//                 .is_ready()
//         }
//     }
// }
</file>

<file path="simulator_core/src/server/actor/connection.rs">
use std::time::{Duration, Instant};

use actix::{
    fut::wrap_future, Actor, ActorContext, Addr, AsyncContext, Context, Handler, Running,
    StreamHandler,
};
use actix_ws::{CloseCode, CloseReason, Message, ProtocolError, Session};
use messages::GameEvent;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
    game::{
        message::{HandleUserAction, RegisterConnection},
        GameActor,
    },
    server::actor::ServerMessage,
};

use super::{messages, UserAction};

/// WebSocket 연결을 관리하는 Actor
pub struct ConnectionActor {
    ws_session: Session,        // 웹소켓 세션 제어
    game_addr: Addr<GameActor>, // 연결된 GameActor 주소
    player_type: PlayerKind,

    last_pong: Instant,
    player_id: Uuid,       // 이 연결의 플레이어 ID
    cleanup_started: bool, // 중복 정리를 방지하기 위한 플래그
    initial_pong_received: bool,
}

impl ConnectionActor {
    /// ConnectionActor의 새 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `session` - 이 액터가 관리할 웹소켓 세션 객체.
    /// * `game_addr` - 이 플레이어가 참여하는 게임을 관리하는 GameActor의 주소.
    /// * `session_id` - 이 연결에 해당하는 플레이어의 고유 식별자.
    /// * `session_manager` - 세션 타임아웃 및 정리를 관리하는 PlayerSessionManager.
    ///
    /// # Returns
    ///
    /// 새로운 ConnectionActor 인스턴스를 반환합니다.
    pub fn new(
        session: Session,
        game_addr: Addr<GameActor>,
        player_id: Uuid,
        player_type: PlayerKind,
    ) -> Self {
        Self {
            ws_session: session,
            game_addr,
            player_id,
            last_pong: Instant::now(),
            player_type,
            cleanup_started: false,
            initial_pong_received: false,
        }
    }

    fn start_heartbeat_check(&self, ctx: &mut Context<Self>) {
        ctx.run_interval(Duration::from_secs(HEARTBEAT_INTERVAL), |act, ctx_inner| {
            if Instant::now().duration_since(act.last_pong) > Duration::from_secs(CLIENT_TIMEOUT) {
                warn!(
                    "Heartbeat timeout for player {:?} (session_id: {}). Closing connection.",
                    act.player_type, act.player_id
                );
                let session_to_close = act.ws_session.clone();
                ctx_inner.spawn(wrap_future::<_, Self>(async move {
                    let _ = session_to_close
                        .close(Some(CloseReason::from(CloseCode::Policy)))
                        .await;
                }));
                ctx_inner.stop();
                return;
            }

            // 1. Ping 작업을 Context::spawn을 사용하여 비동기로 실행
            info!(
                "Spawning heartbeat ping task for player {:?} (session_id: {})",
                act.player_type, act.player_id
            );

            let mut session_clone = act.ws_session.clone();
            let player_type_log = act.player_type;
            let session_id_log = act.player_id;

            // 2. 비동기 블록을 직접 spawn
            ctx_inner.spawn(wrap_future::<_, Self>(async move {
                if let Err(e) = session_clone.ping(b"heartbeat").await {
                    error!(
                        "Failed to send ping to player {:?} (session_id: {}): {:?}",
                        player_type_log, session_id_log, e
                    );
                } else {
                    info!(
                        "Ping sent successfully to player {:?} (session_id: {})",
                        player_type_log, session_id_log
                    );
                }
            }));
        });
    }

    fn start_cleanup_task(&mut self) {
        if self.cleanup_started {
            return;
        }
        self.cleanup_started = true;

        let player_clone = self.player_type;
        let sid_clone = self.player_id;
        let ws_session_clone = self.ws_session.clone();

        tokio::spawn(async move {
            ws_session_clone.close(None).await.unwrap_or_else(|e| {
                error!(
                    "Failed to close WebSocket session for player {:?} (session_id: {}): {:?}",
                    player_clone, sid_clone, e
                );
            });
            info!(
                "Session cleanup task completed: player={:?}, session_id={}",
                player_clone, sid_clone
            );
        });
    }
}

impl Actor for ConnectionActor {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Context<Self>) {
        info!("ConnectionActor started for player {}", self.player_id);

        self.start_heartbeat_check(ctx);

        let player_type_log = self.player_type;
        let session_id_log = self.player_id;
        let mut session_clone = self.ws_session.clone();
        let init_msg = ServerMessage::HeartbeatConnected {
            player: self.player_type.to_string(),
            session_id: self.player_id,
        }
        .to_json();

        // 비동기 작업을 정의하는 Future 생성
        let send_future = async move {
            if let Err(e) = session_clone.text(init_msg).await {
                error!(
                    "Failed to send initial heartbeat_connected message to player {:?} (session_id: {}): {:?}",
                    player_type_log, session_id_log, e
                );
            } else {
                info!(
                    "Sent initial heartbeat_connected message to player {:?} (session_id: {})",
                    player_type_log, session_id_log
                );
            }
        };

        // 표준 Future를 ActorFuture로 감싸서 액터 컨텍스트에서 실행
        ctx.spawn(wrap_future::<_, Self>(send_future));
    }

    fn stopping(&mut self, _ctx: &mut Context<Self>) -> Running {
        // TODO: 필요시 GameActor에게 연결 종료 알림
        // self.game_addr.do_send(ClientDisconnected { session_id: self.session_id });
        info!(
            "ConnectionActor stopping for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );
        self.start_cleanup_task();

        Running::Stop
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        info!(
            "ConnectionActor stopped for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );
    }
}

impl StreamHandler<Result<Message, ProtocolError>> for ConnectionActor {
    fn handle(&mut self, msg: Result<Message, ProtocolError>, ctx: &mut Context<Self>) {
        debug!(
            "ConnectionActor received message from player {:?} (session_id: {}): {:?}",
            self.player_type, self.player_id, msg
        );
        match msg {
            Ok(Message::Ping(ping_msg)) => {
                info!(
                    "ConnectionActor received Ping (handled by HeartbeatActor?) for {}",
                    self.player_id
                );
                self.last_pong = Instant::now();

                let player_type_log = self.player_type;
                let session_id_log = self.player_id;
                let mut session_clone = self.ws_session.clone();

                let send_future = async move {
                    if let Err(e) = session_clone.pong(&ping_msg).await {
                        error!(
                            "Failed to send initial heartbeat_connected message to player {:?} (session_id: {}): {:?}",
                            player_type_log, session_id_log, e
                        );
                    } else {
                        info!(
                            "Sent initial heartbeat_connected message to player {:?} (session_id: {})",
                            player_type_log, session_id_log
                        );
                    }
                };

                ctx.spawn(wrap_future::<_, Self>(send_future));

                info!(
                    "Received Ping from player {:?} (session_id: {})",
                    self.player_type, self.player_id
                );
            }
            Ok(Message::Pong(_)) => {
                self.last_pong = Instant::now();
                info!(
                    "Received Pong from player {:?} (session_id: {})",
                    self.player_type, self.player_id
                );

                if !self.initial_pong_received {
                    self.initial_pong_received = true;
                    info!(
                        "Initial Pong received from player {:?} (session_id: {})",
                        self.player_type, self.player_id
                    );

                    // 첫 번째 Pong 수신이 되었다면, 양방향 수신이 수립된 것이므로, 다음 단계로 진행함.
                    // GameActor에게 자신을 등록 (Context<Self>의 address() 사용)
                    self.game_addr.do_send(RegisterConnection {
                        player_id: self.player_id,
                        addr: ctx.address(),
                    });
                }
            }
            Ok(Message::Close(reason)) => {
                info!(
                    "ConnectionActor received Close (handled by HeartbeatActor) for {}: {:?}",
                    self.player_id, reason
                );
                ctx.stop();
            }

            // Text 메시지만 처리
            Ok(Message::Text(text)) => {
                match serde_json::from_str::<UserAction>(&text.to_string()) {
                    Ok(user_action) => {
                        info!(
                            "ConnectionActor forwarding action from {}: {:?}",
                            self.player_id, user_action
                        );
                        // GameActor에게 메시지 전달
                        self.game_addr.do_send(HandleUserAction {
                            player_id: self.player_id,
                            action: user_action,
                        });
                    }
                    Err(e) => {
                        error!(
                            "ConnectionActor failed to parse UserAction from {}: {}, error: {}",
                            self.player_id, text, e
                        );
                        let error_msg = format!("{{\"error\": \"Invalid message format: {}\"}}", e);
                        // 에러 메시지 전송 시도 (비동기 처리 필요)
                        let mut session_clone = self.ws_session.clone();
                        let session_id_log = self.player_id;
                        ctx.spawn(wrap_future::<_, Self>(async move {
                            if let Err(e) = session_clone.text(error_msg).await {
                                error!(
                                    "ConnectionActor failed to send error text to {}: {:?}",
                                    session_id_log, e
                                );
                            }
                        }));
                    }
                }
            }
            Ok(Message::Binary(_)) => {
                warn!(
                    "ConnectionActor received unexpected Binary message from {}",
                    self.player_id
                );
                // 필요한 경우 처리
            }
            Err(e) => {
                error!(
                    "ConnectionActor websocket error for player {}: {}",
                    self.player_id, e
                );
                ctx.stop(); // 에러 발생 시 액터 중지
            }
            _ => (),
        }
    }

    // 스트림 종료 시 호출됨
    fn finished(&mut self, ctx: &mut Context<Self>) {
        info!(
            "ConnectionActor websocket Stream finished for player {}, stopping actor.",
            self.player_id
        );
        ctx.stop();
    }
}

// GameActor로부터 오는 GameEvent 처리
impl Handler<GameEvent> for ConnectionActor {
    type Result = ();

    fn handle(&mut self, msg: GameEvent, ctx: &mut Context<Self>) {
        match serde_json::to_string(&msg) {
            Ok(json_string) => {
                info!(
                    "ConnectionActor sending event to client {}: {}",
                    self.player_id, json_string
                );
                // 세션을 통해 text 메시지 전송 (비동기 처리)
                let mut session_clone = self.ws_session.clone();
                let session_id_log = self.player_id;
                ctx.spawn(wrap_future::<_, Self>(async move {
                    if let Err(e) = session_clone.text(json_string).await {
                        error!(
                            "ConnectionActor failed to send text event to {}: {:?}",
                            session_id_log, e
                        );
                        // 실패 시 액터 중지 등의 추가 처리 고려
                    }
                }));
            }
            Err(e) => {
                error!(
                    "ConnectionActor failed to serialize GameEvent for player {}: {}",
                    self.player_id, e
                );
            }
        }
    }
}
</file>

<file path="simulator_core/src/server/actor/messages.rs">
use actix::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::exception::GameError;

use super::{
    connection::ConnectionActor,
    types::{GameStateSnapshot, PlayerInputRequest},
};

#[derive(Message, Serialize, Deserialize, Debug, Clone)]
#[rtype(result = "()")]
pub enum GameEvent {
    GameStateUpdate(GameStateSnapshot),
    RequestPlayerInput(PlayerInputRequest),
    GameOver { winner: Uuid },
}
#[derive(Message, Deserialize, Debug, Clone)]
#[rtype(result = "Result<(), GameError>")]
pub struct SendMulliganDealCards {
    pub cards: Vec<Uuid>,
}
impl Handler<SendMulliganDealCards> for ConnectionActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: SendMulliganDealCards, _: &mut Self::Context) -> Self::Result {
        todo!()
    }
}
</file>

<file path="simulator_core/src/server/actor/mod.rs">
use serde::{Deserialize, Serialize};
use types::PlayerInputResponse;
use uuid::Uuid;

pub mod connection;
pub mod messages;
pub mod types;

#[derive(Deserialize, Debug, Clone)]
#[serde(tag = "action")]
pub enum UserAction {
    #[serde(rename = "rerollRequestMulliganCard")]
    RerollRequestMulliganCard { card_id: Vec<Uuid> },
    #[serde(rename = "completeMulligan")]
    CompleteMulligan,
    #[serde(rename = "playCard")]
    PlayCard {
        card_id: Uuid,
        target_id: Option<Uuid>,
    },
    #[serde(rename = "attack")]
    Attack {
        attacker_id: Uuid,
        defender_id: Uuid,
    },
    #[serde(rename = "endTurn")]
    EndTurn,
    #[serde(rename = "submitInput")]
    SubmitInput {
        request_id: Uuid,
        #[serde(flatten)]
        response_data: PlayerInputResponse,
    },
}

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(tag = "type")]
pub enum ServerMessage {
    #[serde(rename = "heartbeat_connected")]
    HeartbeatConnected { player: String, session_id: Uuid },
    #[serde(rename = "mulligan_deal")]
    MulliganDealCards { player: String, cards: Vec<Uuid> },
}

impl ServerMessage {
    pub fn to_json(&self) -> String {
        match self {
            ServerMessage::HeartbeatConnected { player, session_id } => serde_json::json!({
                "type": "heartbeat_connected",
                "player": player,
                "session_id": session_id.to_string()
            })
            .to_string(),
            ServerMessage::MulliganDealCards { player, cards } => todo!(),
        }
    }
}
</file>

<file path="simulator_core/src/server/actor/types.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GameStateSnapshot {
    pub current_phase: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PlayerInputRequest {
    pub request_id: Uuid,
    pub input_type: PlayerInputType,
    pub options: Vec<String>,
    pub message: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerInputType {
    SelectCardFromHand,
    SelectTargetOnField,
    ChooseEffect,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerInputResponse {
    MulliganRerollAnswer(Vec<Uuid>),
    CardSelection(Vec<Uuid>),
    TargetSelection(Uuid),
    EffectChoice(String),
}
</file>

<file path="simulator_core/src/server/helper.rs">
use std::time::Duration;

use actix_ws::Session;
use serde::de::DeserializeOwned;
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    exception::{GameError, MessageProcessResult},
    serialize_error,
};

use super::jsons::{game_features, Message};

/// 에러 메시지 전송 매크로
/// - 세션을 통해 에러 메시지를 전송하고, 전송 성공 여부를 반환합니다.
/// - retry 키워드를 사용하면 최대 재시도 횟수를 지정할 수 있습니다.
#[macro_export]
macro_rules! try_send_error {
    ($session:expr, $error:expr) => {
        if send_error_and_check(&mut $session, $error).await == Some(()) {
            break;
        }
    };

    ($session:expr, $error:expr, retry) => {
        match send_error_and_check(&mut $session, $error).await {
            Some(()) => break,
            None => {
                // 재시도 로직
                let retry_result = send_error_and_check(&mut $session, $error).await;
                if retry_result == Some(()) {
                    break;
                }
            }
        }
    };

    ($session:expr, $error:expr, retry $max_retries:expr) => {{
        let mut retries = 0;
        loop {
            match send_error_and_check(&mut $session, $error).await {
                Some(()) => break,
                None => {
                    retries += 1;
                    if retries >= $max_retries {
                        // 로깅 또는 다른 실패 처리
                        // log::warn!("Failed to send error after {} retries", $max_retries);
                        break;
                    }
                    tokio::time::sleep(std::time::Duration::from_millis(100)).await;
                }
            }
        }
    }};
}

/// 에러 메시지를 전송하고, 전송 성공 여부를 반환합니다.
/// # return
/// - 성공 시 Some(())
/// - 실패 시 None
pub async fn send_error_and_check(session: &mut Session, error_msg: GameError) -> Option<()> {
    // 에러 메시지 직렬화
    let Ok(error_json) = serialize_error!(error_msg) else {
        return None; // 직렬화 실패
    };

    // 메시지 전송
    match session.text(error_json).await {
        Ok(_) => Some(()),
        Err(_) => None,
    }
}

pub struct MessageHandler {
    unexpected_msg_count: usize,
    parsing_error_count: usize,
}

impl MessageHandler {
    pub fn new() -> Self {
        Self {
            unexpected_msg_count: 0,
            parsing_error_count: 0,
        }
    }

    /// 메시지 처리 시도 및 에러 카운트 관리
    pub async fn process_message<T: Message + DeserializeOwned>(
        &mut self,
        session: &mut Session,
        json: &str,
        session_id: Uuid,
        player_type: PlayerKind,
    ) -> MessageProcessResult<T> {
        // 반환 값이 Ok면 계속, Err면 함수를 종료해야 함
        let parse_result = serde_json::from_str::<serde_json::Value>(json);
        if let Err(e) = parse_result {
            // JSON 구문 자체가 잘못됨 (파싱 실패)
            return self
                .handle_parse_error(session, json, e, session_id, player_type)
                .await;
        }

        // 만약 System Message 인 경우,
        match serde_json::from_str::<game_features::ClientMessage>(json) {
            Ok(data) => {
                self.reset_counters();
                return MessageProcessResult::SystemHandled(data);
            }
            Err(_) => {}
        };

        match serde_json::from_str::<T>(json) {
            Ok(data) => {
                // 성공 시 카운터 초기화
                self.reset_counters();
                MessageProcessResult::Success(data)
            }
            Err(e) => {
                self.handle_unexpected_message(session, session_id, player_type)
                    .await
            }
        }
    }

    /// 파싱 에러 처리
    async fn handle_parse_error<T>(
        &mut self,
        session: &mut Session,
        json: &str,
        error: serde_json::Error,
        session_id: Uuid,
        player_type: PlayerKind,
    ) -> MessageProcessResult<T> {
        self.parsing_error_count += 1;

        // 로그 출력
        // log::warn!(
        //     "JSON parsing error: {}, attempt: {}/3, received: {}",
        //     error, self.parsing_error_count, json
        // );

        if self.parsing_error_count >= 3 {
            self.terminate_session(session, GameError::ParseError, session_id, player_type)
                .await;
            return MessageProcessResult::TerminateSession(GameError::ParseError);
        }

        MessageProcessResult::NeedRetry
    }

    /// 예상치 못한 메시지 처리
    async fn handle_unexpected_message<T>(
        &mut self,
        session: &mut Session,
        session_id: Uuid,
        player_type: PlayerKind,
    ) -> MessageProcessResult<T> {
        self.unexpected_msg_count += 1;

        if self.unexpected_msg_count >= 3 {
            self.terminate_session(session, GameError::InvalidApproach, session_id, player_type)
                .await;
            return MessageProcessResult::TerminateSession(GameError::UnexpectedMessage);
        }

        MessageProcessResult::NeedRetry
    }

    /// 세션 종료 처리
    async fn terminate_session(
        &self,
        session: &mut Session,
        error: GameError,
        session_id: Uuid,
        player_type: PlayerKind,
    ) {
        // 에러 메시지 전송 (최대 3회 시도)
        self.send_error_with_retry(session, error).await;
    }

    /// 에러 메시지 전송 (재시도 로직 포함)
    async fn send_error_with_retry(&self, session: &mut Session, error: GameError) -> bool {
        if let Ok(error_json) = serialize_error!(error) {
            for attempt in 0..3 {
                match session.text(error_json.clone()).await {
                    Ok(_) => return true,
                    Err(err) if attempt < 2 => {
                        // log::warn!("Failed to send error, retry {}/3: {}", attempt + 1, err);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                    Err(err) => {
                        // log::error!("Failed to send error after 3 attempts: {}", err);
                        return false;
                    }
                }
            }
        }
        false
    }

    /// 카운터 초기화
    fn reset_counters(&mut self) {
        self.unexpected_msg_count = 0;
        self.parsing_error_count = 0;
    }
}
</file>

<file path="simulator_core/src/server/mod.rs">
pub mod actor;
pub mod end_point;
pub mod helper;
pub mod input_handler;
pub mod jsons;
pub mod types;
</file>

<file path="simulator_core/src/server/types.rs">
use actix::Addr;
use uuid::Uuid;

use crate::{card::cards::Cards, game::GameActor};

pub struct ServerState {
    pub game: Addr<GameActor>,
    pub player1_id: Uuid,
    pub player2_id: Uuid,
}

impl ServerState {
    pub async fn reset(&self) {
        todo!()
    }

    pub fn new() -> Self {
        Self {
            game: todo!(),
            player1_id: todo!(),
            player2_id: todo!(),
        }
    }
}

pub trait ValidationPayload {
    fn validate(&self, cards: &Cards) -> Option<()>;
}
</file>

<file path="simulator_core/src/test/mod.rs">
use std::{
    io::Read,
    net::{SocketAddr, TcpListener},
    time::Duration,
};

use actix::Actor;
use async_tungstenite::tungstenite::{self, error::UrlError, http::Request, Message};
use ctor::ctor;
use futures::SinkExt;
use futures_util::StreamExt;
use rand::{seq::SliceRandom, thread_rng};
use serde::de::DeserializeOwned;
use serde_json::{json, Value};
use tracing::info;
use url::Url;
use uuid::Uuid;

use crate::{
    card::{types::PlayerKind, Card},
    card_gen::CardGenerator,
    enums::{CARD_JSON_PATH, HEARTBEAT_INTERVAL, MAX_CARD_SIZE},
    game::GameActor,
    server::{
        end_point::game,
        jsons::{draw, mulligan, ErrorMessage},
        types::ServerState,
    },
    setup_logger,
    utils::{json, parse_json_to_deck_code},
    VecStringExt,
};

pub fn generate_random_deck_json() -> (Value, Vec<Card>) {
    // 카드 JSON 파일 로드
    let file_path = CARD_JSON_PATH;
    let mut file = std::fs::File::open(file_path).expect("Failed to open cards.json");
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let cards: Vec<json::CardJson> =
        serde_json::from_str(&json_data).expect("Failed to parse JSON");

    let mut rng = thread_rng();
    let selected_cards: Vec<json::CardJson> = cards
        .into_iter()
        .filter(|card| card.collectible == Some(true))
        .collect::<Vec<_>>()
        .choose_multiple(&mut rng, MAX_CARD_SIZE)
        .cloned()
        .collect();

    // 선택된 카드로 덱 JSON 생성
    let deck_json = json!({
        "decks": [{
            "Hero": [{
                "name": "player1"
            }],
            "cards": selected_cards.iter().map(|card| {
                json!({
                    "id": card.id.clone(),
                    "num": 1
                })
            }).collect::<Vec<_>>()
        }]
    });

    // 원본 카드 정보 저장
    let card_generator = CardGenerator::new();
    let original_cards: Vec<Card> = selected_cards
        .iter()
        .map(|card| card_generator.gen_card_by_id_string(card.id.clone().unwrap(), card, 0))
        .collect();
    (deck_json, original_cards)
}

use actix_web::{
    dev::ServerHandle,
    web::{self, Data},
    App, HttpServer,
};

pub fn create_server_state() -> web::Data<ServerState> {
    let (deck_json, _original_cards) = generate_random_deck_json();
    let (deck_json2, _) = generate_random_deck_json();

    let deck_codes = parse_json_to_deck_code(Some(deck_json), Some(deck_json2))
        .expect("Failed to parse deck code");

    let player1_id = Uuid::new_v4();
    let player2_id = Uuid::new_v4();

    let game_actor = GameActor::create(|ctx| {
        let game_actor =
            GameActor::new(Uuid::new_v4(), player1_id, player2_id, PlayerKind::Player1);

        game_actor
    });

    web::Data::new(ServerState {
        game: game_actor,
        player1_id: player1_id,
        player2_id: player2_id,
    })
}

pub async fn spawn_server() -> (SocketAddr, Data<ServerState>, ServerHandle) {
    let server_state = create_server_state();
    let server_state_clone = server_state.clone();
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();

    let server = HttpServer::new(move || App::new().app_data(server_state.clone()).service(game))
        .listen(listener)
        .unwrap()
        .run();

    let handle = server.handle();
    tokio::spawn(server);

    (addr, server_state_clone, handle)
}

/// ws_stream 에서 Deal 메시지를 기다리고 파싱하여 카드 리스트를 반환합니다.
pub async fn expect_mulligan_deal_message(
    ws_stream: &mut async_tungstenite::WebSocketStream<
        async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
    >,
) -> Vec<Uuid> {
    let timeout = tokio::time::timeout(Duration::from_secs(5),
async{
    loop{
        if let Some(msg) = ws_stream.next().await{
            match msg{
                Ok(Message::Text(text)) => {
                    match serde_json::from_str::<mulligan::ServerMessage>(&text) {
                        Ok(mulligan::ServerMessage::Deal(data)) => {
                            return data.cards
                        }
                        Ok(other) => panic!(
                            "Expected a MulliganMessage::Deal message, but received a different variant: {:?}",
                            other
                        ),
                        Err(e) => panic!("Failed to parse the deal message JSON: {:?}", e),
                    }
                },
                Ok(Message::Ping(_)) => {
                    ws_stream.send(Message::Pong(vec![])).await.ok();
                    continue;
                },
                Ok(_) => continue,
                Err(_) => panic!("WebSocket error"),
            }
        }
    }
}).await;
    match timeout {
        Ok(cards) => cards.to_vec_uuid().expect("Failed to parse card UUID"),
        Err(_) => panic!(
            "Did not receive any message from the server while expecting MulliganMessage::Deal."
        ),
    }
}

/// ws_stream 에서 Complete 메시지를 기다리고 파싱하여 카드 리스트를 반환합니다.
pub async fn expect_mulligan_complete_message(
    ws_stream: &mut async_tungstenite::WebSocketStream<
        async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
    >,
) -> Vec<Uuid> {
    // 타임아웃 설정
    let timeout = tokio::time::timeout(
        std::time::Duration::from_secs(5),
        async {
            // 원하는 메시지가 올 때까지 계속 메시지를 받습니다
            loop {
                if let Some(msg) = ws_stream.next().await {
                    match msg {
                        Ok(Message::Text(text)) => {
                            match serde_json::from_str::<mulligan::ClientMessage>(&text) {
                                Ok(mulligan::ClientMessage::Complete(data)) => {
                                    return data.cards
                                }
                                Ok(other) => panic!(
                                    "Expected a MulliganMessage::Complete message, but received a different variant: {:?}",
                                    other
                                ),
                                Err(e) => panic!("Failed to parse the reroll answer JSON: {:?}", e),
                            }
                        }
                        // ping, pong, binary 등 다른 메시지 타입은 무시
                        Ok(Message::Ping(_)) => {
                            // ping 메시지에 자동으로 pong 응답
                            ws_stream.send(Message::Pong(vec![])).await.ok();
                            continue;
                        }
                        Ok(_) => continue,
                        Err(_) => panic!("WebSocket error"),
                    }
                }
            }
        }
    ).await;

    match timeout {
        Ok(cards) => cards.to_vec_uuid().expect("Failed to parse card UUID"),
        Err(_) => panic!("Did not receive any message from the server while expecting MulliganMessage::Complete."),
    }
}

pub fn verify_mulligan_cards(
    server_state: &ServerState,
    player_type: PlayerKind,
    rerolled_cards: &[Uuid],
    deal_cards: Option<&[Uuid]>,
    reroll_count: usize,
) {
    todo!()
    // let game = server_state.game.try_lock().unwrap();
    // let player = game.get_player_by_type(player_type).get();
    // let deck_cards = player.get_deck().get_cards();

    // // 덱 크기 검증
    // if deck_cards.len() != 25 {
    //     panic!(
    //         "Mulligan error: Wrong deck size. expected: {}, Got: {}",
    //         25,
    //         deck_cards.len()
    //     );
    // }

    // // 뽑은 카드가 덱에 없는지 확인
    // for card in rerolled_cards {
    //     if deck_cards.contains_uuid(card.clone()) {
    //         panic!(
    //             "Mulligan error (reroll_count = {}): Rerolled card {:?} should not be present in deck",
    //             reroll_count, card
    //         );
    //     }
    // }

    // // RerollRequest 경우 이전 카드가 덱에 복원되었는지 확인
    // if let Some(cards) = deal_cards {
    //     for card in cards {
    //         if !deck_cards.contains_uuid(card.clone()) {
    //             panic!(
    //                 "Mulligan restore error (reroll_count = {}): Restored card {:?} not found in deck",
    //                 reroll_count, card
    //             );
    //         }
    //     }
    // }
}

pub struct RequestTest {
    pub response: String,
}

impl RequestTest {
    pub async fn connect(
        step: &str,
        addr: SocketAddr,
        cookie: String,
    ) -> Result<Self, reqwest::Error> {
        let client = reqwest::Client::new();
        let response = client
            .get(format!("http://{}/{}", addr, step))
            .header("Cookie", cookie)
            .send()
            .await?;

        Ok(RequestTest {
            response: response.text().await.expect("Failed to get response"),
        })
    }

    /// 특정 타입의 메세지를 예상합니다. 예상한 메세지가 아닌 경우, panic! 합니다.
    pub fn expect_message<T, F, R>(&mut self, extractor: F) -> R
    where
        T: DeserializeOwned,
        F: Fn(T) -> R,
    {
        info!("Response: {}", self.response);
        let msg = serde_json::from_str::<T>(self.response.as_str())
            .expect("Failed to parse JSON (expect_message)");
        extractor(msg)
    }
}

//-------------------------------
// Draw 관련 함수
//-------------------------------
impl RequestTest {
    /// Draw-Answer 메시지를 예상하고 카드 Uuid 를 반환합니다
    pub fn expect_draw_card(&mut self) -> Uuid {
        let extractor = |message: draw::ServerMessage| match message {
            draw::ServerMessage::DrawAnswer(data) => {
                data.cards.parse().unwrap_or_else(|e| {
                    // TODO: Log 함수 사용
                    panic!("Failed to parse card ID: {:?}", e);
                })
            }
        };
        self.expect_message(extractor)
    }

    /// Error 메시지를 예상합니다.
    pub fn expect_error(&mut self) -> String {
        let extractor = |message: ErrorMessage| match message {
            ErrorMessage::Error(data) => data.message,
        };
        self.expect_message(extractor)
    }
}

pub struct WebSocketTest {
    pub stream: futures_util::stream::SplitStream<
        async_tungstenite::WebSocketStream<
            async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
        >,
    >,
    pub sink: futures_util::stream::SplitSink<
        async_tungstenite::WebSocketStream<
            async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
        >,
        Message,
    >,
}
//-------------------------------
// WebSocketTest 구현
//-------------------------------

impl WebSocketTest {
    pub async fn connect(url: String, cookie: String) -> Result<Self, tungstenite::Error> {
        // ... (connect 로직은 이전과 동일) ...
        let mut url = Url::parse(&url).unwrap();
        if url.scheme() == "http" {
            url.set_scheme("ws").unwrap()
        } else if url.scheme() != "ws" && url.scheme() != "wss" {
            return Err(tungstenite::Error::Url(UrlError::UnsupportedUrlScheme));
        }

        let host = url
            .host_str()
            .ok_or(tungstenite::Error::Url(UrlError::EmptyHostName))?;
        let host_header = if let Some(port) = url.port() {
            format!("{}:{}", host, port)
        } else {
            host.to_string()
        };

        let request = Request::builder()
            .uri(url.as_str())
            .header("Cookie", cookie)
            .header("Host", host_header)
            .header(
                "Sec-WebSocket-Key",
                tungstenite::handshake::client::generate_key(),
            )
            .header("Upgrade", "websocket")
            .header("Connection", "Upgrade")
            .header("Sec-WebSocket-Version", "13")
            .body(())?;

        let (ws_stream, response) = async_tungstenite::tokio::connect_async(request).await?;

        assert_eq!(
            response.status(),
            tungstenite::http::StatusCode::SWITCHING_PROTOCOLS
        );

        let (sink, stream) = ws_stream.split(); // 스트림과 싱크 분리

        Ok(Self { stream, sink }) // 분리된 스트림과 싱크 저장
    }

    pub async fn send(&mut self, msg: impl Into<Message>) -> Result<(), tungstenite::Error> {
        self.sink.send(msg.into()).await // 싱크를 통해 메시지 전송
    }

    pub async fn expect_message<T, F, R>(&mut self, extractor: F) -> R
    where
        T: DeserializeOwned,
        F: Fn(T) -> R,
    {
        let callback = async {
            loop {
                match self.stream.next().await {
                    Some(Ok(Message::Text(text))) => {
                        println!("Received message: {}", text);
                        if let Ok(parsed) = serde_json::from_str::<T>(&text) {
                            return extractor(parsed);
                        } else {
                            println!("Failed to parse into expected type: {}", text);
                            // 중요: 여기서 continue를 해야 다른 타입 메시지를 기다림
                            continue;
                        }
                    }
                    Some(Ok(Message::Ping(data))) => {
                        println!("Received ping, sending pong");
                        // 중요: Pong은 sink를 통해 보내야 함
                        if self.sink.send(Message::Pong(data)).await.is_err() {
                            // 에러 처리 필요
                            eprintln!("Failed to send Pong");
                        }
                    }
                    Some(Ok(Message::Pong(_))) => {
                        println!("Received Pong, ignoring.");
                        continue; // Pong은 무시하고 다음 메시지 기다림
                    }
                    Some(Ok(Message::Close(reason))) => {
                        panic!("WebSocket closed unexpectedly while waiting for specific message. Reason: {:?}", reason);
                    }
                    Some(Ok(msg)) => {
                        println!("Ignoring other message type: {:?}", msg);
                        continue; // 다른 메시지 타입 무시
                    }
                    Some(Err(e)) => panic!("WebSocket error: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly"),
                }
            }
        };
        // 타임아웃 시간은 HEARTBEAT_INTERVAL 보다 길게 설정
        match tokio::time::timeout(Duration::from_secs(HEARTBEAT_INTERVAL + 5), callback).await {
            Ok(result) => result,
            Err(_) => panic!(
                "Expected message timeout after {} seconds",
                HEARTBEAT_INTERVAL + 5
            ),
        }
    }
    /// 에러 메시지를 기다리고 에러 문자열을 반환합니다
    pub async fn expect_error(&mut self) -> String {
        let extractor = |message: ErrorMessage| match message {
            ErrorMessage::Error(data) => data.message,
        };
        self.expect_message(extractor).await
    }
}

#[ctor]
fn init() {
    setup_logger();
}
</file>

<file path="simulator_core/src/unit/player.rs">
use crate::{
    card::{cards::Cards, types::PlayerKind},
    selector::mulligan::MulliganState,
    zone::{deck::Deck, effect::Effect, field::Field, graveyard::Graveyard, hand::Hand},
    OptArc,
};

#[derive(Clone, Debug)]
pub struct Resoruce {
    cost: usize,
    limit: usize,
}

impl Resoruce {
    pub fn new(cost: usize, limit: usize) -> Resoruce {
        Resoruce { cost, limit }
    }
    pub fn is_empty(&self) -> bool {
        self.cost == 0
    }
    fn increase(&mut self) -> &mut Self {
        self.cost += 1;
        self
    }

    fn decrease(&mut self) -> &mut Self {
        self.cost -= 1;
        self
    }

    fn set(&mut self, cost: usize) -> &mut Self {
        self.cost = cost;
        self
    }

    fn get(&self) -> usize {
        self.cost
    }

    fn add(&mut self, cost: usize) {
        // TODO!!
        // 추가하고자 하는 리소스가 limit 을 넘어가는지 확인하고 제한해야됨.
        self.cost += cost;
    }
}

/// 플레이어를 행동, 상태 등을 다루는 구조체 입니다.
#[derive(Clone)]
pub struct Player {
    pub opponent: OptArc<Player>,
    player_type: PlayerKind,
    mulligan_state: MulliganState,
    cards: Cards,
    cost: Resoruce,
    mana: Resoruce,

    hand: Hand,
    deck: Deck,
    graveyard: Graveyard,
    effect: Effect,
    field: Field,
}

impl Player {
    pub fn new(
        opponent: OptArc<Player>,
        player_type: PlayerKind,
        cards: Cards,
        cost: Resoruce,
        mana: Resoruce,
    ) -> Player {
        Player {
            opponent,
            player_type,
            mulligan_state: MulliganState::new(),
            cards,
            hand: Hand::new(),
            deck: Deck::new(),
            graveyard: Graveyard::new(),
            effect: Effect::new(),
            field: Field::new(),
            cost,
            mana,
        }
    }

    pub fn get_mulligan_state_mut(&mut self) -> &mut MulliganState {
        &mut self.mulligan_state
    }

    pub fn get_player_type(&self) -> PlayerKind {
        self.player_type
    }

    pub fn get_opponent(&self) -> &OptArc<Player> {
        &self.opponent
    }

    pub fn get_cards(&self) -> &Cards {
        &self.cards
    }

    pub fn get_cost(&mut self) -> &mut Resoruce {
        &mut self.cost
    }

    pub fn get_mana(&mut self) -> &mut Resoruce {
        &mut self.mana
    }

    pub fn set_cards(&mut self, new_cards: Cards) {
        self.cards = new_cards;
    }

    pub fn set_cost(&mut self, cost: usize) {
        self.cost.set(cost);
    }

    pub fn set_mana(&mut self, cost: usize) {
        self.mana.set(cost);
    }
}

impl Player {
    pub fn get_hand_mut(&mut self) -> &mut Hand {
        &mut self.hand
    }

    pub fn get_deck_mut(&mut self) -> &mut Deck {
        &mut self.deck
    }

    pub fn get_graveyard_mut(&mut self) -> &mut Graveyard {
        &mut self.graveyard
    }

    pub fn get_effect_mut(&mut self) -> &mut Effect {
        &mut self.effect
    }

    pub fn get_field_mut(&mut self) -> &mut Field {
        &mut self.field
    }

    pub fn get_hand(&self) -> &Hand {
        &self.hand
    }

    pub fn get_deck(&self) -> &Deck {
        &self.deck
    }

    pub fn get_graveyard(&self) -> &Graveyard {
        &self.graveyard
    }

    pub fn get_effect(&self) -> &Effect {
        &self.effect
    }

    pub fn get_field(&self) -> &Field {
        &self.field
    }
}
</file>

<file path="simulator_core/src/utils/mod.rs">
pub mod json;

use crate::card::cards::Cards;
use crate::card::types::PlayerKind;
use crate::card::Card;
use crate::card_gen::{CardGenerator, Keys};
use crate::enums::*;
use crate::exception::GameError;
use base64::{decode, encode};
use byteorder::WriteBytesExt;
use serde_json::Value;
use std::fs::File;
use std::io::Read;
use std::io::{Cursor, Write};
use std::vec;
use uuid::Uuid;

pub fn generate_uuid() -> Result<Uuid, GameError> {
    let uuid = Uuid::new_v4();
    Ok(uuid)
}

pub fn read_game_config_json() -> Result<json::GameConfigJson, GameError> {
    let file_path = GAME_CONFIG_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: json::GameConfigJson = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(_) => return Err(GameError::JsonParseFailed),
    };

    Ok(card_json)
}

pub fn parse_json_to_deck_code(
    p1_card_json: Option<Value>,
    p2_card_json: Option<Value>,
) -> Result<(String, String), GameError> {
    match (&p1_card_json, &p2_card_json) {
        (None, None) => return Err(GameError::DecodeError),
        (None, Some(_)) => return Err(GameError::DeckCodeIsMissing(PlayerKind::Player1)),
        (Some(_), None) => return Err(GameError::DeckCodeIsMissing(PlayerKind::Player2)),
        _ => {}
    }

    fn parse_deck_json(
        json_value: Option<Value>,
        player_num: usize,
    ) -> Result<json::Decks, GameError> {
        if let Some(value) = json_value {
            serde_json::from_value(value).map_err(|_| GameError::JsonParseFailed)
        } else {
            let file_path = match player_num {
                PLAYER_1 => DECK_JSON_PATH_P1,
                PLAYER_2 => DECK_JSON_PATH_P2,
                _ => return Err(GameError::PathNotExist),
            };

            let mut file = File::open(file_path).map_err(|_| GameError::PathNotExist)?;
            let mut json_data = String::new();
            file.read_to_string(&mut json_data)
                .map_err(|_| GameError::JsonParseFailed)?;

            serde_json::from_str(&json_data).map_err(|_| GameError::JsonParseFailed)
        }
    }

    fn create_card_vector(decks: &json::Decks, keys: &Keys, num: i32) -> Vec<i32> {
        decks.decks[0]
            .cards
            .iter()
            .filter(|card| card.num == num)
            .filter_map(|card| keys.get_usize_by_string(&card.id))
            .collect()
    }

    fn generate_deck_code(
        player_num: usize,
        json_value: Option<Value>,
    ) -> Result<String, GameError> {
        let decks = parse_deck_json(json_value, player_num)?;
        let keys = Keys::new();

        // deckcode 에서 카드 1장 인 것과 2장 인 것을 따로 생성함.
        let card1 = create_card_vector(&decks, &keys, 1);
        let card2 = create_card_vector(&decks, &keys, 2);

        let dbf_hero = 930;
        let format = 2;

        Ok(deck_encode(card1, card2, dbf_hero, format))
    }

    // 두 플레이어의 덱 코드 생성
    let p1_code = generate_deck_code(PLAYER_1, p1_card_json)?;
    let p2_code = generate_deck_code(PLAYER_2, p2_card_json)?;

    Ok((p1_code, p2_code))
}

pub fn deckcode_to_cards(
    p1_deckcode: String,
    p2_deckcode: String,
) -> Result<Vec<Cards>, GameError> {
    // 거대한 json 파일을 읽는 방법 따로 구현해야댐
    // json 을 쌩으로 로드하면 좆댐;

    let file_path = CARD_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: Vec<json::CardJson> = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(_) => return Err(GameError::JsonParseFailed),
    };

    let decoded_deck1 = match deck_decode(p1_deckcode) {
        Ok(data) => data,
        Err(_err) => return Err(GameError::JsonParseFailed),
    };
    let decoded_deck2 = match deck_decode(p2_deckcode) {
        Ok(data) => data,
        Err(_err) => return Err(GameError::JsonParseFailed),
    };

    use json::CardJson;

    let card_genertor = CardGenerator::new();

    let mut p1_cards = vec![];
    let mut p2_cards = vec![];

    let check_values_exist = |card_data: &CardJson,
                              decoded_deck: &(Vec<i32>, Vec<i32>),
                              p_cards: &mut Vec<Card>|
     -> Result<(), GameError> {
        for dbfid in &decoded_deck.0 {
            match card_data.dbfid {
                Some(_dbfid) => {
                    if &_dbfid == dbfid {
                        p_cards.push(card_genertor.gen_card_by_id_i32(*dbfid, card_data, 1));
                    }
                }
                None => {}
            }
        }
        for dbfid in &decoded_deck.1 {
            match card_data.dbfid {
                Some(_dbfid) => {
                    if &_dbfid == dbfid {
                        p_cards.push(card_genertor.gen_card_by_id_i32(*dbfid, card_data, 2));
                    }
                }
                None => {}
            }
        }
        Ok(())
    };

    // player_cards 에는 플레이어의 덱 정보가 담겨있음.
    // 카드의 종류, 갯수만 있을 뿐, 실질적인 정보는 없고 카드의 id 만 있기 때문에 이것을 사용하여
    // cards.json 에서 데이터를 가져와야함.
    // println!("card_json: {:#?}", card_json);
    for card_data in card_json {
        check_values_exist(&card_data, &decoded_deck1, &mut p1_cards)?;
        check_values_exist(&card_data, &decoded_deck2, &mut p2_cards)?;
    }
    Ok(vec![p1_cards, p2_cards])
}

pub fn load_card_id() -> Result<Vec<(String, i32)>, GameError> {
    let file_path = CARD_ID_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: Vec<json::Item> = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(_) => return Err(GameError::JsonParseFailed),
    };

    let mut ids = vec![];

    for item in &card_json {
        ids.push((item.id.clone(), item.dbfid));
    }
    Ok(ids)
}

const DECK_CODE_VERSION: u32 = 1;
pub fn deck_decode(deck_code: String) -> Result<(Vec<i32>, Vec<i32>), ()> {
    let code = decode(deck_code).unwrap();
    let mut pos = 0;

    let read_varint = |pos: &mut usize| {
        let mut shift = 0;
        let mut result = 0;

        loop {
            if *pos >= code.len() {
                return Err(());
            }

            let ch = code[*pos] as usize;

            *pos += 1;

            result |= (ch & 0x7f) << shift;
            shift += 7;

            if (ch & 0x80) == 0 {
                break;
            }
        }
        return Ok(result);
    };

    if code[pos] as char != '\0' {
        println!("Invalid deck code");
        return Err(());
    }
    pos += 1;

    match read_varint(&mut pos) {
        Ok(version) => {
            if version as u32 != DECK_CODE_VERSION {
                println!("Version mismatch");
                return Err(());
            }
        }
        Err(_) => {
            println!("version err");
            return Err(());
        }
    }

    let format = read_varint(&mut pos);
    match format {
        Ok(_) => {}
        Err(_) => {
            println!("Invalid format type");
            return Err(());
        }
    }

    let num = read_varint(&mut pos);
    match num {
        Ok(data) => {
            if data != 1 {
                println!("Hero count must be 1");
                return Err(());
            }
        }
        Err(_) => return Err(()),
    }

    let hero_type = read_varint(&mut pos);
    let _hero_type = match hero_type {
        Ok(hero_id) => hero_id,
        Err(_) => {
            return Err(());
        }
    };

    //Deck deckInfo(format, hero->GetCardClass());
    let mut _1_cards = vec![];
    let mut _2_cards = vec![];

    // Single-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let card_id = read_varint(&mut pos).unwrap();
        _1_cards.push(card_id as i32);
    }

    // 2-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let card_id = read_varint(&mut pos).unwrap();
        _2_cards.push(card_id as i32);
        // deckInfo.AddCard(Cards::FindCardByDbfID(cardID)->id, 2);
    }

    // 하스스톤은 덱에서 같은 카드를 세 개 이상 구성하지 못함. ( 최대 2개 ) 근데 왜 n-copy 코드가 있는지는 잘 모르겠음..
    // n-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let _card_id = read_varint(&mut pos).unwrap();
        let _count = read_varint(&mut pos).unwrap();
        // deckInfo.AddCard(Cards::FindCardByDbfID(cardID)->id, count);
    }
    // println!("{:#?} {:#?}", _1_cards, _2_cards);
    Ok((_1_cards, _2_cards))
}

fn write_varint<W: Write>(writer: &mut W, mut value: usize) -> std::io::Result<()> {
    loop {
        let mut temp: u8 = (value & 0b01111111) as u8;
        value >>= 7;
        if value != 0 {
            temp |= 0b10000000;
        }
        writer.write_u8(temp)?;
        if value == 0 {
            break;
        }
    }
    Ok(())
}

fn deck_encode(deck1: Vec<i32>, deck2: Vec<i32>, dbf_hero: usize, format: usize) -> String {
    let mut baos = Cursor::new(Vec::new());

    write_varint(&mut baos, 0).unwrap(); // always zero
    write_varint(&mut baos, 1).unwrap(); // encoding version number
    write_varint(&mut baos, format).unwrap(); // standard = 2, wild = 1
    write_varint(&mut baos, 1).unwrap(); // number of heroes in heroes array, always 1
    write_varint(&mut baos, dbf_hero).unwrap(); // DBF ID of hero

    write_varint(&mut baos, deck1.len() as usize).unwrap(); // number of 1-quantity cards
    for dbf_id in &deck1 {
        write_varint(&mut baos, *dbf_id as usize).unwrap();
    }

    write_varint(&mut baos, deck2.len() as usize).unwrap(); // number of 2-quantity cards
    for dbf_id in &deck2 {
        write_varint(&mut baos, *dbf_id as usize).unwrap();
    }

    write_varint(&mut baos, 0).unwrap(); // the number of cards that have quantity greater than 2. Always 0 for constructed

    let deck_bytes = baos.into_inner();

    let deck_string = encode(&deck_bytes);

    deck_string
}
</file>

<file path="simulator_core/tests/test.rs">
pub mod mulligan {
    use actix::Addr;
    use simulator_core::{
        card::types::PlayerKind,
        enums::{ZoneType, COUNT_OF_MULLIGAN_CARDS},
        game::{message::GetPlayerZoneCards, GameActor},
        server::actor::ServerMessage,
        test::{spawn_server, WebSocketTest},
    };
    use tracing::info;
    use uuid::Uuid;

    // 플레이어별 테스트 로직을 위한 헬퍼 함수
    async fn player_mulligan_sequence(
        player_kind: PlayerKind,
        player_id: Uuid,
        addr: std::net::SocketAddr,
        game_actor_addr: Addr<GameActor>, // GameActor 주소 전달
    ) -> Vec<Uuid> {
        let player_kind_str = player_kind.as_str();
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player_id);
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 초기 HeartbeatConnected 메시지 수신
        println!(
            "[{}] Waiting for initial HeartbeatConnected message...",
            player_kind_str
        );
        let initial_extractor = |message: ServerMessage| match message {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, player_kind_str);
                assert!(!session_id.is_nil());
                println!(
                    "[{}] Initial HeartbeatConnected received. Session ID: {}",
                    player_kind_str, session_id
                );
            }
            _ => panic!(
                "[{}] Expected HeartbeatConnected as the first message, but got {:?}",
                player_kind_str, message
            ),
        };
        ws.expect_message(initial_extractor).await;

        // 2. MulliganDealCards 메시지 수신
        println!(
            "[{}] Waiting for MulliganDealCards message...",
            player_kind_str
        );
        let mulligan_extractor = |message: ServerMessage| -> Vec<Uuid> {
            match message {
                ServerMessage::MulliganDealCards { player, cards } => {
                    // 중요: MulliganDealCards 메시지의 player 필드가 이 카드를 받는 플레이어를 지칭해야 함
                    assert_eq!(
                        player, player_kind_str,
                        "[{}] Mulligan cards for wrong player",
                        player_kind_str
                    );
                    assert_eq!(
                        cards.len(),
                        COUNT_OF_MULLIGAN_CARDS,
                        "[{}] Incorrect number of mulligan cards",
                        player_kind_str
                    );
                    for card_uuid in &cards {
                        assert!(
                            !card_uuid.is_nil(),
                            "[{}] Nil UUID in mulligan cards",
                            player_kind_str
                        );
                    }
                    println!(
                        "[{}] MulliganDealCards received with {} cards.",
                        player_kind_str,
                        cards.len()
                    );
                    cards
                }
                // 이 시점에는 다른 메시지가 오면 안 됨 (HeartbeatConnected는 이미 처리됨)
                _ => panic!(
                    "[{}] Expected MulliganDealCards message, but got {:?}",
                    player_kind_str, message
                ),
            }
        };
        let dealt_cards = ws.expect_message(mulligan_extractor).await;

        // 3. 받은 카드가 덱에 없는지 확인 (GameActor에게 요청)
        println!(
            "[{}] Verifying dealt cards are not in deck...",
            player_kind_str
        );
        let deck_cards_result = game_actor_addr
            .send(GetPlayerZoneCards {
                // GameActor는 Uuid로 플레이어를 식별하거나, PlayerKind를 Uuid로 변환할 수 있어야 함
                zone: ZoneType::Deck,
                player_type: player_kind,
            })
            .await;

        match deck_cards_result {
            Ok(deck_card_objects) => {
                let deck_uuids: Vec<Uuid> = deck_card_objects
                    .iter()
                    .map(|card| card.get_uuid())
                    .collect();
                for dealt_card_uuid in dealt_cards.iter() {
                    assert!(
                        !deck_uuids.contains(dealt_card_uuid),
                        "[{}] Deck should not contain card {} that was dealt in mulligan",
                        player_kind_str,
                        dealt_card_uuid
                    );
                }
                println!(
                    "[{}] Dealt cards correctly removed from deck.",
                    player_kind_str
                );
            }
            Err(e) => panic!(
                "[{}] GameActor returned error getting deck cards: {:?}",
                player_kind_str, e
            ),
        }

        // 멀리건 단계 완료를 위해 추가적인 메시지 전송/수신 로직이 필요할 수 있음
        // 예: ws.send(UserAction::CompleteMulligan).await;
        //     ws.expect_message(ServerMessage::MulliganPhaseEnd).await;

        dealt_cards // 받은 카드 목록 반환
    }

    #[actix_web::test]
    async fn test_mulligan_deal_cards_to_each_player_concurrently() {
        let (addr, state, _handle) = spawn_server().await;
        let game_actor_addr = state.game.clone(); // AppServerState에 Addr<GameActor> 필드 추가 가정

        let player1_id = state.player1_id;
        let player2_id = state.player2_id;

        // 두 플레이어의 멀리건 시퀀스를 병렬로 실행
        let (p1_results, p2_results) = tokio::join!(
            player_mulligan_sequence(
                PlayerKind::Player1,
                player1_id,
                addr,
                game_actor_addr.clone()
            ),
            player_mulligan_sequence(
                PlayerKind::Player2,
                player2_id,
                addr,
                game_actor_addr.clone()
            )
        );

        println!("Player 1 mulligan cards: {:?}", p1_results);
        println!("Player 2 mulligan cards: {:?}", p2_results);

        // 추가 검증: P1과 P2가 받은 카드가 서로 다른지 등
        let mut all_dealt_cards = p1_results.clone();
        all_dealt_cards.extend(p2_results.clone());
        let unique_cards_count = all_dealt_cards
            .iter()
            .collect::<std::collections::HashSet<_>>()
            .len();
        assert_eq!(
            unique_cards_count,
            COUNT_OF_MULLIGAN_CARDS * 2,
            "Dealt cards between players are not unique."
        );

        info!("Test test_mulligan_deal_cards_to_each_player_concurrently completed.");
    }
}

pub mod heartbeat {
    use std::time::Duration;

    use async_tungstenite::tungstenite::Message;
    use futures::StreamExt;
    use simulator_core::{
        card::types::PlayerKind,
        enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
        server::actor::ServerMessage,
        test::{spawn_server, WebSocketTest},
    };
    use tokio::time::{sleep, timeout};
    use tracing::{info, warn};
    use uuid::Uuid;

    #[actix_web::test]
    async fn test_heartbeat_initialize_msg() {
        let (addr, state, _handle) = spawn_server().await;

        let player_type = PlayerKind::Player1.as_str();

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", state.player1_id);

        // 예시: 서버에 GET 요청 보내기
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        let extractor = |message: ServerMessage| match message {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, player_type);
                assert!(!session_id.is_nil());
            }
            _ => panic!("Expected HeartbeatConnected message"),
        };
        ws.expect_message(extractor).await;
    }

    #[actix_web::test]
    async fn test_heartbeat_timeout() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player_kind_str = PlayerKind::Player1.as_str();

        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 초기 연결 메시지 수신 (선택 사항)
        info!("Waiting for initial connection message...");
        let initial_extractor = |message: ServerMessage| -> Uuid {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert!(!session_id.is_nil());
                    info!(
                        "Initial connection message received. Session ID: {}",
                        session_id
                    );
                    session_id
                }
                _ => panic!("Expected HeartbeatConnected message"),
            }
        };
        // 초기 메시지를 기대하지만, 타임아웃되면 실패 처리
        if timeout(
            Duration::from_secs(HEARTBEAT_INTERVAL),
            ws.expect_message(initial_extractor),
        )
        .await
        .is_err()
        {
            panic!("Timeout waiting for initial HeartbeatConnected message.");
        }

        // 2. 서버의 Ping을 기다리지만 Pong으로 응답하지 않음
        info!("Waiting for Ping, but will not send Pong...");
        let ping_wait_result = timeout(Duration::from_secs(HEARTBEAT_INTERVAL * 2), async {
            loop {
                match ws.stream.next().await {
                    Some(Ok(Message::Ping(_))) => {
                        info!("Ping received, NOT sending Pong.");
                        break; // Ping을 받았으니 대기 종료
                    }
                    Some(Ok(Message::Text(t))) => {
                        info!("Received unexpected Text while waiting for Ping: {}", t);
                        continue; // 무시하고 계속 Ping 기다림
                    }
                    Some(Ok(_)) => continue, // 다른 메시지 무시
                    Some(Err(e)) => panic!("WebSocket error while waiting for Ping: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly while waiting for Ping"),
                }
            }
        })
        .await;

        if ping_wait_result.is_err() {
            panic!(
                "Timeout: Did not receive first Ping within {} seconds.",
                (HEARTBEAT_INTERVAL * 2)
            );
        }

        // 3. CLIENT_TIMEOUT + 약간의 여유 시간 동안 대기
        //    서버가 타임아웃으로 연결을 종료할 것으로 기대
        let wait_duration = Duration::from_secs(CLIENT_TIMEOUT + 5); // 타임아웃 + 여유 시간
        info!(
            "Waiting for {} seconds for server to close connection due to timeout...",
            wait_duration.as_secs()
        );

        let close_check_result = timeout(wait_duration, async {
            // 서버가 연결을 닫을 때까지 메시지를 읽으려고 시도
            loop {
                match ws.stream.next().await {
                    Some(Ok(Message::Close(reason))) => {
                        info!("Server closed connection as expected. Reason: {:?}", reason);
                        return true; // 서버가 닫음
                    }
                    Some(Ok(msg)) => {
                        // 타임아웃 기간 동안 다른 메시지가 오면 안 됨 (오류 가능성)
                        warn!("Received unexpected message during timeout wait: {:?}", msg);
                        continue; // 계속 대기
                    }
                    Some(Err(e)) => {
                        info!(
                            "WebSocket error during timeout wait (expected if closed): {:?}",
                            e
                        );
                        return true; // 에러 발생도 연결 종료 신호로 간주
                    }
                    None => {
                        info!("WebSocket stream ended (closed by server).");
                        return true; // 스트림 종료 = 연결 닫힘
                    }
                }
            }
        })
        .await;

        // 4. 결과 확인
        match close_check_result {
            Ok(true) => {
                info!("Test Success: Server closed the connection due to heartbeat timeout.");
            }
            Ok(false) => {
                // 루프가 값을 반환하지 않은 경우 (이론상 발생 안 함)
                panic!("Test Error: Timeout check loop finished unexpectedly.");
            }
            Err(_) => {
                panic!("Test Failed: Server did NOT close the connection after timeout period.");
            }
        }
    }

    #[actix_web::test]
    async fn test_heartbeat_ping_pong_once() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player_kind_str = PlayerKind::Player1.as_str();

        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 초기 연결 메시지 수신 (선택 사항이지만, 이전 테스트에서 확인했으므로 여기서도 확인)
        info!("Waiting for initial connection message...");
        let initial_extractor = |message: ServerMessage| -> Uuid {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert!(!session_id.is_nil());
                    info!(
                        "Initial connection message received. Session ID: {}",
                        session_id
                    );
                    session_id
                }
                _ => panic!("Expected HeartbeatConnected message first"),
            }
        };
        let _session_id = ws.expect_message(initial_extractor).await;

        // 2. 서버로부터 Ping 메시지 기다리기
        info!("Waiting for Ping message...");
        let ping_received = timeout(Duration::from_secs(HEARTBEAT_INTERVAL * 2), async {
            loop {
                match ws.stream.next().await {
                    Some(Ok(Message::Ping(ping_data))) => {
                        info!("Ping received!");
                        return Some(ping_data);
                    }
                    Some(Ok(Message::Text(text))) => {
                        info!("Received unexpected Text while waiting for Ping: {}", text);
                        continue;
                    }
                    Some(Ok(Message::Pong(_))) => {
                        info!("Received Pong while waiting for Ping, ignoring.");
                        continue;
                    }
                    Some(Ok(_)) => continue,
                    Some(Err(e)) => panic!("WebSocket error while waiting for Ping: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly while waiting for Ping"),
                }
            }
        })
        .await;

        // 3. Ping 수신 및 Pong 전송 확인
        match ping_received {
            Ok(Some(ping_data)) => {
                // Ping을 받았으므로 Pong 전송
                info!("Sending Pong response...");
                ws.send(Message::Pong(ping_data.clone()))
                    .await
                    .expect("Failed to send Pong");
                info!("Pong sent.");

                // 잠시 대기하여 서버가 Pong을 처리하고 연결을 유지하는지 확인
                info!("Waiting to see if connection is maintained...");
                sleep(Duration::from_secs(2)).await; // 짧은 시간 대기

                // 연결이 살아있는지 확인
                let test_msg = Message::Pong(ping_data);
                match ws.send(test_msg).await {
                    Ok(_) => info!("Connection seems alive after Pong."),
                    Err(e) => panic!("Connection seems closed after Pong: {:?}", e),
                }
            }
            Ok(None) => {
                // 루프가 값을 반환하지 않고 종료된 경우
                panic!("Ping waiting loop exited unexpectedly without returning Ping data.");
            }
            Err(_) => {
                panic!(
                    "Timeout: Did not receive Ping within {} seconds.",
                    (HEARTBEAT_INTERVAL * 2)
                );
            }
        }

        // 테스트 종료 (정상적으로 연결 종료)
        info!("Closing WebSocket connection.");
        ws.send(Message::Close(None)).await.ok(); // Close 메시지 전송 시도
    }
}
</file>

<file path="simulator_core/src/game/helper.rs">
#[macro_export]
macro_rules! downcast_effect {
    ($effect:expr, $target_type:ty) => {
        if $effect.get_effect_type() == <$target_type>::static_effect_type() {
            if let Some(specific) = $effect.as_any().downcast_ref::<$target_type>() {
                Some(specific)
            } else {
                None
            }
        } else {
            None
        }
    };
}
</file>

<file path="simulator_core/src/game/message.rs">
use actix::{Addr, AsyncContext, Context, Handler, Message, ResponseFuture};
use serde::Deserialize;
use tracing::{info, warn};
use uuid::Uuid;

use crate::{
    card::{cards::CardVecExt, insert::BottomInsert, take::RandomTake, types::PlayerKind, Card},
    enums::ZoneType,
    exception::GameError,
    game::phase::PlayerPhaseProgress,
    player::{
        message::{
            AddCardsToDeck, GetCardFromDeck, GetDeckCards, GetFieldCards, GetGraveyardCards,
            GetHandCards, GetMulliganDealCards,
        },
        PlayerActor,
    },
    selector::TargetCount,
    server::{
        actor::{
            connection::ConnectionActor, messages::SendMulliganDealCards,
            types::PlayerInputResponse, UserAction,
        },
        input_handler::{InputAnswer, InputRequest},
    },
    PlayerHashMapExt,
};

use super::{phase::Phase, GameActor, GameConfig};

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct InitializeGame(pub GameConfig);

#[derive(Message)]
#[rtype(result = "()")]
pub struct RegisterPlayer {
    pub player_type: PlayerKind,
    pub player_addr: Addr<PlayerActor>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct PlayerReady(pub PlayerKind);

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RequestPlayCard {
    pub player_type: PlayerKind,
    pub card_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct SubmitInput {
    pub player_type: PlayerKind,
    pub request_id: Uuid,
    pub answer: InputAnswer,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RequestInput {
    pub player_type: PlayerKind,
    pub request_id: Uuid,
    pub request: InputRequest,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct IsCorrectPhase {
    pub phase: Phase,
}

#[derive(Message)]
#[rtype(result = "Result<Vec<Card>, GameError>")]
pub struct RerollRequestMulliganCard {
    pub player_type: PlayerKind,
    pub cards: Vec<Uuid>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetPlayerZoneCards {
    pub player_type: PlayerKind,
    pub zone: ZoneType,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct CheckReEntry {
    pub player_type: PlayerKind,
}

#[derive(Message, Deserialize, Debug, Clone)]
#[rtype(result = "Result<PlayerInputResponse, GameError>")]
pub struct HandleUserAction {
    pub player_id: Uuid,
    pub action: UserAction,
}

impl Handler<HandleUserAction> for GameActor {
    type Result = ResponseFuture<Result<PlayerInputResponse, GameError>>;

    fn handle(&mut self, msg: HandleUserAction, ctx: &mut Self::Context) -> Self::Result {
        match msg.action {
            UserAction::PlayCard { card_id, target_id } => {
                todo!()
            }
            UserAction::Attack {
                attacker_id,
                defender_id,
            } => todo!(),
            UserAction::EndTurn => todo!(),
            UserAction::SubmitInput {
                request_id,
                response_data,
            } => todo!(),
            UserAction::RerollRequestMulliganCard { card_id } => {
                let player_type = self.get_player_type_by_uuid(msg.player_id);
                let addr = ctx.address();
                Box::pin(async move {
                    let rerolled_cards = addr
                        .send(RerollRequestMulliganCard {
                            player_type,
                            cards: card_id.clone(),
                        })
                        .await??
                        .iter()
                        .map(|card| card.get_uuid())
                        .collect();

                    Ok(PlayerInputResponse::MulliganRerollAnswer(rerolled_cards))
                })
            }
            UserAction::CompleteMulligan => todo!(),
        }
    }
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RegisterConnection {
    pub player_id: Uuid,
    pub addr: Addr<ConnectionActor>,
}

impl Handler<RegisterConnection> for GameActor {
    type Result = ResponseFuture<Result<(), GameError>>;

    fn handle(&mut self, msg: RegisterConnection, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "GAME ACTOR [{}]: Handling RegisterConnection for player {}",
            self.game_id, msg.player_id
        );

        let kind = self.get_player_type_by_uuid(msg.player_id);
        self.player_connection_ready.insert(kind, true);

        let game_id = self.game_id.clone();
        let player_id = msg.player_id.clone();
        let is_all_ready = self.all_players_ready();
        let cards_future = self.send_to_player_actor(kind, GetMulliganDealCards);
        let connections: Vec<Addr<ConnectionActor>> = self
            .connections
            .iter()
            .map(|(_, addr)| addr.clone())
            .collect();

        Box::pin(async move {
            if is_all_ready {
                info!("GAME ACTOR [{}]: All players are ready", game_id);
                let cards = cards_future
                    .await
                    .unwrap()
                    .iter()
                    .map(|card| card.get_uuid())
                    .collect::<Vec<_>>();

                for connection in connections {
                    if let Err(err) = connection
                        .send(SendMulliganDealCards {
                            cards: cards.clone(),
                        })
                        .await?
                    {
                        warn!(
                            "GAME ACTOR [{}]: Failed to send cards to connection: {}",
                            game_id, err
                        );
                    } else {
                        info!(
                            "GAME ACTOR [{}]: Successfully sent cards to connection",
                            game_id
                        );
                    }
                }
            } else {
                info!("GAME ACTOR [{}]: Not all players are ready yet", game_id);
            }

            Ok(())
        })
    }
}

impl Handler<InitializeGame> for GameActor {
    type Result = Result<(), GameError>;
    fn handle(&mut self, msg: InitializeGame, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<RegisterPlayer> for GameActor {
    type Result = ();
    fn handle(&mut self, msg: RegisterPlayer, _: &mut Self::Context) -> Self::Result {}
}

impl Handler<PlayerReady> for GameActor {
    type Result = ();
    fn handle(&mut self, msg: PlayerReady, _: &mut Self::Context) -> Self::Result {}
}

impl Handler<RequestPlayCard> for GameActor {
    type Result = Result<(), GameError>;
    fn handle(&mut self, msg: RequestPlayCard, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<SubmitInput> for GameActor {
    type Result = Result<(), GameError>;
    fn handle(&mut self, msg: SubmitInput, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<RequestInput> for GameActor {
    type Result = Result<(), GameError>;
    fn handle(&mut self, msg: RequestInput, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<IsCorrectPhase> for GameActor {
    type Result = Result<(), GameError>;
    fn handle(&mut self, msg: IsCorrectPhase, _: &mut Self::Context) -> Self::Result {
        if self.phase_state.get_phase() == msg.phase {
            Ok(())
        } else {
            Err(GameError::WrongPhase)
        }
    }
}

impl Handler<GetPlayerZoneCards> for GameActor {
    type Result = ResponseFuture<Vec<Card>>;

    fn handle(&mut self, msg: GetPlayerZoneCards, _: &mut Context<Self>) -> Self::Result {
        let player_type = msg.player_type;
        let zone = msg.zone;

        let addr = self.get_player_addr_by_kind(player_type);
        Box::pin(async move {
            match zone {
                ZoneType::Deck => addr.send(GetDeckCards).await,
                ZoneType::Hand => addr.send(GetHandCards).await,
                ZoneType::Field => addr.send(GetFieldCards).await,
                ZoneType::Graveyard => addr.send(GetGraveyardCards).await,
                _ => panic!("Invalid zone type: {}", zone),
            }
            .unwrap()
        })
    }
}

impl Handler<RerollRequestMulliganCard> for GameActor {
    type Result = ResponseFuture<Result<Vec<Card>, GameError>>;

    fn handle(&mut self, msg: RerollRequestMulliganCard, _: &mut Context<Self>) -> Self::Result {
        let player_type = msg.player_type;

        let mut cards = vec![];
        let player_cards = self
            .all_cards
            .get(&player_type)
            .unwrap_or_else(|| panic!("Player cards not found for player type: {:?}", player_type));
        for uuid in msg.cards {
            if let Some(card) = player_cards.find_by_uuid(uuid.clone()) {
                cards.push(card.clone());
            } else {
                todo!()
                // return ResponseFuture:;
            }
        }
        let addr = self.get_player_addr_by_kind(player_type);
        Box::pin(async move {
            addr.do_send(AddCardsToDeck {
                cards,
                insert: Box::new(BottomInsert),
            });

            addr.send(GetCardFromDeck {
                take: Box::new(RandomTake(TargetCount::Exact(5))),
            })
            .await?
        })
    }
}

impl Handler<CheckReEntry> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: CheckReEntry, _: &mut Context<Self>) -> Self::Result {
        let current_phase = self.phase_state.get_phase();
        let player_progress = self.phase_state.get_player_progress(msg.player_type);

        info!(
            "GAME ACTOR: Handling CheckReEntry for {:?} in phase {:?}. Current progress: {:?}",
            msg.player_type, current_phase, player_progress
        );

        // 페이즈별 재진입 규칙 정의
        match current_phase {
            Phase::Mulligan => {
                        // 멀리건: Entered 상태가 아니면 재진입 불가 (이미 시작했거나 완료)
                        if player_progress != PlayerPhaseProgress::NotStarted && player_progress != PlayerPhaseProgress::Entered {
                             println!("GAME ACTOR: Re-entry denied for {:?} in Mulligan (Progress: {:?})", msg.player_type, player_progress);
                            Err(GameError::NotAllowedReEntry)
                        } else {
                             // 첫 진입 시 상태 변경
                             self.phase_state.update_player_progress(msg.player_type, PlayerPhaseProgress::Entered);
                            Ok(())
                        }
                    }
            Phase::DrawPhase => {
                        // 드로우: Entered 상태가 아니면 재진입 불가 (이미 드로우 했음)
                        if player_progress != PlayerPhaseProgress::Entered {
                            println!("GAME ACTOR: Re-entry denied for {:?} in DrawPhase (Progress: {:?})", msg.player_type, player_progress);
                            Err(GameError::NotAllowedReEntry)
                        } else {
                             // 드로우 액션 수행 후 상태를 ActionTaken 등으로 변경하는 로직 필요
                             // 이 핸들러는 진입 가능 여부만 확인하므로 상태 변경은 다른 곳에서
                             // self.phase_state.update_player_progress(msg.player_type, PlayerPhaseProgress::ActionTaken); // 예시: 드로우 직후 호출
                            Ok(())
                        }
                    }
            Phase::StandbyPhase => {
                        // 스탠바이: Entered 상태가 아니면 재진입 불가 (이미 처리 시작)
                        if player_progress != PlayerPhaseProgress::Entered {
                            println!("GAME ACTOR: Re-entry denied for {:?} in StandbyPhase (Progress: {:?})", msg.player_type, player_progress);
                            Err(GameError::NotAllowedReEntry)
                        } else {
                            // 스탠바이 처리 시작 시 상태 변경 필요
                            // self.phase_state.update_player_progress(msg.player_type, PlayerPhaseProgress::ActionTaken);
                            Ok(())
                        }
                    }
            Phase::MainPhaseStart | Phase::MainPhase1 | Phase::MainPhase2 => {
                        // 여기서는 단순화를 위해 항상 허용.
                        // 만약 "MainPhaseStart 시" 효과 발동 여부를 체크하려면 다른 상태 필요.
                        if player_progress == PlayerPhaseProgress::NotStarted { // 페이즈가 막 바뀐 직후라면 Entered로 설정
                             self.phase_state.update_player_progress(msg.player_type, PlayerPhaseProgress::Entered);
                        }
                        Ok(())
                    }
            Phase::BattlePhaseStart | Phase::BattleStep | // ... 등등 ...
                    Phase::BattlePhaseEnd => {
                        // 여기서는 단순화를 위해 항상 허용.
                        // 실제로는 공격 선언 후 BattlePhaseStart 재진입 불가 등의 규칙 필요.
                         if player_progress == PlayerPhaseProgress::NotStarted {
                             self.phase_state.update_player_progress(msg.player_type, PlayerPhaseProgress::Entered);
                         }
                        Ok(())
                    }
            Phase::EndPhase => {
                        // 엔드: Entered 상태가 아니면 재진입 불가 (턴 종료 처리 시작됨)
                        if player_progress != PlayerPhaseProgress::Entered {
                            println!("GAME ACTOR: Re-entry denied for {:?} in EndPhase (Progress: {:?})", msg.player_type, player_progress);
                            Err(GameError::NotAllowedReEntry)
                        } else {
                            // 엔드 페이즈 처리 시작 시 상태 변경 필요
                            // self.phase_state.update_player_progress(msg.player_type, PlayerPhaseProgress::ActionTaken);
                            Ok(())
                        }
                    }
            Phase::BattleDamageStepStart => todo!(),
            Phase::BattleDamageStepCalculationBefore => todo!(),
            Phase::BattleDamageStepCalculationStart => todo!(),
            Phase::BattleDamageStepCalculationEnd => todo!(),
            Phase::BattleDamageStepEnd => todo!(),
        }
    }
}
</file>

<file path="simulator_core/src/game/mod.rs">
use std::{collections::HashMap, time::Duration};

use actix::{Actor, Addr, Context, Handler, Message, ResponseFuture};
use phase::{Phase, PhaseState};
use tracing::{error, info, warn};
use turn::Turn;
use uuid::Uuid;

use crate::{
    card::{
        types::{PlayerIdentity, PlayerKind},
        Card,
    },
    exception::GameError,
    player::{message::SetOpponent, PlayerActor},
    server::actor::connection::ConnectionActor,
};

pub mod choice;
pub mod getter;
pub mod helper;
pub mod message;
pub mod phase;
pub mod turn;

pub struct GameConfig {}

pub struct GameActor {
    // 플레이어 액터들의 주소 저장 (PlayerActor 정의 필요)
    pub players: HashMap<PlayerIdentity, Addr<PlayerActor>>,
    pub connections: HashMap<Uuid, Addr<ConnectionActor>>,
    pub player_connection_ready: HashMap<PlayerKind, bool>, // 각 플레이어 초기화 완료 여부
    pub phase_state: PhaseState,
    pub all_cards: HashMap<PlayerKind, Vec<Card>>,
    pub turn: Turn,
    pub is_game_over: bool,
    pub game_id: Uuid,
}

impl Actor for GameActor {
    type Context = Context<Self>;
}

impl GameActor {
    /// 새로운 게임 세션을 위한 GameActor를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `game_id` - 이 게임 세션의 고유 ID.
    /// * `attacker_player_type` - 선공 플레이어의 타입.
    ///
    /// # Returns
    ///
    /// 새로운 GameActor 인스턴스.
    pub fn new(
        game_id: Uuid,
        player1_id: Uuid,
        player2_id: Uuid,
        attacker_player_type: PlayerKind,
    ) -> Self {
        println!("Game::new() Player 1 ID: {:?}", player1_id);
        println!("Game::new() Player 2 ID: {:?}", player2_id);
        let p1_identity = PlayerIdentity {
            id: player1_id,
            kind: PlayerKind::Player1,
        };
        let p2_identity = PlayerIdentity {
            id: player2_id,
            kind: PlayerKind::Player2,
        };

        let mut player_actors_map = HashMap::new();

        // PlayerActor 생성 및 맵에 추가
        let p1_addr = PlayerActor::create(|_ctx| PlayerActor::new(p1_identity.kind));
        let p2_addr = PlayerActor::create(|_ctx| PlayerActor::new(p2_identity.kind));
        player_actors_map.insert(p1_identity, p1_addr.clone());
        player_actors_map.insert(p2_identity, p2_addr.clone());

        actix::spawn(async move {
            while !p1_addr.connected() {
                tokio::time::sleep(Duration::from_millis(5)).await;
            }
            info!("Player 1 connected, P1 can now receive messages.");

            while !p2_addr.connected() {
                tokio::time::sleep(Duration::from_millis(5)).await;
            }
            info!("Player 2 connected, P2 can now receive messages.");

            info!("Both players connected. Sending SetOpponent messages.");
            p1_addr.do_send(SetOpponent {
                opponent: p2_addr.clone(),
            });
            p2_addr.do_send(SetOpponent {
                opponent: p1_addr.clone(),
            });
        });

        GameActor {
            players: player_actors_map,
            connections: HashMap::new(),
            player_connection_ready: HashMap::new(),
            all_cards: HashMap::new(),
            phase_state: PhaseState::new(Phase::Mulligan),
            turn: Turn::new(),
            is_game_over: false,
            game_id,
        }
    }

    pub fn all_players_ready(&self) -> bool {
        self.player_connection_ready.values().all(|&ready| ready)
    }

    fn get_player_info_by_kind(&self, target_kind: PlayerKind) -> Option<(Uuid, &PlayerIdentity)> {
        for (identity, addr) in &self.players {
            if identity.kind == target_kind {
                return Some((identity.id, identity));
            }
        }
        None
    }

    /// PlayerKind를 기반으로 PlayerActor의 주소(Addr)를 가져옵니다.
    pub fn get_player_addr_by_kind(&self, target_kind: PlayerKind) -> Addr<PlayerActor> {
        for (identity, addr) in &self.players {
            if identity.kind == target_kind {
                return addr.clone();
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with kind {:?} not found", target_kind)
    }

    pub fn get_player_type_by_uuid(&self, player_id: Uuid) -> PlayerKind {
        for (identity, _) in &self.players {
            if identity.id == player_id {
                return identity.kind;
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with ID {} not found", player_id)
    }
    pub fn get_player_uuid_by_kind(&self, target_kind: PlayerKind) -> Uuid {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return identity.id;
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with kind {:?} not found", target_kind)
    }

    /// PlayerKind를 기반으로 ConnectionActor의 주소(Addr)를 가져옵니다.
    pub fn get_connection_addr_by_kind(
        &self,
        target_kind: PlayerKind,
    ) -> Option<Addr<ConnectionActor>> {
        todo!()
    }

    /// PlayerKind를 기반으로 해당 PlayerActor에게 메시지를 보내고 결과를 기다립니다. (send 버전)
    ///
    /// # Arguments
    /// * `target_kind` - 메시지를 보낼 대상 플레이어의 PlayerKind.
    /// * `msg` - 보낼 메시지.
    ///
    /// # Returns
    /// * `ResponseFuture<Result<M::Result, GameActorError>>` -
    ///   비동기적으로 PlayerActor 핸들러의 결과 또는 에러를 반환합니다.
    ///   `GameActorError`는 플레이어를 찾지 못했거나 Mailbox 에러를 포함할 수 있습니다.
    pub fn send_to_player_actor<M>(
        &self,
        target_kind: PlayerKind,
        msg: M,
    ) -> ResponseFuture<Result<M::Result, GameError>>
    where
        M: Message + Send + 'static, // 메시지 제약 조건
        M::Result: Send,             // 결과 제약 조건
        PlayerActor: Handler<M>,     // PlayerActor가 이 메시지를 처리할 수 있어야 함
    {
        // 1. target_kind에 해당하는 PlayerActor의 주소(Addr)를 찾습니다.
        let addr = self.get_player_addr_by_kind(target_kind);
        // 2. 주소를 찾았으면, send 메서드를 호출하고 결과를 await합니다.
        //    send의 결과는 Result<M::Result, MailboxError> 입니다.
        //    이를 GameError로 매핑하여 반환합니다.

        let game_id = self.game_id;
        Box::pin(async move {
            info!(
                "GAME ACTOR [{}]: Sending message to PlayerActor ({:?}) and awaiting response.",
                // self.game_id, // self 직접 접근 불가, 필요시 game_id를 클론해서 전달
                game_id,
                target_kind
            );
            match addr.send(msg).await {
                Ok(handler_result) => {
                    // PlayerActor 핸들러가 반환한 M::Result
                    // 이 M::Result 자체가 Result<T, E>일 수 있음 (핸들러가 오류를 반환하는 경우)
                    // 여기서는 M::Result를 그대로 반환 (필요시 내부 Result 처리)
                    Ok(handler_result)
                }
                Err(mailbox_error) => {
                    error!(
                        "GAME ACTOR: Mailbox error sending message to PlayerActor ({:?}): {:?}",
                        target_kind, mailbox_error
                    );
                    Err(GameError::MailboxError)
                }
            }
        })
    }

    /// PlayerKind를 기반으로 해당 PlayerActor에게 메시지를 보냅니다. (do_send 버전)
    pub fn do_send_to_player_actor<M>(&self, target_kind: PlayerKind, msg: M)
    where
        M: Message + Send + 'static,
        M::Result: Send,
        // PlayerActor: Handler<M>, // Handler 제약은 받는 쪽에서 필요, 보내는 쪽에서는 불필요
    {
        todo!()
    }

    /// PlayerKind를 기반으로 해당 ConnectionActor에게 메시지를 보냅니다. (do_send 버전)
    /// (GameEvent 등을 보낼 때 사용)
    pub fn send_to_connection<M>(&self, target_kind: PlayerKind, msg: M)
    where
        M: Message + Send + 'static,
        M::Result: Send,
        // ConnectionActor: Handler<M>, // 받는 쪽에서 필요
    {
        todo!()
    }

    /// 게임 내 모든 플레이어의 ConnectionActor에게 메시지를 브로드캐스트합니다.
    pub fn broadcast_to_connections<M>(&self, msg: M)
    where
        M: Message + Send + Clone + 'static, // Clone 필요
        M::Result: Send,
        // ConnectionActor: Handler<M>, // 받는 쪽에서 필요
    {
        todo!()
    }
}
</file>

<file path="simulator_core/src/player/message.rs">
use crate::{
    card::{
        cards::CardVecExt,
        insert::Insert,
        take::{RandomTake, Take},
        Card,
    },
    enums::{ZoneType, COUNT_OF_MULLIGAN_CARDS},
    exception::GameError,
    selector::TargetCount,
    zone::zone::Zone,
};
use actix::{Addr, Context, Handler, Message};
use tracing::info;
use uuid::Uuid;

use super::PlayerActor;

#[derive(Message)]
#[rtype(result = "Result<Vec<Uuid>, GameError>")] // 새로 뽑은 카드 목록 또는 에러 반환
pub struct RequestMulliganReroll {
    pub cards_to_restore: Vec<Uuid>, // 덱으로 되돌릴 카드 UUID 목록
}

#[derive(Message)]
#[rtype(result = "()")] // 새로 뽑은 카드 목록 또는 에러 반환
pub struct SetOpponent {
    pub opponent: Addr<PlayerActor>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetCardsByUuid {
    pub uuid: Vec<Uuid>,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct AddCardsToDeck {
    pub cards: Vec<Card>,
    pub insert: Box<dyn Insert>,
}

#[derive(Message)]
#[rtype(result = "Result<Vec<Card>, GameError>")]
pub struct GetCardFromDeck {
    pub take: Box<dyn Take>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetDeckCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetHandCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetFieldCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetGraveyardCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetMulliganDealCards;

impl Handler<GetMulliganDealCards> for PlayerActor {
    type Result = Vec<Card>; // 카드 목록 반환

    fn handle(&mut self, _: GetMulliganDealCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetMulliganDealCards",
            self.player_type
        );

        self.deck
            .take_card(Box::new(RandomTake(TargetCount::Exact(
                COUNT_OF_MULLIGAN_CARDS,
            ))))
            .unwrap_or_else(|_| vec![])
            .into_iter()
            .map(|card| card.clone())
            .collect::<Vec<_>>()
    }
}

impl Handler<RequestMulliganReroll> for PlayerActor {
    type Result = Result<Vec<Uuid>, GameError>; // 새로 뽑은 카드 반환

    fn handle(&mut self, msg: RequestMulliganReroll, ctx: &mut Context<Self>) -> Self::Result {
        println!(
            "PLAYER ACTOR [{:?}]: Handling RequestMulliganReroll",
            self.player_type
        );

        // 카드를 복원
        let cards_to_restore = self.get_cards_by_uuids(&msg.cards_to_restore)?;
        self.restore_cards(&cards_to_restore, ZoneType::Deck)?;

        // 복원 시킨 카드 갯수 만큼 카드를 뽑음.
        let new_cards = self.get_new_mulligan_cards(
            self.player_type,
            cards_to_restore.len(), // 뽑을 카드 갯수
        )?;

        // 뽑은 카드의 갯수를 확인
        if new_cards.len() != cards_to_restore.len() {
            return Err(GameError::InternalServerError);
        }

        // 뽑은 카드를 mulligan state 에 넣음.
        self.mulligan_state.add_select_cards(new_cards.clone());

        // 뽑은 카드 목록을 반환
        Ok(new_cards)
    }
}

impl Handler<SetOpponent> for PlayerActor {
    type Result = ();

    fn handle(&mut self, msg: SetOpponent, ctx: &mut Context<Self>) -> Self::Result {
        println!(
            "PLAYER ACTOR [{:?}]: Handling SetOpponent",
            self.player_type
        );

        // 상대방 플레이어를 설정
        self.opponent = Some(msg.opponent);
    }
}

impl Handler<GetCardsByUuid> for PlayerActor {
    type Result = Vec<Card>; // 카드 목록 반환

    fn handle(&mut self, msg: GetCardsByUuid, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetCardsByUuid",
            self.player_type
        );

        // UUID에 해당하는 카드 목록을 반환
        let mut result = vec![];
        for uuid in msg.uuid {
            if let Some(card) = self.get_cards().find_by_uuid(uuid) {
                result.push(card.clone());
            } else {
                return vec![]; // 카드가 없으면 빈 벡터 반환
            }
        }
        result
    }
}

impl Handler<AddCardsToDeck> for PlayerActor {
    type Result = Result<(), GameError>; // 성공 또는 에러 반환

    fn handle(&mut self, msg: AddCardsToDeck, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling AddCardsToDeck",
            self.player_type
        );

        self.deck.add_card(msg.cards, msg.insert)
    }
}

impl Handler<GetCardFromDeck> for PlayerActor {
    type Result = Result<Vec<Card>, GameError>; // 카드 목록 또는 에러 반환

    fn handle(&mut self, msg: GetCardFromDeck, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetCardFromDeck",
            self.player_type
        );

        // 덱에서 카드를 가져옴
        let cards = self.deck.take_card(msg.take)?;
        Ok(cards)
    }
}

impl Handler<GetDeckCards> for PlayerActor {
    type Result = Vec<Card>; // 카드 목록 반환

    fn handle(&mut self, _: GetDeckCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetDeckCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.deck.get_cards().clone()
    }
}

impl Handler<GetHandCards> for PlayerActor {
    type Result = Vec<Card>; // 카드 목록 반환

    fn handle(&mut self, _: GetHandCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetHandCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.hand.get_cards().clone()
    }
}

impl Handler<GetFieldCards> for PlayerActor {
    type Result = Vec<Card>; // 카드 목록 반환

    fn handle(&mut self, _: GetFieldCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetFieldCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.field.get_cards().clone()
    }
}

impl Handler<GetGraveyardCards> for PlayerActor {
    type Result = Vec<Card>; // 카드 목록 반환

    fn handle(&mut self, _: GetGraveyardCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetGraveyardCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.graveyard.get_cards().clone()
    }
}
</file>

<file path="simulator_core/src/server/end_point.rs">
use std::{future::Future, pin::Pin};

use actix::{Actor, AsyncContext, Context, StreamHandler};
use actix_web::{get, web, FromRequest, HttpRequest, HttpResponse};
use actix_ws::{handle, Session};
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    exception::GameError,
    server::{actor::connection::ConnectionActor, types::ServerState},
};

#[derive(Debug, Clone, Copy)]
pub struct AuthPlayer {
    ptype: PlayerKind,
    id: Uuid,
}

impl AuthPlayer {
    fn new(ptype: PlayerKind, id: Uuid) -> Self {
        Self { ptype, id }
    }
}

impl AuthPlayer {
    fn reverse(&self) -> PlayerKind {
        match self.ptype {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }
}

impl FromRequest for AuthPlayer {
    type Error = GameError;
    type Future = Pin<Box<dyn Future<Output = Result<Self, Self::Error>>>>;

    fn from_request(req: &HttpRequest, payload: &mut actix_web::dev::Payload) -> Self::Future {
        let req = req.clone();
        Box::pin(async move {
            debug!("AuthPlayer::from_request 시작: 인증 처리 중...");

            let Some(player_id_cookie) = req.cookie("user_id") else {
                error!("쿠키 누락: 'user_id' 쿠키를 찾을 수 없음");
                return Err(GameError::CookieNotFound);
            };

            let player_id_string = player_id_cookie.to_string().replace("user_id=", "");
            debug!("쿠키 파싱 완료: player_name={}", player_id_string);

            if let Some(state) = req.app_data::<web::Data<ServerState>>() {
                let player_id = match Uuid::parse_str(&player_id_string) {
                    Ok(id) => id,
                    Err(e) => {
                        warn!(
                            "Failed to parse player_id from cookie: '{}'. Error: {}",
                            player_id_string, e
                        );
                        return Err(GameError::InvalidPayload);
                    }
                };

                // 서버 상태에서 플레이어 ID 가져오기 (state: &web::Data<ServerState>)
                let p1_key = state.player1_id;
                let p2_key = state.player2_id;

                // if-else if-else 로 PlayerType 결정
                let player_type = if player_id == p1_key {
                    debug!("Player authenticated as Player1 (ID: {})", player_id);
                    PlayerKind::Player1
                } else if player_id == p2_key {
                    debug!("Player authenticated as Player2 (ID: {})", player_id);
                    PlayerKind::Player2
                } else {
                    // 알 수 없는 ID 처리 (명확한 오류 반환)
                    error!(
                        "Authentication failed: Unknown player ID '{}' from cookie. Expected {} or {}.",
                        player_id, p1_key, p2_key
                    );
                    // 인증 실패 또는 잘못된 플레이어 오류 반환
                    return Err(GameError::InvalidPlayer);
                };

                debug!("Request Guard 통과: player_type={:?}", player_type);

                Ok(AuthPlayer::new(player_type, player_id))
            } else {
                error!("서버 상태 객체를 찾을 수 없음");
                Err(GameError::ServerStateNotFound)
            }
        })
    }
}

impl From<AuthPlayer> for PlayerKind {
    fn from(value: AuthPlayer) -> Self {
        value.ptype
    }
}

impl From<AuthPlayer> for String {
    fn from(value: AuthPlayer) -> Self {
        value.ptype.to_string()
    }
}

/// Game 의 전반적인 기능을 책임지는 end point
#[get("/game")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype))]
pub async fn game(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    info!("멀리건 단계 핸들러 시작: player={:?}", player.ptype);

    let player_type = player.ptype;
    let player_id = player.id;
    debug!("플레이어 타입 설정: {:?}", player_type);

    // Http 업그레이드: 이때 session과 stream이 반환됩니다.
    debug!("WebSocket 연결 업그레이드 시작");
    let (response, session, message_stream) = match handle(&req, payload) {
        Ok(result) => {
            info!(
                "WebSocket handshake successful for player_id: {}",
                player_id
            );
            result
        }
        Err(e) => {
            error!(
                "WebSocket handshake failed for player_id: {}: {:?}",
                player_id, e
            );
            return Ok(
                HttpResponse::InternalServerError().body(format!("WS Handshake Error: {}", e))
            );
        }
    };

    ConnectionActor::create(|ctx: &mut Context<ConnectionActor>| {
        let new_actor = ConnectionActor::new(session, state.game.clone(), player_id, player_type);
        ctx.add_stream(message_stream);
        new_actor
    });

    Ok(response)
}
</file>

<file path="Cargo.toml">
[workspace.package]
version = "0.1.0"
edition = "2021"
description = "card backend"

[workspace]
members = [
    "simulator_core",
    "simulator_dedicated_server",
    "simulator_match_server",
]

resolver = "2"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</file>

</files>
