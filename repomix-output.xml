This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/settings.local.json
.gitignore
Cargo.toml
simulator_core/.cargo/config.toml
simulator_core/.claude/settings.local.json
simulator_core/.github/workflows/main.yml
simulator_core/.gitignore
simulator_core/.idea/.gitignore
simulator_core/.idea/discord.xml
simulator_core/.idea/modules.xml
simulator_core/.idea/simulator.iml
simulator_core/.idea/vcs.xml
simulator_core/.vscode/launch.json
simulator_core/benches/bench.rs
simulator_core/build.rs
simulator_core/Cargo.toml
simulator_core/Datas/config.json
simulator_core/Datas/game_behaivor.csv
simulator_core/Datas/mock.json
simulator_core/Datas/player1_test.json
simulator_core/Datas/player2_test.json
simulator_core/GameData/cards-json.txt
simulator_core/GameData/hero.txt
simulator_core/GameData/task.txt
simulator_core/GameData/turn-structure.txt
simulator_core/Resource/card_data
simulator_core/Resource/cards_id.json
simulator_core/Resource/cards.json
simulator_core/src/card_gen/builder.rs
simulator_core/src/card_gen/human.rs
simulator_core/src/card_gen/mod.rs
simulator_core/src/card_gen/monster.rs
simulator_core/src/card_gen/public.rs
simulator_core/src/card/cards.rs
simulator_core/src/card/insert.rs
simulator_core/src/card/mod.rs
simulator_core/src/card/modifier.rs
simulator_core/src/card/take.rs
simulator_core/src/card/types.rs
simulator_core/src/effect/effects.rs
simulator_core/src/effect/mod.rs
simulator_core/src/effect/types.rs
simulator_core/src/enums/mod.rs
simulator_core/src/exception/mod.rs
simulator_core/src/game_old/chain copy.rs
simulator_core/src/game_old/chain.rs
simulator_core/src/game_old/choice.rs
simulator_core/src/game_old/game_step.rs
simulator_core/src/game_old/getter.rs
simulator_core/src/game_old/helper.rs
simulator_core/src/game_old/mod.rs
simulator_core/src/game_old/phase.rs
simulator_core/src/game_old/turn_manager.rs
simulator_core/src/game/choice.rs
simulator_core/src/game/mod.rs
simulator_core/src/game/msg/connection.rs
simulator_core/src/game/msg/error_message.rs
simulator_core/src/game/msg/gameplay.rs
simulator_core/src/game/msg/lifecycle.rs
simulator_core/src/game/msg/mod.rs
simulator_core/src/game/msg/mulligan.rs
simulator_core/src/game/msg/zones.rs
simulator_core/src/game/phase.rs
simulator_core/src/game/state.rs
simulator_core/src/game/turn.rs
simulator_core/src/lib.rs
simulator_core/src/main.rs
simulator_core/src/player/message.rs
simulator_core/src/player/mod.rs
simulator_core/src/resource.rs
simulator_core/src/selector/automatic.rs
simulator_core/src/selector/complex.rs
simulator_core/src/selector/mod.rs
simulator_core/src/selector/mulligan.rs
simulator_core/src/selector/multi.rs
simulator_core/src/selector/single.rs
simulator_core/src/utils/json.rs
simulator_core/src/utils/mod.rs
simulator_core/src/zone/deck.rs
simulator_core/src/zone/effect.rs
simulator_core/src/zone/field.rs
simulator_core/src/zone/graveyard.rs
simulator_core/src/zone/hand.rs
simulator_core/src/zone/mod.rs
simulator_core/src/zone/zone.rs
simulator_dedicated_server/.github/workflows/main.yml
simulator_dedicated_server/.gitignore
simulator_dedicated_server/.idea/.gitignore
simulator_dedicated_server/.idea/discord.xml
simulator_dedicated_server/.idea/modules.xml
simulator_dedicated_server/.idea/simulator.iml
simulator_dedicated_server/.idea/vcs.xml
simulator_dedicated_server/.vscode/launch.json
simulator_dedicated_server/Cargo.toml
simulator_dedicated_server/logs/app.log.2025-06-10
simulator_dedicated_server/src/connection/connection.rs
simulator_dedicated_server/src/connection/messages.rs
simulator_dedicated_server/src/connection/mod.rs
simulator_dedicated_server/src/connection/types.rs
simulator_dedicated_server/src/enums.rs
simulator_dedicated_server/src/lib.rs
simulator_dedicated_server/src/main.rs
simulator_dedicated_server/src/room/mod.rs
simulator_dedicated_server/src/server/mod.rs
simulator_dedicated_server/src/test/mod.rs
simulator_dedicated_server/tests/test.rs
simulator_match_server/.github/workflows/main.yml
simulator_match_server/.gitignore
simulator_match_server/.idea/.gitignore
simulator_match_server/.idea/discord.xml
simulator_match_server/.idea/modules.xml
simulator_match_server/.idea/simulator.iml
simulator_match_server/.idea/vcs.xml
simulator_match_server/.vscode/launch.json
simulator_match_server/Cargo.toml
simulator_match_server/src/lib.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(rg:*)",
      "Bash(grep:*)",
      "WebFetch(domain:docs.rs)",
      "Bash(cargo check:*)",
      "Bash(find:*)"
    ],
    "deny": []
  }
}
</file>

<file path="simulator_core/.cargo/config.toml">
[build]
rustflags = ["--cfg", "tokio_unstable"]
</file>

<file path="simulator_core/.claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(cargo check:*)"
    ],
    "deny": []
  }
}
</file>

<file path="simulator_core/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_core/.gitignore">
/target
</file>

<file path="simulator_core/.idea/.gitignore">
# 디폴트 무시된 파일
/shelf/
/workspace.xml
# 에디터 기반 HTTP 클라이언트 요청
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
</file>

<file path="simulator_core/.idea/discord.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="PROJECT_FILES" />
    <option name="description" value="" />
    <option name="applicationTheme" value="default" />
    <option name="iconsTheme" value="default" />
    <option name="button1Title" value="" />
    <option name="button1Url" value="" />
    <option name="button2Title" value="" />
    <option name="button2Url" value="" />
    <option name="customApplicationId" value="" />
  </component>
</project>
</file>

<file path="simulator_core/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/simulator.iml" filepath="$PROJECT_DIR$/.idea/simulator.iml" />
    </modules>
  </component>
</project>
</file>

<file path="simulator_core/.idea/simulator.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="EMPTY_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="simulator_core/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
  </component>
</project>
</file>

<file path="simulator_core/.vscode/launch.json">
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'card_game'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in executable 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug integration test 'test'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--test=test",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "test",
                    "kind": "test"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</file>

<file path="simulator_core/build.rs">
use std::fs;
use std::io::Write;
use std::path::Path;

pub fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("card_registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // 카드 모듈 디렉토리 스캔
    let modules = ["human", "monster", "public"];
    let mut card_registrations = Vec::new();

    for module in modules {
        let path = format!("src/card_gen/{}.rs", module);
        let content = fs::read_to_string(&path).unwrap();

        // 함수 이름 찾기 (예: HM_001, MT_001 등)
        for line in content.lines() {
            if line.contains("pub fn")
                && (line.contains("HM_") || line.contains("MT_") || line.contains("PB_"))
            {
                let func_name = line.split("fn ").nth(1).unwrap().split("(").next().unwrap();
                card_registrations.push(format!("    {}::{}", module, func_name));
            }
        }
    }

    // 매크로 호출 생성
    write!(
        f,
        r#"
        generate_card_map! {{
        {}
        }}
    "#,
        card_registrations.join(",\n")
    )
    .unwrap();
}
</file>

<file path="simulator_core/Datas/config.json">
{
  "DeckCodes": [
    {
      "code1": "",
      "code2": ""
    }
  ],
  "Attacker": 1,
  "Names": [
    {
      "name1": "player1",
      "name2": "player2"
    }
  ]
}
</file>

<file path="simulator_core/Datas/game_behaivor.csv">
PlayerType,Message
Player1
</file>

<file path="simulator_core/Datas/mock.json">
{
  "player_type": "player",
  "cards": ["CARD_UUID_1", "CARD_UUID_2", "CARD_UUID_3", "CARD_UUID_4"]
}
</file>

<file path="simulator_core/Datas/player1_test.json">
{
  "decks": [
    {
      "Hero": [
        {
          "name": "player1"
        }
      ],
      "cards": [
        {
          "id": "HM_001",
          "num": 2
        },
        {
          "id": "HM_002",
          "num": 2
        },
        {
          "id": "HM_003",
          "num": 2
        },
        {
          "id": "HM_004",
          "num": 2
        }
      ]
    }
  ]
}
</file>

<file path="simulator_core/Datas/player2_test.json">
{
  "decks": [
    {
      "Hero": [
        {
          "name": "player2"
        }
      ],
      "cards": [
        {
          "id": "HM_001",
          "num": 2
        },
        {
          "id": "HM_002",
          "num": 2
        },
        {
          "id": "HM_003",
          "num": 2
        },
        {
          "id": "HM_004",
          "num": 2
        }
      ]
    }
  ]
}
</file>

<file path="simulator_core/GameData/cards-json.txt">
datas 폴더엔 플레이어의 덱 정보가 담긴 json 파일이 있다.
구조는 다음과 같다.
[
    {
        "id": "ID",
        "num": INT
    }
]
{ } 블럭은 단일 카드에 대한 id 정보와 갯수를 포함한다.

Resource 폴더에 있는 cards.json 은 게임에 있는 모든 카드의 정보를 담는다.
구조는 위와 비슷하지만 포함하는 정보량이 다르다.
이 json 파일은 카드에 대한 모든 정보(예를 들어 공격력, 체력, 효과 등)를 담기 때문에, 덱에서 id 를 가져온 뒤 해당 json 파일에서 카드 정보를 가져오는
방식으로 한다.
</file>

<file path="simulator_core/GameData/hero.txt">
이 게임에서는 사전 구성된 덱을 가지고 플레이어가 게임에 참여한다.
이 때 덱을 구성하는 카드는 각자의 진영을 갖고 있는데,
진영을 대표하는 카드를 히어로라고 한다.

덱에서 동시에 존재할 수 있는 히어로의 갯수는 최대 2개이다.

히어로는
</file>

<file path="simulator_core/GameData/task.txt">
카드 게임에서 존재하는 모든 행동을, 함수/열거형으로 정의한다.
그리고 카드는 자신이 가진 능력과 관련된 함수들을 table 로 가진다.

모든 행동은 하나의 queue 에 task 형식으로 저장되어, 순차적으로 처리된다.

task_queue 는 후입선출 방식으로 처리한다.
</file>

<file path="simulator_core/GameData/turn-structure.txt">
턴 구조는 유희왕과 비슷하다.
</file>

<file path="simulator_core/Resource/card_data">
월인/달토끼 (MH)

링고[몬스터/달토끼] [코스트3]
스탯 1/4
상시 : 경단을 사용한 턴 2/1를 얻는다.
조건 : 소환 성공 및 공격선언 시 발동한다.
효과 : 패에 "경단" 2장을 넣는다.
디메리트 : 경단을 사용하지 않은 턴 종료시에 2의 데미지를 받는다.

경단[행동/대응]
상시 : 1턴에 1번만 발동할 수 있다.
효과 : 달토끼에게 영구적으로 1/1를 부여한다. 

악마 (DM)

소악마[행동]
① : 자신은 2장 드로우한다. 그 후 데몬 카드 1장을 버린다. 만약 버릴수 없을 경우 자신의 패를 전부 덱으로 되돌린다.

레밀리아 스칼렛[몬스터] [코스트 2]
스탯 2/3
"상시 : 이 카드의 ①, ② 효과는 1턴에 1번만 발동할 수 있다.\n① : 자신 필드에 "플랑드르 스칼렛"이 없다면 발동할 수 있다. 패, 덱, 묘지에서 "플랑드르 스칼렛" 1장을 소환한다. \n② : 자신 필드에 "플랑드르 스칼렛"이 존재하고 이 카드가 소환 되었을 경우 발동 할 수있다. 자신은 1장 드로우한다.",

플랑드르 스칼렛[몬스터] [코스트 2]
스탯 3/2
"상시 : 이 카드의 ①, ② 효과는 1턴에 1번만 발동할 수 있다.\n① : 자신 필드에 "레밀리아 스칼렛"이 없다면 발동할 수 있다. 패, 덱, 묘지에서 "레밀리아 스칼렛" 1장을 소환한다. \n② : 자신 필드에 "레밀리아 스칼렛"이 존재하고 이 카드가 소환 되었을 경우 상대 필드 카드 1장을 대상으로 발동할 수 있다. 그카드를 파괴한다.",

인간 (HM)

히에다노 아큐[필드]
① : 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.

모토오리 코스즈[필드]
"① : 자신 필드에 "인간"이 존재할 경우 발동할 수 있다. 상대 패에 존재하는 카드 1장을 자신의 패에 추가한다. \n② : 그 카드를 사용하지 않은 턴 종료시 에 발동한다. 그 카드를 상대패에 추가한다.",


이자요이 사쿠야[행동]
"① : 이 카드에 빛이 존재할 경우 발동할 수 있다. 이턴 인간 카드의 비용이 0이 된다. \n② : ①효과를 발동한 엔드페이즈에 발동한다. 자신 필드 어둠 4개를을 생성한다.",
//②효과는 강제발동이다.

파츄리 널릿지[행동]
"이 카드의 ①은 1턴에 1번만 발동할 수 있으며, 빛이 존재하지 않을 경우 무효화 된다. \n① : 자신 덱에서 "인간"진형 카드 2장을 패에 넣는다. 그 후 패 1장을 버린다.",


하쿠레이 레이무[몬스터] [코스트 1]
스탯 0/1 
"빛에 존재하는 이 카드는 대상이 되지 않는다. \n① : 이 카드를 소환했을 때 발동할 수 있다. 덱에서 "인간"진형 카드 1장을 패에 넣는다.",


우사미 스미레코[행동/대응]
"이 카드의 ①의 효과는 상대턴에도 발동 가능하다. \n① : 필드에 빛 또는 어둠이 존재할 경우 다른 필드에 대상으로 발동할 수 있다. 필드에 존재하는 빛 또는 어둠 1개만 대상으로 한 곳으로 이동한다.",


코치야 사나에[몬스터] [코스트 3]
스탯 ?/? [신]
"이카드는 자신필드에 존재하는 모든 "인간"카드를 묘지로 보내야만 소환할 수 있다.\n이 카드의 공격력과 생명력은 이카드를 소환하기 위해 보내진 "인간"카드 1장당 2/2씩 얻는다. \n① : 이 카드에 빛이 존재하고, 상대가 몬스터/행동 카드의 효과를 발동했을 때 발동할 수 있다. 이카드의 스탯 2/2를 감소시키고 그 발동을 무효로 한다. \n② : 이 카드에 어둠이 존재하고, 이카드 이외에 다른 카드가 공격대상이 되었을 경우 발동할 수 있다. 공격대상을 이카드로 바꾼다.",

엘리스 마가트로이드[몬스터] [코스트 4]
리워크 예정

후지와라노 모코우[몬스터] [코스트 2] [인형]
리워크 예정

키라사메 마리사[몬스터] [코스트 1]
리워크 예정

카미시라사와 케이네[몬스터] [코스트 6]
스탯 6/5
"이카드의 ①, ②효과는 상대턴에도 발동 할 수 있으며, 1턴에 1번만 발동할 수 있다. \n① : 이 카드에 어둠이 있을경우 발동할 수 있다. 덱에서 인간카드 1장을 패에 추가한다. \n② : 이카드에 빛이 있을경우 발동할 수 있다. 이 카드를 덱으로 되돌리고 덱에서 인간 몬스터 1장을 소환한다.",

마에리베리 한[몬스터] [코스트 10]
리워크 예정

요괴 (MT)

루미아[행동/대응]
① : 낮일 경우 발동할 수 있다. 자신 필드에 어둠 1개를 생성한다.

미스티아 로렐라이[행동/대응]
① : 어둠이 존재 할때 발동할 수 있다. 필드에 어둠 2개를 생성한다.

나즈린[행동]
① : 자신 덱에서 "요과"카드 한장을 가져온다.

이누바시리 모미지[행동]
이 카드의 ① 효과는 1턴에 1번만 발동 할 수 있다. \n① : 어둠이 존재할 경우 발동할 수 있다. 자신의 덱 맨 위에서 3장을 공개하고 그중 1장을 패에 넣는다.",
    //선택받지 못한 카드는 덱으로 간다

미야코 요시카[몬스터] [코스트 3]
스탯 3/4 [강시]
어둠에 존재하는 카드 1장당 이 카드의 스탯 1/1 상승한다.\n① : 필드에 어둠이 존재할 경우 발동할 수 있다. 필드 1개에 어둠을 생성한다.", 
//필드에 어둠이 존재하고 그 위에 다른 카드가 존재해야 이 카드의 스탯이 오름.

야쿠모 란[몬스터] [코스트 4]
스탯 3/4
① : 자신 필드에 "첸"이 존재하지 않을 경우 발동할 수 있다. 덱/묘지에서 첸을 소환한다.\n② : 필드에 첸이 존재할 경우 발동할 수 있다. 첸 아래에 존재하는 카드 1개를 묘지로 보내고 아래에 효과를 적용한다. \n몬스터 : 이번 턴 자신의 몬스터는 체력 1 미만으로 내려가지 않는다. \n행동 : 자신은 1장 드로우한다. \n대응 : 자신 묘지에 존재하는 카드 1장을 자신의 패로 가져온다. \n필드 : 이번 턴 필드의 효과는 무효화 된다.",


첸[몬스터] [코스트 2]
스탯 0/4
이카드는 이카드 아래에 존재하는 카드 1장당 0/1 스탯을 얻는다.\n① : 어둠에 이 카드가 존재할 경우 드로우 페이즈에 발동할 수 있다. 상대 덱 맨 위에 카드를 1장 이카드 아래에 둔다.",

Yukari Yakumo [몬스터] [코스트 8]
스탯 10/6 
"자신 필드에 "야쿠모 란", "첸"이 존재하지 않을경우 이카드는 소환 및 효과 발동을 할 수 없다.\n① : 상대가 몬스터/행동 효과를 발동했을 때 발동할 수 있다. "첸" 아래에 있는 카드를 1장 묘지로 보내고 그 효과를 무효로 하고 파괴한다.\n ② : 자신 필드에 "야쿠모 란", "첸", "야쿠모 유카리"만 존재할 경우 발동할 수 있다. 이 턴 종료시 까지 자신 필드의 "야쿠모 란", "첸"은 자신 필드의 "야쿠모 유카리"의 공격력과 수비력을 가진다.",

이마이즈미 카게로[몬스터] [코스트 3]
스탯 2/4
"빛에 존재하는 이 카드는 공격할 수 없다.\n어둠에 있을때 이 카드는 5/4가 된다. \n이카드는 2번 공격할 수 있다.", 

공용 (PB)

릴리 화이트[행동/대응]
필드존에 카드가 없어야 발동 할 수 있다. 덱에서 "필드카드" 1장을 필드존에 놓는다.

서니 밀크[필드]
이 카드가 존재하는 한 필드 3개를 빛으로 취급한다.
//이 효과를 발동한 플레이어만 정한다.

루나 차일드[필드]
이 카드가 존재하는 한 필드 3개를 어둠으로 취급한다.
//이 효과를 발동한 플레이어만 정한다.

아키 시즈하[행동/대응]
1턴에 1번 필드존의 카드가 존재할 경우에만 발동할 수 있다. 필드존의 카드를 파괴한다.

아키 미노리코[행동대]
1턴에 1번 "필드카드"가 존재하면 발동할 수 있다. 자신은 2장 드로우한다.

치르노[행동/대응]
리워크 예정

스타 사파이어[몬스터] [코스트 1]
리워크 예정

레티 화이트락[행동 / 대응]
1턴에 1번 패에서 이 카드를 버리고 몬스터를 대상으로 발동할 수 있다. 대상 몬스터는 효과 무효 및 공격을 할 수 없으며, 공격대상또한 되지 않는다.
</file>

<file path="simulator_core/Resource/cards_id.json">
[
  { "id": "HM_001", "dbfid": 20 },
  { "id": "HM_002", "dbfid": 21 },
  { "id": "HM_003", "dbfid": 22 },
  { "id": "HM_004", "dbfid": 23 },
  { "id": "HM_005", "dbfid": 24 },
  { "id": "HM_006", "dbfid": 25 },
  { "id": "HM_007", "dbfid": 26 },
  { "id": "HM_008", "dbfid": 27 },
  { "id": "MT_001", "dbfid": 28 },
  { "id": "MT_002", "dbfid": 29 },
  { "id": "MT_003", "dbfid": 30 },
  { "id": "MT_004", "dbfid": 31 },
  { "id": "MT_005", "dbfid": 32 },
  { "id": "MT_006", "dbfid": 33 },
  { "id": "MT_007", "dbfid": 34 },
  { "id": "MT_008", "dbfid": 35 },
  { "id": "MT_009", "dbfid": 36 },
  { "id": "MT_010", "dbfid": 37 },
  { "id": "PB_001", "dbfid": 38 },
  { "id": "PB_002", "dbfid": 39 },
  { "id": "PB_003", "dbfid": 40 },
  { "id": "PB_004", "dbfid": 41 },
  { "id": "PB_005", "dbfid": 42 },
  { "id": "PB_006", "dbfid": 43 },
  { "id": "PB_007", "dbfid": 44 },
  { "id": "PB_008", "dbfid": 45 },
  { "id": "PB_009", "dbfid": 46 },
  { "id": "PB_010", "dbfid": 47 },
  { "id": "PB_011", "dbfid": 48 },
  { "id": "PB_012", "dbfid": 49 },
  { "id": "PB_013", "dbfid": 50 },
  { "id": "PB_014", "dbfid": 51 },
  { "id": "PB_015", "dbfid": 52 },
  { "id": "PB_016", "dbfid": 53 },
  { "id": "PB_017", "dbfid": 54 }
]
</file>

<file path="simulator_core/Resource/cards.json">
[
  {
    "id": "HM_001",
    "dbfid": 20,
    "cardClass": "Human",
    "name": "Hieda no Akyuu",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "효과 : 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "HM_002",
    "dbfid": 21,
    "cardClass": "Human",
    "name": "Kosuzu Motoori",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 자신 필드에 \"인간\"이 존재할 경우 발동할 수 있다. \n효과 : 상대 패에 존재하는 카드 1장을 자신의 패에 추가한다. \n디메리트 : 그 카드를 사용하지 않은 턴 종료시 그 카드를 상대패에 추가한다.",
    "type": "Spell"
  },
  {
    "id": "HM_003",
    "dbfid": 22,
    "cardClass": "Human",
    "name": "Sakuya Izayoi",
    "attack": 0,
    "health": 2,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 이 카드에 \"빛\"이 존재할 경우 발동할 수 있다. \n효과 : 이턴 인간 카드의 비용이 0이 된다. \n디메리트 : 자신 필드 4개에 \"어둠\"을 생성한다.",
    "type": "Unit"
  },
  {
    "id": "HM_004",
    "dbfid": 23,
    "cardClass": "Human",
    "name": "Patchouli Knowledge",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "상시 : 이 카드는 1턴에 1번에만 발동할 수 있으며, 빛이 존재하지 않을 경우 무효화 된다. \n효과 : 자신 덱에서 \"인간\"진형 카드 2장을 패에 넣는다. 그 후 패 1장을 버린다.",
    "type": "Spell"
  },
  {
    "id": "HM_005",
    "dbfid": 24,
    "cardClass": "Human",
    "name": "Reimu Hakurei",
    "attack": 0,
    "health": 1,
    "cost": 1,
    "rarity": "A",
    "collectible": true,
    "text": "상시 : 빛에 존재하는 이 카드는 대상이 되지 않는다. \n조건 : 이 카드 소환시 발동할 수 있다. \n효과 : 덱에서 \"인간\"진형 카드 1장을 패에 넣는다.",
    "type": "Unit"
  },
  {
    "id": "HM_006",
    "dbfid": 25,
    "cardClass": "Human",
    "name": "Usami Sumireko",
    "attack": 2,
    "health": 3,
    "cost": 2,
    "rarity": "B",
    "collectible": true,
    "text": "조건 : 필드에 빛 또는 어둠이 존재할 경우 다른 필드에 대상으로 발동할 수 있다. [이 효과는 상대턴에도 발동 가능]\n효과 : 필드에 존재하는 빛 또는 어둠 1개만 대상으로 한 곳으로 이동한다.",
    "type": "Spell"
  },
  {
    "id": "HM_007",
    "dbfid": 26,
    "cardClass": "Human",
    "name": "Sanae Kochiya",
    "attack": 0,
    "health": 0,
    "cost": 3,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 이 카드는 자신 필드에 존재하는 모든 \"인간\"카드를 묘지로 보내야만 소환할 수 있다.\n이 카드의 공격력과 생명력은 이카드를 소환하기 위해 보내진 \"인간\"카드 1장당 2/2씩 얻는다. \n조건 1 : 이 카드에 빛이 존재하고, 상대가 몬스터/행동 카드의 효과를 발동했을 때 발동할 수 있다. \n효과 1 : 이카드의 스탯 2/2를 감소시키고 그 발동을 무효로 한다. \n조건 2 : 이 카드에 어둠이 존재하고, 이카드 이외에 다른 카드가 공격대상이 되었을 경우 발동할 수 있다. \n효과 2 : 공격대상을 이카드로 바꾼다.",
    "type": "Ace"
  },
  {
    "id": "HM_008",
    "dbfid": 27,
    "cardClass": "Human",
    "name": "Keine Kamishirasawa",
    "attack": 5,
    "health": 5,
    "cost": 6,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 이 카드의 효과는 상대턴에도 발동 할 수 있으며, 1턴에 1번만 발동할 수 있다. \n조건 1 : 이 카드에 어둠이 있을경우 발동할 수 있다. \n효과 1 : 덱에서 인간카드 1장을 패에 추가한다. \n조건 2 : 이카드에 빛이 있을경우 발동할 수 있다. \n효과 2 : 이 카드를 덱으로 되돌리고 덱에서 인간 몬스터 1장을 소환한다.",
    "type": "Ace"
  },
  {
    "id": "MT_001",
    "dbfid": 28,
    "cardClass": "Monster",
    "name": "Rumia",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 낮에만 발동할 수 있다. \n효과 : 자신 필드에 어둠을 1개 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_002",
    "dbfid": 29,
    "cardClass": "Monster",
    "name": "Mystia Lorelei",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 어둠이 있을 경우 발동할 수 있다. \n효과 : 필드에 어둠을 2개 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_003",
    "dbfid": 30,
    "cardClass": "Monster",
    "name": "Nazreen",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "효과 : 자신 덱에서 \"요과\"카드 한장을 가져온다.",
    "type": "Spell"
  },
  {
    "id": "MT_004",
    "dbfid": 31,
    "cardClass": "Monster",
    "name": "Inubashiri Momiji",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 어둠이 있을 경우 발동할 수 있다. \n효과 : 자신 덱 위에서 3장을 공개하고 그 중 1장을 패에 넣는다. 그 후 나머지 카드는 덱 맨 밑에 둔다.",
    "type": "Spell"
  },
  {
    "id": "MT_005",
    "dbfid": 32,
    "cardClass": "Monster",
    "name": "Miyako Yoshika",
    "attack": 3,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "상시 : 어둠에 존재하는 카드 1장당 이 카드의 스탯 1/1 상승한다. \n조건 : 필드에 어둠이 존재할 경우 발동할 수 있다. \n효과 : 사용하고 있지 않은 필드 1개에 어둠을 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_006",
    "dbfid": 33,
    "cardClass": "Monster",
    "name": "Ran Yakumo",
    "attack": 3,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "조건 1 : 자신 필드에 \"첸\"이 존재하지 않을 경우 발동할 수 있다. \n효과 1 : 덱/묘지에서 첸을 소환한다. \n조건 2 : 필드에 첸이 존재할 경우 발동할 수 있다. \n 효과 2 : 첸 아래에 존재하는 카드 1개를 묘지로 보내고 효과를 적용한다. \n몬스터 : 이번 턴 자신의 몬스터는 체력 1 미만으로 내려가지 않는다. \n행동 : 자신은 1장 드로우한다. \n대응 : 자신 묘지에 존재하는 카드 1장을 자신의 패로 가져온다. \n필드 : 이번 턴 필드의 효과는 무효화 된다.",
    "type": "Unit"
  },
  {
    "id": "MT_007",
    "dbfid": 34,
    "cardClass": "Monster",
    "name": "Chen",
    "attack": 0,
    "health": 4,
    "cost": 2,
    "rarity": "B",
    "collectible": true,
    "text": "상시 : 이카드는 이카드 아래에 존재하는 카드 1장당 0/1 스탯을 얻는다. \n조건 1 : 이 카드가 어둠에 존재하고 있을경우 드로우 페이즈에 발동할 수 있다. \n효과 1 : 상대 덱 맨 위에 카드를 1장 이카드 아래에 둔다.",
    "type": "Unit"
  },
  {
    "id": "MT_008",
    "dbfid": 35,
    "cardClass": "Monster",
    "name": "Yukari Yakumo",
    "attack": 0,
    "health": 0,
    "cost": 8,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 자신 필드에 \"야쿠모 란\", \"첸\"이 존재하지 않을경우 이카드는 소환 및 효과 발동을 할 수 없다. \n조건 1 : 상대가 몬스터/행동 효과를 발동했을 때 발동할 수 있다. \n효과 1 : 첸 아래에 있는 카드를 1장 묘지로 보내고 그 효과를 무효로 하고 파괴한다. \n조건 2 : 자신 필드에 \"야쿠모 란\", \"첸\", \"야쿠모 유카리\"만 존재할 경우 발동할 수 있다. \n효과 2 : 이 턴 종료시 까지 자신 필드의 \"야쿠모 란\", \"첸\"은 자신 필드의 \"야쿠모 유카리\"의 공격력과 수비력을 가진다.",
    "type": "Ace"
  },
  {
    "id": "MT_009",
    "dbfid": 36,
    "cardClass": "Monster",
    "name": "Kagerou Imaizumi",
    "attack": 2,
    "health": 4,
    "cost": 3,
    "rarity": "B",
    "collectible": true,
    "text": "상시 : 이 카드가 빛에 있을때는 이 카드는 공격할 수 없다. \n 이 카드가 어둠에 있을때 이 카드는 5/4가 된다. \n 이카드는 2번 공격할 수 있다.",
    "type": "Unit"
  },
  {
    "id": "MT_010",
    "dbfid": 37,
    "cardClass": "Monster",
    "name": "Lily White",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_001",
    "dbfid": 38,
    "cardClass": "Public",
    "name": "Lily White",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 필드존에 카드가 없어야 발동 할 수 있다. \n효과 : 덱에서 \"필드카드\" 1장을 필드존에 놓는다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_002",
    "dbfid": 39,
    "cardClass": "Public",
    "name": "Sunny Milk",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "효과 : 이 카드가 존재하는 한 자신 필드 3개를 빛으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_003",
    "dbfid": 40,
    "cardClass": "Public",
    "name": "Luna Child",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "효과 : 이 카드가 존재하는 한 자신 필드 3개를 어둠으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_004",
    "dbfid": 41,
    "cardClass": "Public",
    "name": "Minoriko Aki",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "조건 : 1턴에 1번 \"필드카드\"가 존재하면 발동할 수 있다. \n효과 : 자신은 2장 드로우한다.",
    "type": "Spell"
  },
  {
    "id": "PB_005",
    "dbfid": 42,
    "cardClass": "Public",
    "name": "Shizuha Aki",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 1턴에 1번 필드존의 카드가 존재할 경우에만 발동할 수 있다. \n효과 : 자신 필드에 어둠을 생성한다.",
    "type": "Spell"
  },
  {
    "id": "PB_006",
    "dbfid": 43,
    "cardClass": "Public",
    "name": "Hina Kagiyama",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 필드에 카드가 없어야 발동 할 수 있다. \n효과 : 자신 필드 2개를 어둠으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_007",
    "dbfid": 44,
    "cardClass": "Public",
    "name": "Nitori Kawashiro",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "S",
    "collectible": true,
    "text": "효과 : 필드를 모두 초기화한다. \n조건 1 : 상대가 어둠의 효과를 발동한 턴에 발동할 수 있다. \n조건 2 : 이 카드가 필드존에 존재해야만 발동할 수 있다. \n효과 2 : 상대 필드 필드존에 있는 어둠카드는 파괴된 어둠카드에 공격력만큼의 피해를 입힌다.",
    "type": "Spell"
  },
  {
    "id": "PB_008",
    "dbfid": 45,
    "cardClass": "Public",
    "name": "Reimu Hakurei",
    "attack": 2,
    "health": 3,
    "cost": 3,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 자신 주위의 적에게 2의 피해를 입힌다.\n조건: 필드에 다른 미니언이 없을 때 발동한다.",
    "type": "Unit",
    "behavior": "대응"
  },
  {
    "id": "PB_009",
    "dbfid": 46,
    "cardClass": "Public",
    "name": "Marisa Kirisame",
    "attack": 3,
    "health": 2,
    "cost": 3,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 적 유닛 하나에게 3의 피해와 1의 관통 피해를 준다.\n조건: 주문 카드 보유 시 발동한다.",
    "type": "Unit",
    "behavior": "돌진"
  },
  {
    "id": "PB_010",
    "dbfid": 47,
    "cardClass": "Public",
    "name": "Sakuya Izayoi",
    "attack": 2,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "효과: 상대의 다음 행동 순서를 1회 지연시킨다.\n조건: 반드시 적 미니언 한 마리를 지정해야 한다.",
    "type": "Spell",
    "behavior": "전략"
  },
  {
    "id": "PB_011",
    "dbfid": 48,
    "cardClass": "Public",
    "name": "Alice Margatroid",
    "attack": 1,
    "health": 5,
    "cost": 4,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 소환한 인형마다 주문 비용이 1 감소한다.\n조건: 인형 카드가 필드에 존재할 때 발동한다.",
    "type": "Unit",
    "behavior": "필드"
  },
  {
    "id": "PB_012",
    "dbfid": 49,
    "cardClass": "Public",
    "name": "Patchouli Knowledge",
    "attack": 0,
    "health": 4,
    "cost": 5,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 모든 주문 카드의 효과를 1턴 연기시킨다.\n조건: 필드에 마법 카드가 1장 이상 있을 때 발동한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_013",
    "dbfid": 50,
    "cardClass": "Public",
    "name": "Yuyuko Saigyouji",
    "attack": 1,
    "health": 6,
    "cost": 6,
    "rarity": "A",
    "collectible": true,
    "text": "효과: 피해를 입은 아군 미니언 한 마리를 회복시킨다.\n조건: 해당 미니언의 체력이 3 이하일 때 발동한다.",
    "type": "Unit",
    "behavior": "회복"
  },
  {
    "id": "PB_014",
    "dbfid": 51,
    "cardClass": "Public",
    "name": "Remilia Scarlet",
    "attack": 4,
    "health": 4,
    "cost": 5,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 모든 적 미니언에게 2의 피해를 준다.\n조건: 상대 턴에만 발동 가능하다.",
    "type": "Unit",
    "behavior": "광역"
  },
  {
    "id": "PB_015",
    "dbfid": 52,
    "cardClass": "Public",
    "name": "Flandre Scarlet",
    "attack": 5,
    "health": 3,
    "cost": 6,
    "rarity": "SS",
    "collectible": true,
    "text": "효과: 공격 시, 적 전장에 있는 모든 유닛에게 1의 피해를 준다.\n조건: 공격 성공 시 자동 발동한다.",
    "type": "Unit",
    "behavior": "대량"
  },
  {
    "id": "PB_016",
    "dbfid": 53,
    "cardClass": "Public",
    "name": "Nitori Kawashiro",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 필드를 모두 초기화한다.\n조건 1: 상대가 어둠의 효과를 발동한 턴에,\n조건 2: 이 카드가 필드존에 존재할 때 발동한다.\n효과 2: 상대 필드의 어둠 카드에 피해를 입힌다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_017",
    "dbfid": 54,
    "cardClass": "Public",
    "name": "Cirno",
    "attack": 3,
    "health": 3,
    "cost": 4,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 적 미니언 하나의 공격력을 1 감소시킨다.\n조건: 얼음 효과 발동 시, 대상 미니언의 공격력이 0 이하가 되지 않는다.",
    "type": "Spell",
    "behavior": "전략"
  }
]
</file>

<file path="simulator_core/src/card_gen/human.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;
// -------------------------------------------------- FIELD
// [HM_001] Hieda no Akyuu - COST:?? [ATK:??/HP:?]
// - Set: Human, Rarity: C
// --------------------------------------------------------
// Text: 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.
// --------------------------------------------------------
// Behaviors:
// - ListenOtherEvent
// - DrawCardFromDeck
// --------------------------------------------------------
#[allow(non_snake_case)]
pub fn HM_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

#[allow(non_snake_case)]
pub fn HM_002(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}

#[allow(non_snake_case)]
pub fn HM_003(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_004(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_005(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_006(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_007(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn HM_008(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/mod.rs">
mod builder;
mod human;
mod monster;
mod public;

use crate::card::Card;
use crate::{utils, utils::json::CardJson};

use once_cell::sync::Lazy;
use std::collections::HashMap;

type CardGeneratorFn = fn(&CardJson, i32) -> Card;

macro_rules! generate_card_map {
    ($($module:ident :: $func:ident),* $(,)?) => {
        static CARD_GENERATORS: Lazy<HashMap<String, CardGeneratorFn>> = Lazy::new(|| {
            let mut m = HashMap::new();
            $(
                m.insert(stringify!($func).to_string(), $module::$func as CardGeneratorFn);
            )*
            m
        });
    };
}

include!(concat!(env!("OUT_DIR"), "/card_registry.rs"));

type Key = Vec<(String, i32)>;
pub struct CardGenerator {
    keys: Keys,
    card_generators: HashMap<i32, CardGeneratorFn>,
}

pub struct Keys {
    pub keys: Key,
}

impl Keys {
    pub fn new() -> Keys {
        let keys = match utils::load_card_id() {
            Ok(data) => data,
            Err(_) => panic!("Unknown Err fun: Keys initialize"),
        };
        Keys { keys }
    }

    pub fn get_usize_by_string(&self, key: &str) -> Option<i32> {
        self.keys
            .iter()
            .find(|&(item_key, _)| item_key == key)
            .map(|&(_, value)| value)
    }

    pub fn get_string_by_usize(&self, key: i32) -> Option<String> {
        self.keys
            .iter()
            .find(|&(_, item_key)| item_key == &key)
            .map(|(value, _)| value.clone())
    }
}

impl CardGenerator {
    pub fn new() -> CardGenerator {
        let keys = Keys::new();
        let mut card_generators = HashMap::new();

        for (str_id, func) in CARD_GENERATORS.iter() {
            if let Some(id) = keys.get_usize_by_string(str_id) {
                card_generators.insert(id, *func);
            }
        }

        CardGenerator {
            keys,
            card_generators,
        }
    }

    pub fn gen_card_by_id_i32(&self, id: i32, card_json: &CardJson, count: i32) -> Card {
        if let Some(generator) = self.card_generators.get(&id) {
            generator(card_json, count)
        } else {
            panic!("Unknown ID: {}", id);
        }
    }

    pub fn gen_card_by_id_string(&self, key: String, card_json: &CardJson, count: i32) -> Card {
        match self.keys.get_usize_by_string(&key[..]) {
            Some(id) => self.gen_card_by_id_i32(id, card_json, count),
            None => panic!("Unknown ID: {}", key),
        }
    }
}
</file>

<file path="simulator_core/src/card_gen/monster.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

#[allow(non_snake_case)]
pub fn MT_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

#[allow(non_snake_case)]
pub fn MT_002(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}

#[allow(non_snake_case)]
pub fn MT_003(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_004(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_005(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_006(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_007(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_008(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_009(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_010(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/public.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

#[allow(non_snake_case)]
pub fn PB_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}
#[allow(non_snake_case)]
pub fn PB_002(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_003(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_004(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_005(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_006(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_007(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_008(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_009(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_010(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_011(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_012(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_013(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_014(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_015(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_016(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_017(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
</file>

<file path="simulator_core/src/card/cards.rs">
use super::Card;
use uuid::Uuid;

/// Vec<Card> 타입의 별칭
pub type Cards = Vec<Card>;

/// Vec<Card> 확장 트레이트
pub trait CardVecExt {
    fn contains_uuid<U: Into<Uuid>>(&self, uuid: U) -> bool;
    fn find_by_uuid<U: Into<Uuid>>(&self, uuid: U) -> Option<&Card>;
    fn find_by_uuid_mut<U: Into<Uuid>>(&mut self, uuid: U) -> Option<&mut Card>;
    fn find_all<F>(&self, predicate: F) -> Vec<&Card>
    where
        F: Fn(&Card) -> bool;
    fn find_all_mut<F>(&mut self, predicate: F) -> Vec<&mut Card>
    where
        F: Fn(&Card) -> bool;
    fn shuffle(&mut self);
    fn count<F>(&self, predicate: F) -> usize
    where
        F: Fn(&Card) -> bool;
    // 새로 추가할 메소드들
    fn remove_by_uuid<U: Into<Uuid>>(&mut self, uuid: U) -> Option<Card>;
    fn remove_all<F>(&mut self, predicate: F) -> Vec<Card>
    where
        F: Fn(&Card) -> bool;
}

impl CardVecExt for Vec<Card> {
    /// 특정 UUID를 가진 카드를 찾아 벡터에서 제거하고 반환합니다.
    /// # Returns
    /// * `Some(Card)` - 해당 UUID를 가진 카드가 발견되어 제거된 경우
    /// * `None` - 해당 UUID를 가진 카드가 없는 경우
    fn remove_by_uuid<U: Into<Uuid>>(&mut self, uuid: U) -> Option<Card> {
        let uuid = uuid.into();
        let position = self.iter().position(|card| card.uuid == uuid)?;
        Some(self.remove(position))
    }

    /// 특정 조건을 만족하는 모든 카드를 벡터에서 제거하고 반환합니다.
    /// # Returns
    /// * `Vec<Card>` - 제거된 카드들의 벡터 (조건을 만족하는 카드가 없으면 빈 벡터)
    fn remove_all<F>(&mut self, predicate: F) -> Vec<Card>
    where
        F: Fn(&Card) -> bool,
    {
        // 제거할 카드 인덱스들 수집 (역순으로 정렬해야 함)
        let mut indices: Vec<usize> = self
            .iter()
            .enumerate()
            .filter(|(_, card)| predicate(card))
            .map(|(i, _)| i)
            .collect();

        // 역순으로 정렬 (뒤에서부터 제거해야 인덱스가 변하지 않음)
        indices.sort_by(|a, b| b.cmp(a));

        // 카드 제거하고 수집
        let mut removed = Vec::with_capacity(indices.len());
        for index in indices {
            removed.push(self.remove(index));
        }

        // 원래 순서대로 뒤집기
        removed.reverse();
        removed
    }
    /// Vec<Card> 에서 특정 Uuid 를 가진 Card 가 존재하는지 확인합니다.
    /// # RETURNS
    /// * `true` - 존재하는 경우
    /// * `false` - 존재하지 않는 경우
    fn contains_uuid<U: Into<Uuid>>(&self, uuid: U) -> bool {
        let uuid = uuid.into();
        self.iter().any(|card| card.uuid == uuid)
    }

    fn find_by_uuid<U: Into<Uuid>>(&self, uuid: U) -> Option<&Card> {
        let uuid = uuid.into();
        self.iter().find(|card| card.uuid == uuid)
    }

    fn find_by_uuid_mut<U: Into<Uuid>>(&mut self, uuid: U) -> Option<&mut Card> {
        let uuid = uuid.into();
        self.iter_mut().find(|card| card.uuid == uuid)
    }

    fn find_all<F>(&self, predicate: F) -> Vec<&Card>
    where
        F: Fn(&Card) -> bool,
    {
        self.iter().filter(|card| predicate(card)).collect()
    }

    fn find_all_mut<F>(&mut self, predicate: F) -> Vec<&mut Card>
    where
        F: Fn(&Card) -> bool,
    {
        self.iter_mut().filter(|card| predicate(card)).collect()
    }

    fn shuffle(&mut self) {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        self.as_mut_slice().shuffle(&mut rng);
    }

    fn count<F>(&self, predicate: F) -> usize
    where
        F: Fn(&Card) -> bool,
    {
        self.iter().filter(|card| predicate(card)).count()
    }
}
</file>

<file path="simulator_core/src/card/mod.rs">
pub mod cards;
pub mod insert;
pub mod modifier;
pub mod take;
pub mod types;

use std::fmt;

use actix::Addr;
use types::{CardSpecs, CardStatus, OwnerType, StatType};
use uuid::Uuid;

use crate::{
    card::types::CardType,
    effect::{effects::EffectTiming, Effect},
    exception::GameError,
    game::GameActor,
    utils::json::CardJson,
};

#[derive(Clone)]
pub struct Card {
    uuid: Uuid,
    name: String,
    card_type: CardType,
    effects: Vec<EffectTiming>,
    specs: CardSpecs,
    status: CardStatus,
    owner: OwnerType,
    json_data: CardJson,
}

impl fmt::Debug for Card {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Card")
            .field("uuid", &self.uuid)
            .field("name", &self.name)
            .field("card_type", &self.card_type)
            .field("owner", &self.owner)
            // .field("effects", &self.effects)
            // .field("specs", &self.specs)
            // .field("status", &self.status)
            // .field("json_data", &self.json_data)
            .finish()
    }
}

impl PartialEq for Card {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl Eq for Card {}

impl Clone for Box<dyn Effect> {
    fn clone(&self) -> Self {
        self.clone_effect().unwrap()
    }
}

impl Card {
    pub fn new(
        owner: OwnerType,
        uuid: Uuid,
        name: String,
        effects: Vec<EffectTiming>,
        r#type: CardType,
        specs: CardSpecs,
        status: CardStatus,
        json_data: CardJson,
    ) -> Self {
        Self {
            uuid,
            name,
            card_type: r#type,
            effects,
            specs,
            status,
            owner,
            json_data,
        }
    }

    pub fn activate(&self, game: Addr<GameActor>) -> Result<(), GameError> {
        todo!()
    }

    // effect 효과로 처리
    pub fn can_be_targeted(&self) -> bool {
        todo!()
    }

    // Getter/Setter 메서드들
    pub fn get_uuid(&self) -> Uuid {
        self.uuid
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    pub fn get_type(&self) -> &CardType {
        &self.card_type
    }

    pub fn get_owner(&self) -> OwnerType {
        self.owner
    }

    pub fn set_owner(&mut self, player: OwnerType) {
        self.owner = player;
    }

    pub fn get_specs(&self) -> &CardSpecs {
        &self.specs
    }

    pub fn get_status(&self) -> &CardStatus {
        &self.status
    }

    pub fn get_status_mut(&mut self) -> &mut CardStatus {
        &mut self.status
    }

    pub fn get_prioritized_effect(&self) -> &Vec<EffectTiming> {
        &self.effects
    }

    pub fn get_prioritized_effect_mut(&mut self) -> &mut Vec<EffectTiming> {
        &mut self.effects
    }

    // 효과 추가
    pub fn add_effect<E: Effect + 'static>(&mut self, effect: E) {
        todo!()
        // self.effects.push(Box::new(effect));
    }

    pub fn modify_stat(&mut self, stat_type: StatType, amount: i32) -> Result<(), GameError> {
        Ok(())
    }

    // 카드 복사 (새로운 UUID 생성)
    pub fn clone_with_new_uuid(&self) -> Result<Self, GameError> {
        todo!()
        // Ok(Card {
        //     uuid: utils::generate_uuid()?,
        //     name: self.name.clone(),
        //     card_type: self.card_type.clone(),
        //     effects: self
        //         .effects
        //         .iter()
        //         .map(|e| e.clone_effect())
        //         .collect::<Result<Vec<_>, _>>()?,
        //     specs: self.specs.clone(),
        //     status: CardStatus::default(),
        //     owner: self.owner.clone(),
        //     json_data: self.json_data.clone(),
        // })
    }
}
</file>

<file path="simulator_core/src/card/modifier.rs">
use crate::game::phase::Phase;

use super::types::{Duration, ModifierType};

///
/// 카드의 상태를 수정하는 구조체
///
#[derive(Clone)]
pub struct Modifier {
    modifier_type: ModifierType,
    value: i32,
    duration: Duration,
    source_card: Option<String>,
    applied_turn: usize,  // 효과가 적용된 턴
    applied_phase: Phase, // 효과가 적용된 페이즈
}

impl Modifier {
    // Getters
    pub fn get_modifier_type(&self) -> ModifierType {
        self.modifier_type
    }

    pub fn get_value(&self) -> i32 {
        self.value
    }

    pub fn get_duration(&self) -> Duration {
        self.duration
    }

    pub fn get_source_card(&self) -> Option<&String> {
        self.source_card.as_ref()
    }

    pub fn get_applied_turn(&self) -> usize {
        self.applied_turn
    }

    pub fn get_applied_phase(&self) -> Phase {
        self.applied_phase
    }

    // Setters
    pub fn set_modifier_type(&mut self, modifier_type: ModifierType) {
        self.modifier_type = modifier_type;
    }

    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }

    pub fn set_duration(&mut self, duration: Duration) {
        self.duration = duration;
    }

    pub fn set_source_card(&mut self, source_card: Option<String>) {
        self.source_card = source_card;
    }

    pub fn set_applied_turn(&mut self, turn: usize) {
        self.applied_turn = turn;
    }

    pub fn set_applied_phase(&mut self, phase: Phase) {
        self.applied_phase = phase;
    }

    // 편의 메서드들
    pub fn new(
        modifier_type: ModifierType,
        value: i32,
        duration: Duration,
        source_card: Option<String>,
        applied_turn: usize,
        applied_phase: Phase,
    ) -> Self {
        Self {
            modifier_type,
            value,
            duration,
            source_card,
            applied_turn,
            applied_phase,
        }
    }

    // 수정자가 아직 유효한지 확인
    pub fn is_expired(&self, current_turn: usize, current_phase: Phase) -> bool {
        match self.duration {
            Duration::Permanent => true,
            Duration::UntilEndOfTurn => current_turn == self.applied_turn,
            Duration::UntilEndOfPhase => {
                current_turn == self.applied_turn && current_phase == self.applied_phase
            }
            Duration::ForXTurns(turns) => current_turn <= self.applied_turn + turns,
        }
    }

    // 수정자의 남은 지속 시간 계산
    pub fn remaining_duration(&self, current_turn: usize) -> Option<usize> {
        match self.duration {
            Duration::Permanent => None,
            Duration::UntilEndOfTurn => {
                if current_turn > self.applied_turn {
                    Some(0)
                } else {
                    Some(1)
                }
            }
            Duration::UntilEndOfPhase => Some(if current_turn > self.applied_turn {
                0
            } else {
                1
            }),
            Duration::ForXTurns(turns) => {
                Some(turns.saturating_sub(current_turn - self.applied_turn))
            }
        }
    }

    // 수정자 복사본 생성 (다른 턴/페이즈에 적용)
    pub fn copy_with_new_timing(&self, turn: usize, phase: Phase) -> Self {
        let mut new = self.clone();
        new.set_applied_turn(turn);
        new.set_applied_phase(phase);
        new
    }

    // 수정자 값 변경
    pub fn modify_value(&mut self, delta: i32) {
        self.value += delta;
    }

    // 지속 시간 연장
    pub fn extend_duration(&mut self, additional: Duration) {
        self.duration = match (self.duration, additional) {
            (Duration::ForXTurns(t1), Duration::ForXTurns(t2)) => Duration::ForXTurns(t1 + t2),
            (Duration::Permanent, _) => Duration::Permanent,
            _ => self.duration,
        };
    }
}
</file>

<file path="simulator_core/src/effect/effects.rs">
use actix::Addr;

use crate::{card::Card, game::GameActor};

use super::{types::EffectSpeed, Effect};

// Effect 에 우선순위를 부여하는건 장기적으로 좋음.
pub struct Effects {
    // 항상 정렬 상태를 보장해야함.
    prioritized_effects: Vec<EffectTiming>,
}

impl Effects {
    pub fn new() -> Self {
        Self {
            prioritized_effects: vec![],
        }
    }

    pub fn add_effect(&mut self, effect: EffectTiming) {
        self.prioritized_effects.push(effect);
        self.prioritized_effects.sort_by_key(|e| e.get_priority());
    }

    pub fn get_effects(&self) -> Vec<&Box<dyn Effect>> {
        self.prioritized_effects
            .iter()
            .map(|e| e.get_effect())
            .collect::<Vec<_>>()
    }

    pub fn get_effects_mut(&mut self) -> Vec<&mut Box<dyn Effect>> {
        self.prioritized_effects
            .iter_mut()
            .map(|e| e.get_effect_mut())
            .collect::<Vec<_>>()
    }

    // 특정 조건을 만족하는 효과만 필터링 (조건을 클로저로 전달)
    pub fn filter_effects<F>(&self, filter: F) -> Vec<&EffectTiming>
    where
        F: Fn(&EffectTiming) -> bool,
    {
        self.prioritized_effects
            .iter()
            .filter(|e| filter(e))
            .collect()
    }

    // 체인 상태에서 추가 가능한 효과만 필터링
    pub fn get_chainable_effects(&self, current_chain_level: EffectSpeed) -> Vec<&EffectTiming> {
        self.prioritized_effects
            .iter()
            .filter(|e| {
                let timing = e.get_effect().get_speed();
                if timing >= current_chain_level {
                    return true;
                } else {
                    return false;
                }
            })
            .collect()
    }

    // 발동 가능한 효과만 필터링
    pub fn get_activatable_effects(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Vec<&EffectTiming> {
        todo!()
        // self.prioritized_effects
        //     .iter()
        //     .filter(|e| e.get_effect().can_activate(game, source))
        //     .collect()
    }
}

#[derive(Clone)]
pub struct EffectTiming {
    priority: u8, // 낮을수록 높은 우선순위
    speed: EffectSpeed,
    is_used: bool, // 효과가 사용되었는지 여부
    effect: Box<dyn Effect>,
}

impl EffectTiming {
    pub fn new(priority: u8, speed: EffectSpeed, effect: Box<dyn Effect>) -> Self {
        Self {
            priority,
            effect,
            speed,
            is_used: false,
        }
    }

    pub fn get_priority(&self) -> u8 {
        self.priority
    }

    pub fn get_speed(&self) -> EffectSpeed {
        self.speed
    }

    pub fn get_effect(&self) -> &Box<dyn Effect> {
        &self.effect
    }

    pub fn get_effect_mut(&mut self) -> &mut Box<dyn Effect> {
        &mut self.effect
    }
}
</file>

<file path="simulator_core/src/game_old/chain copy.rs">
use crate::{
    card::{
        effect::{Effect, EffectResult},
        types::PlayerType,
        Card, PrioritizedEffect,
    },
    exception::GameError,
    server::input_handler::InputAnswer,
};
use std::collections::HashSet;
use tracing::info;
use uuid::Uuid;

use super::{game_step::PlayCardResult, Game};

// 체인 처리 단계
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChainPhase {
    Building,  // 체인 구성 중 (효과 추가 가능)
    Resolving, // 체인 해결 중 (효과 실행 단계)
    Waiting,   // 사용자 입력 대기 중
    Completed, // 체인 처리 완료
}

impl Default for ChainPhase {
    fn default() -> Self {
        todo!()
    }
}

// 체인 아이템 구조체 (효과와 소스 카드 연결)
#[derive(Clone)]
pub struct ChainLink {
    effect: Box<dyn Effect>,
    source_card: Card,
}

#[derive(Clone, Default)]
pub struct Chain {
    // 체인 큐 (LIFO 방식으로 처리)
    links: Vec<ChainLink>,

    // 현재 체인 처리 단계
    current_phase: ChainPhase,

    // 현재 처리 중인 카드 (입력 대기 중일 때 사용)
    pending_card: Option<Card>,

    // 처리 대기 중인 효과들 (입력 후 체인에 추가 예정)
    pending_effects: Vec<PrioritizedEffect>,

    // 이미 처리된 효과 ID
    processed_effect_ids: HashSet<Uuid>,

    // 유저 입력 대기 정보
    waiting_effect_index: Option<usize>,
    waiting_input: Option<InputAnswer>,
}

impl Chain {
    pub fn new() -> Self {
        Self {
            links: Vec::new(),
            current_phase: ChainPhase::Completed, // 초기 상태는 완료
            pending_card: None,
            pending_effects: Vec::new(),
            processed_effect_ids: HashSet::new(),
            waiting_effect_index: None,
            waiting_input: None,
        }
    }

    /// 카드의 모든 효과를 처리합니다
    pub async fn process_card_effects(
        &mut self,
        game: &mut Game,
        player_type: PlayerType,
        card: Card,
    ) -> Result<PlayCardResult, GameError> {
        info!(
            "카드 효과 처리: player={:?}, card={:?}",
            player_type,
            card.get_uuid()
        );

        // 효과 처리 준비
        let effects = card.get_prioritized_effect();

        // 1. 즉발 효과 처리
        let result = self
            .process_immediate_effects(game, &card, &effects)
            .await?;

        // 2. 체인 효과 처리
        self.add_chain_effects(game, &card, &effects)?;

        // 3. 체인 해결
        if self.has_effects() {
            match self.resolve(game)? {
                ChainResolutionResult::Completed => Ok(PlayCardResult::Success),
                ChainResolutionResult::WaitingForInput(result) => Ok(result),
            }
        } else {
            Ok(PlayCardResult::Success)
        }
    }

    /// 즉발 효과 처리
    async fn process_immediate_effects(
        &mut self,
        game: &mut Game,
        card: &Card,
        effects: &[PrioritizedEffect],
    ) -> Result<Option<PlayCardResult>, GameError> {
        // 즉발 효과 수집
        let immediate_effects: Vec<_> = effects
            .iter()
            .filter(|e| e.get_effect().get_timing() == EffectLevel::Immediate)
            .collect();

        // let result = vec![];

        // 효과 처리
        for prioritized_effect in immediate_effects {
            // 이미 처리된 효과는 건너뛰기
            let effect_id = prioritized_effect.get_effect().get_id().into();
            if self.processed_effect_ids.contains(&effect_id) {
                continue;
            }

            if let Ok(effect_clone) = prioritized_effect.get_effect().clone_effect() {
                let result = effect_clone.begin_effect(game, card)?;

                match result {
                    EffectResult::Completed => {
                        // 효과 완료, 처리된 효과로 표시
                        self.processed_effect_ids.insert(effect_id);
                    }
                    EffectResult::NeedsInput { inner, handler } => {
                        let rx = game.get_input_waiter_mut().wait_for_input(inner).await?;
                        return Ok(Some(PlayCardResult::NeedInput(rx, handler)));
                    }
                }
            }
        }

        // 모든 즉발 효과가 완료됨
        Ok(None)
    }

    /// 체인 효과 추가
    fn add_chain_effects(
        &mut self,
        game: &mut Game,
        card: &Card,
        effects: &[PrioritizedEffect],
    ) -> Result<(), GameError> {
        // 체인 효과 수집
        let chain_effects: Vec<_> = effects
            .iter()
            .filter(|e| e.get_effect().get_timing() == EffectLevel::Chain)
            .collect();

        // 체인에 효과 추가
        for prioritized_effect in chain_effects {
            // 이미 처리된 효과는 건너뛰기
            let effect_id = prioritized_effect.get_effect().get_id().into();
            if self.processed_effect_ids.contains(&effect_id) {
                continue;
            }

            if let Ok(effect_clone) = prioritized_effect.get_effect().clone_effect() {
                self.add_effect(card.clone(), effect_clone);
            }
        }

        Ok(())
    }

    pub fn has_effects(&self) -> bool {
        !self.links.is_empty()
    }

    /// 체인에 효과 추가
    pub fn add_effect(&mut self, card: Card, effect: Box<dyn Effect>) {
        // 체인 구성 단계가 아니면 효과 추가 불가
        if self.current_phase != ChainPhase::Building {
            self.start_building(); // 새 체인 시작
        }

        // 효과를 체인 링크로 래핑하여 추가
        self.links.push(ChainLink {
            effect,
            source_card: card,
        });
    }

    /// 보류 중인 효과들을 체인에 추가
    pub fn pending_chain_effects(&mut self, card: Card, effects: Vec<PrioritizedEffect>) {
        // 입력 대기 상태로 변경
        self.current_phase = ChainPhase::Waiting;
        self.pending_card = Some(card);
        self.pending_effects = effects;
    }

    /// 사용자 입력 처리 후 보류 중인 효과 추가
    pub fn add_pending_effects_after_input(&mut self) -> Result<(), GameError> {
        if self.current_phase != ChainPhase::Waiting || self.pending_card.is_none() {
            return Err(GameError::InvalidChainState);
        }

        // 준비 단계로 전환
        self.current_phase = ChainPhase::Building;
        let card = self.pending_card.take().unwrap();

        // 벡터 소유권 가져오기
        let pending_effects = std::mem::take(&mut self.pending_effects);

        // 소유권을 가진 벡터 처리
        for prioritized_effect in pending_effects {
            let effect_id = prioritized_effect.get_effect().get_id();
            if !self.processed_effect_ids.contains(&effect_id.into()) {
                if let Ok(effect) = prioritized_effect.get_effect().clone_effect() {
                    self.add_effect(card.clone(), effect);
                }
            }
        }

        Ok(())
    }

    /// 체인 구성 시작
    pub fn start_building(&mut self) {
        // 이전 체인 상태 정리
        if self.current_phase == ChainPhase::Building || self.current_phase == ChainPhase::Resolving
        {
            // 이미 활성화된 체인이 있으면 처리 완료해야 함
            // 여기서는 간단히 초기화만 수행
            self.links.clear();
        }

        self.current_phase = ChainPhase::Building;
    }

    /// 체인 해결 시작
    pub fn start_resolving(&mut self) -> Result<(), GameError> {
        if self.links.is_empty() {
            return Ok(()); // 체인이 비어있으면 아무것도 안 함
        }

        self.current_phase = ChainPhase::Resolving;
        Ok(())
    }

    /// 체인의 모든 효과 해결
    pub fn resolve(&mut self, game: &mut Game) -> Result<ChainResolutionResult, GameError> {
        // 체인이 구성 중이면 해결 단계로 전환
        if self.current_phase == ChainPhase::Building {
            self.start_resolving()?;
        }

        // 해결 단계가 아니면 에러
        if self.current_phase != ChainPhase::Resolving {
            return Err(GameError::InvalidChainState);
        }

        // 대기 중인 입력이 있으면 처리
        if let Some(index) = self.waiting_effect_index {
            if let Some(input) = self.waiting_input.take() {
                let link = &self.links[index];
                let result = link.effect.handle_input(game, &link.source_card, input)?;

                match result {
                    EffectResult::Completed => {
                        // 효과 완료, 처리된 효과로 표시
                        self.processed_effect_ids
                            .insert(link.effect.get_id().into());
                        self.waiting_effect_index = None;
                    }
                    EffectResult::NeedsInput { inner, handler } => {
                        // 여전히 입력 필요
                        // return Ok(ChainResolutionResult::WaitingForInput(inner));
                    }
                }
            } else {
                // 대기 중인데 입력이 없으면 에러
                return Err(GameError::MissingInput);
            }
        }

        // LIFO 방식으로 체인 해결 (뒤에서부터 처리)
        while !self.links.is_empty() {
            let index = self.links.len() - 1;
            let link = &self.links[index];
            let effect_id = link.effect.get_id();

            // 이미 처리된 효과는 건너뛰기
            if self.processed_effect_ids.contains(&effect_id.into()) {
                self.links.pop();
                continue;
            }

            // 효과 실행
            let result = link.effect.begin_effect(game, &link.source_card)?;

            match result {
                EffectResult::Completed => {
                    // 효과 완료, 체인에서 제거
                    self.processed_effect_ids.insert(effect_id.into());
                    self.links.pop();
                }
                EffectResult::NeedsInput { inner, handler } => {
                    // 입력 대기 상태로 전환
                    self.waiting_effect_index = Some(index);
                    self.current_phase = ChainPhase::Waiting;
                    // return Ok(ChainResolutionResult::WaitingForInput(inner));
                }
            }
        }

        // 모든 효과 처리 완료
        self.current_phase = ChainPhase::Completed;
        Ok(ChainResolutionResult::Completed)
    }
}

impl Chain {
    /// 현재 체인 처리 단계 반환
    pub fn phase(&self) -> ChainPhase {
        self.current_phase
    }

    /// 현재 처리 중인 카드 참조 반환
    pub fn pending_card(&self) -> Option<&Card> {
        self.pending_card.as_ref()
    }

    /// 처리 대기 중인 효과들 참조 반환
    pub fn pending_effects(&self) -> &[PrioritizedEffect] {
        &self.pending_effects
    }

    /// 이미 처리된 효과 ID 목록 참조 반환
    // TODO: 사용된 효과는 특정 조건에 따라 다시 복구될 수 있어야함.
    pub fn processed_effect_ids(&self) -> &HashSet<Uuid> {
        &self.processed_effect_ids
    }

    /// 대기 중인 효과 인덱스 반환
    pub fn waiting_effect_index(&self) -> Option<usize> {
        self.waiting_effect_index
    }

    /// 대기 중인 사용자 입력 참조 반환
    pub fn waiting_input(&self) -> Option<&InputAnswer> {
        self.waiting_input.as_ref()
    }

    //
    // Setter 메서드 (필요한 필드만)
    //

    /// 체인 처리 단계 설정
    pub fn set_phase(&mut self, phase: ChainPhase) {
        self.current_phase = phase;
    }

    /// 처리 중인 카드 설정
    pub fn set_pending_card(&mut self, card: Option<Card>) {
        self.pending_card = card;
    }

    /// 대기 중인 효과들 설정
    pub fn set_pending_effects(&mut self, effects: Vec<PrioritizedEffect>) {
        self.pending_effects = effects;
    }

    /// 처리된 효과 ID 추가
    pub fn add_processed_effect_id(&mut self, effect_id: Uuid) {
        self.processed_effect_ids.insert(effect_id);
    }

    /// 처리된 효과 ID 목록 초기화
    pub fn clear_processed_effect_ids(&mut self) {
        self.processed_effect_ids.clear();
    }

    /// 효과가 이미 처리되었는지 확인
    pub fn is_effect_processed(&self, effect_id: &Uuid) -> bool {
        self.processed_effect_ids.contains(effect_id)
    }

    /// 대기 중인 효과 인덱스 설정
    pub fn set_waiting_effect_index(&mut self, index: Option<usize>) {
        self.waiting_effect_index = index;
    }

    /// 대기 중인 사용자 입력 설정
    pub fn set_waiting_input(&mut self, input: Option<InputAnswer>) {
        self.waiting_input = input;
    }

    //
    // 유틸리티 메서드
    //

    /// 대기 중인 효과 및 입력 정보 초기화
    pub fn clear_waiting_state(&mut self) {
        self.waiting_effect_index = None;
        self.waiting_input = None;
    }

    /// 모든 상태 초기화 (새 체인 시작용)
    pub fn reset(&mut self) {
        self.links.clear();
        self.current_phase = ChainPhase::Completed;
        self.pending_card = None;
        self.pending_effects.clear();
        self.processed_effect_ids.clear();
        self.clear_waiting_state();
    }
}

// 체인 해결 결과
pub enum ChainResolutionResult {
    Completed,                       // 모든 효과 처리 완료
    WaitingForInput(PlayCardResult), // 사용자 입력 대기
}
</file>

<file path="simulator_core/src/game_old/chain.rs">
use crate::{
    card::{types::PlayerType, Card},
    effect::{
        effects::EffectTiming,
        types::{EffectResult, EffectSpeed, HandlerType},
    },
    exception::GameError,
    server::input_handler::{InputAnswer, InputRequest},
};
use std::collections::HashSet;
use tracing::info;
use uuid::Uuid;

use super::{game_step::PlayCardResult, Game};

// 체인 처리 단계
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChainPhase {
    Idle,      // 대기 중 (새로운 체인 생서 가능)
    Building,  // 체인 구성 중 (효과 추가 가능)
    Resolving, // 체인 해결 중 (효과 실행 단계)
    Waiting,   // 사용자 입력 대기 중
    Completed, // 체인 처리 완료
}

impl Default for ChainPhase {
    fn default() -> Self {
        todo!()
    }
}

// 체인 아이템 구조체 (효과와 소스 카드 연결)
#[derive(Clone)]
pub struct ChainLink {
    effect: EffectTiming,
    source_card: Card,
}

#[derive(Clone, Default)]
pub struct Chain {
    // 체인 큐 (LIFO 방식으로 처리)
    links: Vec<ChainLink>,

    // 현재 체인 처리 단계
    current_phase: ChainPhase,

    // 이미 처리된 효과 ID
    processed_effect_ids: HashSet<Uuid>,
}

impl Chain {
    pub fn new() -> Self {
        Self {
            links: Vec::new(),
            current_phase: ChainPhase::Completed, // 초기 상태는 완료
            processed_effect_ids: HashSet::new(),
        }
    }

    /// 카드의 모든 효과를 처리합니다
    pub async fn process_card_effects(
        &mut self,
        game: &mut Game,
        player_type: PlayerType,
        card: Card,
    ) -> Result<PlayCardResult, GameError> {
        info!(
            "카드 효과 처리: player={:?}, card={:?}",
            player_type,
            card.get_uuid()
        );

        // 카드는 효과를 여러개 가질 수 있음.
        // 1. 카드의 효과는 각 게임 상태에 따라 발동 여부가 결정됨
        // 2. 개중에는 동시에 발동할 수 있는 효과도 있음 ( 이런 경우, 사용자가 무슨 효과를 발동할 지 선택함. )
        // 효과 중 이미 처리된 효과는 제외 해야함.
        // 이 때 이미 사용되었다고 해서 무조건 GameError 을 발생시키면 안됨.

        // 현재 입력된 카드의 효과를 가져옵니다.
        let effects = card.get_prioritized_effect().clone();

        // 발동 가능한 효과를 필터링 합니다.
        let activable_effects = effects
            .iter()
            .filter(|e| e.get_effect().can_activate(game, &card))
            .collect::<Vec<_>>();

        if activable_effects.is_empty() {
            // 발동 가능한 효과가 없으면 종료합니다.
            return Err(GameError::NoActivatableEffect);
        }

        // 발동 가능한 효과가 두 개 이상일 경우, 사용자로부터 선택을 받아야 합니다.
        if activable_effects.len() >= 2 {
            let rx = game
                .get_input_waiter_mut()
                .wait_for_input(InputRequest::SelectEffect {
                    source_card: card.get_uuid(),
                    potential_effects: activable_effects
                        .iter()
                        .map(|e| e.get_effect().get_id())
                        .collect(),
                })
                .await?;
            // TODO: HandlerType 넘겨서 외부 처리를 기대하는 패턴은 잘못된 것 같음.
            // 소유권, 생명 주기 관리가 어렵다
            // handle_input 에서 처리하거나 
            return Ok(PlayCardResult::NeedInput(
                rx,
                HandlerType::General(Box::new(
                    move |game: &mut Game,
                          source: &Card,
                          input: InputAnswer|
                          -> Result<EffectResult, GameError> {
                        Ok(EffectResult::Completed)
                    },
                )),
            ));
            // TODO: 무슨 효과를 발동할 지 선택 받아야함.
        }

        // 최종적으로 선택된 효과 하나를 가져옵니다.
        let activable_effect = *activable_effects.last().unwrap();

        match self.current_phase {
            // 체인이 대기 상태일 때
            ChainPhase::Idle => {
                // 바로 체인에 추가합니다.
                self.add_link_to_chain(activable_effect.clone(), card.clone());

                self.current_phase = ChainPhase::Building; // 체인 상태를 변경합니다.
            }
            // 체인이 구성 중일 때.
            ChainPhase::Building => {
                // 이전 체인 스피드를 확인하여 체인을 이어갈 수 있는지 확인합니다.
                // 체인 스피드가 같거나 빠른 경우에만 체인에 추가합니다.
                let last_effect = self.links.last().unwrap().effect.clone();

                // 현재 처리중인 효과의 이펙트 스피드가 체인보다 느릴 경우,
                if last_effect
                    .get_speed()
                    .can_it_chain(activable_effect.get_speed())
                    == false
                {
                    return Err(GameError::InvalidChainSpeed);
                }

                self.add_link_to_chain(activable_effect.clone(), card.clone());
            }
            _ => {
                // 체인 처리 중일 때는 추가할 수 없습니다.
                return Err(GameError::InvalidChainPhase);
            }
        }

        // 카드의 효과 중 발동될 수 있는 효과를 필터링 합니다.
        // 이 때 확인 사항은
        // 1. 효과가 발동될 수 있는 게임 상태인가?
        // 2. 아직 사용되지 않은 효과인가?

        todo!()
    }

    pub fn add_link_to_chain(&mut self, effect: EffectTiming, card: Card) {
        // 체인에 링크를 추가합니다.
        self.links.push(ChainLink {
            effect,
            source_card: card,
        });
    }

    pub fn can_add_to_chain(&self, effect_speed: EffectSpeed) -> bool {
        match self.current_phase {
            ChainPhase::Idle => true,
            ChainPhase::Building => {
                if let Some(last_link) = self.links.last() {
                    // 마지막 링크의 스피드와 비교하여 체인 가능 여부를 판단합니다.
                    return last_link.effect.get_speed().can_it_chain(effect_speed);
                } else {
                    // 체인이 비어있다면 추가 가능
                    return true;
                }
            }
            _ => false,
        }
    }
}

// 체인 해결 결과
pub enum ChainResolutionResult {
    Completed,                       // 모든 효과 처리 완료
    WaitingForInput(PlayCardResult), // 사용자 입력 대기
}
</file>

<file path="simulator_core/src/game_old/choice.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    card::types::PlayerType, enums::ZoneType, exception::GameError, server::jsons::game_features,
};

// ChoiceType 은 카드 선택의 종류를 나타냄
// 클라이언트 단으로 전달할 때, 게임 진행을 위한 정보가 여럿 포함되어 있는데.
// 이러한 정보들은 effect 로부터 얻어와야함.
// 대표적으로 DigEffect 의 경우, src, dest 정보가 필요함.
// src 의 경우 selector 에서 얻어오고
// dst 의 경우 insert 에서 얻어오면 될 듯?
// 근데 take, insert 는 카드를 어디서 가져오는지 정보를 가지고 있지 않음.
// 그러한 정보는 외부에서 저장되어있음.
// 그래서 Effect 자체에서 가지고 있는게 나을듯?
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChoiceType {
    Dig,          // 덱에서 카드 탐색
    Discard,      // 핸드에서 버릴 카드 선택
    SelectTarget, // 대상 선택 (유닛, 플레이어 등)
    Sacrifice,    // 희생할 카드 선택
    Rearrange,    // 카드 재배치/순서 변경
    RevealChoice, // 공개된 카드 중 선택
    MultiZone,    // 여러 영역에서 선택
}

impl ChoiceType {
    pub fn to_string(&self) -> String {
        match self {
            ChoiceType::Dig => "Dig".to_string(),
            ChoiceType::Discard => "Discard".to_string(),
            ChoiceType::SelectTarget => "SelectTarget".to_string(),
            ChoiceType::Sacrifice => "Sacrifice".to_string(),
            ChoiceType::Rearrange => "Rearrange".to_string(),
            ChoiceType::RevealChoice => "RevealChoice".to_string(),
            ChoiceType::MultiZone => "MultiZone".to_string(),
        }
    }
}

// 사용자
#[derive(Debug, Clone)]
pub struct ChoiceState {
    // 기본 정보
    player: PlayerType,
    choice_type: ChoiceType,

    // 소스 및 대상 정보
    source_card_id: Option<Uuid>,   // 선택 효과를 발동한 카드
    source_effect_id: Option<Uuid>, // 선택을 요청한 효과

    // 선택 제한 설정
    min_selections: usize, // 최소 선택 개수
    max_selections: usize, // 최대 선택 개수
    destination: ZoneType, // 선택 후 카드 목적지

    // 상태 관리
    is_open: bool,      // 선택이 활성화되어 있는지
    is_mandatory: bool, // 필수 선택 여부 (취소 불가)

    is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
}

impl Default for ChoiceState {
    fn default() -> Self {
        Self {
            player: PlayerType::Player1,
            choice_type: ChoiceType::Dig,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: true,
            is_mandatory: true,
            is_hidden_from_opponent: false,
        }
    }
}

impl ChoiceState {
    pub fn builder(player: PlayerType, choice_type: ChoiceType) -> ChoiceStateBuilder {
        ChoiceStateBuilder::new(player, choice_type)
    }

    pub fn new(
        player: PlayerType,
        choice_type: ChoiceType,
        source_card_id: Option<Uuid>,
        source_effect_id: Option<Uuid>,
        min_selections: usize,
        max_selections: usize,
        destination: ZoneType,
        is_open: bool,
        is_mandatory: bool,
        is_hidden_from_opponent: bool,
    ) -> Self {
        Self {
            player,
            choice_type,
            source_card_id,
            source_effect_id,
            min_selections,
            max_selections,
            destination,
            is_open,
            is_mandatory,
            is_hidden_from_opponent,
        }
    }

    pub fn serialize_message(&self) -> Result<String, GameError> {
        // ChoiceState의 정보를 ChoiceCardPayload로 변환
        let message = game_features::ChoiceCardRequestPayload {
            player: self.player.to_string(), // PlayerType을 문자열로 변환
            choice_type: self.choice_type.to_string(), // ChoiceType을 문자열로 변환
            source_card_id: self.source_card_id.unwrap(),
            min_selections: self.min_selections,
            max_selections: self.max_selections,
            destination: self.destination.to_string(),
            is_open: self.is_open,
            is_hidden_from_opponent: self.is_hidden_from_opponent,
        };

        // JSON 문자열로 직렬화
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

pub struct ChoiceStateBuilder {
    player: PlayerType,
    choice_type: ChoiceType,
    source_card_id: Option<Uuid>,
    source_effect_id: Option<Uuid>,
    min_selections: usize,
    max_selections: usize,
    destination: ZoneType,
    is_open: bool,
    is_mandatory: bool,
    is_hidden_from_opponent: bool,
}

impl ChoiceStateBuilder {
    pub fn new(player: PlayerType, choice_type: ChoiceType) -> Self {
        Self {
            player,
            choice_type,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: false,
            is_mandatory: false,
            is_hidden_from_opponent: false,
        }
    }

    pub fn source_card(mut self, card_id: impl Into<Option<Uuid>>) -> Self {
        self.source_card_id = card_id.into();
        self
    }

    pub fn source_effect(mut self, effect_id: impl Into<Option<Uuid>>) -> Self {
        self.source_effect_id = effect_id.into();
        self
    }

    pub fn selections(mut self, min: usize, max: usize) -> Self {
        self.min_selections = min;
        self.max_selections = max;
        self
    }

    pub fn destination(mut self, destination: ZoneType) -> Self {
        self.destination = destination;
        self
    }

    pub fn open(mut self, is_open: bool) -> Self {
        self.is_open = is_open;
        self
    }

    pub fn mandatory(mut self, is_mandatory: bool) -> Self {
        self.is_mandatory = is_mandatory;
        self
    }

    pub fn hidden_from_opponent(mut self, is_hidden: bool) -> Self {
        self.is_hidden_from_opponent = is_hidden;
        self
    }

    pub fn build(self) -> ChoiceState {
        ChoiceState::new(
            self.player,
            self.choice_type,
            self.source_card_id,
            self.source_effect_id,
            self.min_selections,
            self.max_selections,
            self.destination,
            self.is_open,
            self.is_mandatory,
            self.is_hidden_from_opponent,
        )
    }
}
</file>

<file path="simulator_core/src/game_old/game_step.rs">
use std::fmt;

use tokio::sync::oneshot::Receiver;
use uuid::Uuid;

use tracing::{debug, error, info, instrument, trace, warn};

use crate::{
    card::{insert::TopInsert, take::TopTake, types::PlayerType},
    effect::types::HandlerType,
    exception::GameError,
    selector::TargetCount,
    server::input_handler::InputAnswer,
    zone::zone::Zone,
    LogExt,
};

use super::Game;

pub enum PhaseResult {
    Mulligan,
    DrawPhase,
    StandbyPhase,
    MainPhaseStart,
    MainPhase1,
    BattlePhaseStart,
    BattleStep,
    BattleDamageStepStart,
    BattleDamageStepCalculationBefore,
    BattleDamageStepCalculationStart,
    BattleDamageStepCalculationEnd,
    BattleDamageStepEnd,
    BattlePhaseEnd,
    MainPhase2,
    EndPhase,
}

type PhaseResultType = Result<PhaseResult, GameError>;

// mulligan 에 필요한 게임 함수들.
pub mod mulligan {
    use super::*;
    impl Game {
        #[instrument(skip(self), fields(player_type = ?player_type.into()))]
        pub fn get_mulligan_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            count: usize,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            debug!(
                "멀리건 카드 뽑기 시도: player={:?}, count={}",
                player_type, count
            );

            let result = self
                .get_player_by_type(player_type)
                .get()
                .get_deck_mut()
                .take_card(Box::new(TopTake(TargetCount::Exact(count))));

            match &result {
                Ok(cards) => {
                    debug!(
                        "덱에서 카드 추출 성공: player={:?}, count={}",
                        player_type,
                        cards.len()
                    );
                }
                Err(e) => {
                    // 에러 로깅 추가
                    error!(
                        "덱에서 카드 추출 실패: player={:?}, error={:?}",
                        player_type, e
                    );
                }
            }

            // 성공 시 UUID 변환
            let cards = result?
                .iter()
                .map(|card| card.get_uuid())
                .collect::<Vec<_>>();
            debug!(
                "멀리건 카드 뽑기 완료: player={:?}, card_count={}",
                player_type,
                cards.len()
            );

            Ok(cards)
        }

        #[instrument(skip(self), fields(player_type = ?player_type.into()))]
        pub fn add_select_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            cards: Vec<Uuid>,
            player_type: T,
        ) {
            let player_type = player_type.into();
            debug!(
                "멀리건 상태에 카드 추가 시작: player={:?}, cards={:?}",
                player_type, cards
            );

            let mut player = self.get_player_by_type(player_type).get();

            player
                .get_mulligan_state_mut()
                .add_select_cards(cards.clone());
            debug!("멀리건 상태에 카드 추가 완료: player={:?}", player_type);
        }

        pub fn add_reroll_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            payload_cards: Vec<Uuid>,
            rerolled_cards: Vec<Uuid>,
        ) {
            let player_type = player_type.into();
            debug!("선택 카드 제거: player={:?}", player_type);
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .remove_select_cards(payload_cards);

            debug!("리롤된 카드 추가: player={:?}", player_type);
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .add_select_cards(rerolled_cards);
        }

        pub fn reroll_request<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            cards: Vec<Uuid>,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            // 플레이어가 이미 준비 상태인 경우
            if self
                .get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .is_ready()
            {
                warn!("플레이어가 이미 준비 상태: player={:?}", player_type);
                return Err(GameError::AlreadyReady);
                // try_send_error!(session, GameError::AlreadyReady, retry 3);
            }

            // 플레이어가 선택한 카드가 유효한지 확인합니다.
            debug!("선택한 카드 유효성 검사: player={:?}", player_type);
            if let Err(e) = self.get_cards_by_uuids(cards.clone()) {
                error!("유효하지 않은 카드 선택: player={:?}", player_type);
                return Err(e);
            }

            // 기존 카드를 덱의 최하단에 위치 시킨 뒤, 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장하고 json 으로 변환하여 전송합니다.
            info!("카드 리롤 시작: player={:?}", player_type);
            let rerolled_card = match self.restore_then_reroll_mulligan_cards(player_type, cards) {
                Ok(cards) => {
                    debug!("카드 리롤 성공: card_count={}", cards.len());
                    cards
                }
                Err(e) => {
                    error!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
                    panic!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
                }
            };

            Ok(rerolled_card)
        }

        /// 멀리건 완료 처리 함수
        /// - 게임 객체를 받아서, 플레이어의 멀리건 상태를 완료로 변경하고, 선택한 카드들을 손으로 이동시킵니다.
        /// - 선택한 카드들의 UUID를 반환합니다.
        /// # Arguments
        /// * `game` - 게임 객체
        /// * `player_type` - 플레이어 타입
        /// # Returns
        /// * `Vec<Uuid>` - 선택한 카드들의 UUID

        pub fn process_mulligan_completion<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();

            // 선택된 멀리건 카드들의 UUID 를 얻습니다.
            let selected_cards = self
                .get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .get_select_cards();

            // UUID -> Card 객체로 변환하는 과정입니다.
            let cards = self.get_cards_by_uuids(selected_cards.clone())?;

            // add_card 함수를 통해 선택된 카드들을 손으로 이동시킵니다.
            self.get_player_by_type(player_type)
                .get()
                .get_hand_mut()
                .add_card(cards, Box::new(TopInsert))
                .map_err(|_| GameError::InternalServerError)?;

            // 멀리건 상태를 "완료" 상태로 변경합니다.
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .confirm_selection();

            // 그런 뒤, 선택한 카드들을 반환합니다.
            Ok(selected_cards)
        }

        pub fn check_player_ready_state<T: Into<PlayerType> + Copy>(&self, player_type: T) -> bool {
            let player_type = player_type.into();
            self.get_player_by_type(player_type.reverse())
                .get()
                .get_mulligan_state_mut()
                .is_ready()
        }
    }
}

pub enum PlayCardResult {
    Success,
    NeedInput(Receiver<InputAnswer>, HandlerType),
    Fail(GameError),
}

impl fmt::Debug for PlayCardResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PlayCardResult::Success => write!(f, "PlayCardResult::Success"),
            PlayCardResult::NeedInput(rx, _) => {
                write!(f, "PlayCardResult::NeedInput({:?}, <function>)", rx)
            }
            PlayCardResult::Fail(err) => write!(f, "PlayCardResult::Fail({:?})", err),
        }
    }
}

pub mod main_phase1 {

    use super::*;
    impl Game {
        // 카드를 처리하는 함수인데
        // 외부 ( end point ) 에서 사용하는 함수라서 카드 처리 함수는 이 함수로 유일해야함.

        // 카드의 효과 발동 방법은 다음과 같이 2 가지 유형으로 나뉘어짐.
        // 1. 카드 플레이 ( 핸드에서 필드로 카드를 낸 경우 )
        // 2. 특정 조건을 만족한 경우, 효과 발동 ( 카드 위치는 상관 없이 )
        // 이 함수는 1 번에 대해서만 처리하는 함수임.
        pub async fn proceed_card<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            card_uuid: Uuid,
        ) -> Result<PlayCardResult, GameError> {
            let player_type = player_type.into();
            info!(
                "카드 처리 시작: player={:?}, card_uuid={:?}",
                player_type, card_uuid
            );

            // 카드 조회 및 활성화 가능 여부 확인
            let card = self.get_cards_by_uuid(card_uuid)?;
            // card.can_activate(&self)?;

            // 효과 처리 다시 작업해야함.
            // 카드의 종료는 다음과 같음.
            // 1 . 프리체인 ( 체인에 안걸리고 바로 발동하는 효과들 )
            // 2 . 체인에 걸리는 효과들 ( 카드 효과들 )

            // 체인 형성 중 일반 카드 ( 일반 소환 등 )는 사용할 수 없음.
            // 카드 효과 유발에 레벨을 개념을 적용시켜야함.
            // 스펠 스피드 1, 2, 3 등으로 나눔.
            // 스펠 스피드 1 은 가장 느린 스피드를 가지는 효과로써, 체인을 이어갈 수 없음.
            // 스펠 스피드 2 는 스피드 1, 2에 효과에 대해 체인을 이어갈 수 있음.
            // 스펠 스피드 3 은 스피드 1, 2, 3에 효과에 대해 체인을 이어갈 수 있음.

            // Chain에 카드 효과 처리 위임
            let mut chain = std::mem::take(self.get_chain_mut());
            let result = chain.process_card_effects(self, player_type, card).await;
            *self.get_chain_mut() = chain;

            result
        }
    }
}

pub mod gmae_effects_funcs {

    use crate::{card::Card, effect::DigEffect};

    use super::*;

    impl Game {
        /// 카드 탐색(Digging) 기능을 수행합니다.
        ///
        /// # Arguments
        /// * `player_type` - 카드를 탐색하는 플레이어
        /// * `effect_id` - 사용할 탐색 효과의 ID
        /// * `card_uuid` - 탐색 효과가 있는 소스 카드의 UUID
        ///
        /// # Returns
        /// * `Result<Vec<Uuid>, GameError>` - 탐색 가능한 카드들의 UUID 목록
        pub fn digging_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            effect_id: Uuid,
            card_uuid: Uuid,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            info!(
                "카드 탐색 시작: player={:?}, effect_id={:?}, card={}",
                player_type, effect_id, card_uuid
            );

            // 1. 소스 카드 찾기
            let source_card = self.get_cards_by_uuid(card_uuid)?;

            // 2. 카드에서 해당 Dig 효과 찾기
            let dig_effect = self.find_dig_effect(&source_card, effect_id)?;

            // 3. 선택 가능한 카드들 찾기
            let selectable_cards = dig_effect
                .get_selector()
                .select_targets(self, &source_card)
                .map_err(|e| {
                    error!("대상 선택 실패: {:?}", e);
                    GameError::InvalidTarget
                })?;

            // 4. 선택 가능한 카드가 없는 경우 처리
            if selectable_cards.is_empty() {
                warn!("선택 가능한 카드가 없음: player={:?}", player_type);
                return Err(GameError::NoValidTargets);
            }

            // 5. UUID 목록 생성
            let card_uuids: Vec<Uuid> = selectable_cards
                .iter()
                .map(|card| card.get_uuid())
                .collect();

            debug!(
                "탐색 가능한 카드: count={}, uuids={:?}",
                card_uuids.len(),
                card_uuids
            );

            Ok(card_uuids)
        }

        /// 카드에서 특정 ID를 가진 DigEffect를 찾습니다.
        fn find_dig_effect<'a>(
            &mut self,
            card: &'a Card,
            effect_id: Uuid,
        ) -> Result<&'a DigEffect, GameError> {
            // 효과 찾기
            let effect = card
                .get_prioritized_effect()
                .iter()
                .find(|e| e.get_effect().get_id() == effect_id)
                .ok_or_else(|| {
                    error!("효과를 찾을 수 없음: effect_id={:?}", effect_id);
                    GameError::EffectNotFound
                })?;

            // DigEffect로 다운캐스팅
            effect
                .get_effect()
                .as_any()
                .downcast_ref::<DigEffect>()
                .ok_or_else(|| {
                    error!(
                        "잘못된 효과 타입: expected=DigEffect, effect_id={:?}",
                        effect_id
                    );
                    GameError::InvalidEffectType
                })
        }
    }
}

impl Game {
    // pub fn handle_phase_start(&mut self) -> PhaseResultType {
    //     match self.get_phase() {
    //         Phase::Mulligan => Ok(PhaseResult::Mulligan),
    //         Phase::DrawPhase => Ok(PhaseResult::DrawPhase),
    //         Phase::StandbyPhase => self.handle_standby_phase(),
    //         Phase::MainPhaseStart => self.handle_main_phase_start(),
    //         Phase::MainPhase1 => self.handle_main_phase_1(),
    //         Phase::BattlePhaseStart => self.handle_battle_phase_start(),
    //         Phase::BattleStep => self.handle_battle_step(),
    //         Phase::BattleDamageStepStart => self.handle_damage_step_start(),
    //         Phase::BattleDamageStepCalculationBefore => self.handle_before_damage_calculation(),
    //         Phase::BattleDamageStepCalculationStart => self.handle_damage_calculation(),
    //         Phase::BattleDamageStepCalculationEnd => self.handle_after_damage_calculation(),
    //         Phase::BattleDamageStepEnd => self.handle_damage_step_end(),
    //         Phase::BattlePhaseEnd => self.handle_battle_phase_end(),
    //         Phase::MainPhase2 => self.handle_main_phase_2(),
    //         Phase::EndPhase => self.handle_end_phase(),
    //     }
    // }

    pub fn handle_muliigan_phase(&mut self) {
        // 멀리건 페이즈 시작
        info!("멀리건 페이즈 시작");

        // 멀리건 페이즈 종료
        info!("멀리건 페이즈 종료");
    }

    #[instrument(skip(self), fields(player_type = ?player_type.into()))]
    pub fn handle_draw_phase<T: Into<PlayerType> + Copy>(
        &mut self,
        player_type: T,
    ) -> Result<Uuid, GameError> {
        let player_type = player_type.into();
        info!("드로우 페이즈 시작: player={:?}", player_type);

        trace!("드로우 페이즈 효과 발동 중...");
        // self.trigger_draw_phase_effects()?;
        debug!("드로우 페이즈 효과 발동 완료");

        let card = self
            .draw_card(player_type)
            .log_ok(|| debug!("카드 드로우 성공: player={:?}", player_type,))
            .map_err(|e| {
                error!("카드 드로우 실패: player={:?}, error={:?}", player_type, e);
                e
            })?;

        debug!(
            "카드 드로우 성공: player={:?}, card_uuid={}",
            player_type,
            card.get_uuid()
        );

        trace!("핸드에 카드 추가 시작: player={:?}", player_type);
        let mut player = self.get_player_by_type(player_type).get();

        player
            .get_hand_mut()
            .add_card(vec![card.clone()], Box::new(TopInsert))
            .log_ok(|| debug!("핸드에 카드 추가 성공: player={:?}", player_type))
            .log_err(|e| {
                warn!(
                    "핸드에 카드 추가 중 문제 발생: player={:?}, error={:?}",
                    player_type, e
                )
            })?;

        info!(
            "드로우 페이즈 완료: player={:?}, card_uuid={}",
            player_type,
            card.get_uuid()
        );
        Ok(card.get_uuid())
    }

    pub fn handle_standby_phase(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈에서 발동하는 효과들 처리
        self.trigger_standby_effects()?;
        todo!()
    }

    pub fn handle_main_phase_start(&mut self) -> PhaseResultType {
        // 메인 페이즈 1 개시시 효과 처리
        self.trigger_main_phase_start_effects()?;
        todo!()
    }

    fn handle_main_phase_1(&mut self) -> PhaseResultType {
        // 메인 페이즈 1 진입 처리
        todo!()
    }

    fn handle_battle_phase_start(&mut self) -> PhaseResultType {
        // 배틀 페이즈 개시시 효과 처리
        self.trigger_battle_phase_start_effects()?;
        todo!()
    }

    fn handle_battle_step(&mut self) -> PhaseResultType {
        // 배틀 스텝 처리
        todo!()
    }

    fn handle_damage_step_start(&mut self) -> PhaseResultType {
        // 데미지 스텝 시작 처리
        self.trigger_damage_step_start_effects()?;
        todo!()
    }

    fn handle_before_damage_calculation(&mut self) -> PhaseResultType {
        // 데미지 계산 전 효과 처리
        todo!()
    }

    fn handle_damage_calculation(&mut self) -> PhaseResultType {
        // 실제 데미지 계산 처리
        self.calculate_battle_damage()?;
        todo!()
    }

    fn handle_after_damage_calculation(&mut self) -> PhaseResultType {
        // 데미지 계산 후 효과 처리
        todo!()
    }

    fn handle_damage_step_end(&mut self) -> PhaseResultType {
        // 데미지 스텝 종료 처리
        todo!()
    }

    fn handle_battle_phase_end(&mut self) -> PhaseResultType {
        // 배틀 페이즈 종료 처리
        todo!()
    }

    fn handle_main_phase_2(&mut self) -> PhaseResultType {
        // 메인 페이즈 2 처리
        todo!()
    }

    fn handle_end_phase(&mut self) -> PhaseResultType {
        // 턴 종료 처리
        self.handle_turn_end()?;
        todo!()
    }

    /// 페이즈 종료 시 처리
    fn handle_phase_end(&mut self) -> PhaseResultType {
        // 현재 페이즈 종료 시 필요한 처리
        todo!()
    }

    /// 턴 종료 처리
    fn handle_turn_end(&mut self) -> PhaseResultType {
        todo!()
    }

    //
    fn trigger_draw_phase_effects(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈 효과 발동
        todo!()
    }

    // 유틸리티 메서드들
    fn trigger_standby_effects(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈 효과 발동
        todo!()
    }

    fn trigger_main_phase_start_effects(&mut self) -> PhaseResultType {
        // 메인 페이즈 개시시 효과 발동
        todo!()
    }

    fn trigger_battle_phase_start_effects(&mut self) -> PhaseResultType {
        // 배틀 페이즈 개시시 효과 발동
        todo!()
    }

    fn trigger_damage_step_start_effects(&mut self) -> PhaseResultType {
        // 데미지 스텝 개시시 효과 발동
        todo!()
    }

    fn calculate_battle_damage(&mut self) -> PhaseResultType {
        // 전투 데미지 계산
        todo!()
    }

    fn check_hand_limit(&mut self) -> PhaseResultType {
        // 손 카드 제한(10장) 체크
        todo!()
    }
}
</file>

<file path="simulator_core/src/game_old/getter.rs">
use crate::{
    card::{types::PlayerType, Card},
    enums::ZoneType,
    zone::zone::Zone,
};

use super::Game;

impl Game {
    pub fn get_cards_by_player_and_zone_type(
        &self,
        player_type: PlayerType,
        zone_type: ZoneType,
    ) -> Vec<Card> {
        match (player_type, zone_type) {
            (PlayerType::Player1, ZoneType::Hand) => self.get_player_hand_cards(),
            (PlayerType::Player1, ZoneType::Field) => self.get_player_field_cards(),
            (PlayerType::Player1, ZoneType::Deck) => self.get_player_deck_cards(),
            (PlayerType::Player1, ZoneType::Graveyard) => self.get_player_graveyard_cards(),

            (PlayerType::Player2, ZoneType::Hand) => self.get_opponent_hand_cards(),
            (PlayerType::Player2, ZoneType::Field) => self.get_opponent_field_cards(),
            (PlayerType::Player2, ZoneType::Deck) => self.get_opponent_deck_cards(),
            (PlayerType::Player2, ZoneType::Graveyard) => self.get_opponent_graveyard_cards(),

            (_, ZoneType::Effect) => todo!(),
            (_, ZoneType::None) => panic!("Zone type is not allowed to be None"),
        }
    }

    pub fn get_player_field_cards(&self) -> Vec<Card> {
        self.get_player().get().get_field().get_cards().clone()
    }

    pub fn with_player_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_field_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_field_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_field().get_cards().clone()
    }

    pub fn with_opponent_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_field_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 핸드 카드
    pub fn get_player_hand_cards(&self) -> Vec<Card> {
        self.get_player().get().get_hand().get_cards().clone()
    }

    pub fn with_player_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_hand_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_hand_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_hand().get_cards().clone()
    }

    pub fn with_opponent_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_hand_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 묘지 카드
    pub fn get_player_graveyard_cards(&self) -> Vec<Card> {
        self.get_player().get().get_graveyard().get_cards().clone()
    }

    pub fn with_player_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_graveyard_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_graveyard_cards(&self) -> Vec<Card> {
        self.get_opponent()
            .get()
            .get_graveyard()
            .get_cards()
            .clone()
    }

    pub fn with_opponent_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_graveyard_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 덱 카드
    pub fn get_player_deck_cards(&self) -> Vec<Card> {
        self.get_player().get().get_deck().get_cards().clone()
    }

    pub fn with_player_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_deck_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_deck().get_cards().clone()
    }

    pub fn with_opponent_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }
}
</file>

<file path="simulator_core/src/game_old/helper.rs">
use uuid::Uuid;

use crate::{card::types::PlayerType, exception::GameError};

use super::Game;

impl Game {
    pub fn restore_then_reroll_mulligan_cards<T: Into<PlayerType>>(
        &mut self,
        player_type: T,
        exclude_cards: Vec<Uuid>,
    ) -> Result<Vec<Uuid>, GameError> {
        let player_type = player_type.into();
        self.restore_card(player_type, &exclude_cards)?;
        let new_cards = self.get_mulligan_cards(player_type, exclude_cards.len())?;
        Ok(new_cards)
    }
}

#[macro_export]
macro_rules! downcast_effect {
    ($effect:expr, $target_type:ty) => {
        if $effect.get_effect_type() == <$target_type>::static_effect_type() {
            if let Some(specific) = $effect.as_any().downcast_ref::<$target_type>() {
                Some(specific)
            } else {
                None
            }
        } else {
            None
        }
    };
}

pub async fn wait_for_input() -> Result<(), GameError> {
    todo!()
}
</file>

<file path="simulator_core/src/game_old/mod.rs">
pub mod chain;
pub mod choice;
pub mod game_step;
mod getter;
mod helper;
pub mod phase;
pub mod turn_manager;

use std::collections::HashMap;

use chain::Chain;
use phase::{Phase, PhaseState};
use turn_manager::Turn;
use uuid::Uuid;

use crate::{
    card::{cards::CardVecExt, insert::BottomInsert, take::BottomTake, types::PlayerType, Card},
    enums::DeckCode,
    exception::GameError,
    selector::TargetCount,
    server::input_handler::InputWaiter,
    unit::player::{Player, Resoruce},
    utils::deckcode_to_cards,
    zone::zone::Zone,
    OptArc,
};

pub struct GameConfig {
    /// Player's Deckcode
    pub player_1_deckcode: DeckCode,
    pub player_2_deckcode: DeckCode,

    /// 1 : Player 1,
    /// 2 : Player 2
    pub attacker: usize,
}

/// 게임의 상태를 관리/저장 하는 구조체
/// Card 로 인한 모든 변경 사항은 Task 로써 저장되며,
/// 그것을 담은 Tasks 를 Procedure 에게 전달하여 게임 결과를 계산한다.
#[derive(Clone)]
pub struct Game {
    pub player1: OptArc<Player>,
    pub player2: OptArc<Player>,
    pub phase_state: PhaseState,
    pub turn: Turn,
    pub chain: Chain,
    pub input_waiter: InputWaiter,
}

/// initialize 함수에 GameConfig 을 넣음으로써 두 플레이어의 Cards 을 설정한다.
impl Game {
    pub fn initialize(&mut self, _config: GameConfig) -> Result<(), GameError> {
        let cards = deckcode_to_cards(_config.player_1_deckcode, _config.player_2_deckcode)?;

        // TODO: Limit 을 const 로 빼야함.
        let cost = Resoruce::new(0, 10);
        let mana = Resoruce::new(0, 3);
        self.player1 = OptArc::new(Player::new(
            OptArc::none(),
            PlayerType::Player1,
            cards[0].clone(),
            cost.clone(),
            mana.clone(),
        ));
        self.player2 = OptArc::new(Player::new(
            OptArc::none(),
            PlayerType::Player2,
            cards[1].clone(),
            cost,
            mana,
        ));

        self.player1
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .extend(cards[0].clone());
        self.player2
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .extend(cards[1].clone());
        Ok(())
    }
}

impl Game {
    pub fn get_player_by_type<T: Into<PlayerType> + Copy>(
        &self,
        player_type: T,
    ) -> &OptArc<Player> {
        match player_type.into() {
            PlayerType::Player1 => &self.player1,
            PlayerType::Player2 => &self.player2,
        }
    }

    pub fn get_turn(&self) -> &Turn {
        &self.turn
    }

    pub fn get_phase(&self) -> Phase {
        self.phase_state.get_phase()
    }

    pub fn get_phase_state_mut(&mut self) -> &mut PhaseState {
        &mut self.phase_state
    }

    pub fn get_phase_state(&mut self) -> &PhaseState {
        &self.phase_state
    }

    pub fn get_turn_mut(&mut self) -> &mut Turn {
        &mut self.turn
    }

    pub fn move_phase(&mut self) {
        self.phase_state.get_phase().move_to_next_phase();
    }

    pub fn get_player(&self) -> &OptArc<Player> {
        &self.player1
    }

    pub fn get_opponent(&self) -> &OptArc<Player> {
        &self.player2
    }

    pub fn get_chain_mut(&mut self) -> &mut Chain {
        &mut self.chain
    }

    pub fn get_input_waiter_mut(&mut self) -> &mut InputWaiter {
        &mut self.input_waiter
    }

    // pub fn resolve_chain(&mut self) -> Result<(), GameError> {
    //     self.chain.resolve(self)?;
    //     Ok(())
    // }

    pub fn get_chain(&self) -> &Chain {
        &self.chain
    }

    /// 플레이어의 덱에서 카드를 뽑아 손에 추가합니다.
    /// # Parameters
    /// * `player_type` - 덱에서 카드를 뽑을 플레이어의 종류입니다.
    /// # Returns
    /// * 뽑은 카드를 반환합니다.
    /// # Errors
    /// * 덱에 카드가 없을 경우 NoCardsLeft 에러를 반환합니다.
    pub fn draw_card(&mut self, player_type: PlayerType) -> Result<Card, GameError> {
        let result = self
            .get_player_by_type(player_type)
            .get()
            .get_deck_mut()
            .take_card(Box::new(BottomTake(TargetCount::Exact(1))))?;

        // TODO: 이 확인이 필요한가?
        if result.is_empty() {
            return Err(GameError::NoCardsLeft);
        }

        Ok(result[0].clone())
    }

    /// 파라미터로 들어오는 카드들을 덱의 맨 밑으로 복원합니다.
    ///
    /// # Parameters
    /// * `player_type` - 카드를 복원할 플레이어 타입
    /// * `src_cards` - 복원할 카드들의 UUID 목록
    ///
    /// # Returns
    /// * `Ok(())` - 모든 카드가 성공적으로 덱의 맨 밑에 추가됨
    /// * `Err(GameError)` - 카드 복원 중 오류 발생
    ///
    /// # Errors
    /// * `GameError::CardNotFound` - 지정된 UUID를 가진 카드를 플레이어가 소유하지 않은 경우
    /// * `GameError::ExceededCardLimit` - 덱에 자리가 없어 카드를 추가할 수 없는 경우
    ///
    pub fn restore_card(
        &mut self,
        player_type: PlayerType,
        src_cards: &Vec<Uuid>,
    ) -> Result<(), GameError> {
        for card_uuid in src_cards {
            let card = {
                let player = self.get_player_by_type(player_type).get();
                match player.get_cards().find_by_uuid(card_uuid.clone()) {
                    Some(card) => card.clone(),
                    None => return Err(GameError::CardNotFound),
                }
            };
            self.get_player_by_type(player_type)
                .get()
                .get_deck_mut()
                .add_card(vec![card.clone()], Box::new(BottomInsert))?;
        }
        Ok(())
    }

    /// 두 플레이어의 카드 목록에서 입력받은 UUID에 해당하는 카드를 순서대로 찾아 반환합니다.
    ///
    /// # 설명
    /// - 플레이어와 상대방의 모든 카드 목록을 합쳐서, 각 카드의 고유한 UUID를 key로 하는 HashMap을 생성합니다.
    /// - 입력받은 UUID 리스트의 순서대로 해당 카드들을 찾아 Vec<Card>로 반환합니다.
    ///
    /// # Parameters
    /// - `uuids`: 찾고자 하는 카드의 고유 식별자(UUID)들이 담긴 벡터입니다.
    ///             각 UUID는 고유하다고 가정합니다.
    ///
    /// # Returns
    /// - 입력받은 순서대로 찾은 카드들을 담은 Vec<Card>를 반환합니다.
    ///
    /// # Panics
    /// - 만약 입력받은 UUID 중 하나라도 플레이어와 상대방의 카드 목록에서 찾지 못하면,
    ///   GameError::CardsNotFound 에러를 반환합니다.
    pub fn get_cards_by_uuids(&self, uuids: Vec<Uuid>) -> Result<Vec<Card>, GameError> {
        let player = self.get_player().get();
        let opponent = self.get_opponent().get();

        // 두 카드 리스트를 하나의 iterator로 합칩니다.
        // UUID가 고유하다고 가정하므로, (uuid, card) 쌍을 HashMap에 저장할 수 있습니다.
        let card_map: HashMap<Uuid, Card> = player
            .get_cards()
            .iter()
            .chain(opponent.get_cards().iter())
            .map(|card| (card.get_uuid(), card.clone()))
            .collect();

        // 입력한 uuid 순서대로 카드들을 찾아서 반환합니다.
        // 입력 uuid 중 하나라도 매칭되는 카드가 없으면 panic! 합니다.
        let mut results = Vec::with_capacity(uuids.len());
        for uuid in uuids {
            if let Some(card) = card_map.get(&uuid) {
                results.push(card.clone());
            } else {
                return Err(GameError::CardsNotFound);
            }
        }
        Ok(results)
    }

    /// 두 플레이어의 카드 목록에서 입력받은 UUID에 해당하는 카드를 순서대로 찾아 반환합니다.
    ///
    /// # 설명
    /// - 플레이어와 상대방의 모든 카드 목록을 합쳐서, 각 카드의 고유한 UUID를 key로 하는 HashMap을 생성합니다.
    /// - 입력받은 UUID 리스트의 순서대로 해당 카드들을 찾아 Card로 반환합니다.
    ///
    /// # Parameters
    /// - `uuids`: 찾고자 하는 카드의 고유 식별자(UUID)들이 담긴 벡터입니다.
    ///             각 UUID는 고유하다고 가정합니다.
    ///
    /// # Returns
    /// - 입력받은 순서대로 찾은 카드들을 담은 Card를 반환합니다.
    ///
    /// # Panics
    /// - 만약 입력받은 UUID 를 가지고 플레이어와 상대방의 카드 목록에서 찾지 못하면,
    ///   GameError::CardNotFound 에러를 반환합니다.
    pub fn get_cards_by_uuid(&self, uuid: Uuid) -> Result<Card, GameError> {
        let player = self.get_player().get();
        let opponent = self.get_opponent().get();

        // 두 카드 리스트를 하나의 iterator로 합칩니다.
        // UUID가 고유하다고 가정하므로, (uuid, card) 쌍을 HashMap에 저장할 수 있습니다.
        let card_map: HashMap<Uuid, Card> = player
            .get_cards()
            .iter()
            .chain(opponent.get_cards().iter())
            .map(|card| (card.get_uuid(), card.clone()))
            .collect();

        // 입력한 uuid 순서대로 카드들을 찾아서 반환합니다.
        // 입력 uuid 중 하나라도 매칭되는 카드가 없으면 panic! 합니다.
        card_map.get(&uuid).cloned().ok_or(GameError::CardNotFound)
    }
}

// TODO: 게임의 상태를 hash 로 변환해서 제공해야함.
</file>

<file path="simulator_core/src/game_old/phase.rs">
use std::collections::HashSet;

use crate::card::types::PlayerType;

#[derive(Clone)]
pub struct PhaseState {
    current_phase: Phase,
    completed_players: HashSet<PlayerType>,
}

impl PhaseState {
    pub fn new(phase: Phase) -> Self {
        Self {
            current_phase: phase,
            completed_players: HashSet::new(),
        }
    }

    pub fn has_player_completed(&self, player_type: PlayerType) -> bool {
        self.completed_players.contains(&player_type)
    }

    pub fn mark_player_completed(&mut self, player_type: PlayerType) {
        self.completed_players.insert(player_type);
    }

    pub fn reset_player_completed(&mut self, player_type: PlayerType) {
        self.completed_players.remove(&player_type);
    }

    pub fn reset(&mut self) {
        self.completed_players.clear();
    }

    pub fn get_phase(&self) -> Phase {
        self.current_phase
    }

    pub fn set_phase(&mut self, phase: Phase) {
        self.current_phase = phase;
    }
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum Phase {
    Heartbeat,

    Mulligan,

    // 가장 먼저 시작되는 드로우 페이즈 ( 기타 자원 등 증가함. )
    DrawPhase,

    // 메인 페이즈 진입 전 시작되는 페이즈
    StandbyPhase,

    // 메인 페이즈 개시시
    MainPhaseStart,
    // 메인 페이즈 개시중
    MainPhase1,

    // 배틀 페이즈 진입
    BattlePhaseStart,
    // 배틀 페이즈 중
    BattleStep,
    // 데미지 스텝 개시시
    BattleDamageStepStart,
    // 데미지 계산 전
    BattleDamageStepCalculationBefore,
    // 데미지 계산 중
    BattleDamageStepCalculationStart,
    // 데미지 계산 후
    BattleDamageStepCalculationEnd,
    // 데미지 스텝 종료시
    BattleDamageStepEnd,
    // 데미지 페이즈 종료
    BattlePhaseEnd,

    // 메인 페이즈2 시작
    MainPhase2,

    // 턴 종료
    EndPhase,
}

impl From<String> for Phase {
    fn from(value: String) -> Self {
        match value.to_lowercase().as_str() {
            "mulligan" => Phase::Mulligan,
            "drawphase" => Phase::DrawPhase,
            "standbyphase" => Phase::StandbyPhase,
            "mainphasestart" => Phase::MainPhaseStart,
            "mainphase1" => Phase::MainPhase1,
            "battlephasestart" => Phase::BattlePhaseStart,
            "battlestep" => Phase::BattleStep,
            "battledamagestepstart" => Phase::BattleDamageStepStart,
            "battledamagestepcalculationbefore" => Phase::BattleDamageStepCalculationBefore,
            "battledamagestepcalculationstart" => Phase::BattleDamageStepCalculationStart,
            "battledamagestepcalculationend" => Phase::BattleDamageStepCalculationEnd,
            "battledamagestepend" => Phase::BattleDamageStepEnd,
            "battlephaseend" => Phase::BattlePhaseEnd,
            "mainphase2" => Phase::MainPhase2,
            "endphase" => Phase::EndPhase,
            "heartbeat" => Phase::Heartbeat,
            _ => panic!("Invalid Phase string: {}", value),
        }
    }
}

impl PartialOrd for Phase {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Phase {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.order().cmp(&other.order())
    }
}

impl Phase {
    fn order(&self) -> u8 {
        match self {
            Phase::Mulligan => 0,
            Phase::DrawPhase => 1,
            Phase::StandbyPhase => 2,
            Phase::MainPhaseStart => 3,
            Phase::MainPhase1 => 4,
            Phase::BattlePhaseStart => 5,
            Phase::BattleStep => 6,
            Phase::BattleDamageStepStart => 7,
            Phase::BattleDamageStepCalculationBefore => 8,
            Phase::BattleDamageStepCalculationStart => 9,
            Phase::BattleDamageStepCalculationEnd => 10,
            Phase::BattleDamageStepEnd => 11,
            Phase::BattlePhaseEnd => 12,
            Phase::MainPhase2 => 13,
            Phase::EndPhase => 14,
            Phase::Heartbeat => 15,
        }
    }

    /// 현재 페이즈가 드로우 페이즈인지 확인
    pub fn is_draw_phase(&self) -> bool {
        matches!(self, Phase::DrawPhase)
    }

    /// 현재 페이즈가 스탠바이 페이즈인지 확인
    pub fn is_standby_phase(&self) -> bool {
        matches!(self, Phase::StandbyPhase)
    }

    /// 메인 페이즈 1 관련 체크
    pub fn is_main_phase_1(&self) -> bool {
        matches!(self, Phase::MainPhase1)
    }

    pub fn is_main_phase_1_start(&self) -> bool {
        matches!(self, Phase::MainPhaseStart)
    }

    /// 배틀 페이즈 관련 체크
    pub fn is_battle_phase(&self) -> bool {
        matches!(
            self,
            Phase::BattlePhaseStart
                | Phase::BattleStep
                | Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
                | Phase::BattlePhaseEnd
        )
    }

    pub fn is_battle_step(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    pub fn is_damage_step(&self) -> bool {
        matches!(
            self,
            Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
        )
    }

    pub fn is_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationStart)
    }

    pub fn is_before_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationBefore)
    }

    pub fn is_after_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationEnd)
    }

    /// 메인 페이즈 2 체크
    pub fn is_main_phase_2(&self) -> bool {
        matches!(self, Phase::MainPhase2)
    }

    /// 엔드 페이즈 체크
    pub fn is_end_phase(&self) -> bool {
        matches!(self, Phase::EndPhase)
    }

    /// 메인 페이즈 체크 (1과 2 모두)
    pub fn is_main_phase(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::MainPhase1 | Phase::MainPhase2
        )
    }

    /// 일반 소환이 가능한 페이즈인지 체크
    pub fn can_normal_summon(&self) -> bool {
        matches!(self, Phase::MainPhase1 | Phase::MainPhase2)
    }

    /// 공격이 가능한 페이즈인지 체크
    pub fn can_attack(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    /// 현재 페이즈가 개시시인지 체크
    pub fn is_phase_start(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::BattlePhaseStart | Phase::BattleDamageStepStart
        )
    }

    /// 다음 페이즈 반환
    pub fn next_phase(&self) -> Phase {
        match self {
            Phase::Mulligan => Phase::DrawPhase,
            Phase::DrawPhase => Phase::StandbyPhase,
            Phase::StandbyPhase => Phase::MainPhaseStart,
            Phase::MainPhaseStart => Phase::MainPhase1,
            Phase::MainPhase1 => Phase::BattlePhaseStart,
            Phase::BattlePhaseStart => Phase::BattleStep,
            Phase::BattleStep => Phase::BattleDamageStepStart,
            Phase::BattleDamageStepStart => Phase::BattleDamageStepCalculationBefore,
            Phase::BattleDamageStepCalculationBefore => Phase::BattleDamageStepCalculationStart,
            Phase::BattleDamageStepCalculationStart => Phase::BattleDamageStepCalculationEnd,
            Phase::BattleDamageStepCalculationEnd => Phase::BattleDamageStepEnd,
            Phase::BattleDamageStepEnd => Phase::BattlePhaseEnd,
            Phase::BattlePhaseEnd => Phase::MainPhase2,
            Phase::MainPhase2 => Phase::EndPhase,
            Phase::EndPhase => Phase::DrawPhase,
            Phase::Heartbeat => Phase::Mulligan,
        }
    }

    pub fn move_to_next_phase(&mut self) {
        *self = self.next_phase();
    }

    pub fn set_phase(&mut self, phase: Phase) {
        *self = phase;
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            Phase::Mulligan => "Mulligan",
            Phase::DrawPhase => "DrawPhase",
            Phase::StandbyPhase => "StandbyPhase",
            Phase::MainPhaseStart => "MainPhaseStart",
            Phase::MainPhase1 => "MainPhase1",
            Phase::BattlePhaseStart => "BattlePhaseStart",
            Phase::BattleStep => "BattleStep",
            Phase::BattleDamageStepStart => "BattleDamageStepStart",
            Phase::BattleDamageStepCalculationBefore => "BattleDamageStepCalculationBefore",
            Phase::BattleDamageStepCalculationStart => "BattleDamageStepCalculationStart",
            Phase::BattleDamageStepCalculationEnd => "BattleDamageStepCalculationEnd",
            Phase::BattleDamageStepEnd => "BattleDamageStepEnd",
            Phase::BattlePhaseEnd => "BattlePhaseEnd",
            Phase::MainPhase2 => "MainPhase2",
            Phase::EndPhase => "EndPhase",
            Phase::Heartbeat => "Heartbeat",
        }
    }
}
</file>

<file path="simulator_core/src/game_old/turn_manager.rs">
use crate::card::types::PlayerType;

#[derive(Clone)]
pub struct Turn {
    current_turn: PlayerType,
    turn_count: usize,
}

impl Turn {
    pub fn new() -> Self {
        Turn {
            current_turn: PlayerType::Player1,
            turn_count: 0,
        }
    }

    pub fn get_turn_count(&self) -> usize {
        self.turn_count
    }

    pub fn increase_turn_count(&mut self) -> usize {
        self.turn_count += 1;
        self.turn_count
    }

    pub fn current_turn(&self) -> PlayerType {
        self.current_turn
    }

    pub fn change_turn(&mut self) -> PlayerType {
        self.current_turn = match self.current_turn {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        };
        self.current_turn
    }

    pub fn is_player_turn(&self) -> bool {
        self.current_turn == PlayerType::Player1
    }

    pub fn is_opponent_turn(&self) -> bool {
        self.current_turn == PlayerType::Player2
    }

    pub fn get_opponent_turn(&self) -> PlayerType {
        match self.current_turn {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        }
    }

    // 특정 플레이어의 턴으로 강제 설정
    pub fn set_turn(&mut self, player: PlayerType) {
        self.current_turn = player;
    }
}
</file>

<file path="simulator_core/src/game/msg/connection.rs">
use std::time::Duration;

use actix::{ActorContext, AsyncContext, Context, Handler, Message, ResponseFuture};
use tracing::{error, info, warn};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    enums::CLIENT_TIMEOUT,
    exception::{ConnectionError, GameError, StateError, SystemError},
    game::{state::GamePhase, GameActor},
};

use super::GameEvent;

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RegisterConnection {
    pub player_id: Uuid,
    pub recipient: actix::Recipient<GameEvent>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct HandleOpponentWaitTimer {
    // 기다리는 상대의 종류
    pub opponent_kind: PlayerKind,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct CancelOpponentWaitTimer;

impl Handler<RegisterConnection> for GameActor {
    type Result = ResponseFuture<Result<(), GameError>>;

    fn handle(&mut self, msg: RegisterConnection, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "GAME ACTOR [{}]: Handling RegisterConnection for player {}",
            self.game_id, msg.player_id
        );

        let game_id_clone = self.game_id.clone();
        let player_id = msg.player_id;
        let connection_recipient = msg.recipient.clone();

        let game_state = self.game_state.clone();
        let game_actor_addr = ctx.address().clone();
        let players = self.players.clone();
        let connections = self.connections.clone();
        let gsm = self.game_state.clone();

        let player_kind = self.get_player_type_by_uuid(player_id);
        let opponent_kind = self.opponent_player_kind.clone();
        let opponent_wait_timer_handle = self.opponent_wait_timer_handle.clone();

        Box::pin(async move {
            // --- 0. 기존 연결 확인 및 connections 맵 업데이트 ---
            {
                let gsm = gsm.lock().await;
                if gsm.current_phase() == GamePhase::Aborted {
                    info!(
                        "GAME ACTOR [{}]: Game is already aborted. Rejecting connection for player {}.",
                        game_id_clone, player_id
                    );
                    return Err(GameError::State(StateError::GameAborted));
                }
            }

            {
                let mut connections_guard = connections.lock().await;

                if connections_guard.contains_key(&player_id) {
                    info!(
                        "GAME ACTOR [{}]: Player {} already has an active connection. Rejecting new connection.",
                        game_id_clone, player_id
                    );
                    return Err(GameError::Connection(ConnectionError::SessionExists(
                        player_id,
                    )));
                }

                connections_guard.insert(player_id, connection_recipient.clone());
                info!(
                    "GAME ACTOR [{}]: Connection for player {} registered successfully. Total connections: {}",
                    game_id_clone, player_id, connections_guard.len()
                );
            }

            // --- 1. GameState 업데이트 ---
            let is_all_players_connected;
            let mut current_phase;
            {
                let mut gsm = game_state.lock().await;
                info!(
                    "GAME ACTOR [{}]: Game state locked for player {}",
                    game_id_clone, player_id
                );

                gsm.add_connected_player(player_kind);
                info!(
                    "GAME ACTOR [{}]: Player {} connection status updated in GameStateManager.",
                    game_id_clone, player_id
                );

                is_all_players_connected = gsm.is_all_players_connected();
                current_phase = gsm.current_phase();

                if current_phase == GamePhase::Initial && is_all_players_connected {
                    info!(
                        "GAME ACTOR [{}]: All players connected. Transitioning to Mulligan phase.",
                        game_id_clone
                    );
                    gsm.transition_to_phase(GamePhase::Mulligan);
                    current_phase = gsm.current_phase();
                }
            }

            // --- 2. WaitTimer 처리 ---
            if let Some(kind) = opponent_kind {
                if kind != player_kind {
                    warn!(
                        "GAME ACTOR [{}]: Opponent kind mismatch: expected {:?}, got {:?}.",
                        game_id_clone, kind, player_kind
                    );
                    return Err(GameError::Connection(
                        ConnectionError::AuthenticationFailed("Player kind mismatch".to_string()),
                    ));
                }

                if let Some(_) = opponent_wait_timer_handle {
                    info!(
                        "GAME ACTOR [{}]: Cancelling opponent wait timer for player {}.",
                        game_id_clone, kind
                    );
                    game_actor_addr.do_send(CancelOpponentWaitTimer);
                } else {
                    warn!(
                        "GAME ACTOR [{}]: No opponent wait timer to cancel for player {}.",
                        game_id_clone, kind
                    );
                    return Err(GameError::System(SystemError::Internal(
                        "Timer handle not found".to_string(),
                    )));
                }
            }

            // --- 3. 게임 로직 진행 ---
            // TODO: callback 으로 바꾸면 좋을 것 같음.
            // 현재 RegisterConnection 핸들러가 두 개 이상의 책임을 가지고 있음
            // 1. 플레이어 연결 등록
            // 2. 멀리건 카드 전송
            // then 같은 메소드를 활용해서 분리하면 좋을듯.
            if current_phase == GamePhase::Mulligan && is_all_players_connected {
                info!(
                    "GAME ACTOR [{}]: Proceeding with Mulligan card distribution.",
                    game_id_clone
                );

                use crate::game::state::PlayerMulliganStatus;
                use crate::player::message::GetMulliganDealCards;

                for (player_identity, player_addr) in players.iter() {
                    let connection_addr = {
                        let connections_snapshot = connections.lock().await;
                        connections_snapshot
                            .get(&player_identity.id)
                            .ok_or_else(|| {
                                error!(
                                    "Connection not found for player {} in connections_snapshot",
                                    player_identity.id
                                );
                                GameError::System(SystemError::Internal(
                                    "Connection not found".to_string(),
                                ))
                            })?
                            .clone()
                    };

                    match player_addr.send(GetMulliganDealCards).await {
                        Ok(cards) => {
                            let card_uuids: Vec<Uuid> =
                                cards.iter().map(|c| c.get_uuid()).collect();
                            if let Err(e) = connection_addr
                                .send(GameEvent::SendMulliganDealCards {
                                    cards: card_uuids.clone(),
                                })
                                .await
                            {
                                warn!(
                                    "Failed to send mulligan cards to {}: {:?}",
                                    player_identity.id, e
                                );
                            } else {
                                info!(
                                    "Sent mulligan cards ({} count) to player {}",
                                    card_uuids.len(),
                                    player_identity.id
                                );
                                let mut gsm_update = game_state.lock().await;
                                gsm_update.update_player_mulligan_status(
                                    player_identity.kind,
                                    PlayerMulliganStatus::CardsDealt,
                                );
                            }
                        }
                        Err(mailbox_err) => {
                            error!(
                                "Mailbox error getting mulligan cards for {}: {:?}",
                                player_identity.id, mailbox_err
                            );
                        }
                    }
                }
            } else if current_phase != GamePhase::Initial {
                warn!(
                    "GAME ACTOR [{}]: Player {} connected, but not all players are ready or in an unexpected game phase: {:?}.",
                    game_id_clone, player_id, current_phase
                );
            } else if is_all_players_connected == false {
                info!(
                    "GAME ACTOR [{}]: Player {} connected, but not all players are ready. Waiting for others.",
                    game_id_clone, player_id
                );
                if current_phase == GamePhase::Aborted {
                    return Err(GameError::State(StateError::GameAborted));
                }
                game_actor_addr.do_send(HandleOpponentWaitTimer {
                    opponent_kind: player_kind.reverse(),
                });
            }

            Ok(())
        })
    }
}

impl Handler<HandleOpponentWaitTimer> for GameActor {
    type Result = ();

    fn handle(&mut self, msg: HandleOpponentWaitTimer, ctx: &mut Context<Self>) {
        if self.opponent_wait_timer_handle.is_some() {
            warn!("Opponent wait timer already started. Ignoring new request.");
            return;
        }
        info!(
            "Starting opponent wait timer for first player: {}",
            msg.opponent_kind
        );

        self.opponent_player_kind = Some(msg.opponent_kind);
        let handle = ctx.run_later(Duration::from_secs(CLIENT_TIMEOUT), move |act, ctx_later| {
            // TODO: try_lock -> lock 변경 해야함
            if let Ok(mut gsm) = act.game_state.try_lock() {

                // 현재 GamePhase 가 Initial이고, 연결된 플레이어가 1명이며( count_connected_players ), 상대방이 미접속 상태인( is_player_connected_by_kind ) 경우
                if gsm.current_phase() == GamePhase::Initial
                    && gsm.count_connected_players() == 1
                    && gsm.is_player_connected_by_kind(msg.opponent_kind) == None
                {
                    warn!(
                        "GAME ACTOR [{}]: Opponent wait timeout for player {}. Aborting game.",
                        act.game_id,
                        msg.opponent_kind
                    );
                    gsm.transition_to_phase(GamePhase::Aborted);
                    ctx_later.stop();

                } else if gsm.current_phase() == GamePhase::Aborted {
                    info!(
                        "GAME ACTOR [{}]: OpponentWaitTimeout for player {} triggered, but situation already resolved.",
                        act.game_id, msg.opponent_kind
                    );
                    gsm.transition_to_phase(GamePhase::AlreadyCancelled);
                } else {
                    warn!(
                        "GAME ACTOR [{}]: Opponent wait timeout for player {} but game is in unexpected phase: {:?}.",
                        act.game_id, msg.opponent_kind, gsm.current_phase()
                    );
                    gsm.transition_to_phase(GamePhase::UnexpectedGamePhase);
                    ctx_later.stop();
                }

            } else {
                error!(
                    "GAME ACTOR [{}]: Failed to lock game state during opponent wait timeout logic.",
                    act.game_id
                );
                act.unexpected_stop = true;
                ctx_later.stop();
            }
        });

        self.opponent_wait_timer_handle = Some(handle);
    }
}

// 이미 접속된 플레이어에게 게임 종료 알림 전송
// for (player_identity, player_addr) in act.players.iter() {
//     if let Some(connection) = act.connections.lock().await.get(&player_identity.id) {
//         if let Err(e) = connection.send(GameEvent::GameAborted).await {
//             warn!(
//                 "Failed to send GameAborted event to player {}: {:?}",
//                 player_identity.id, e
//             );
//         } else {
//             info!(
//                 "Sent GameAborted event to player {}",
//                 player_identity.id
//             );
//         }
//     } else {
//         warn!(
//             "No connection found for player {} when sending GameAborted event.",
//             player_identity.id
//         );
//     }
// }

impl Handler<CancelOpponentWaitTimer> for GameActor {
    type Result = ();

    fn handle(&mut self, _msg: CancelOpponentWaitTimer, ctx: &mut Context<Self>) {
        if let Some(handle) = self.opponent_wait_timer_handle.take() {
            info!("Cancelling opponent wait timer.");
            if ctx.cancel_future(handle) {
                info!("Opponent wait timer cancelled successfully.");
            } else {
                warn!("Failed to cancel opponent wait timer, it may have already been cancelled or expired.");
            }
            self.opponent_player_kind = None;
            self.opponent_wait_timer_handle = None;
        } else {
            info!("No opponent wait timer to cancel, or already cancelled.");
        }
    }
}
</file>

<file path="simulator_core/src/game/msg/error_message.rs">

</file>

<file path="simulator_core/src/game/msg/gameplay.rs">
use actix::{Handler, Message};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    exception::{GameError, StateError},
    game::{phase::Phase, GameActor},
};

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RequestPlayCard {
    pub player_type: PlayerKind,
    pub card_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct SubmitInput {
    pub player_type: PlayerKind,
    pub request_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RequestInput {
    pub player_type: PlayerKind,
    pub request_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct IsCorrectPhase {
    pub phase: Phase,
}

pub struct ChoiceCardRequestPayload {
    pub player: String,
    pub choice_type: String,
    pub source_card_id: Uuid,
    pub min_selections: usize,
    pub max_selections: usize,
    pub destination: String,
    pub is_open: bool,
    pub is_hidden_from_opponent: bool,
}

impl Handler<RequestPlayCard> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: RequestPlayCard, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<SubmitInput> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: SubmitInput, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<RequestInput> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: RequestInput, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<IsCorrectPhase> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: IsCorrectPhase, _: &mut Self::Context) -> Self::Result {
        if self.turn.current_phase == msg.phase {
            Ok(())
        } else {
            Err(GameError::State(StateError::InvalidActionForPhase { current_phase: format!("{:?}", self.turn.current_phase), action: format!("{:?}", msg.phase) }))
        }
    }
}
</file>

<file path="simulator_core/src/game/msg/lifecycle.rs">
use actix::{Context, Handler, Message};
use tracing::info;

use crate::{card::types::PlayerKind, exception::{GameError, GameplayError}, game::GameActor, game::GameConfig};

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct InitializeGame(pub GameConfig);

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RemovePlayerActor {
    pub player_kind: PlayerKind,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct PlayerReady(pub PlayerKind);

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct CheckReEntry {
    pub player_type: PlayerKind,
}

impl Handler<InitializeGame> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: InitializeGame, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<RemovePlayerActor> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: RemovePlayerActor, _: &mut Self::Context) -> Self::Result {
        info!("Removing player actor: {:?}", msg.player_kind);
        let player_identity = self
            .get_player_identity_by_kind(msg.player_kind)
            .cloned()
            .ok_or_else(|| GameError::Gameplay(GameplayError::ResourceNotFound { kind: "player_identity", id: format!("{:?}", msg.player_kind) }))?;
        if let None = self.players.remove(&player_identity) {
            return Err(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "player_identity", id: format!("{:?}", msg.player_kind) }));
        }
        Ok(())
    }
}

impl Handler<PlayerReady> for GameActor {
    type Result = ();

    fn handle(&mut self, msg: PlayerReady, _: &mut Self::Context) -> Self::Result {}
}

impl Handler<CheckReEntry> for GameActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: CheckReEntry, _: &mut Context<Self>) -> Self::Result {
        todo!()
    }
}
</file>

<file path="simulator_core/src/game/msg/mod.rs">
pub mod connection;
pub mod error_message;
pub mod gameplay;
pub mod lifecycle;
pub mod mulligan;
pub mod zones;

use actix::Message;
use uuid::Uuid;

#[derive(Message)]
#[rtype(result = "()")]
pub enum GameEvent {
    GameStopped,
    SendMulliganDealCards { cards: Vec<Uuid> },
}
</file>

<file path="simulator_core/src/game/msg/mulligan.rs">
use actix::{Context, Handler, Message, ResponseFuture};
use uuid::Uuid;

use crate::{
    card::{cards::CardVecExt, insert::BottomInsert, take::RandomTake, types::PlayerKind, Card},
    exception::GameError,
    game::GameActor,
    player::message::{AddCardsToDeck, GetCardFromDeck},
    selector::TargetCount,
};

#[derive(Message)]
#[rtype(result = "Result<Vec<Card>, GameError>")]
pub struct RerollRequestMulliganCard {
    pub player_type: PlayerKind,
    pub cards: Vec<Uuid>,
}

impl Handler<RerollRequestMulliganCard> for GameActor {
    type Result = ResponseFuture<Result<Vec<Card>, GameError>>;

    fn handle(&mut self, msg: RerollRequestMulliganCard, _: &mut Context<Self>) -> Self::Result {
        let player_type = msg.player_type;

        let mut cards = vec![];
        let player_cards = self
            .all_cards
            .get(&player_type)
            .unwrap_or_else(|| panic!("Player cards not found for player type: {:?}", player_type));
        for uuid in msg.cards {
            if let Some(card) = player_cards.find_by_uuid(uuid.clone()) {
                cards.push(card.clone());
            } else {
                todo!()
            }
        }
        let addr = self.get_player_addr_by_kind(player_type);
        Box::pin(async move {
            addr.do_send(AddCardsToDeck {
                cards,
                insert: Box::new(BottomInsert),
            });

            addr.send(GetCardFromDeck {
                take: Box::new(RandomTake(TargetCount::Exact(5))),
            })
            .await?
        })
    }
}
</file>

<file path="simulator_core/src/game/msg/zones.rs">
use actix::{Context, Handler, Message, ResponseFuture};

use crate::{
    card::{types::PlayerKind, Card},
    enums::ZoneType,
    game::GameActor,
    player::message::{GetDeckCards, GetFieldCards, GetGraveyardCards, GetHandCards},
};

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetPlayerZoneCards {
    pub player_type: PlayerKind,
    pub zone: ZoneType,
}

impl Handler<GetPlayerZoneCards> for GameActor {
    type Result = ResponseFuture<Vec<Card>>;

    fn handle(&mut self, msg: GetPlayerZoneCards, _: &mut Context<Self>) -> Self::Result {
        let player_type = msg.player_type;
        let zone = msg.zone;

        let addr = self.get_player_addr_by_kind(player_type);
        Box::pin(async move {
            match zone {
                ZoneType::Deck => addr.send(GetDeckCards).await,
                ZoneType::Hand => addr.send(GetHandCards).await,
                ZoneType::Field => addr.send(GetFieldCards).await,
                ZoneType::Graveyard => addr.send(GetGraveyardCards).await,
                _ => panic!("Invalid zone type: {}", zone),
            }
            .unwrap()
        })
    }
}
</file>

<file path="simulator_core/src/resource.rs">
///
/// 수정 가능한 자원에 대해서 증감 및 관련 편의 메소드를 제공하는 trait
///

pub trait Resource {
    /// 현재 값을 가져옴
    fn get_value(&self) -> i32;

    /// 기본 값을 가져옴
    fn get_base_value(&self) -> i32;

    /// 현재 값을 설정
    fn set_value(&mut self, value: i32);

    /// 값을 증가
    fn increase(&mut self, amount: i32) {
        self.set_value(self.get_value() + amount);
    }

    /// 값을 감소
    fn decrease(&mut self, amount: i32) {
        self.set_value(self.get_value() - amount);
    }

    /// 최소값 제한
    fn get_min_value(&self) -> Option<i32> {
        None // 기본적으로는 제한 없음
    }

    /// 최대값 제한
    fn get_max_value(&self) -> Option<i32> {
        None // 기본적으로는 제한 없음
    }

    /// 제한을 고려한 값 설정
    fn set_value_with_limits(&mut self, value: i32) {
        let value = if let Some(min) = self.get_min_value() {
            value.max(min)
        } else {
            value
        };

        let value = if let Some(max) = self.get_max_value() {
            value.min(max)
        } else {
            value
        };

        self.set_value(value);
    }

    /// 퍼센트 기반 증가
    fn increase_percent(&mut self, percent: f32) {
        let increase = (self.get_base_value() as f32 * percent).round() as i32;
        self.increase(increase);
    }
}

pub trait ResourceExtension: Resource {
    /// 기본값으로 초기화
    fn reset_to_base(&mut self) {
        self.set_value(self.get_base_value());
    }

    /// 현재 값이 기본값보다 높은지 확인
    fn is_buffed(&self) -> bool {
        self.get_value() > self.get_base_value()
    }

    /// 현재 값이 기본값보다 낮은지 확인
    fn is_debuffed(&self) -> bool {
        self.get_value() < self.get_base_value()
    }

    /// 현재 값이 기본값과 다른지 확인
    fn is_modified(&self) -> bool {
        self.get_value() != self.get_base_value()
    }

    /// 버프/디버프의 차이값 반환
    fn get_modification_amount(&self) -> i32 {
        self.get_value() - self.get_base_value()
    }
}

#[derive(Clone)]
pub struct CardSpecsResource {
    value: i32,
    base: i32,
}

impl Resource for CardSpecsResource {
    fn get_value(&self) -> i32 {
        self.value
    }

    fn get_base_value(&self) -> i32 {
        self.base
    }

    fn set_value(&mut self, value: i32) {
        self.value = value;
    }
}

impl ResourceExtension for CardSpecsResource {}

impl CardSpecsResource {
    pub fn new(value: i32) -> Self {
        Self { value, base: value }
    }
}
</file>

<file path="simulator_core/src/selector/automatic.rs">
use super::TargetCondition;

pub enum AutoSelectType {
    Weakest,
    Strongest,
    Random,
    All,
}

// 자동 선택기 (가장 약한 카드, 가장 강한 카드 등)
pub struct AutomaticSelector {
    condition: TargetCondition,
    selection_type: AutoSelectType,
}
</file>

<file path="simulator_core/src/selector/complex.rs">
use super::{SelectorLogic, TargetCondition};

pub struct ComplexSelector {
    conditions: Vec<TargetCondition>,
    logic: SelectorLogic,
}
</file>

<file path="simulator_core/src/selector/mod.rs">
use std::sync::Arc;

pub mod automatic;
pub mod complex;
pub mod mulligan;
pub mod multi;
pub mod single;

use actix::Addr;

use crate::{
    card::{
        types::{CardType, OwnerType},
        Card,
    },
    enums::ZoneType,
    exception::GameError,
    game::GameActor,
};

pub trait TargetSelector: Send + Sync {
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError>;
    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool;
    fn get_target_count(&self) -> TargetCount;
    fn clone_selector(&self) -> Box<dyn TargetSelector>;

    fn get_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> Vec<Card> {
        // let mut valid_targets = Vec::new();

        // for location in self.get_locations() {
        //     let cards = game.get_cards_by_player_and_zone_type(self.get_owner().into(), location);

        //     for card in cards {
        //         if self.is_valid_target(&card, game, source) {
        //             valid_targets.push(card);
        //         }
        //     }
        // }

        // valid_targets
        todo!()
    }

    fn get_owner(&self) -> OwnerType;

    fn get_locations(&self) -> Vec<ZoneType>;

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool;
}

#[derive(Clone, Copy)]
pub enum TargetCount {
    Exact(usize),
    Range(usize, usize),
    Any,
    None,
}

/// 카드 선택 조건
/// - location: 카드의 위치
/// - owner: 카드의 소유자
/// - card_type: 카드의 타입
/// - custom_filter: 카드에 대한 사용자 정의 필터
#[derive(Clone)]
pub struct TargetCondition {
    location: Vec<ZoneType>,
    owner: OwnerType,
    card_type: Option<CardType>,
    custom_filter: Option<Arc<dyn Fn(&Card) -> bool + Send + Sync>>,
}

pub enum SelectorLogic {
    And,
    Or,
    Not(Box<dyn TargetSelector>),
}
</file>

<file path="simulator_core/src/selector/mulligan.rs">
use uuid::Uuid;

#[derive(Clone)]
pub struct MulliganState {
    player_ready: bool,
    select_cards: Vec<Uuid>,
}

impl MulliganState {
    pub fn new() -> Self {
        Self {
            player_ready: false,
            select_cards: vec![],
        }
    }

    pub fn confirm_selection(&mut self) {
        self.player_ready = true;
    }

    pub fn get_select_cards(&self) -> Vec<Uuid> {
        self.select_cards.clone()
    }

    pub fn add_select_cards(&mut self, cards: Vec<Uuid>) {
        self.select_cards.extend(cards);
    }

    pub fn remove_select_cards(&mut self, cards: Vec<Uuid>) {
        self.select_cards.retain(|x| !cards.contains(x));
    }

    pub fn is_ready(&self) -> bool {
        self.player_ready
    }
}
</file>

<file path="simulator_core/src/selector/multi.rs">
use actix::Addr;

use crate::{
    card::{types::OwnerType, Card},
    exception::GameError,
    game::GameActor,
};

use super::{TargetCondition, TargetCount, TargetSelector};

// 다중 카드 선택기
pub struct MultiCardSelector {
    condition: TargetCondition,
    count: TargetCount,
}

impl TargetSelector for MultiCardSelector {
    /// 다중 카드 선택기 생성자
    ///
    /// # Parameters
    /// * `game` - 게임 객체
    /// * `source` - 이벤트를 발생시킨 카드
    ///
    /// # Returns
    /// * `Ok(Vec<Card>)` - 선택된 카드 목록
    /// * `Err(GameError)` - 카드 선택 중 오류 발생
    ///
    /// # Errors
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError> {
        todo!()
    }

    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }

    fn get_target_count(&self) -> TargetCount {
        todo!()
    }

    fn clone_selector(&self) -> Box<dyn TargetSelector> {
        todo!()
    }

    fn get_owner(&self) -> OwnerType {
        todo!()
    }

    fn get_locations(&self) -> Vec<crate::enums::ZoneType> {
        todo!()
    }

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }
}
</file>

<file path="simulator_core/src/utils/json.rs">
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Item {
    pub id: String,
    pub dbfid: i32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Card {
    pub id: String,
    pub num: i32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Hero {
    pub name: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize, Serialize)]
pub struct Deck {
    pub Hero: Vec<Hero>,
    pub cards: Vec<Card>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Decks {
    pub decks: Vec<Deck>,
}

#[derive(Debug, Deserialize)]
pub struct Names {
    pub name1: String,
    pub name2: String,
}

#[derive(Debug, Deserialize)]
pub struct DeckCodes {
    pub code1: String,
    pub code2: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct GameConfigJson {
    pub DeckCodes: Vec<DeckCodes>,
    pub Attacker: i32,
    pub Names: Vec<Names>,
}

/*
    "id": "AT_010",
    "attack": 3,
    "health": 3,
    "cost": 5,
    "rarity": "RARE",
    "collectible": true,
    "name": "Ram Wrangler",
    "text": "<b>Battlecry:</b> If you have a Beast, summon a\nrandom Beast.",
    "type": "Agent"
*/
#[derive(Debug, Deserialize, Serialize, Clone, Eq, PartialEq, Hash)]
pub struct CardJson {
    pub id: Option<String>,
    pub dbfid: Option<i32>,
    pub cost: Option<i32>,
    pub name: Option<String>,
    pub text: Option<String>,
    pub attack: Option<i32>,
    pub health: Option<i32>,
    pub collectible: Option<bool>,
    pub r#type: Option<String>,
}

impl CardJson {
    pub fn new() -> CardJson {
        CardJson {
            id: None,
            dbfid: None,
            cost: None,
            name: None,
            text: None,
            attack: None,
            health: None,
            collectible: None,
            r#type: None,
        }
    }
}
</file>

<file path="simulator_core/src/zone/effect.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Effect {
    zone_cards: Cards,
    zone_size: usize,
}

impl Effect {
    pub fn new() -> Effect {
        Effect {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Effect {
    fn get_cards(&self) -> &Cards {
        todo!()
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/field.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Field {
    zone_cards: Cards,
    zone_size: usize,
}

impl Zone for Field {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}

impl Field {
    pub fn new() -> Field {
        Field {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }
}
</file>

<file path="simulator_core/src/zone/graveyard.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Graveyard {
    zone_cards: Cards,
    zone_size: usize,
}

impl Graveyard {
    pub fn new() -> Graveyard {
        Graveyard {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Graveyard {
    fn get_cards(&self) -> &Cards {
        todo!()
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/mod.rs">
pub mod deck;
pub mod effect;
pub mod field;
pub mod graveyard;
pub mod hand;
pub mod zone;
</file>

<file path="simulator_core/src/zone/zone.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, insert::Insert, take::Take, Card},
    exception::GameError,
};

pub trait Zone {
    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError>;

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError>;

    fn remove_card(&mut self, uuid: Uuid);

    fn get_cards(&self) -> &Cards;

    fn get_cards_mut(&mut self) -> &mut Cards;

    fn len(&self) -> usize;
}
</file>

<file path="simulator_dedicated_server/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_dedicated_server/.gitignore">
/target
</file>

<file path="simulator_dedicated_server/.idea/.gitignore">
# 디폴트 무시된 파일
/shelf/
/workspace.xml
# 에디터 기반 HTTP 클라이언트 요청
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
</file>

<file path="simulator_dedicated_server/.idea/discord.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="PROJECT_FILES" />
    <option name="description" value="" />
    <option name="applicationTheme" value="default" />
    <option name="iconsTheme" value="default" />
    <option name="button1Title" value="" />
    <option name="button1Url" value="" />
    <option name="button2Title" value="" />
    <option name="button2Url" value="" />
    <option name="customApplicationId" value="" />
  </component>
</project>
</file>

<file path="simulator_dedicated_server/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/simulator.iml" filepath="$PROJECT_DIR$/.idea/simulator.iml" />
    </modules>
  </component>
</project>
</file>

<file path="simulator_dedicated_server/.idea/simulator.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="EMPTY_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="simulator_dedicated_server/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
  </component>
</project>
</file>

<file path="simulator_dedicated_server/.vscode/launch.json">
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'card_game'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in executable 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug integration test 'test'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--test=test",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "test",
                    "kind": "test"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</file>

<file path="simulator_dedicated_server/logs/app.log.2025-06-10">
2025-06-10T11:51:27.090181Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T11:51:27.131870Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T11:51:27.136555Z  INFO  starting 32 workers
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\builder.rs:272 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:27.136720Z  INFO  PlayerActor 1 connected ( not session connection! ), P1 can now receive messages.
    at simulator_core\src\game\mod.rs:203 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:27.136728Z  INFO  PlayerActor 2 connected ( not session connection! ), P2 can now receive messages.
    at simulator_core\src\game\mod.rs:210 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:27.136732Z  INFO  Both players actor connected. ( not session connection! ) Sending SetOpponent messages.
    at simulator_core\src\game\mod.rs:214 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:27.136799Z  INFO  Actix runtime found; starting in Actix runtime
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:191 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:27.136815Z  INFO  starting service: "actix-web-service-127.0.0.1:9711", workers: 32, listening on: 127.0.0.1:9711
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:197 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:27.145920Z  INFO  멀리건 단계 핸들러 시작: player=Player1
    at simulator_dedicated_server\src\server\mod.rs:115 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player1, id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3 }, player_type: Player1

  2025-06-10T11:51:27.146006Z  INFO  WebSocket handshake successful for player_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3
    at simulator_dedicated_server\src\server\mod.rs:125 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player1, id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3 }, player_type: Player1

  2025-06-10T11:51:27.146125Z  INFO  ConnectionActor started for player Player1 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3
    at simulator_dedicated_server\src\connection\connection.rs:148 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:27.146206Z  INFO  Sent initial heartbeat_connected message to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:171 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:27.146270Z  INFO  [TEST] Received message: {"player":"Player1","session_id":"7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3","type":"heartbeat_connected"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151155Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:32.151247Z  INFO  Ping sent successfully to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3) last_pong Instant { t: 149541.4636989s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:32.151442Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151618Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:32.151636Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Initial Pong received. Registering with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:262 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:32.151709Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Handling RegisterConnection for player 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3
    at simulator_core\src\game\msg\connection.rs:38 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151764Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Connection for player 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3 registered successfully. Total connections: 1
    at simulator_core\src\game\msg\connection.rs:82 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151776Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Game state locked for player 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3
    at simulator_core\src\game\msg\connection.rs:93 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151786Z  INFO  Player Player1 added to game state as Connected
    at simulator_core\src\game\state.rs:83 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151791Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Player 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3 connection status updated in GameStateManager.
    at simulator_core\src\game\msg\connection.rs:99 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151802Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Player 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3 connected, but not all players are ready. Waiting for others.
    at simulator_core\src\game\msg\connection.rs:208 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151831Z  INFO  Starting opponent wait timer for first player: Player2
    at simulator_core\src\game\msg\connection.rs:233 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:32.151852Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Successfully registered with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:318 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:37.153851Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:37.153951Z  INFO  Ping sent successfully to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3) last_pong Instant { t: 149546.4692833s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:37.154151Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:37.154311Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:42.153863Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:42.153950Z  INFO  Ping sent successfully to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3) last_pong Instant { t: 149551.4719832s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:42.154132Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:42.154282Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:47.150059Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:47.150145Z  INFO  Ping sent successfully to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3) last_pong Instant { t: 149556.4719537s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:47.150338Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:47.150499Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:52.161075Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:52.161150Z  INFO  Ping sent successfully to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3) last_pong Instant { t: 149561.4681715s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:52.161295Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:51:52.161388Z  INFO  ConnectionActor for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:57.147992Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:51:57.148095Z  INFO  Ping sent successfully to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3) last_pong Instant { t: 149566.4790604s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:52:02.153249Z  WARN  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Opponent wait timeout for player Player2. Aborting game.
    at simulator_core\src\game\msg\connection.rs:248 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153240Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:52:02.153338Z ERROR  Failed to send ping to player Player1 (session_id: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3): Closed
    at simulator_dedicated_server\src\connection\connection.rs:101 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:52:02.153329Z  INFO  Game phase transitioning from Initial to Aborted
    at simulator_core\src\game\state.rs:128 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153362Z  INFO  Cancelling heartbeat for player: Player1
    at simulator_dedicated_server\src\connection\messages.rs:24 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:52:02.153372Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8] is stopping. Initiating comprehensive cleanup.
    at simulator_core\src\game\mod.rs:70 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153388Z  INFO  Heartbeat cancelled successfully for player: 7e5cb93c-7a2f-4a9e-bc9d-6d7f7ae840c3
    at simulator_dedicated_server\src\connection\messages.rs:27 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T11:52:02.153398Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: stopping() method finished, comprehensive cleanup scheduled.
    at simulator_core\src\game\mod.rs:152 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153408Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Starting comprehensive cleanup task.
    at simulator_core\src\game\mod.rs:82 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153422Z  INFO  Player Player1 removed from game state
    at simulator_core\src\game\state.rs:90 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153426Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: All players removed from GameStateManager.
    at simulator_core\src\game\mod.rs:94 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153438Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: All connections cleared.
    at simulator_core\src\game\mod.rs:104 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153443Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Preparing to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }).
    at simulator_core\src\game\mod.rs:113 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153463Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Preparing to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }).
    at simulator_core\src\game\mod.rs:113 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153487Z  INFO  PLAYER ACTOR [Player2]: Handling GameOver
    at simulator_core\src\player\message.rs:91 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153544Z  INFO  PLAYER ACTOR [Player1]: Handling GameOver
    at simulator_core\src\player\message.rs:91 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153592Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Successfully sent GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } })
    at simulator_core\src\game\mod.rs:120 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153599Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Successfully sent GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } })
    at simulator_core\src\game\mod.rs:120 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153605Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Comprehensive cleanup task completed.
    at simulator_core\src\game\mod.rs:134 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.153608Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: All cleanup completed.
    at simulator_core\src\game\mod.rs:142 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:02.154390Z  INFO  멀리건 단계 핸들러 시작: player=Player2
    at simulator_dedicated_server\src\server\mod.rs:115 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player2, id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120 }, player_type: Player2

  2025-06-10T11:52:02.154436Z  INFO  WebSocket handshake successful for player_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120
    at simulator_dedicated_server\src\server\mod.rs:125 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player2, id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120 }, player_type: Player2

  2025-06-10T11:52:02.154512Z  INFO  ConnectionActor started for player Player2 1877dd41-6d65-45b8-a3ec-1a63a6bac120
    at simulator_dedicated_server\src\connection\connection.rs:148 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:02.154554Z  INFO  Sent initial heartbeat_connected message to player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120)
    at simulator_dedicated_server\src\connection\connection.rs:171 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:02.154603Z  INFO  [TEST] Received message: {"player":"Player2","session_id":"1877dd41-6d65-45b8-a3ec-1a63a6bac120","type":"heartbeat_connected"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.164493Z  INFO  Spawning heartbeat ping task for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.164568Z  INFO  Ping sent successfully to player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120) last_pong Instant { t: 149576.4721231s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.164744Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.164837Z  INFO  ConnectionActor for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.164850Z  INFO  ConnectionActor for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120): Initial Pong received. Registering with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:262 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.164888Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Handling RegisterConnection for player 1877dd41-6d65-45b8-a3ec-1a63a6bac120
    at simulator_core\src\game\msg\connection.rs:38 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.164925Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Game is already aborted. Rejecting connection for player 1877dd41-6d65-45b8-a3ec-1a63a6bac120.
    at simulator_core\src\game\msg\connection.rs:62 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.164972Z ERROR  ConnectionActor for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120): Message sent to GameActor, but registration failed with GameError: GameAlreadyAborted
    at simulator_dedicated_server\src\connection\connection.rs:288 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.164999Z  WARN  RegisterConnection failed on attempt 1/3. Error: GameAlreadyAborted. Retrying...
    at simulator_core\src\lib.rs:252 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.273953Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Handling RegisterConnection for player 1877dd41-6d65-45b8-a3ec-1a63a6bac120
    at simulator_core\src\game\msg\connection.rs:38 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.274035Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Game is already aborted. Rejecting connection for player 1877dd41-6d65-45b8-a3ec-1a63a6bac120.
    at simulator_core\src\game\msg\connection.rs:62 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.274079Z ERROR  ConnectionActor for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120): Message sent to GameActor, but registration failed with GameError: GameAlreadyAborted
    at simulator_dedicated_server\src\connection\connection.rs:288 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.274100Z  WARN  RegisterConnection failed on attempt 2/3. Error: GameAlreadyAborted. Retrying...
    at simulator_core\src\lib.rs:252 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489743Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Handling RegisterConnection for player 1877dd41-6d65-45b8-a3ec-1a63a6bac120
    at simulator_core\src\game\msg\connection.rs:38 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.489818Z  INFO  GAME ACTOR [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: Game is already aborted. Rejecting connection for player 1877dd41-6d65-45b8-a3ec-1a63a6bac120.
    at simulator_core\src\game\msg\connection.rs:62 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T11:52:07.489875Z ERROR  ConnectionActor for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120): Message sent to GameActor, but registration failed with GameError: GameAlreadyAborted
    at simulator_dedicated_server\src\connection\connection.rs:288 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489902Z ERROR  RegisterConnection failed after 3 attempts. Final error: GameAlreadyAborted
    at simulator_core\src\lib.rs:245 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489909Z ERROR  ConnectionActor for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120): Failed to register with GameActor after retries: GameAlreadyAborted
    at simulator_dedicated_server\src\connection\connection.rs:310 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489939Z  INFO  Stopping ConnectionActor for player: 1877dd41-6d65-45b8-a3ec-1a63a6bac120 due to error: RetryFailed
    at simulator_dedicated_server\src\connection\messages.rs:49 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489946Z  INFO  ConnectionActor stopping for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120)
    at simulator_dedicated_server\src\connection\connection.rs:183 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489956Z  INFO  Heartbeat task cancelled for player Player2 (session_id: 1877dd41-6d65-45b8-a3ec-1a63a6bac120)
    at simulator_dedicated_server\src\connection\connection.rs:190 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.489981Z  INFO  Session cleanup task completed: player=Player2, session_id=1877dd41-6d65-45b8-a3ec-1a63a6bac120
    at simulator_dedicated_server\src\connection\connection.rs:135 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T11:52:07.490414Z  INFO  GameActor [2541a8bf-b9fb-4853-9d4a-c6d903787ab8]: stopping() called again, but cleanup is already in progress. Ignoring.
    at simulator_core\src\game\mod.rs:60 on mulligan::test_mulligan_deal_cards_one_player_delayed ThreadId(3)

  2025-06-10T12:13:45.665779Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T12:13:45.702094Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T12:13:45.706901Z  INFO  starting 32 workers
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\builder.rs:272 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:13:45.707108Z  INFO  PlayerActor 1 connected ( not session connection! ), P1 can now receive messages.
    at simulator_core\src\game\mod.rs:203 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:13:45.707120Z  INFO  PlayerActor 2 connected ( not session connection! ), P2 can now receive messages.
    at simulator_core\src\game\mod.rs:210 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:13:45.707123Z  INFO  Both players actor connected. ( not session connection! ) Sending SetOpponent messages.
    at simulator_core\src\game\mod.rs:214 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:13:45.707205Z  INFO  Actix runtime found; starting in Actix runtime
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:191 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:13:45.707222Z  INFO  starting service: "actix-web-service-127.0.0.1:10070", workers: 32, listening on: 127.0.0.1:10070
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:197 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:15:33.652230Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T12:15:33.676756Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T12:15:33.681087Z  INFO  starting 32 workers
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\builder.rs:272 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:15:33.681287Z  INFO  PlayerActor 1 connected ( not session connection! ), P1 can now receive messages.
    at simulator_core\src\game\mod.rs:203 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:15:33.681303Z  INFO  PlayerActor 2 connected ( not session connection! ), P2 can now receive messages.
    at simulator_core\src\game\mod.rs:210 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:15:33.681307Z  INFO  Both players actor connected. ( not session connection! ) Sending SetOpponent messages.
    at simulator_core\src\game\mod.rs:214 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:15:33.681515Z  INFO  Actix runtime found; starting in Actix runtime
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:191 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:15:33.681539Z  INFO  starting service: "actix-web-service-127.0.0.1:10088", workers: 32, listening on: 127.0.0.1:10088
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:197 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.802835Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T12:22:12.831157Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T12:22:12.836474Z  INFO  starting 32 workers
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\builder.rs:272 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.836790Z  INFO  PlayerActor 1 connected ( not session connection! ), P1 can now receive messages.
    at simulator_core\src\game\mod.rs:203 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.836807Z  INFO  PlayerActor 2 connected ( not session connection! ), P2 can now receive messages.
    at simulator_core\src\game\mod.rs:210 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.836811Z  INFO  Both players actor connected. ( not session connection! ) Sending SetOpponent messages.
    at simulator_core\src\game\mod.rs:214 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.837096Z  INFO  Actix runtime found; starting in Actix runtime
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:191 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.837130Z  INFO  starting service: "actix-web-service-127.0.0.1:10179", workers: 32, listening on: 127.0.0.1:10179
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:197 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.847205Z  INFO  멀리건 단계 핸들러 시작: player=Player1
    at simulator_dedicated_server\src\server\mod.rs:115 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player1, id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9 }, player_type: Player1

  2025-06-10T12:22:12.847221Z  INFO  멀리건 단계 핸들러 시작: player=Player2
    at simulator_dedicated_server\src\server\mod.rs:115 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player2, id: e0159fea-dd83-4966-974a-6da069c0e3aa }, player_type: Player2

  2025-06-10T12:22:12.847341Z  INFO  WebSocket handshake successful for player_id: e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_dedicated_server\src\server\mod.rs:125 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player2, id: e0159fea-dd83-4966-974a-6da069c0e3aa }, player_type: Player2

  2025-06-10T12:22:12.847343Z  INFO  WebSocket handshake successful for player_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_dedicated_server\src\server\mod.rs:125 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player1, id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9 }, player_type: Player1

  2025-06-10T12:22:12.847487Z  INFO  ConnectionActor started for player Player2 e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_dedicated_server\src\connection\connection.rs:148 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:12.847503Z  INFO  ConnectionActor started for player Player1 ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_dedicated_server\src\connection\connection.rs:148 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:12.847604Z  INFO  Sent initial heartbeat_connected message to player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa)
    at simulator_dedicated_server\src\connection\connection.rs:171 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:12.847607Z  INFO  Sent initial heartbeat_connected message to player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9)
    at simulator_dedicated_server\src\connection\connection.rs:171 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:12.847788Z  INFO  [TEST] Received message: {"player":"Player1","session_id":"ce7ac098-b8b1-40c6-9ed7-ecffb17257e9","type":"heartbeat_connected"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:12.847990Z  INFO  [TEST] Received message: {"player":"Player2","session_id":"e0159fea-dd83-4966-974a-6da069c0e3aa","type":"heartbeat_connected"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854188Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.854198Z  INFO  Spawning heartbeat ping task for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.854287Z  INFO  Ping sent successfully to player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9) last_pong Instant { t: 151387.1650514s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.854289Z  INFO  Ping sent successfully to player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa) last_pong Instant { t: 151387.1650432s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.854484Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854563Z  INFO  [TEST] Received ping (auto-pong by tungstenite), ignoring.
    at simulator_dedicated_server\src\test\mod.rs:249 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854609Z  INFO  ConnectionActor for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.854627Z  INFO  ConnectionActor for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa): Initial Pong received. Registering with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:262 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.854632Z  INFO  ConnectionActor for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9): Received Pong from client
    at simulator_dedicated_server\src\connection\connection.rs:254 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.854642Z  INFO  ConnectionActor for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9): Initial Pong received. Registering with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:262 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.854684Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Handling RegisterConnection for player e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_core\src\game\msg\connection.rs:38 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854713Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Handling RegisterConnection for player ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_core\src\game\msg\connection.rs:38 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854757Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Connection for player e0159fea-dd83-4966-974a-6da069c0e3aa registered successfully. Total connections: 1
    at simulator_core\src\game\msg\connection.rs:82 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854766Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Game state locked for player e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_core\src\game\msg\connection.rs:93 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854774Z  INFO  Player Player2 added to game state as Connected
    at simulator_core\src\game\state.rs:83 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854782Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Player e0159fea-dd83-4966-974a-6da069c0e3aa connection status updated in GameStateManager.
    at simulator_core\src\game\msg\connection.rs:99 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854792Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Player e0159fea-dd83-4966-974a-6da069c0e3aa connected, but not all players are ready. Waiting for others.
    at simulator_core\src\game\msg\connection.rs:213 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854817Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Connection for player ce7ac098-b8b1-40c6-9ed7-ecffb17257e9 registered successfully. Total connections: 2
    at simulator_core\src\game\msg\connection.rs:82 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854822Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Game state locked for player ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_core\src\game\msg\connection.rs:93 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854825Z  INFO  Player Player1 added to game state as Connected
    at simulator_core\src\game\state.rs:83 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854832Z  INFO  Game phase transitioning from Initial to Mulligan
    at simulator_core\src\game\state.rs:147 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854836Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Player ce7ac098-b8b1-40c6-9ed7-ecffb17257e9 connection status updated in GameStateManager.
    at simulator_core\src\game\msg\connection.rs:99 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854841Z  INFO  GAME ACTOR [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Proceeding with Mulligan card distribution.
    at simulator_core\src\game\msg\connection.rs:149 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854840Z  INFO  ConnectionActor for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa): Successfully registered with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:318 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.854854Z  INFO  Starting opponent wait timer for first player: Player1
    at simulator_core\src\game\msg\connection.rs:238 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854875Z  INFO  PLAYER ACTOR [Player1]: Handling GetMulliganDealCards
    at simulator_core\src\player\message.rs:104 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.854976Z  INFO  Received SendMulliganDealCards event, sending directly to client for player: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_dedicated_server\src\connection\messages.rs:63 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.855052Z  INFO  Successfully sent Mulligan deal cards directly to player: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_dedicated_server\src\connection\messages.rs:85 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.855056Z  INFO  Sent mulligan cards (5 count) to player ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_core\src\game\msg\connection.rs:187 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855066Z  INFO  Player Player1 mulligan status updated from NotStarted to CardsDealt
    at simulator_core\src\game\state.rs:174 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855086Z  INFO  PLAYER ACTOR [Player2]: Handling GetMulliganDealCards
    at simulator_core\src\player\message.rs:104 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855142Z  INFO  Received SendMulliganDealCards event, sending directly to client for player: e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_dedicated_server\src\connection\messages.rs:63 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.855156Z  INFO  [TEST] Received message: {"cards":["8336a13e-a27a-4a87-ae81-8dd7a5f4fe28","b8490289-cb17-4056-9ec4-1f4955f0c7d5","6ee58bc7-69c9-414b-841b-96edd126c44b","24333be2-f5cd-46b1-8707-a143dda94b04","4bb7e590-52a0-422d-8c84-e76d49bc6ae0"],"player":"Player1","type":"mulligan_deal"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855215Z  INFO  Successfully sent Mulligan deal cards directly to player: e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_dedicated_server\src\connection\messages.rs:85 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.855413Z  INFO  PLAYER ACTOR [Player1]: Handling GetDeckCards
    at simulator_core\src\player\message.rs:220 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855482Z  INFO  Sent mulligan cards (5 count) to player e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_core\src\game\msg\connection.rs:187 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855491Z  INFO  Player Player2 mulligan status updated from NotStarted to CardsDealt
    at simulator_core\src\game\state.rs:174 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855520Z  INFO  [TEST] Received message: {"cards":["e3f92aa5-0bf2-4bc8-abe6-f44791f75d48","40c62cd0-5e8f-4896-a819-42511758bd24","e7827728-c8e9-4844-8ddc-26d1663ad62a","3d10b79e-0336-4dad-b736-be425dd37d6d","7c4d38b8-1c39-4e49-ac23-2075b9cddd03"],"player":"Player2","type":"mulligan_deal"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.855534Z  INFO  ConnectionActor for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9): Successfully registered with GameActor.
    at simulator_dedicated_server\src\connection\connection.rs:318 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.855848Z  INFO  PLAYER ACTOR [Player2]: Handling GetDeckCards
    at simulator_core\src\player\message.rs:220 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856225Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b] is stopping. Initiating comprehensive cleanup.
    at simulator_core\src\game\mod.rs:70 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856249Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: stopping() method finished, comprehensive cleanup scheduled.
    at simulator_core\src\game\mod.rs:152 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856268Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Starting comprehensive cleanup task.
    at simulator_core\src\game\mod.rs:82 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856283Z  INFO  Player Player2 removed from game state
    at simulator_core\src\game\state.rs:90 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856288Z  INFO  Player Player1 removed from game state
    at simulator_core\src\game\state.rs:90 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856292Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: All players removed from GameStateManager.
    at simulator_core\src\game\mod.rs:94 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856309Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: All connections cleared.
    at simulator_core\src\game\mod.rs:104 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856318Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Preparing to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }).
    at simulator_core\src\game\mod.rs:113 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856332Z  INFO  ConnectionActor for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9): WebSocket stream finished. Stopping actor.
    at simulator_dedicated_server\src\connection\connection.rs:388 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.856331Z  INFO  ConnectionActor for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa): WebSocket stream finished. Stopping actor.
    at simulator_dedicated_server\src\connection\connection.rs:388 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.856339Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Preparing to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }).
    at simulator_core\src\game\mod.rs:113 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856355Z  WARN  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Failed to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }): MailboxError(Mailbox has closed). Attempting Terminate.
    at simulator_core\src\game\mod.rs:122 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856361Z  INFO  ConnectionActor stopping for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9)
    at simulator_dedicated_server\src\connection\connection.rs:183 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.856362Z  WARN  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Failed to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }): MailboxError(Mailbox has closed). Attempting Terminate.
    at simulator_core\src\game\mod.rs:122 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856369Z  INFO  Heartbeat task cancelled for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9)
    at simulator_dedicated_server\src\connection\connection.rs:190 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.856370Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: Comprehensive cleanup task completed.
    at simulator_core\src\game\mod.rs:134 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856375Z  INFO  GameActor [405c7b6d-4aab-4329-b3d8-1f3486e8d73b]: All cleanup completed.
    at simulator_core\src\game\mod.rs:142 on mulligan::test_mulligan_deal_cards_on_simultaneous_connection_with_barrier ThreadId(3)

  2025-06-10T12:22:17.856371Z  INFO  ConnectionActor stopping for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa)
    at simulator_dedicated_server\src\connection\connection.rs:183 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.856386Z  INFO  Heartbeat task cancelled for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa)
    at simulator_dedicated_server\src\connection\connection.rs:190 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.856386Z  INFO  ConnectionActor stopping for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9)
    at simulator_dedicated_server\src\connection\connection.rs:183 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.856394Z  WARN  No heartbeat task to cancel for player Player1 (session_id: ce7ac098-b8b1-40c6-9ed7-ecffb17257e9)
    at simulator_dedicated_server\src\connection\connection.rs:195 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.856403Z  INFO  ConnectionActor stopping for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa)
    at simulator_dedicated_server\src\connection\connection.rs:183 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.856407Z  WARN  No heartbeat task to cancel for player Player2 (session_id: e0159fea-dd83-4966-974a-6da069c0e3aa)
    at simulator_dedicated_server\src\connection\connection.rs:195 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T12:22:17.856408Z  INFO  Session cleanup task completed: player=Player1, session_id=ce7ac098-b8b1-40c6-9ed7-ecffb17257e9
    at simulator_dedicated_server\src\connection\connection.rs:135 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T12:22:17.856418Z  INFO  Session cleanup task completed: player=Player2, session_id=e0159fea-dd83-4966-974a-6da069c0e3aa
    at simulator_dedicated_server\src\connection\connection.rs:135 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T16:20:48.943134Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T16:20:48.968857Z  INFO  로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.
    at simulator_core\src\lib.rs:71 on ThreadId(2)

  2025-06-10T16:20:48.973683Z  INFO  starting 32 workers
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\builder.rs:272 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:48.974620Z  INFO  PlayerActor 1 connected ( not session connection! ), P1 can now receive messages.
    at simulator_core\src\game\mod.rs:203 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:48.974636Z  INFO  PlayerActor 2 connected ( not session connection! ), P2 can now receive messages.
    at simulator_core\src\game\mod.rs:210 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:48.974640Z  INFO  Both players actor connected. ( not session connection! ) Sending SetOpponent messages.
    at simulator_core\src\game\mod.rs:214 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:48.974861Z  INFO  Actix runtime found; starting in Actix runtime
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:191 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:48.974908Z  INFO  starting service: "actix-web-service-127.0.0.1:14420", workers: 32, listening on: 127.0.0.1:14420
    at C:\Users\blast\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\actix-server-2.5.0\src\server.rs:197 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:48.982491Z  INFO  멀리건 단계 핸들러 시작: player=Player1
    at simulator_dedicated_server\src\server\mod.rs:128 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player1, id: d6b329d5-49c6-40d5-84cc-6f832188c8c4 }, player_type: Player1

  2025-06-10T16:20:48.982577Z  INFO  WebSocket handshake successful for player_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4
    at simulator_dedicated_server\src\server\mod.rs:138 on actix-rt|system:0|arbiter:0 ThreadId(4)
    in game with player: AuthPlayer { ptype: Player1, id: d6b329d5-49c6-40d5-84cc-6f832188c8c4 }, player_type: Player1

  2025-06-10T16:20:48.982690Z  INFO  ConnectionActor started for player Player1 d6b329d5-49c6-40d5-84cc-6f832188c8c4
    at simulator_dedicated_server\src\connection\connection.rs:148 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T16:20:48.982761Z  INFO  Sent initial heartbeat_connected message to player Player1 (session_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4)
    at simulator_dedicated_server\src\connection\connection.rs:171 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T16:20:48.982826Z  INFO  [TEST] Received message: {"type":"heartbeat_connected","player":"Player1","session_id":"d6b329d5-49c6-40d5-84cc-6f832188c8c4"}
    at simulator_dedicated_server\src\test\mod.rs:239 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:49.086365Z  INFO  멀리건 단계 핸들러 시작: player=Player1
    at simulator_dedicated_server\src\server\mod.rs:128 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player1, id: d6b329d5-49c6-40d5-84cc-6f832188c8c4 }, player_type: Player1

  2025-06-10T16:20:49.086426Z  INFO  WebSocket handshake successful for player_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4
    at simulator_dedicated_server\src\server\mod.rs:138 on actix-rt|system:0|arbiter:1 ThreadId(5)
    in game with player: AuthPlayer { ptype: Player1, id: d6b329d5-49c6-40d5-84cc-6f832188c8c4 }, player_type: Player1

  2025-06-10T16:20:49.086521Z  INFO  ConnectionActor started for player Player1 d6b329d5-49c6-40d5-84cc-6f832188c8c4
    at simulator_dedicated_server\src\connection\connection.rs:148 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T16:20:49.086558Z  INFO  Sent initial heartbeat_connected message to player Player1 (session_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4)
    at simulator_dedicated_server\src\connection\connection.rs:171 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T16:20:53.992116Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T16:20:53.992221Z  INFO  Ping sent successfully to player Player1 (session_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4) last_pong Instant { t: 165703.3002694s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:0 ThreadId(4)

  2025-06-10T16:20:54.101211Z  INFO  Spawning heartbeat ping task for player Player1 (session_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4)
    at simulator_dedicated_server\src\connection\connection.rs:87 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T16:20:54.101270Z  INFO  Ping sent successfully to player Player1 (session_id: d6b329d5-49c6-40d5-84cc-6f832188c8c4) last_pong Instant { t: 165703.4041155s }
    at simulator_dedicated_server\src\connection\connection.rs:107 on actix-rt|system:0|arbiter:1 ThreadId(5)

  2025-06-10T16:20:54.101915Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20] is stopping. Initiating comprehensive cleanup.
    at simulator_core\src\game\mod.rs:70 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.101952Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: stopping() method finished, comprehensive cleanup scheduled.
    at simulator_core\src\game\mod.rs:152 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.101962Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: Starting comprehensive cleanup task.
    at simulator_core\src\game\mod.rs:82 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.101974Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: All players removed from GameStateManager.
    at simulator_core\src\game\mod.rs:94 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.101980Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: All connections cleared.
    at simulator_core\src\game\mod.rs:104 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.101986Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: Preparing to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }).
    at simulator_core\src\game\mod.rs:113 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.102005Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: Preparing to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }).
    at simulator_core\src\game\mod.rs:113 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.102025Z  WARN  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: Failed to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }): MailboxError(Mailbox has closed). Attempting Terminate.
    at simulator_core\src\game\mod.rs:122 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.102031Z  WARN  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: Failed to send GameOver to PlayerActor (Addr { tx: AddressSender { sender_task: Mutex { data: SenderTask { task: None, is_parked: false } }, maybe_parked: false } }): MailboxError(Mailbox has closed). Attempting Terminate.
    at simulator_core\src\game\mod.rs:122 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.102037Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: Comprehensive cleanup task completed.
    at simulator_core\src\game\mod.rs:134 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)

  2025-06-10T16:20:54.102041Z  INFO  GameActor [10affd7b-6bf0-44a7-92da-ce4e9eed0a20]: All cleanup completed.
    at simulator_core\src\game\mod.rs:142 on mulligan::test_rejects_duplicate_connection_for_same_player ThreadId(3)
</file>

<file path="simulator_dedicated_server/src/connection/types.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GameStateSnapshot {
    pub current_phase: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PlayerInputRequest {
    pub request_id: Uuid,
    pub input_type: PlayerInputType,
    pub options: Vec<String>,
    pub message: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerInputType {
    SelectCardFromHand,
    SelectTargetOnField,
    ChooseEffect,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerInputResponse {
    MulliganRerollAnswer(Vec<Uuid>),
    CardSelection(Vec<Uuid>),
    TargetSelection(Uuid),
    EffectChoice(String),
}
</file>

<file path="simulator_dedicated_server/src/enums.rs">
pub const HEARTBEAT_INTERVAL: u64 = 5;
pub const CLIENT_TIMEOUT: u64 = 30; // 30초 동안 응답 없으면 연결 끊김
</file>

<file path="simulator_dedicated_server/src/room/mod.rs">
pub struct RoomManagerActor {}
</file>

<file path="simulator_match_server/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_match_server/.gitignore">
/target
</file>

<file path="simulator_match_server/.idea/.gitignore">
# 디폴트 무시된 파일
/shelf/
/workspace.xml
# 에디터 기반 HTTP 클라이언트 요청
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml
</file>

<file path="simulator_match_server/.idea/discord.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DiscordProjectSettings">
    <option name="show" value="PROJECT_FILES" />
    <option name="description" value="" />
    <option name="applicationTheme" value="default" />
    <option name="iconsTheme" value="default" />
    <option name="button1Title" value="" />
    <option name="button1Url" value="" />
    <option name="button2Title" value="" />
    <option name="button2Url" value="" />
    <option name="customApplicationId" value="" />
  </component>
</project>
</file>

<file path="simulator_match_server/.idea/modules.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/simulator.iml" filepath="$PROJECT_DIR$/.idea/simulator.iml" />
    </modules>
  </component>
</project>
</file>

<file path="simulator_match_server/.idea/simulator.iml">
<?xml version="1.0" encoding="UTF-8"?>
<module type="EMPTY_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/tests" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/target" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
</file>

<file path="simulator_match_server/.idea/vcs.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="" vcs="Git" />
  </component>
</project>
</file>

<file path="simulator_match_server/.vscode/launch.json">
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'card_game'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in executable 'card_game'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--bin=card_game",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "card_game",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug integration test 'test'",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--test=test",
                    "--package=card_game"
                ],
                "filter": {
                    "name": "test",
                    "kind": "test"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</file>

<file path="simulator_match_server/src/lib.rs">

</file>

<file path="simulator_core/benches/bench.rs">
use criterion::{criterion_group, criterion_main, Criterion};
// use tokio::runtime::Runtime;

fn bench_spawn_server(_c: &mut Criterion) {
    // Tokio 런타임 생성
    // let rt = Runtime::new().unwrap();

    // c.bench_function("spawn_server", |b| {
    //     b.iter(|| {
    //         // 런타임 내에서 비동기 작업 실행
    //         rt.block_on(async {
    //             let _ = spawn_server().await;
    //         });
    //     });
    // });
}

criterion_group!(benches, bench_spawn_server);
criterion_main!(benches);
</file>

<file path="simulator_core/src/card_gen/builder.rs">
use uuid::Uuid;

use crate::{
    card::{
        types::{CardSpecs, CardStatus, CardType, OwnerType},
        Card,
    },
    effect::{effects::EffectTiming, types::EffectSpeed, Effect},
    exception::{GameError, GameplayError},
    utils::{self, json::CardJson},
};

pub struct CardBuilder {
    uuid: Uuid,
    name: String,
    card_type: CardType,
    effects: Vec<EffectTiming>,
    json_data: CardJson,
    owner: OwnerType,
    pub specs: CardSpecs,
    status: CardStatus,
}

impl CardBuilder {
    pub fn new(card_json: &CardJson) -> Result<Self, GameError> {
        Ok(Self {
            uuid: utils::generate_uuid().unwrap(),
            name: card_json.name.clone().ok_or(GameError::Gameplay(GameplayError::InvalidAction { reason: "Invalid card data".to_string() }))?,
            card_type: CardType::from_json(card_json)?,
            effects: vec![],
            json_data: card_json.clone(),
            owner: OwnerType::None,
            specs: CardSpecs::new(card_json),
            status: CardStatus::new(),
        })
    }

    pub fn add_effect<E: Effect + 'static>(mut self, effect: E) -> Self {
        // TODO: priority 설정
        self.effects
            .push(EffectTiming::new(1, EffectSpeed::Medium, Box::new(effect)));
        self
    }

    // // UUID 설정
    // pub fn uuid(mut self, uuid: UUID) -> Self {
    //     self.uuid = uuid;
    //     self
    // }

    // // 이름 설정
    // pub fn name(mut self, name: String) -> Self {
    //     self.name = name;
    //     self
    // }

    // // 카드 타입 설정
    // pub fn card_type(mut self, card_type: CardType) -> Self {
    //     self.card_type = card_type;
    //     self
    // }

    // // 효과 목록 한번에 설정
    // pub fn effects(mut self, effects: Vec<Box<dyn Effect>>) -> Self {
    //     self.effects = effects;
    //     self
    // }

    // // JSON 데이터 설정
    // pub fn json_data(mut self, json_data: CardJson) -> Self {
    //     self.json_data = json_data;
    //     self
    // }

    // // 소유자 설정
    // pub fn owner(mut self, owner: OwnerType) -> Self {
    //     self.owner = owner;
    //     self
    // }

    // // 스펙 설정
    // pub fn specs(mut self, specs: CardSpecs) -> Self {
    //     self.specs = specs;
    //     self
    // }

    // pub fn status(mut self, status: CardStatus) -> Self {
    //     self.status = status;
    //     self
    // }

    pub fn build(self) -> Card {
        // owner: OwnerType,
        // uuid: UUID,
        // name: String,
        // effects: Vec<Box<dyn Effect>>,
        // r#type: CardType,
        // specs: CardSpecs,
        // status: CardStatus,
        // json_data: CardJson)
        Card::new(
            self.owner,
            self.uuid,
            self.name,
            self.effects,
            self.card_type,
            self.specs,
            self.status,
            self.json_data,
        )
    }
}
</file>

<file path="simulator_core/src/card/insert.rs">
use uuid::Uuid;

use crate::{exception::{GameError, GameplayError}, zone::zone::Zone};

use super::Card;

pub trait Insert: Send + Sync {
    /// 카드를 지정된 영역에 삽입합니다.
    ///
    /// # Arguments
    /// * `zone` - 카드를 삽입할 영역
    /// * `card` - 삽입할 카드
    ///
    /// # Returns
    /// * `Result<(), GameError>` - 삽입 성공 여부
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError>;

    /// 자기 자신의 복제본을 Box로 반환합니다.
    fn clone_box(&self) -> Box<dyn Insert>;
}
pub struct GeneralInsert;
pub struct TopInsert;
pub struct BottomInsert;
pub struct RandomInsert;
pub struct SpecificPositionInsert {
    target_card_uuid: Uuid,
    is_above: bool,
}

// Top 구현
impl Insert for TopInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인 (Zone 타입에 따라 다르게 처리할 수 있음)

        cards.push(card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(TopInsert)
    }
}

// Bottom 구현
impl Insert for BottomInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        cards.insert(0, card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(BottomInsert)
    }
}

// Random 구현
impl Insert for RandomInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        use rand::Rng;
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        let mut rng = rand::thread_rng();
        let position = rng.gen_range(0..=cards.len());
        cards.insert(position, card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(RandomInsert)
    }
}

// 특정 위치 구현
impl SpecificPositionInsert {
    pub fn new(target_card_uuid: Uuid, is_above: bool) -> Self {
        Self {
            target_card_uuid,
            is_above,
        }
    }
}

impl Insert for SpecificPositionInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        if let Some(pos) = cards
            .iter()
            .position(|c| c.get_uuid() == self.target_card_uuid)
        {
            let insert_pos = if self.is_above { pos } else { pos + 1 };
            cards.insert(insert_pos, card);
            Ok(())
        } else {
            Err(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "card", id: self.target_card_uuid.to_string() }))
        }
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(Self {
            target_card_uuid: self.target_card_uuid,
            is_above: self.is_above,
        })
    }
}
</file>

<file path="simulator_core/src/card/take.rs">
use uuid::Uuid;

use crate::{exception::{GameError, SystemError, GameplayError, DeckError}, selector::TargetCount, zone::zone::Zone};

use super::Card;
use crate::card::cards::CardVecExt;

pub trait Take: Send + Sync {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError>;
    fn clone_box(&self) -> Box<dyn Take>;
}

// TopTake: 덱/존의 위에서 카드를 가져옴
#[derive(Clone)]
pub struct TopTake(pub TargetCount);

impl Take for TopTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::System(SystemError::Internal("Not enough cards available".to_string())));
        }

        // drain은 앞에서부터 제거하므로, 뒤에서부터 가져오려면 인덱스 계산 필요
        let start_index = available.saturating_sub(count);
        Ok(cards.drain(start_index..).collect()) // drain은 역순으로 반환하지 않음, 순서 유지됨
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone()) // Clone을 이용해 간단히 구현
    }
}

// BottomTake: 덱/존의 아래에서 카드를 가져옴
#[derive(Clone)]
pub struct BottomTake(pub TargetCount);

impl Take for BottomTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::System(SystemError::Internal("Not enough cards available".to_string())));
        }

        // 앞에서부터 count만큼 제거
        Ok(cards.drain(0..count).collect())
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// RandomTake: 덱/존에서 무작위로 카드를 가져옴
#[derive(Clone)]
pub struct RandomTake(pub TargetCount);

impl Take for RandomTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::System(SystemError::Internal("Not enough cards available".to_string())));
        }

        // 1. 무작위 인덱스를 count만큼 중복 없이 뽑기
        let mut rng = rand::thread_rng();
        let indices_to_take: Vec<usize> =
            rand::seq::index::sample(&mut rng, available, count).into_vec();

        // 2. 인덱스를 내림차순으로 정렬하여 제거 시 다른 인덱스에 영향을 주지 않도록 함
        let mut sorted_indices = indices_to_take;
        sorted_indices.sort_unstable_by(|a, b| b.cmp(a)); // 내림차순 정렬

        // 3. 정렬된 인덱스를 사용하여 카드 제거 및 수집
        let mut taken_cards = Vec::with_capacity(count);
        for index in sorted_indices {
            // remove는 요소를 제거하고 뒤의 요소들을 앞으로 당김
            taken_cards.push(cards.remove(index));
        }

        // 4. 원래 뽑힌 순서대로 돌려주려면 taken_cards를 reverse 해야 함 (선택적)
        // 현재는 제거된 순서의 역순으로 반환됨. 무작위 선택이므로 순서가 중요하지 않을 수 있음.
        // taken_cards.reverse();

        Ok(taken_cards)
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// SpecificTake: 특정 UUID의 카드를 가져옴
#[derive(Clone)]
pub struct SpecificTake(pub Uuid);

impl Take for SpecificTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();

        match cards.remove_by_uuid(self.0) {
            Some(card) => Ok(vec![card]),
            None => Err(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "card", id: self.0.to_string() })),
        }
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// --- Helper Function ---

/// 가져올 카드의 수를 계산하는 헬퍼 함수
fn calculate_take_count(target_count: TargetCount, available: usize) -> Result<usize, GameError> {
    use std::cmp::min; // 함수 내에서만 사용

    match target_count {
        TargetCount::Exact(n) => {
            if n > available {
                // 정확히 n개를 가져와야 하는데 부족한 경우 -> 에러 처리 또는 정책 결정 필요
                // 여기서는 일단 에러로 처리 (혹은 0개를 반환할 수도 있음)
                Err(GameError::Gameplay(GameplayError::DeckError(DeckError::NoCardsLeftToDraw)))
            } else {
                Ok(n)
            }
        }
        TargetCount::Range(low, high) => {
            if available < low {
                // 최소 요구량보다 적으면 에러 또는 0 반환
                Err(GameError::Gameplay(GameplayError::DeckError(DeckError::NoCardsLeftToDraw)))
            } else {
                // low 이상 high 이하, 그리고 available 이하의 값을 반환
                Ok(min(high, available))
            }
        }
        TargetCount::Any => {
            // 가능한 모든 카드
            Ok(available)
        }
        TargetCount::None => {
            // 0개
            Ok(0)
        }
    }
}

// --- 새로운 에러 타입 정의 (선택적) ---
// exception/mod.rs 에 추가
// #[derive(Debug, PartialEq, Clone)]
// pub enum GameError {
//     // ... 기존 에러들 ...
//     NotEnoughCards(usize, usize), // 필요한 카드 수, 실제 있는 카드 수
//     // ...
// }
//
// impl fmt::Display for GameError {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self {
//             // ...
//             Self::NotEnoughCards(needed, available) => write!(f, "Not enough cards: needed {}, available {}", needed, available),
//             // ...
//         }
//     }
// }
</file>

<file path="simulator_core/src/main.rs">
use std::fs;
use std::io::Write;
use std::path::Path;

use actix_web::{App, HttpServer};
use simulator_core::setup_logger;

use clap::Parser;
use uuid::Uuid;

// main
#[derive(Parser)]
#[command(
    name = "card game backend",           // 프로그램 이름
    author = env!("CARGO_PKG_AUTHORS"),       // 작성자
    version = env!("CARGO_PKG_VERSION"),           // 버전
    about = env!("CARGO_PKG_DESCRIPTION"),   // 짧은 설명
    long_about = None,         // 긴 설명 (None은 미사용)
)]
struct Args {
    #[arg(long = "p1_deck")]
    #[arg(required = true)]
    player_1_deckcode: String,

    #[arg(long = "p2_deck")]
    #[arg(required = true)]
    player_2_deckcode: String,

    #[arg(required = true)]
    attacker: usize,
}

// TODO: 매칭으로 만난 두 플레이어의 닉네임을 받은 뒤, 게임 공용 서버인 valid server 에 전송하여 실제 플레이어가 맞는지 확인 후, key 값을 리턴 받음.
pub fn check_session(_nick1: String, _nick2: String) -> (Uuid, Uuid) {
    todo!()
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("card_registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // 카드 모듈 디렉토리 스캔
    let modules = ["human", "monster", "public"];
    let mut card_registrations = Vec::new();

    for module in modules {
        let path = format!("src/card_gen/{}.rs", module);
        let content = fs::read_to_string(&path).unwrap();

        // 함수 이름 찾기
        for line in content.lines() {
            if line.contains("pub fn")
                && (line.contains("HM_") || line.contains("MT_") || line.contains("PB_"))
            {
                let func_name = line.split("fn ").nth(1).unwrap().split("(").next().unwrap();
                card_registrations.push(format!("    {}::{}", module, func_name));
            }
        }
    }

    // 매크로 호출 생성
    write!(
        f,
        r#"
        // 자동 생성된 카드 레지스트리
        generate_card_map! {{
            {}
        }}
        "#,
        card_registrations.join(",\n")
    )
    .unwrap();

    // let (deck_json, _) = generate_random_deck_json();
    // let (deck_json2, _) = generate_random_deck_json();

    // // 2. JSON을 덱 코드로 변환
    // let deck_codes = parse_json_to_deck_code(Some(deck_json), Some(deck_json2))
    //     .expect("Failed to parse deck code");

    // let app = initialize_app(deck_codes.0, deck_codes.1, 0);

    // let session_keys = check_session("".to_string(), "".to_string());

    // let state = web::Data::new(ServerState {
    //     game: Mutex::new(app.game),
    //     player_cookie: session_keys.0,
    //     opponent_cookie: session_keys.1,
    //     session_manager: PlayerSessionManager::new(CLIENT_TIMEOUT),
    // });

    setup_logger();
    HttpServer::new(move || {
        App::new()
        // .app_data(state.clone())
        // .service(mulligan_phase)
        // .service(draw_phase)
        // .service(standby_phase)
        // .service(main_phase_start_phase)
        // .service(heartbeat)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
</file>

<file path="simulator_core/src/selector/single.rs">
use std::sync::Arc;

use actix::Addr;

use crate::{
    card::{
        types::{CardType, OwnerType},
        Card,
    },
    enums::ZoneType,
    exception::GameError,
    game::GameActor,
};

use super::{TargetCondition, TargetCount, TargetSelector};

pub struct SingleCardSelector {
    condition: TargetCondition,
}

impl SingleCardSelector {
    pub fn new(location: ZoneType, owner: OwnerType) -> Self {
        Self {
            condition: TargetCondition {
                location: vec![location],
                owner,
                card_type: None,
                custom_filter: None,
            },
        }
    }

    pub fn with_card_type(mut self, card_type: CardType) -> Self {
        self.condition.card_type = Some(card_type);
        self
    }

    pub fn with_filter<F>(mut self, filter: F) -> Self
    where
        F: Fn(&Card) -> bool + Send + Sync + 'static,
    {
        self.condition.custom_filter = Some(Arc::new(filter));
        self
    }
}

impl TargetSelector for SingleCardSelector {
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError> {
        // let valid_targets = self.get_valid_targets(game, source);

        // if valid_targets.is_empty() {
        //     return Err(GameError::NoValidTargets);
        // }

        // // 실제 게임에서는 플레이어가 선택
        // Ok(vec![valid_targets[0].clone()])
        todo!()
    }

    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool {
        // !self.get_valid_targets(game, source).is_empty()
        todo!()
    }

    fn get_target_count(&self) -> TargetCount {
        // TargetCount::Exact(1)
        todo!()
    }

    fn clone_selector(&self) -> Box<dyn TargetSelector> {
        Box::new(Self {
            condition: self.condition.clone(),
        })
    }

    fn get_owner(&self) -> OwnerType {
        todo!()
    }

    fn get_locations(&self) -> Vec<ZoneType> {
        todo!()
    }

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/deck.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, insert::Insert, take::Take, Card},
    enums::DECK_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Deck {
    zone_cards: Cards,
    zone_size: usize,
}

impl Deck {
    pub fn new(zone_cards: Cards) -> Deck {
        Deck {
            zone_cards,
            zone_size: DECK_ZONE_SIZE,
        }
    }

    /// 현재 Zone 에 카드를 추가 합니다.
    /// TODO: 무슨 방식으로(eg. 랜덤, 맨 위, 맨 아래) 넣을지 구현해야함.

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Deck {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        &mut self.zone_cards
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError> {
        for card in cards {
            insert.insert(self, card)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, mut take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        take_type.as_mut().take(self)
    }
}
</file>

<file path="simulator_core/src/zone/hand.rs">
use uuid::Uuid;

use crate::{
    card::{
        cards::{CardVecExt, Cards},
        insert::Insert,
        take::Take,
        Card,
    },
    enums::UNIT_ZONE_SIZE,
    exception::{GameError, GameplayError},
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Hand {
    zone_cards: Cards,
    zone_size: usize,
}

impl Hand {
    pub fn new() -> Hand {
        Hand {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, card: Card) -> Result<(), GameError> {
        self.zone_cards
            .remove_by_uuid(card.get_uuid())
            .map(|_| ())
            .ok_or(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "card", id: card.get_uuid().to_string() }))
    }
}

impl Zone for Hand {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError> {
        for card in cards {
            insert.insert(self, card)?;
        }
        Ok(())
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_dedicated_server/src/connection/connection.rs">
use std::time::{Duration, Instant};

use actix::{
    fut::wrap_future, Actor, ActorContext, Addr, AsyncContext, Context, Running, SpawnHandle,
    StreamHandler,
};
use actix_ws::{Message, ProtocolError, Session};
use simulator_core::{
    card::types::PlayerKind,
    exception::{GameError, SystemError},
    game::{
        msg::connection::RegisterConnection,
        GameActor,
    },
    retry, RetryConfig,
};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::{
    connection::{
        messages::{CancelHeartbeat, StopActorOnError},
        ServerMessage,
    },
    enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
};

use super::UserAction;

/// WebSocket 연결을 관리하는 Actor
pub struct ConnectionActor {
    pub ws_session: Session,        // 웹소켓 세션 제어
    pub game_addr: Addr<GameActor>, // 연결된 GameActor 주소
    pub player_type: PlayerKind,

    pub last_pong: Instant,
    pub player_id: Uuid,       // 이 연결의 플레이어 ID
    pub cleanup_started: bool, // 중복 정리를 방지하기 위한 플래그
    pub initial_pong_received: bool,
    pub heartbeat_handle: Option<SpawnHandle>,
}

impl ConnectionActor {
    /// ConnectionActor의 새 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `session` - 이 액터가 관리할 웹소켓 세션 객체.
    /// * `game_addr` - 이 플레이어가 참여하는 게임을 관리하는 GameActor의 주소.
    /// * `session_id` - 이 연결에 해당하는 플레이어의 고유 식별자.
    /// * `session_manager` - 세션 타임아웃 및 정리를 관리하는 PlayerSessionManager.
    ///
    /// # Returns
    ///
    /// 새로운 ConnectionActor 인스턴스를 반환합니다.
    pub fn new(
        session: Session,
        game_addr: Addr<GameActor>,
        player_id: Uuid,
        player_type: PlayerKind,
    ) -> Self {
        Self {
            ws_session: session,
            game_addr,
            player_id,
            last_pong: Instant::now(),
            player_type,
            cleanup_started: false,
            initial_pong_received: false,
            heartbeat_handle: None,
        }
    }

    fn start_heartbeat_check(&mut self, ctx: &mut Context<Self>) {
        let handle = ctx.run_interval(Duration::from_secs(HEARTBEAT_INTERVAL), |act, ctx_inner| {
            if Instant::now().duration_since(act.last_pong) > Duration::from_secs(CLIENT_TIMEOUT) {
                // Timeout 처리
                warn!(
                    "Heartbeat timeout for player {:?} (session_id: {}). Closing connection.",
                    act.player_type, act.player_id
                );
                ctx_inner.stop();
                return;
            }

            // 1. Ping 작업을 Context::spawn을 사용하여 비동기로 실행
            info!(
                "Spawning heartbeat ping task for player {:?} (session_id: {})",
                act.player_type, act.player_id
            );

            let mut session_clone = act.ws_session.clone();
            let player_type_log = act.player_type;
            let session_id_log = act.player_id;
            let last_pong = act.last_pong;
            let connection_adrr = ctx_inner.address().clone();

            // 2. 비동기 블록을 직접 spawn
            ctx_inner.spawn(wrap_future::<_, Self>(async move {
                if let Err(e) = session_clone.ping(b"heartbeat").await {
                    error!(
                        "Failed to send ping to player {:?} (session_id: {}): {:?}",
                        player_type_log, session_id_log, e
                    );
                    connection_adrr.do_send(CancelHeartbeat);
                } else {
                    info!(
                        "Ping sent successfully to player {:?} (session_id: {}) last_pong {:?}",
                        player_type_log, session_id_log, last_pong
                    );
                }
            }));
        });

        self.heartbeat_handle = Some(handle);
    }

    fn start_cleanup_task(&mut self) {
        if self.cleanup_started {
            return;
        }
        self.cleanup_started = true;

        let player_clone = self.player_type;
        let sid_clone = self.player_id;
        let ws_session_clone = self.ws_session.clone();

        tokio::spawn(async move {
            ws_session_clone.close(None).await.unwrap_or_else(|e| {
                error!(
                    "Failed to close WebSocket session for player {:?} (session_id: {}): {:?}",
                    player_clone, sid_clone, e
                );
            });
            info!(
                "Session cleanup task completed: player={:?}, session_id={}",
                player_clone, sid_clone
            );
        });
    }
}

impl Actor for ConnectionActor {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Context<Self>) {
        let player_type_log = self.player_type;
        info!(
            "ConnectionActor started for player {} {}",
            player_type_log, self.player_id
        );

        self.start_heartbeat_check(ctx);

        let session_id_log = self.player_id;
        let mut session_clone = self.ws_session.clone();
        let init_msg = ServerMessage::HeartbeatConnected {
            player: self.player_type.to_string(),
            session_id: self.player_id,
        }
        .to_json();

        // 비동기 작업을 정의하는 Future 생성
        let send_future = async move {
            if let Err(e) = session_clone.text(init_msg).await {
                error!(
                    "Failed to send initial heartbeat_connected message to player {:?} (session_id: {}): {:?}",
                    player_type_log, session_id_log, e
                );
            } else {
                info!(
                    "Sent initial heartbeat_connected message to player {:?} (session_id: {})",
                    player_type_log, session_id_log
                );
            }
        };

        // 표준 Future를 ActorFuture로 감싸서 액터 컨텍스트에서 실행
        ctx.spawn(wrap_future::<_, Self>(send_future));
    }

    fn stopping(&mut self, ctx: &mut Context<Self>) -> Running {
        info!(
            "ConnectionActor stopping for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );

        if let Some(handle) = self.heartbeat_handle.take() {
            ctx.cancel_future(handle);
            info!(
                "Heartbeat task cancelled for player {:?} (session_id: {})",
                self.player_type, self.player_id
            );
        } else {
            warn!(
                "No heartbeat task to cancel for player {:?} (session_id: {})",
                self.player_type, self.player_id
            );
        }

        self.start_cleanup_task();

        Running::Continue
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        info!(
            "ConnectionActor stopped for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );
    }
}

impl StreamHandler<Result<Message, ProtocolError>> for ConnectionActor {
    fn handle(&mut self, msg: Result<Message, ProtocolError>, ctx: &mut Context<Self>) {
        debug!(
            "ConnectionActor received message from player {:?} (session_id: {}): {:?}",
            self.player_type, self.player_id, msg
        );
        match msg {
            Ok(Message::Ping(ping_msg)) => {
                info!(
                    "ConnectionActor for player {:?} (session_id: {}) received Ping from client.",
                    self.player_type, self.player_id
                );

                let player_type_log = self.player_type;
                let session_id_log = self.player_id;
                let mut session_clone = self.ws_session.clone();

                let send_future = async move {
                    if let Err(e) = session_clone.pong(&ping_msg).await {
                        error!(
                            "ConnectionActor for player {:?} (session_id: {}): Failed to send Pong to client: {:?}",
                            player_type_log, session_id_log, e
                        );
                    } else {
                        info!(
                            "ConnectionActor for player {:?} (session_id: {}): Sent Pong to client.",
                            player_type_log, session_id_log
                        );
                    }
                };
                ctx.spawn(wrap_future::<_, Self>(send_future));
            }
            Ok(Message::Pong(_)) => {
                let player_type = self.player_type;
                let player_id = self.player_id;
                let game_addr = self.game_addr.clone();
                let addr = ctx.address().clone();

                // 1. 활성 시간 갱신
                self.last_pong = Instant::now();
                info!(
                    "ConnectionActor for player {:?} (session_id: {}): Received Pong from client",
                    self.player_type, self.player_id
                );

                // 2. 초기 Pong 수신 여부 확인
                if !self.initial_pong_received {
                    self.initial_pong_received = true;
                    info!(
                        "ConnectionActor for player {:?} (session_id: {}): Initial Pong received. Registering with GameActor.",
                        self.player_type, self.player_id
                    );

                    let connection_addr = ctx.address().clone();
                    let ws_session = self.ws_session.clone(); // ws_session도 클론

                    ctx.spawn(wrap_future::<_, Self>(async move {
                        // 3. GameActor에 연결 등록 메시지를 전송하는 비동기 함수 생성
                        let operation = || {
                            let game_addr_clone = game_addr.clone();
                            let connection_addr_clone = connection_addr.clone();
                            async move {
                                let register_connection_future = game_addr_clone
                                    .send(RegisterConnection {
                                        player_id,
                                        recipient: connection_addr_clone.recipient(),
                                    }).await;

                                match register_connection_future {
                                    Ok(handler_result) => {
                                        match handler_result {
                                            Ok(_) => {
                                                return Ok(());
                                            }
                                            Err(game_error) => {
                                                error!(
                                                    "ConnectionActor for player {:?} (session_id: {}): Message sent to GameActor, but registration failed with GameError: {:?}",
                                                    player_type, player_id, game_error
                                                );
                                                return Err(game_error);
                                            }
                                        }
                                    }
                                    Err(mailbox_error) => {
                                        error!(
                                        "ConnectionActor for player {:?} (session_id: {}): Failed to send RegisterConnection message to GameActor (MailboxError): {:?}",
                                        player_type, player_id, mailbox_error
                                    );
                                        return Err(GameError::System(SystemError::Mailbox(mailbox_error)));
                                    }
                                }
                            }
                        };

                        // 4. 생성된 비동기 함수를 retry 함수에 넘겨서 재시도 로직 적용
                        // TODO: retry -> retry_with_condition 로 변경해야하나?
                        if let Err(e) = retry(operation, RetryConfig::default(), "RegisterConnection").await{
                            error!(
                                "ConnectionActor for player {:?} (session_id: {}): Failed to register with GameActor after retries: {:?}",
                                player_type, player_id, e
                            );

                            // 클라이언트에게 에러 메시지 전송
                            let server_error_message = ServerMessage::from(e);
                            
                            // 2. ServerMessage를 JSON 문자열로 변환합니다.
                            //    (to_json 헬퍼 함수가 이 새로운 variant를 처리하도록 수정 필요)
                            let error_payload = server_error_message.to_json();
                            
                            let mut session_clone = ws_session.clone();
                            if let Err(send_err) = session_clone.text(error_payload).await {
                                warn!("Failed to send error message to client: {:?}", send_err);
                            }
                            addr.do_send(StopActorOnError {
                                error: GameError::System(SystemError::Internal(
                                    "Failed to register with GameActor after retries".to_string(),
                                )),
                            });
                        } else {
                            info!(
                                "ConnectionActor for player {:?} (session_id: {}): Successfully registered with GameActor.",
                                player_type, player_id
                            );
                        }
                    }));
                }
            }
            Ok(Message::Close(reason)) => {
                info!(
                    "ConnectionActor for player {:?} (session_id: {}): Received Close from client. Reason: {:?}",
                    self.player_type, self.player_id, reason
                );
                ctx.stop();
            }
            Ok(Message::Text(text)) => {
                match serde_json::from_str::<UserAction>(&text.to_string()) {
                    Ok(user_action) => {
                        info!(
                            "ConnectionActor for player {:?} (session_id: {}): Forwarding action to GameActor: {:?}",
                            self.player_type, self.player_id, user_action
                        );
                        // self.game_addr.do_send(HandleUserAction {
                        //     player_id: self.player_id,
                        //     action: user_action,
                        // });
                    }
                    Err(e) => {
                        error!(
                            "ConnectionActor for player {:?} (session_id: {}): Failed to parse UserAction from text '{}'. Error: {}",
                            self.player_type, self.player_id, text, e
                        );
                        let error_msg = format!("{{\"error\": \"Invalid message format: {}\"}}", e);
                        let mut session_clone = self.ws_session.clone();
                        let player_id_log = self.player_id; // 로그용 ID 클론
                        ctx.spawn(wrap_future::<_, Self>(async move {
                            if let Err(send_err) = session_clone.text(error_msg).await {
                                error!(
                                    "ConnectionActor for player_id {}: Failed to send error text to client: {:?}",
                                    player_id_log, send_err
                                );
                            }
                        }));
                    }
                }
            }
            Ok(Message::Binary(_)) => {
                warn!(
                    "ConnectionActor for player {:?} (session_id: {}): Received unexpected Binary message.",
                    self.player_type, self.player_id
                );
            }
            Err(e) => {
                error!(
                    "ConnectionActor for player {:?} (session_id: {}): WebSocket error: {}",
                    self.player_type, self.player_id, e
                );
                ctx.stop();
            }
            _ => {
                // 예를 들어 Ok(Message::Continuation(_)) 등 명시적으로 처리하지 않은 메시지 타입
                warn!(
                    "ConnectionActor for player {:?} (session_id: {}): Received unhandled message type.",
                    self.player_type, self.player_id
                );
            }
        }
    }

    fn finished(&mut self, ctx: &mut Context<Self>) {
        info!(
            "ConnectionActor for player {:?} (session_id: {}): WebSocket stream finished. Stopping actor.",
            self.player_type, self.player_id
        );
        ctx.stop();
    }
}
</file>

<file path="simulator_dedicated_server/src/connection/messages.rs">
use std::io::Error;

use actix::{fut::wrap_future, prelude::*};
use tracing::{info, warn};

use simulator_core::{
    exception::{GameError, GameplayError, SystemError},
    game::msg::GameEvent,
};

use super::{connection::ConnectionActor, ServerMessage};

use actix::Message;

#[derive(Message)]
#[rtype(result = "()")]
pub struct StopActorOnError {
    pub error: GameError,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct CancelHeartbeat;

impl Handler<CancelHeartbeat> for ConnectionActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, _msg: CancelHeartbeat, ctx: &mut Context<Self>) -> Self::Result {
        info!("Cancelling heartbeat for player: {:?}", self.player_type);
        if let Some(handle) = self.heartbeat_handle {
            if ctx.cancel_future(handle) {
                info!(
                    "Heartbeat cancelled successfully for player: {:?}",
                    self.player_id
                );
                self.heartbeat_handle = None;
                return Ok(());
            } else {
                warn!(
                    "Failed to cancel heartbeat for player: {:?}, handle may not be valid.",
                    self.player_id
                );
                return Err(GameError::System(SystemError::Internal(
                    "Failed to cancel heartbeat, handle may not be valid.".to_string(),
                )));
            }
        }
        return Err(GameError::System(SystemError::Internal(
            "No heartbeat handle to cancel.".to_string(),
        )));
    }
}

impl Handler<StopActorOnError> for ConnectionActor {
    type Result = ();

    fn handle(&mut self, msg: StopActorOnError, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "Stopping ConnectionActor for player: {:?} due to error: {:?}",
            self.player_id, msg.error
        );
        // HeartBeat 등 리소스는 stopping 에서 처리함.
        ctx.stop();
    }
}

impl Handler<GameEvent> for ConnectionActor {
    type Result = ();
    fn handle(&mut self, msg: GameEvent, ctx: &mut Context<Self>) {
        match msg {
            GameEvent::SendMulliganDealCards { cards } => {
                info!("Received SendMulliganDealCards event, sending directly to client for player: {:?}", self.player_id);
                let data_to_send = ServerMessage::MulliganDealCards {
                    // ServerMessage는 클라이언트와 약속된 포맷
                    player: self.player_type.to_string(), // 또는 self.player_id.to_string()
                    cards: cards,                         // Uuid 리스트
                }
                .to_json(); // JSON 문자열로 변환하는 헬퍼

                let mut session_clone = self.ws_session.clone();
                let player_id_log = self.player_id;
                let actor_addr = ctx.address(); // 에러 시 중지를 위해

                let send_future = async move {
                    if let Err(e) = session_clone.text(data_to_send).await {
                        warn!(
                            "Failed to send Mulligan deal cards directly for player {}: {:?}",
                            player_id_log, e
                        );
                        actor_addr.do_send(StopActorOnError {
                            error: GameError::System(SystemError::Io(Error::new(
                                std::io::ErrorKind::ConnectionRefused,
                                format!("Failed to send Mulligan deal cards: {}", e),
                            ))),
                        });
                    } else {
                        info!(
                            "Successfully sent Mulligan deal cards directly to player: {}",
                            player_id_log
                        );
                    }
                };
                ctx.spawn(wrap_future::<_, Self>(send_future));
            }
            GameEvent::GameStopped => {
                info!(
                    "Game stopped event received, stopping ConnectionActor for player: {:?}",
                    self.player_id
                );
                ctx.stop(); // 게임이 중지되면 액터를 중지
            }
        }
    }
}
</file>

<file path="simulator_dedicated_server/src/connection/mod.rs">
use serde::{Deserialize, Serialize};
use simulator_core::exception::{ConnectionError, GameError, StateError};
use types::PlayerInputResponse;
use uuid::Uuid;

pub mod connection;
pub mod messages;
pub mod types;

#[derive(Deserialize, Debug, Clone)]
#[serde(tag = "action")]
pub enum UserAction {
    #[serde(rename = "rerollRequestMulliganCard")]
    RerollRequestMulliganCard { card_id: Vec<Uuid> },
    #[serde(rename = "completeMulligan")]
    CompleteMulligan,
    #[serde(rename = "playCard")]
    PlayCard {
        card_id: Uuid,
        target_id: Option<Uuid>,
    },
    #[serde(rename = "attack")]
    Attack {
        attacker_id: Uuid,
        defender_id: Uuid,
    },
    #[serde(rename = "endTurn")]
    EndTurn,
    #[serde(rename = "submitInput")]
    SubmitInput {
        request_id: Uuid,
        #[serde(flatten)]
        response_data: PlayerInputResponse,
    },
}

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(tag = "type")]
pub enum ServerMessage {
    #[serde(rename = "heartbeat_connected")]
    HeartbeatConnected { player: String, session_id: Uuid },
    #[serde(rename = "mulligan_deal")]
    MulliganDealCards { player: String, cards: Vec<Uuid> },

    #[serde(rename = "error")]
    Error(ErrorMessagePayload),
}

impl ServerMessage {
    pub fn to_json(&self) -> String {
        serde_json::to_string(self)
            .unwrap_or_else(|_| "{\"error\":\"json serialization failed\"}".to_string())
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")] // JSON에서는 "ACTIVE_SESSION_EXISTS"와 같이 변환
pub enum ServerErrorCode {
    ActiveSessionExists,
    GameAborted,
    InvalidAction,
    InternalServerError,
}

/// 클라이언트에게 전송될 에러 메시지의 실제 내용입니다.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ErrorMessagePayload {
    pub code: ServerErrorCode,
    pub message: String,
}

impl From<GameError> for ServerMessage {
    fn from(err: GameError) -> Self {
        // 서버 로그에는 변환 전의 상세한 에러를 기록합니다.
        tracing::warn!("Converting GameError to a client-facing message: {}", err);

        let (code, message) = match &err {
            // 시스템 에러는 내부 구현을 노출하지 않습니다.
            GameError::System(_) => (
                ServerErrorCode::InternalServerError,
                "An internal server error occurred.".to_string(),
            ),

            // 클라이언트가 명확히 처리할 수 있는 특정 에러들
            GameError::Connection(ConnectionError::SessionExists(_)) => {
                (ServerErrorCode::ActiveSessionExists, err.to_string())
            }
            GameError::State(StateError::GameAborted) => {
                (ServerErrorCode::GameAborted, err.to_string())
            }

            // 그 외 모든 에러는 클라이언트의 유효하지 않은 액션으로 간주합니다.
            // Display 트레이트 구현이 클라이언트에게 유용한 정보를 제공합니다.
            GameError::Connection(_) | GameError::State(_) | GameError::Gameplay(_) => {
                (ServerErrorCode::InvalidAction, err.to_string())
            }
        };

        ServerMessage::Error(ErrorMessagePayload { code, message })
    }
}
</file>

<file path="simulator_dedicated_server/src/lib.rs">
pub mod connection;
pub mod enums;
pub mod room;
pub mod server;
pub mod test;
</file>

<file path="simulator_dedicated_server/src/main.rs">
fn main() {}

/*
늑대 수간
{
    symbol-shaped pupils, green hair, fox tail, blunt bangs, ahoge,
    {{{{{{{{{{{{{{{{{furrification, furry female, furry, thick body fur, green body fur, green fur, body fur, furry face, furry body, animal feet, animal nose, two-tone fur, neck fur, pawpads}}}}}}}}}}}}}}}}, huohuo (honkai: star rail), large breasts, areolae, fluffy tail},

    0.4::artist:kambo::,

    1.0::artist:shiroi yoru::, 1.2::artist:wagashi (dagashiya)::, 0.5::artist:atte nanakusa::, 0.8::artist:tianliang duohe fangdongye::, 0.7::artist:kame_(3t)::, nsfw,
    {{{1 wolf, A very big wolf. oversized animal, bestiality}}}, <tags/clothes>, indoor, -x-ray, -comic, -multiple views, -{{{anal sex}}}, -paper doll, -futanari, :begin :seq {{{{A woman under the wolf. view between legs, squatting, from side}}}}, -{{{sex}}}, {{penis on face, precum}}, twitching penis, surprised, open mouth, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq {{{{A woman under the wolf. view between legs, squatting, from side}}}}, -{{{sex}}}, imminent fellatio, {{{masturbation, precum, licking penis}}}, open mouth, tongue out, drooling, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq {{{{A woman under the wolf. view between legs, squatting, from side}}}}, -{{{sex}}}, {{{deepthroat, irrumatio, throat bulge}}}, surprised, testicles, canine penis, penis in mouth, :seq {{{{A woman under the wolf. view between legs, squatting, from side, spreading legs}}}}, -{{{sex}}}, {{{{{{hand on another's head}}}}}}, -{{{sex}}}, {{{deepthroat, irrumatio, throat bulge}}}, surprised, cum, excessive cum, cum in mouth, testicles, canine penis, penis in mouth, :seq {{{{A woman under the wolf. view between legs, squatting, from side}}}}, -{{{sex}}}, smile, -fellatio, -irrumatio, open mouth, tongue out, cum in mouth, cum, excessive cum, male ejaculation, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, twitching penis, :seq pov, -{{{sex}}}, {{penis on face, precum}}, twitching penis, surprised, open mouth, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq pov, -{{{sex}}}, imminent fellatio, {{{masturbation, precum, licking penis}}}, open mouth, tongue out, drooling, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq -{{{sex}}}, {{{{pov, girl on top, paizuri, deepthroat}}}}, <breasts squeezed together | paizuri underclothes, breasts squeezed together>, double v, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, precum, :seq -{{{sex}}}, {{{{pov, girl on top, paizuri, deepthroat}}}}, <breasts squeezed together | paizuri underclothes, breasts squeezed together>, {{{surprised, cum, excessive cum, cum in mouth}}}, heart in eye, spoken heart, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq -{{{sex}}}, {{{{pov, girl on top, paizuri,}}}}, -deepthroat, <breasts squeezed together | paizuri underclothes, breasts squeezed together>, {{{smile, cum, excessive cum, cum in mouth, after fellatio, cum on breasts, cum on face}}}, heart in eye, spoken heart, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis,  :seq -sex, {{{{{{girl on top, squatting, guided penetrating, shallow penetration, imminent penetration, crotch rub}}}}}}, precum, pussy, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq {{{{{{girl on top, squatting, A dog lying on its stomach.}}}}}}, surprised, bouncing breasts, {{{{deep penetration}}}}, male penetrating female, female orgasm, female penetrated, sex, big dom small sub, pussy, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq -girl on top, {{{{A woman under the wolf. A wolf on a woman. crotch rub, pussy, from behind}}}}, <all fours|bent over>, imminent penetration, bottomless, panties aside, {{{{{{hand on another's head}}}}}}, -{{{sex}}}, -penetration, testicles, canine penis, knotted, knotting penis, gigantic penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, :seq {{{{A woman under the wolf. sex from behind, A wolf on a woman. doggystyle, {{{from behind}}}, sex, cervix}}}}, bottomless, panties aside, -internal cum, surprised, bouncing breasts, deep penetration, male penetrating female, female orgasm, female penetrated, sex, big dom small sub, testicles, canine penis, knotted, knotting penis, penile spines , :seq -{{{anal sex}}}, {{{{A woman under the wolf. sex from behind, A wolf on a woman. doggystyle, {{{from behind, from below, top-down bottom-up}}}, sex}}}}, pussy juice, cumdrip, {{{{{{hand on another's head}}}}}}, {{{pussy focus, looking back, bottomless, panties aside}}}, -internal cum, deep penetration, male penetrating female, female orgasm, female penetrated, sex, big dom small sub, testicles, canine penis, knotted, knotting penis, penile spines , :seq {{{{mating press, sex, A woman under the wolf. from behind, legs up, lying, on back, boy on top, impregnation, leg lock, motion blur}}}}, spoken heart, feet, cum in pussy, cum overflow, erection, ass focus, pussy focus, {{{bottomless, panties aside}}}, deep penetration, male penetrating female, female orgasm, female penetrated, sex, big dom small sub, testicles, canine penis, penile spines, knotted, knotting penis, penile spines , :seq {{{{{{{{ass-to-ass penetration, top-down bottom-up, from side}}}}}}}},  {{{bottomless, panties aside}}}, internal cum, deep penetration, male penetrating female, vaginal knotting, female orgasm, female penetrated, sex, big dom small sub, testicles, canine penis, knotted, knotting penis, penile spines , cumdrip, pussy juice, cum inflation, spoken heart, cum overflow, orgasm, :seq -imminent penetration, -sex, -deep penetration, -fellatio, {{{{french kiss, pussy focus, from below, girl on top, french kiss, A fox and a woman are kissing. on back, lying, spread legs, spread pussy, cum in pussy, cumdrip, pregnant, impregnation, smile}}}}, heart in eyes, spoken heart, female orgasm, testicles, canine penis, knotted, knotting penis, gigantic penis, long penis, gigantic penis, girthy penis, veiny penis, penile spines , twitching penis, precum, cum on pussy, cum on body,    :end
    detailed eyes, detailed face, detailed finger, highres, very aesthetic, best quality, amazing quality, incredibly absurdres
}

{
    1.0::artist:shiroi yoru::, 1.2::artist:wagashi (dagashiya)::, 0.5::artist:atte nanakusa::, 0.8::artist:tianliang duohe fangdongye::, 0.7::artist:kame_(3t)::, nsfw,
    <tags/huohuo_horse_wolf>,
    detailed eyes, detailed face, detailed finger, highres, very aesthetic, best quality, amazing quality, incredibly absurdres
}

*/
</file>

<file path="simulator_dedicated_server/src/server/mod.rs">
use std::{future::Future, pin::Pin};

use actix::{Actor, AsyncContext, Context};
use actix_web::{get, web, FromRequest, HttpRequest, HttpResponse};
use actix_ws::handle;
use simulator_core::{
    card::types::PlayerKind,
    exception::{ConnectionError, GameError, SystemError},
};
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

use crate::{connection::connection::ConnectionActor, test::ServerState};

#[derive(Debug, Clone, Copy)]
pub struct AuthPlayer {
    ptype: PlayerKind,
    id: Uuid,
}

impl AuthPlayer {
    fn new(ptype: PlayerKind, id: Uuid) -> Self {
        Self { ptype, id }
    }
}

impl AuthPlayer {
    fn reverse(&self) -> PlayerKind {
        match self.ptype {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }
}

impl FromRequest for AuthPlayer {
    type Error = GameError;
    type Future = Pin<Box<dyn Future<Output = Result<Self, Self::Error>>>>;

    fn from_request(req: &HttpRequest, _payload: &mut actix_web::dev::Payload) -> Self::Future {
        let req = req.clone();
        Box::pin(async move {
            debug!("AuthPlayer::from_request 시작: 인증 처리 중...");

            let Some(player_id_cookie) = req.cookie("user_id") else {
                error!("쿠키 누락: 'user_id' 쿠키를 찾을 수 없음");
                return Err(GameError::Connection(ConnectionError::InvalidPayload(
                    "Missing 'user_id' cookie".to_string(),
                )));
            };

            let player_id_string = player_id_cookie.to_string().replace("user_id=", "");
            debug!("쿠키 파싱 완료: player_name={}", player_id_string);

            if let Some(state) = req.app_data::<web::Data<ServerState>>() {
                let player_id = match Uuid::parse_str(&player_id_string) {
                    Ok(id) => id,
                    Err(e) => {
                        warn!(
                            "Failed to parse player_id from cookie: '{}'. Error: {}",
                            player_id_string, e
                        );
                        return Err(GameError::System(SystemError::Internal(format!(
                            "Invalid UUID format in cookie: '{}'",
                            player_id_string
                        ))));
                    }
                };

                // 서버 상태에서 플레이어 ID 가져오기 (state: &web::Data<ServerState>)
                let p1_key = state.player1_id;
                let p2_key = state.player2_id;

                // if-else if-else 로 PlayerType 결정
                let player_type = if player_id == p1_key {
                    debug!("Player authenticated as Player1 (ID: {})", player_id);
                    PlayerKind::Player1
                } else if player_id == p2_key {
                    debug!("Player authenticated as Player2 (ID: {})", player_id);
                    PlayerKind::Player2
                } else {
                    // 알 수 없는 ID 처리 (명확한 오류 반환)
                    error!(
                        "Authentication failed: Unknown player ID '{}' from cookie. Expected {} or {}.",
                        player_id, p1_key, p2_key
                    );
                    // 인증 실패 또는 잘못된 플레이어 오류 반환
                    return Err(GameError::Connection(ConnectionError::InvalidPayload(format!(
                        "Authentication failed: Unknown player ID '{}' from cookie. Expected {} or {}.",
                        player_id, p1_key, p2_key)
                    )));
                };

                debug!("Request Guard 통과: player_type={:?}", player_type);

                Ok(AuthPlayer::new(player_type, player_id))
            } else {
                error!("서버 상태 객체를 찾을 수 없음");
                Err(GameError::System(SystemError::Internal(
                    "Can't not found server state".to_string(),
                )))
            }
        })
    }
}

impl From<AuthPlayer> for PlayerKind {
    fn from(value: AuthPlayer) -> Self {
        value.ptype
    }
}

impl From<AuthPlayer> for String {
    fn from(value: AuthPlayer) -> Self {
        value.ptype.to_string()
    }
}

/// Game 의 전반적인 기능을 책임지는 end point
#[get("/game")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype))]
pub async fn game(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    info!("멀리건 단계 핸들러 시작: player={:?}", player.ptype);

    let player_type = player.ptype;
    let player_id = player.id;
    debug!("플레이어 타입 설정: {:?}", player_type);

    // Http 업그레이드: 이때 session과 stream이 반환됩니다.
    debug!("WebSocket 연결 업그레이드 시작");
    let (response, session, message_stream) = match handle(&req, payload) {
        Ok(result) => {
            info!(
                "WebSocket handshake successful for player_id: {}",
                player_id
            );
            result
        }
        Err(e) => {
            error!(
                "WebSocket handshake failed for player_id: {}: {:?}",
                player_id, e
            );
            return Ok(
                HttpResponse::InternalServerError().body(format!("WS Handshake Error: {}", e))
            );
        }
    };

    ConnectionActor::create(|ctx: &mut Context<ConnectionActor>| {
        let new_actor = ConnectionActor::new(session, state.game.clone(), player_id, player_type);
        ctx.add_stream(message_stream);
        new_actor
    });

    Ok(response)
}
</file>

<file path="simulator_dedicated_server/src/test/mod.rs">
use std::{
    io::Read,
    net::{SocketAddr, TcpListener},
    time::Duration,
};

use actix::{Actor, Addr};
use actix_web::{
    dev::ServerHandle,
    web::{self, Data},
    App, HttpServer,
};
use async_tungstenite::tungstenite::{self, error::UrlError, http::Request, Message};
use ctor::ctor;
use futures::{SinkExt, StreamExt};
use rand::{seq::SliceRandom, thread_rng};
use serde::de::DeserializeOwned;
use serde_json::{json, Value};
use simulator_core::{
    card::{types::PlayerKind, Card},
    card_gen::CardGenerator,
    enums::{CARD_JSON_PATH, CLIENT_TIMEOUT, HEARTBEAT_INTERVAL, MAX_CARD_SIZE},
    game::GameActor,
    setup_logger,
    utils::{json, parse_json_to_deck_code},
};
use tracing::info;
use url::Url;
use uuid::Uuid;

use crate::server::game;

pub struct ServerState {
    pub game: Addr<GameActor>,
    pub player1_id: Uuid,
    pub player2_id: Uuid,
}

pub fn generate_random_deck_json() -> (Value, Vec<Card>) {
    // 카드 JSON 파일 로드
    let file_path = CARD_JSON_PATH;
    let mut file = std::fs::File::open(file_path).expect("Failed to open cards.json");
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let cards: Vec<json::CardJson> =
        serde_json::from_str(&json_data).expect("Failed to parse JSON");

    let mut rng = thread_rng();
    let selected_cards: Vec<json::CardJson> = cards
        .into_iter()
        .filter(|card| card.collectible == Some(true))
        .collect::<Vec<_>>()
        .choose_multiple(&mut rng, MAX_CARD_SIZE)
        .cloned()
        .collect();

    // 선택된 카드로 덱 JSON 생성
    let deck_json = json!({
        "decks": [{
            "Hero": [{
                "name": "player1"
            }],
            "cards": selected_cards.iter().map(|card| {
                json!({
                    "id": card.id.clone(),
                    "num": 1
                })
            }).collect::<Vec<_>>()
        }]
    });

    // 원본 카드 정보 저장
    let card_generator = CardGenerator::new();
    let original_cards: Vec<Card> = selected_cards
        .iter()
        .map(|card| card_generator.gen_card_by_id_string(card.id.clone().unwrap(), card, 0))
        .collect();
    (deck_json, original_cards)
}

pub fn create_server_state() -> web::Data<ServerState> {
    let (deck_json, _original_cards) = generate_random_deck_json();
    let (deck_json2, _) = generate_random_deck_json();

    let deck_codes = parse_json_to_deck_code(Some(deck_json), Some(deck_json2))
        .expect("Failed to parse deck code");

    let player1_id = Uuid::new_v4();
    let player2_id = Uuid::new_v4();

    let game_actor = GameActor::create(|_ctx| {
        let game_actor = GameActor::new(
            Uuid::new_v4(),
            player1_id,
            player2_id,
            deck_codes.0,
            deck_codes.1,
            PlayerKind::Player1,
        );

        game_actor
    });

    web::Data::new(ServerState {
        game: game_actor,
        player1_id: player1_id,
        player2_id: player2_id,
    })
}

pub async fn spawn_server() -> (SocketAddr, Data<ServerState>, ServerHandle) {
    let server_state = create_server_state();
    let server_state_clone = server_state.clone();
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();

    let server = HttpServer::new(move || App::new().app_data(server_state.clone()).service(game))
        .listen(listener)
        .unwrap()
        .run();

    let handle = server.handle();
    tokio::spawn(server);

    (addr, server_state_clone, handle)
}

pub struct RequestTest {
    pub response: String,
}

impl RequestTest {
    pub async fn connect(
        step: &str,
        addr: SocketAddr,
        cookie: String,
    ) -> Result<Self, reqwest::Error> {
        let client = reqwest::Client::new();
        let response = client
            .get(format!("http://{}/{}", addr, step))
            .header("Cookie", cookie)
            .send()
            .await?;

        Ok(RequestTest {
            response: response.text().await.expect("Failed to get response"),
        })
    }

    /// 특정 타입의 메세지를 예상합니다. 예상한 메세지가 아닌 경우, panic! 합니다.
    pub fn expect_message<T, F, R>(&mut self, extractor: F) -> R
    where
        T: DeserializeOwned,
        F: Fn(T) -> R,
    {
        info!("[TEST] Response: {}", self.response);
        let msg = serde_json::from_str::<T>(self.response.as_str())
            .expect("Failed to parse JSON (expect_message)");
        extractor(msg)
    }
}

pub struct WebSocketTest {
    pub stream: futures_util::stream::SplitStream<
        async_tungstenite::WebSocketStream<
            async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
        >,
    >,
    pub sink: futures_util::stream::SplitSink<
        async_tungstenite::WebSocketStream<
            async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
        >,
        Message,
    >,
}
//-------------------------------
// WebSocketTest 구현
//-------------------------------

impl WebSocketTest {
    pub async fn connect(url: String, cookie: String) -> Result<Self, tungstenite::Error> {
        // ... (connect 로직은 이전과 동일) ...
        let mut url = Url::parse(&url).unwrap();
        if url.scheme() == "http" {
            url.set_scheme("ws").unwrap()
        } else if url.scheme() != "ws" && url.scheme() != "wss" {
            return Err(tungstenite::Error::Url(UrlError::UnsupportedUrlScheme));
        }

        let host = url
            .host_str()
            .ok_or(tungstenite::Error::Url(UrlError::EmptyHostName))?;
        let host_header = if let Some(port) = url.port() {
            format!("{}:{}", host, port)
        } else {
            host.to_string()
        };

        let request = Request::builder()
            .uri(url.as_str())
            .header("Cookie", cookie)
            .header("Host", host_header)
            .header(
                "Sec-WebSocket-Key",
                tungstenite::handshake::client::generate_key(),
            )
            .header("Upgrade", "websocket")
            .header("Connection", "Upgrade")
            .header("Sec-WebSocket-Version", "13")
            .body(())?;

        let (ws_stream, response) = async_tungstenite::tokio::connect_async(request).await?;

        assert_eq!(
            response.status(),
            tungstenite::http::StatusCode::SWITCHING_PROTOCOLS
        );

        let (sink, stream) = ws_stream.split(); // 스트림과 싱크 분리

        Ok(Self { stream, sink }) // 분리된 스트림과 싱크 저장
    }

    pub async fn send(&mut self, msg: impl Into<Message>) -> Result<(), tungstenite::Error> {
        self.sink.send(msg.into()).await // 싱크를 통해 메시지 전송
    }

    pub async fn expect_message<T, F, R>(&mut self, extractor: F) -> R
    where
        T: DeserializeOwned,
        F: Fn(T) -> R,
    {
        let callback = async {
            loop {
                match self.stream.next().await {
                    Some(Ok(Message::Text(text))) => {
                        info!("[TEST] Received message: {}", text);
                        if let Ok(parsed) = serde_json::from_str::<T>(&text) {
                            return extractor(parsed);
                        } else {
                            info!("[TEST] Failed to parse into expected type: {}", text);
                            // 중요: 여기서 continue를 해야 다른 타입 메시지를 기다림
                            continue;
                        }
                    }
                    Some(Ok(Message::Ping(_))) => {
                        info!("[TEST] Received ping (auto-pong by tungstenite), ignoring.");
                        continue; // 자동으로 pong 처리됨
                    }
                    Some(Ok(Message::Pong(_))) => {
                        info!("[TEST] Received Pong, ignoring.");
                        continue; // Pong은 무시하고 다음 메시지 기다림
                    }
                    Some(Ok(Message::Close(reason))) => {
                        panic!("WebSocket closed unexpectedly while waiting for specific message. Reason: {:?}", reason);
                    }
                    Some(Ok(msg)) => {
                        info!("[TEST] Ignoring other message type: {:?}", msg);
                        continue; // 다른 메시지 타입 무시
                    }
                    Some(Err(e)) => panic!("WebSocket error: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly"),
                }
            }
        };

        match tokio::time::timeout(Duration::from_secs(CLIENT_TIMEOUT), callback).await {
            Ok(result) => result,
            Err(_) => panic!(
                "Expected message timeout after {} seconds",
                HEARTBEAT_INTERVAL + 5
            ),
        }
    }
}

#[ctor]
fn init() {
    setup_logger();
}
</file>

<file path="simulator_dedicated_server/tests/test.rs">
pub mod mulligan {
    use std::{collections::HashSet, sync::Arc, time::Duration};

    use actix::Addr;
    use async_tungstenite::tungstenite::Message;
    use dedicated_server::{
        connection::ServerMessage,
        enums::HEARTBEAT_INTERVAL,
        test::{spawn_server, WebSocketTest},
    };
    use futures::StreamExt;
    use simulator_core::{
        card::types::PlayerKind,
        enums::{ZoneType, CLIENT_TIMEOUT, COUNT_OF_MULLIGAN_CARDS},
        game::{msg::zones::GetPlayerZoneCards, GameActor},
    };
    use tokio::{
        join,
        sync::Barrier,
        time::{sleep, timeout},
    };
    use uuid::Uuid;

    // 플레이어별 테스트 로직을 위한 헬퍼 함수
    async fn player_mulligan_sequence(
        player_kind: PlayerKind,
        player_id: Uuid,
        addr: std::net::SocketAddr,
        game_actor_addr: Addr<GameActor>, // GameActor 주소 전달
    ) -> (WebSocketTest, Vec<Uuid>) {
        let player_kind_str = player_kind.as_str();
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player_id);
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 초기 HeartbeatConnected 메시지 수신
        println!(
            "[{}] Waiting for initial HeartbeatConnected message...",
            player_kind_str
        );
        let initial_extractor = |message: ServerMessage| match message {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, player_kind_str);
                assert!(!session_id.is_nil());
                println!(
                    "[{}] Initial HeartbeatConnected received. Session ID: {}",
                    player_kind_str, session_id
                );
            }
            _ => panic!(
                "[{}] Expected HeartbeatConnected as the first message, but got {:?}",
                player_kind_str, message
            ),
        };
        ws.expect_message(initial_extractor).await;

        // 2. MulliganDealCards 메시지 수신
        println!(
            "[{}] Waiting for MulliganDealCards message...",
            player_kind_str
        );
        let mulligan_extractor = |message: ServerMessage| -> Vec<Uuid> {
            match message {
                ServerMessage::MulliganDealCards { player, cards } => {
                    // 중요: MulliganDealCards 메시지의 player 필드가 이 카드를 받는 플레이어를 지칭해야 함
                    assert_eq!(
                        player, player_kind_str,
                        "[{}] Mulligan cards for wrong player",
                        player_kind_str
                    );
                    assert_eq!(
                        cards.len(),
                        COUNT_OF_MULLIGAN_CARDS,
                        "[{}] Incorrect number of mulligan cards",
                        player_kind_str
                    );
                    for card_uuid in &cards {
                        assert!(
                            !card_uuid.is_nil(),
                            "[{}] Nil UUID in mulligan cards",
                            player_kind_str
                        );
                    }
                    println!(
                        "[{}] MulliganDealCards received with {} cards.",
                        player_kind_str,
                        cards.len()
                    );
                    cards
                }
                // 이 시점에는 다른 메시지가 오면 안 됨 (HeartbeatConnected는 이미 처리됨)
                _ => panic!(
                    "[{}] Expected MulliganDealCards message, but got {:?}",
                    player_kind_str, message
                ),
            }
        };
        let dealt_cards = ws.expect_message(mulligan_extractor).await;

        // 3. 받은 카드가 덱에 없는지 확인 (GameActor에게 요청)
        println!(
            "[{}] Verifying dealt cards are not in deck...",
            player_kind_str
        );
        let deck_cards_result = game_actor_addr
            .send(GetPlayerZoneCards {
                // GameActor는 Uuid로 플레이어를 식별하거나, PlayerKind를 Uuid로 변환할 수 있어야 함
                zone: ZoneType::Deck,
                player_type: player_kind,
            })
            .await;

        match deck_cards_result {
            Ok(deck_card_objects) => {
                let deck_uuids: Vec<Uuid> = deck_card_objects
                    .iter()
                    .map(|card| card.get_uuid())
                    .collect();
                for dealt_card_uuid in dealt_cards.iter() {
                    assert!(
                        !deck_uuids.contains(dealt_card_uuid),
                        "[{}] Deck should not contain card {} that was dealt in mulligan",
                        player_kind_str,
                        dealt_card_uuid
                    );
                }
                println!(
                    "[{}] Dealt cards correctly removed from deck.",
                    player_kind_str
                );
            }
            Err(e) => panic!(
                "[{}] GameActor returned error getting deck cards: {:?}",
                player_kind_str, e
            ),
        }

        // 멀리건 단계 완료를 위해 추가적인 메시지 전송/수신 로직이 필요할 수 있음
        // 예: ws.send(UserAction::CompleteMulligan).await;
        //     ws.expect_message(ServerMessage::MulliganPhaseEnd).await;

        (ws, dealt_cards) // 받은 카드 목록 반환
    }

    #[actix_web::test]
    async fn test_mulligan_deal_cards_to_each_player_concurrently() {
        let (addr, state, _handle) = spawn_server().await;
        let game_actor_addr = state.game.clone();

        let player1_id = state.player1_id;
        let player2_id = state.player2_id;

        // 두 플레이어의 멀리건 시퀀스를 병렬로 실행
        let ((_p1_ws, p1_results), (_p2_ws, p2_results)) = tokio::join!(
            player_mulligan_sequence(
                PlayerKind::Player1,
                player1_id,
                addr,
                game_actor_addr.clone()
            ),
            player_mulligan_sequence(
                PlayerKind::Player2,
                player2_id,
                addr,
                game_actor_addr.clone()
            )
        );

        println!("Player 1 mulligan cards: {:?}", p1_results);
        println!("Player 2 mulligan cards: {:?}", p2_results);

        // 추가 검증: P1과 P2가 받은 카드가 서로 다른지 등
        let mut all_dealt_cards = p1_results.clone();
        all_dealt_cards.extend(p2_results.clone());
        let unique_cards_count = all_dealt_cards
            .iter()
            .collect::<std::collections::HashSet<_>>()
            .len();
        assert_eq!(
            unique_cards_count,
            COUNT_OF_MULLIGAN_CARDS * 2,
            "Dealt cards between players are not unique."
        );

        println!("Test test_mulligan_deal_cards_to_each_player_concurrently completed.");
    }

    #[actix_web::test]
    #[should_panic]
    async fn test_mulligan_deal_cards_one_player_delayed() {
        let (addr, state, _handle) = spawn_server().await;
        let game_actor_addr = state.game.clone();

        let player1_id = state.player1_id;
        let player2_id = state.player2_id;

        // 플레이어 1은 즉시 시작
        let player1_task = tokio::spawn(player_mulligan_sequence(
            PlayerKind::Player1,
            player1_id,
            addr,
            game_actor_addr.clone(),
        ));

        // 플레이어 2는 35초 지연 후 시작 (이 시간 동안 서버가 P1을 기다리는지 확인)
        // 이 지연 시간은 서버의 관련 타임아웃 설정보다 길거나 짧게 조절하여 테스트 가능
        let delay_duration = Duration::from_secs(CLIENT_TIMEOUT + 5);
        println!(
            "[DELAYED_TEST] Player 2 will start mulligan sequence after {:?} delay.",
            delay_duration
        );

        let player2_task = tokio::spawn(async move {
            sleep(delay_duration).await;
            println!("[DELAYED_TEST] Player 2 starting mulligan sequence now.");
            player_mulligan_sequence(PlayerKind::Player2, player2_id, addr, game_actor_addr).await
        });

        // 두 태스크의 결과 기다림
        // P1은 바로 완료될 수 있고, P2는 지연 후 완료되거나,
        // 서버 정책에 따라 P1이 P2를 기다리다가 특정 조건 후 진행될 수 있음.
        let (p1_result_outer, p2_result_outer) = tokio::join!(player1_task, player2_task);

        // 태스크 실행 결과 확인 (JoinError 처리)
        let (_p1_ws, p1_results) = match p1_result_outer {
            Ok((ws, res)) => {
                println!(
                    "[DELAYED_TEST] Player 1 mulligan sequence completed with results: {:?}",
                    res
                );
                (ws, res)
            }
            Err(e) => {
                panic!("[DELAYED_TEST] Player 1 task failed: {:?}", e);
            }
        };

        let (_p2_ws, p2_results) = match p2_result_outer {
            Ok((ws, res)) => {
                println!(
                    "[DELAYED_TEST] Player 2 mulligan sequence completed with results: {:?}",
                    res
                );
                (ws, res)
            }
            Err(e) => {
                panic!("[DELAYED_TEST] Player 2 task failed: {:?}", e);
            }
        };

        // 결과 검증:
        // 이 부분은 서버가 지연된 플레이어를 어떻게 처리하는지에 따라 달라집니다.
        // 1. 서버가 P2를 기다려서 두 플레이어 모두 정상적으로 멀리건을 완료하는 경우:
        if !p1_results.is_empty() && !p2_results.is_empty() {
            println!("[DELAYED_TEST] Both players seem to have completed mulligan.");
            let mut all_dealt_cards = p1_results.clone();
            all_dealt_cards.extend(p2_results.clone());
            let unique_cards_count = all_dealt_cards
                .iter()
                .collect::<std::collections::HashSet<_>>()
                .len();
            assert_eq!(
            unique_cards_count,
            COUNT_OF_MULLIGAN_CARDS * 2,
            "[DELAYED_TEST] Dealt cards between players are not unique or not all players completed mulligan."
        );
        } else if !p1_results.is_empty() && p2_results.is_empty() {
            // 2. 서버가 P1만으로 게임을 시작하거나, P2를 기다리다 P1에 대한 타임아웃/오류 처리 후 P2는 실패하는 경우
            println!("[DELAYED_TEST] Player 1 completed mulligan, but Player 2 did not (possibly expected).");
            // 이 경우 P1의 멀리건 카드 수만 검증할 수 있습니다.
            assert_eq!(
                p1_results.len(),
                COUNT_OF_MULLIGAN_CARDS,
                "[DELAYED_TEST] Player 1 did not receive the correct number of mulligan cards."
            );
            // 서버 로그를 통해 P1이 P2를 기다렸는지, 또는 특정 시간 후 P1만으로 진행했는지 확인해야 합니다.
            // 또는 GameActor의 상태를 직접 확인하여 게임이 어떻게 진행되었는지 검증할 수 있습니다.
            // 예를 들어, GameStateManager.current_phase()가 Mulligan이 아닌 다른 상태로 넘어갔는지 등.
        } else {
            // 3. 두 플레이어 모두 실패한 경우 (예: 서버가 P1 지연으로 인해 전체 게임을 시작하지 못함)
            panic!("[DELAYED_TEST] Neither player completed the mulligan sequence. P1 results: {:?}, P2 results: {:?}", p1_results, p2_results);
        }

        println!("[DELAYED_TEST] Test test_mulligan_deal_cards_one_player_delayed completed.");
    }

    #[actix_web::test]
    async fn test_mulligan_deal_cards_on_simultaneous_connection_with_barrier() {
        // 1. Arrange: 서버와 함께 Barrier를 준비합니다.
        let (addr, state, _handle) = spawn_server().await;
        let game_actor_addr = state.game.clone();
        let player1_id = state.player1_id;
        let player2_id = state.player2_id;

        // 2개의 태스크를 동기화할 Barrier 생성
        let barrier = Arc::new(Barrier::new(2));

        println!("[BARRIER_TEST] Starting simultaneous connection test with Barrier.");

        // 2. Act: 각 플레이어 태스크가 Barrier에서 대기 후 동시에 진행하도록 합니다.
        let p1_barrier = barrier.clone();
        let p1_task = tokio::spawn(async move {
            println!("[BARRIER_TEST] Player 1 task is ready and waiting at the barrier.");
            p1_barrier.wait().await; // .await를 추가하여 비동기로 대기
            println!("[BARRIER_TEST] Player 1 task released from barrier, connecting now.");
            player_mulligan_sequence(PlayerKind::Player1, player1_id, addr, game_actor_addr).await
        });

        let p2_barrier = barrier.clone();
        let p2_task = tokio::spawn(async move {
            println!("[BARRIER_TEST] Player 2 task is ready and waiting at the barrier.");
            p2_barrier.wait().await; // .await를 추가하여 비동기로 대기
            println!("[BARRIER_TEST] Player 2 task released from barrier, connecting now.");
            player_mulligan_sequence(PlayerKind::Player2, player2_id, addr, state.game.clone())
                .await
        });

        // 두 태스크의 결과를 기다립니다.
        let (p1_result, p2_result) = join!(p1_task, p2_task);

        let (_p1_ws, p1_dealt_cards) = p1_result.expect("Player 1 task panicked");
        let (_p2_ws, p2_dealt_cards) = p2_result.expect("Player 2 task panicked");

        println!("[BARRIER_TEST] Both players completed their sequences after barrier.");

        // 3. Assert: 결과는 기존 테스트와 동일하게 검증합니다.
        assert_eq!(p1_dealt_cards.len(), COUNT_OF_MULLIGAN_CARDS);
        assert_eq!(p2_dealt_cards.len(), COUNT_OF_MULLIGAN_CARDS);

        let mut all_dealt_cards = p1_dealt_cards.clone();
        all_dealt_cards.extend(p2_dealt_cards.clone());

        let mut unique_cards = HashSet::new();
        for card_uuid in all_dealt_cards {
            assert!(
                unique_cards.insert(card_uuid),
                "Duplicate card found: {}",
                card_uuid
            );
        }

        println!("[BARRIER_TEST] Simultaneous connection test with Barrier PASSED.");
    }

    #[actix_web::test]
    async fn test_rejects_duplicate_connection_for_same_player() {
        // 1. Arrange: 테스트 서버를 시작하고 P1의 정보를 준비합니다.
        let (addr, state, _handle) = spawn_server().await;
        let player1_id = state.player1_id;
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        println!("[DUPLICATE_TEST] Starting duplicate connection test for Player 1.");

        // 2. Act (First Connection): 첫 번째 연결을 성공적으로 맺습니다.
        let mut ws1 = WebSocketTest::connect(url.clone(), cookie.clone())
            .await
            .expect("First connection should succeed");

        println!("[DUPLICATE_TEST] First connection established.");

        // 첫 번째 연결이 HeartbeatConnected 메시지를 받아 활성화되었는지 확인합니다.
        ws1.expect_message(|msg: ServerMessage| match msg {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, "Player1");
                assert_eq!(session_id, player1_id);
            }
            _ => panic!("Expected HeartbeatConnected for the first connection"),
        })
        .await;
        println!("[DUPLICATE_TEST] First connection confirmed active.");

        // 잠시 시간을 주어 첫 번째 연결이 서버에 완전히 등록되도록 합니다.
        tokio::time::sleep(Duration::from_millis(100)).await;

        // 3. Act (Second Connection): 동일한 플레이어로 두 번째 연결을 시도합니다.
        let mut ws2 = WebSocketTest::connect(url, cookie)
            .await
            .expect("Second connection handshake should also succeed initially");

        println!("[DUPLICATE_TEST] Second connection established. Now expecting it to be closed by server.");

        // 4. Assert (Second Connection Closed): 두 번째 연결이 서버에 의해 닫히는지 확인합니다.
        // 서버는 중복 세션을 감지하고 이 연결을 끊어야 합니다.
        // 스트림에서 Close 메시지를 받거나 스트림이 끝나면(None) 성공입니다.
        let close_result = timeout(Duration::from_secs(5), async {
            loop {
                match ws2.stream.next().await {
                    Some(Ok(Message::Close(_))) => {
                        println!("[DUPLICATE_TEST] Second connection received a Close frame as expected.");
                        return true;
                    },
                    Some(Ok(Message::Text(text))) => {
                        // 초기 HeartbeatConnected가 올 수도 있지만, 그 후엔 바로 Close가 와야 합니다.
                        println!("[DUPLICATE_TEST] Second connection received text (ignoring and waiting for close): {}", text);
                        continue;
                    }
                    Some(Ok(msg)) => {
                        println!("[DUPLICATE_TEST] Second connection received other message (ignoring): {:?}", msg);
                        continue;
                    },
                    Some(Err(e)) => {
                        println!("[DUPLICATE_TEST] Second connection terminated with error: {:?}", e);
                        return true; // 에러로 인한 종료도 예상된 결과일 수 있습니다.
                    },
                    None => {
                        println!("[DUPLICATE_TEST] Second connection stream ended (None), which is also an expected outcome.");
                        return true;
                    }
                }
            }
        }).await;

        assert!(
            close_result.unwrap_or(false),
            "Server did not close the duplicate connection within 5 seconds."
        );

        // 5. Assert (First Connection Intact): 첫 번째 연결이 여전히 살아있는지 확인합니다.
        // 서버로부터 오는 다음 heartbeat ping을 기다리는 것으로 확인할 수 있습니다.
        println!("[DUPLICATE_TEST] Verifying first connection is still alive.");
        let ping_check_result = timeout(Duration::from_secs(HEARTBEAT_INTERVAL + 2), async {
            loop {
                match ws1.stream.next().await {
                    Some(Ok(Message::Ping(_))) => {
                        println!("[DUPLICATE_TEST] First connection received a heartbeat ping. It's alive!");
                        return true;
                    }
                    Some(Ok(_)) => continue, // 다른 메시지는 무시
                    Some(Err(_)) | None => return false, // 스트림이 닫혔으면 실패
                }
            }
        }).await;

        assert!(
            ping_check_result.unwrap_or(false),
            "The first connection was unexpectedly closed after a duplicate attempt."
        );

        println!("[DUPLICATE_TEST] Duplicate connection test PASSED.");
    }
}

pub mod heartbeat {
    use std::time::Duration;

    use async_tungstenite::tungstenite::Message;
    use dedicated_server::{
        connection::ServerMessage,
        test::{spawn_server, WebSocketTest},
    };
    use futures::StreamExt;
    use simulator_core::{
        card::types::PlayerKind,
        enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
    };
    use tokio::time::{sleep, timeout};
    use tracing::info;
    use uuid::Uuid;

    #[actix_web::test]
    async fn test_heartbeat_initialize_msg() {
        let (addr, state, _handle) = spawn_server().await;

        let player_type = PlayerKind::Player1.as_str();

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", state.player1_id);

        // 예시: 서버에 GET 요청 보내기
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        let extractor = |message: ServerMessage| match message {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, player_type);
                assert!(!session_id.is_nil());
            }
            _ => panic!("Expected HeartbeatConnected message"),
        };
        ws.expect_message(extractor).await;
    }

    #[actix_web::test]
    async fn test_heartbeat_timeout() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player_kind_str = PlayerKind::Player1.as_str();

        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 초기 연결 메시지 수신
        info!("[TEST] Waiting for initial connection message...");
        let initial_extractor = |message: ServerMessage| -> Uuid {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert!(!session_id.is_nil());
                    info!(
                        "[TEST] Initial connection message received. Session ID: {}",
                        session_id
                    );
                    session_id
                }
                _ => panic!("Expected HeartbeatConnected message"),
            }
        };
        if timeout(
            Duration::from_secs(HEARTBEAT_INTERVAL),
            ws.expect_message(initial_extractor),
        )
        .await
        .is_err()
        {
            panic!("Timeout waiting for initial HeartbeatConnected message.");
        }

        // 2. 충분히 기다림 (CLIENT_TIMEOUT + 여유)
        let wait_duration = Duration::from_secs(CLIENT_TIMEOUT + 5);
        info!(
            "[TEST] Waiting for {} seconds to see if server closes connection (should NOT close due to auto Pong)...",
            wait_duration.as_secs()
        );

        sleep(wait_duration).await;

        // 3. 연결이 살아있는지 송수신 테스트 (예: Ping 보내고 Pong 받기)
        info!("[TEST] Sending Ping to check if connection is alive...");
        let ping_data = b"test_ping".to_vec();
        let send_result = ws.send(Message::Ping(ping_data.clone())).await;

        let pong_received = match send_result {
            Ok(_) => {
                // Pong 응답을 기다림
                timeout(Duration::from_secs(2), async {
                    loop {
                        match ws.stream.next().await {
                            Some(Ok(Message::Pong(data))) if data == ping_data => break true,
                            Some(Ok(_)) => continue,
                            Some(Err(_)) | None => break false,
                        }
                    }
                })
                .await
                .unwrap_or(false)
            }
            Err(_) => false, // 이미 연결이 끊겼다면
        };

        if pong_received {
            panic!("[TEST] Test Failed: Connection is still alive after client timeout (should be closed).");
        } else {
            info!("[TEST] Test Success: Connection is closed after client timeout (as expected).");
        }
    }

    #[actix_web::test]
    async fn test_heartbeat_ping_pong_once() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player_kind_str = PlayerKind::Player1.as_str();

        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 초기 연결 메시지 수신 (선택 사항이지만, 이전 테스트에서 확인했으므로 여기서도 확인)
        info!("[TEST] Waiting for initial connection message...");
        let initial_extractor = |message: ServerMessage| -> Uuid {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert!(!session_id.is_nil());
                    info!(
                        "Initial connection message received. Session ID: {}",
                        session_id
                    );
                    session_id
                }
                _ => panic!("Expected HeartbeatConnected message first"),
            }
        };
        let _session_id = ws.expect_message(initial_extractor).await;

        // 2. 서버로부터 Ping 메시지 기다리기
        info!("[TEST] Waiting for Ping message...");
        let ping_received = timeout(Duration::from_secs(HEARTBEAT_INTERVAL * 2), async {
            loop {
                match ws.stream.next().await {
                    Some(Ok(Message::Ping(ping_data))) => {
                        info!("[TEST] Ping received!");
                        return Some(ping_data);
                    }
                    Some(Ok(Message::Text(text))) => {
                        info!(
                            "[TEST] Received unexpected Text while waiting for Ping: {}",
                            text
                        );
                        continue;
                    }
                    Some(Ok(Message::Pong(_))) => {
                        info!("[TEST] Received Pong while waiting for Ping, ignoring.");
                        continue;
                    }
                    Some(Ok(_)) => continue,
                    Some(Err(e)) => panic!("WebSocket error while waiting for Ping: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly while waiting for Ping"),
                }
            }
        })
        .await;

        // 3. Ping 수신 및 Pong 전송 확인
        match ping_received {
            Ok(Some(ping_data)) => {
                // Ping을 받았으므로 Pong 전송
                info!("[TEST] Sending Pong response...");
                ws.send(Message::Pong(ping_data.clone()))
                    .await
                    .expect("Failed to send Pong");
                info!("[TEST] Pong sent.");

                // 잠시 대기하여 서버가 Pong을 처리하고 연결을 유지하는지 확인
                info!("[TEST] Waiting to see if connection is maintained...");
                sleep(Duration::from_secs(2)).await; // 짧은 시간 대기

                // 연결이 살아있는지 확인
                let test_msg = Message::Pong(ping_data);
                match ws.send(test_msg).await {
                    Ok(_) => info!("[TEST] Connection seems alive after Pong."),
                    Err(e) => panic!("Connection seems closed after Pong: {:?}", e),
                }
            }
            Ok(None) => {
                // 루프가 값을 반환하지 않고 종료된 경우
                panic!("Ping waiting loop exited unexpectedly without returning Ping data.");
            }
            Err(_) => {
                panic!(
                    "Timeout: Did not receive Ping within {} seconds.",
                    (HEARTBEAT_INTERVAL * 2)
                );
            }
        }

        // 테스트 종료 (정상적으로 연결 종료)
        info!("[TEST] Closing WebSocket connection.");
        ws.send(Message::Close(None)).await.ok(); // Close 메시지 전송 시도
    }
}
</file>

<file path="simulator_match_server/Cargo.toml">
[package]
name = "match_server"
version = "0.1.0"
edition = "2021"
description = "card backend"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</file>

<file path=".gitignore">
/target
</file>

<file path="simulator_core/Cargo.toml">
[package]
name = "simulator_core"
version = "0.1.0"
edition = "2021"
description = "card backend"
build = "build.rs"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[build-dependencies]

[[bench]]
name = "bench"
harness = false

[dependencies]
rand_core = "0.6"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.18.0"
base64 = "0.13.1"
byteorder = "1.5.0"
rayon = "1.8.0"
clap = {version="4.5.26", features = ["derive"]}
ctor = "0.4.1"

actix-web = "4.9.0"
actix = "=0.13.5"
actix-ws = "0.3.0"
async-tungstenite = {version="0.28.2", features = ["tokio-runtime"]}
reqwest = "0.12.12"

futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
argon2 = "0.5.3"
dotenv = "0.15.0"

gnuplot = "0.0.45"
criterion = "0.5.1"
url = "2.5.4"

tokio = { version = "1.15", features = ["full", "tracing"] }
tokio-console = "0.1.13"
console-subscriber = "0.4.1"

uuid = { version = "1.14.0", features = ["v4", "serde"] }
lazy_static = "1.5.0"
structopt = "=0.3.26"
rand = "0.8.5"
hex = "0.4.3"
parking_lot = "0.12.3"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
paste = "1.0.15"
cargo-llvm-cov = "0.6.16"

serial_test = "3.2.0"
</file>

<file path="simulator_core/src/effect/mod.rs">
pub mod effects;
pub mod types;
use std::any::Any;

use actix::Addr;
use types::{EffectInfo, EffectResult, EffectSpeed, EffectType};
use uuid::Uuid;

use crate::{
    card::{insert::Insert, take::Take, types::StatType, Card},
    exception::GameError,
    game::GameActor,
    selector::TargetSelector,
};

// 이 카드명의 "카드"는 1턴에 1장밖에 "발동"할 수 없다.
// 이 카드명의 "효과"는 1턴에 1장밖에 "사용"할 수 없다.
pub trait Effect: Send + Sync {
    /// 효과를 발동합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `Result<EffectResult, GameError>`
    /// # Errors
    /// * `GameError` - 효과 적용에 실패한 경우.
    fn begin_effect(&self, game: Addr<GameActor>, source: &Card)
        -> Result<EffectResult, GameError>;

    /// 효과를 발동할 수 있는지 확인합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `bool`
    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool;

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError>;

    fn get_effect_type(&self) -> EffectType;

    fn as_any(&self) -> &dyn Any;

    fn as_any_mut(&mut self) -> &mut dyn Any;

    fn get_id(&self) -> Uuid;

    fn get_speed(&self) -> EffectSpeed;
}

pub struct DigEffect {
    pub selector: Box<dyn TargetSelector>,
    pub insert: Box<dyn Insert>,
    pub take: Box<dyn Take>,
    pub info: EffectInfo,
}

impl DigEffect {
    pub fn new(
        selector: Box<dyn TargetSelector>,
        insert: Box<dyn Insert>,
        take: Box<dyn Take>,
        info: EffectInfo,
    ) -> Self {
        Self {
            selector,
            insert,
            take,
            info,
        }
    }

    pub fn get_selector(&self) -> &Box<dyn TargetSelector> {
        &self.selector
    }

    pub fn get_selector_mut(&mut self) -> &mut Box<dyn TargetSelector> {
        &mut self.selector
    }

    pub fn get_effect_type(&self) -> EffectType {
        EffectType::Dig
    }
}

impl Effect for DigEffect {
    /// dig 효과를 발동합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `Result<EffectResult, GameError>`
    /// # Errors
    /// * `GameError` - 효과 적용에 실패한 경우.
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        // // select_targets 으로 대상 카드를 가져옵니다.
        // let potential_targets = self.selector.select_targets(game, source)?;

        // if potential_targets.is_empty() {
        //     // 파낼 카드가 없으면 효과 종료 (또는 다른 처리)
        //     return Ok(EffectResult::Completed);
        // }

        // // Vec<Card> -> Vec<Uuid> 변환
        // let potential_targets_uuids = potential_targets
        //     .iter()
        //     .map(|card| card.get_uuid())
        //     .collect::<Vec<Uuid>>();

        // Ok(EffectResult::NeedsInput {
        //     inner: InputRequest::Dig {
        //         source_card: source.get_uuid(),
        //         source_effect_uuid: self.info.effect_id,
        //         potential_cards: potential_targets_uuids,
        //     },
        //     handler: HandlerType::General(Box::new(move |game, source, input| {
        //         Ok(EffectResult::Completed)
        //     })),
        // })
        todo!()
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        todo!()
    }

    fn get_effect_type(&self) -> EffectType {
        EffectType::Dig
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }

    fn get_id(&self) -> Uuid {
        self.info.effect_id
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}

pub struct DrawEffect {
    pub count: usize,
}

impl Effect for DrawEffect {
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        todo!()
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
        // game.get_player_by_type(source.get_owner())
        //     .get()
        //     .get_deck()
        //     .len()
        //     >= self.count
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        Ok(Box::new(Self { count: self.count }))
    }

    fn get_effect_type(&self) -> EffectType {
        todo!()
    }

    fn as_any(&self) -> &dyn Any {
        todo!()
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        todo!()
    }

    fn get_id(&self) -> Uuid {
        todo!()
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}

pub struct ModifyStatEffect {
    pub stat_type: StatType,
    pub amount: i32,
    pub target_selector: Box<dyn TargetSelector>,
}

impl Effect for ModifyStatEffect {
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        todo!()
        // let targets = self.target_selector.select_targets(game, source)?;
        // for mut target in targets {
        //     target.modify_stat(self.stat_type, self.amount)?;
        // }
        // Ok(())
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        self.target_selector.has_valid_targets(game, source)
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        Ok(Box::new(Self {
            stat_type: self.stat_type,
            amount: self.amount,
            target_selector: self.target_selector.clone_selector(),
        }))
    }

    fn get_effect_type(&self) -> EffectType {
        todo!()
    }

    fn as_any(&self) -> &dyn Any {
        todo!()
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        todo!()
    }

    fn get_id(&self) -> Uuid {
        todo!()
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}
</file>

<file path="simulator_core/src/effect/types.rs">
use uuid::Uuid;

use crate::enums::ZoneType;

pub struct EffectInfo {
    pub effect_id: Uuid,
    pub effect_type: EffectType,
    pub from_location: ZoneType,
    pub to_location: ZoneType,
}

impl EffectInfo {
    pub fn new(
        effect_id: Uuid,
        effect_type: EffectType,
        from_location: ZoneType,
        to_location: ZoneType,
    ) -> Self {
        Self {
            effect_id,
            effect_type,
            from_location,
            to_location,
        }
    }
}

pub enum EffectResult {
    // 효과가 완전히 실행됨
    Completed,
}

#[derive(PartialEq, Eq, PartialOrd, Clone, Copy)]
pub enum EffectSpeed {
    Quick = 3,  // 스피드 3
    Medium = 2, // 스피드 2
    Slow = 1,   // 스피드 1
}

impl EffectSpeed {
    pub fn is_faster_than(&self, other: EffectSpeed) -> bool {
        self > &other
    }
    pub fn is_slower_than(&self, other: EffectSpeed) -> bool {
        self < &other
    }
    pub fn is_equal_to(&self, other: EffectSpeed) -> bool {
        self == &other
    }
    pub fn can_it_chain(&self, other: EffectSpeed) -> bool {
        self.is_faster_than(other) || self.is_equal_to(other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EffectType {
    Dig,
    Draw,
    ModifyStat,
}

#[derive(Debug, Clone, Copy)]
pub enum EffectProcessPhase {
    ImmediatePhase, // 즉발 효과 처리 중
    ChainPhase,     // 체인 효과 처리 중
    InputWaiting,   // 사용자 입력 대기 중
}
</file>

<file path="simulator_core/src/game/choice.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{card::types::PlayerKind, enums::ZoneType, exception::GameError};

// ChoiceType 은 카드 선택의 종류를 나타냄
// 클라이언트 단으로 전달할 때, 게임 진행을 위한 정보가 여럿 포함되어 있는데.
// 이러한 정보들은 effect 로부터 얻어와야함.
// 대표적으로 DigEffect 의 경우, src, dest 정보가 필요함.
// src 의 경우 selector 에서 얻어오고
// dst 의 경우 insert 에서 얻어오면 될 듯?
// 근데 take, insert 는 카드를 어디서 가져오는지 정보를 가지고 있지 않음.
// 그러한 정보는 외부에서 저장되어있음.
// 그래서 Effect 자체에서 가지고 있는게 나을듯?
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChoiceType {
    Dig,          // 덱에서 카드 탐색
    Discard,      // 핸드에서 버릴 카드 선택
    SelectTarget, // 대상 선택 (유닛, 플레이어 등)
    Sacrifice,    // 희생할 카드 선택
    Rearrange,    // 카드 재배치/순서 변경
    RevealChoice, // 공개된 카드 중 선택
    MultiZone,    // 여러 영역에서 선택
}

impl ChoiceType {
    pub fn to_string(&self) -> String {
        match self {
            ChoiceType::Dig => "Dig".to_string(),
            ChoiceType::Discard => "Discard".to_string(),
            ChoiceType::SelectTarget => "SelectTarget".to_string(),
            ChoiceType::Sacrifice => "Sacrifice".to_string(),
            ChoiceType::Rearrange => "Rearrange".to_string(),
            ChoiceType::RevealChoice => "RevealChoice".to_string(),
            ChoiceType::MultiZone => "MultiZone".to_string(),
        }
    }
}

// 사용자
#[derive(Debug, Clone)]
pub struct ChoiceState {
    // 기본 정보
    player: PlayerKind,
    choice_type: ChoiceType,

    // 소스 및 대상 정보
    source_card_id: Option<Uuid>,   // 선택 효과를 발동한 카드
    source_effect_id: Option<Uuid>, // 선택을 요청한 효과

    // 선택 제한 설정
    min_selections: usize, // 최소 선택 개수
    max_selections: usize, // 최대 선택 개수
    destination: ZoneType, // 선택 후 카드 목적지

    // 상태 관리
    is_open: bool,      // 선택이 활성화되어 있는지
    is_mandatory: bool, // 필수 선택 여부 (취소 불가)

    is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
}

impl Default for ChoiceState {
    fn default() -> Self {
        Self {
            player: PlayerKind::Player1,
            choice_type: ChoiceType::Dig,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: true,
            is_mandatory: true,
            is_hidden_from_opponent: false,
        }
    }
}

impl ChoiceState {
    pub fn builder(player: PlayerKind, choice_type: ChoiceType) -> ChoiceStateBuilder {
        ChoiceStateBuilder::new(player, choice_type)
    }

    pub fn new(
        player: PlayerKind,
        choice_type: ChoiceType,
        source_card_id: Option<Uuid>,
        source_effect_id: Option<Uuid>,
        min_selections: usize,
        max_selections: usize,
        destination: ZoneType,
        is_open: bool,
        is_mandatory: bool,
        is_hidden_from_opponent: bool,
    ) -> Self {
        Self {
            player,
            choice_type,
            source_card_id,
            source_effect_id,
            min_selections,
            max_selections,
            destination,
            is_open,
            is_mandatory,
            is_hidden_from_opponent,
        }
    }

    pub fn serialize_message(&self) -> Result<String, GameError> {
        // ChoiceState의 정보를 ChoiceCardPayload로 변환
        // let message = game_features::ChoiceCardRequestPayload {
        //     player: self.player.to_string(), // PlayerType을 문자열로 변환
        //     choice_type: self.choice_type.to_string(), // ChoiceType을 문자열로 변환
        //     source_card_id: self.source_card_id.unwrap(),
        //     min_selections: self.min_selections,
        //     max_selections: self.max_selections,
        //     destination: self.destination.to_string(),
        //     is_open: self.is_open,
        //     is_hidden_from_opponent: self.is_hidden_from_opponent,
        // };

        // // JSON 문자열로 직렬화
        // serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
        todo!()
    }
}

pub struct ChoiceStateBuilder {
    player: PlayerKind,
    choice_type: ChoiceType,
    source_card_id: Option<Uuid>,
    source_effect_id: Option<Uuid>,
    min_selections: usize,
    max_selections: usize,
    destination: ZoneType,
    is_open: bool,
    is_mandatory: bool,
    is_hidden_from_opponent: bool,
}

impl ChoiceStateBuilder {
    pub fn new(player: PlayerKind, choice_type: ChoiceType) -> Self {
        Self {
            player,
            choice_type,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: false,
            is_mandatory: false,
            is_hidden_from_opponent: false,
        }
    }

    pub fn source_card(mut self, card_id: impl Into<Option<Uuid>>) -> Self {
        self.source_card_id = card_id.into();
        self
    }

    pub fn source_effect(mut self, effect_id: impl Into<Option<Uuid>>) -> Self {
        self.source_effect_id = effect_id.into();
        self
    }

    pub fn selections(mut self, min: usize, max: usize) -> Self {
        self.min_selections = min;
        self.max_selections = max;
        self
    }

    pub fn destination(mut self, destination: ZoneType) -> Self {
        self.destination = destination;
        self
    }

    pub fn open(mut self, is_open: bool) -> Self {
        self.is_open = is_open;
        self
    }

    pub fn mandatory(mut self, is_mandatory: bool) -> Self {
        self.is_mandatory = is_mandatory;
        self
    }

    pub fn hidden_from_opponent(mut self, is_hidden: bool) -> Self {
        self.is_hidden_from_opponent = is_hidden;
        self
    }

    pub fn build(self) -> ChoiceState {
        ChoiceState::new(
            self.player,
            self.choice_type,
            self.source_card_id,
            self.source_effect_id,
            self.min_selections,
            self.max_selections,
            self.destination,
            self.is_open,
            self.is_mandatory,
            self.is_hidden_from_opponent,
        )
    }
}
</file>

<file path="simulator_core/src/game/phase.rs">
use std::collections::HashMap;

use crate::{card::types::PlayerKind, exception::{GameError, StateError}};

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum PlayerPhaseProgress {
    NotStarted,         // 아직 해당 페이즈 시작 안 함
    Entered,            // 페이즈에 막 진입했거나 기본적인 작업 대기 중
    ActionTaken,        // 페이즈 내 주요 액션 수행 (예: 드로우 완료, 공격 선언 완료)
    WaitingForOpponent, // 자신의 액션은 끝났고 상대방 대기 중
    Completed,          // 해당 페이즈 완전히 종료 (양쪽 동의)
}

#[derive(Clone)]
pub struct PhaseState {
    current_phase: Phase,
    // 플레이어별 진행 상태 저장
    player_progress: HashMap<PlayerKind, PlayerPhaseProgress>,
}

impl PhaseState {
    pub fn new(phase: Phase) -> Self {
        let mut progress = HashMap::new();
        // 초기 상태는 NotStarted 또는 Entered
        progress.insert(PlayerKind::Player1, PlayerPhaseProgress::NotStarted);
        progress.insert(PlayerKind::Player2, PlayerPhaseProgress::NotStarted);
        Self {
            current_phase: phase,
            player_progress: progress,
        }
    }

    pub fn get_phase(&self) -> Phase {
        self.current_phase
    }

    pub fn set_phase(&mut self, phase: Phase) {
        self.current_phase = phase;
        // 페이즈 전환 시 플레이어 상태 초기화
        self.reset_progress();
    }

    // 플레이어 진행 상태 가져오기
    pub fn get_player_progress(&self, player: PlayerKind) -> PlayerPhaseProgress {
        self.player_progress
            .get(&player)
            .cloned()
            .unwrap_or(PlayerPhaseProgress::NotStarted)
    }

    // 플레이어 진행 상태 업데이트
    pub fn update_player_progress(&mut self, player: PlayerKind, progress: PlayerPhaseProgress) {
        println!("PhaseState Update: Player {:?} -> {:?}", player, progress); // 로그 추가
        self.player_progress.insert(player, progress);
    }

    // 페이즈 전환 시 상태 초기화
    pub fn reset_progress(&mut self) {
        for progress in self.player_progress.values_mut() {
            *progress = PlayerPhaseProgress::Entered; // 새 페이즈는 Entered 상태로 시작
        }
        println!(
            "PhaseState Reset: All players progress set to Entered for phase {:?}",
            self.current_phase
        );
    }

    // 특정 상태인 플레이어가 있는지 확인 (예: 둘 다 Completed 인지)
    pub fn both_players_in_progress(&self, progress: PlayerPhaseProgress) -> bool {
        self.player_progress.len() == 2 && self.player_progress.values().all(|p| *p == progress)
    }
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum PlayerActionStatus {
    NotYetActed,   // 아직 행동하지 않음
    ActedOrPassed, // 행동을 했거나 우선권을 넘김
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum MulliganStatus {
    NotStarted,                  // 시작 전
    DealingInitialHands,         // 초기 패 분배 중
    Player1Deciding(PlayerKind), // P1 멀리건 결정 대기 (현재 턴 플레이어 명시)
    Player2Deciding(PlayerKind), // P2 멀리건 결정 대기 (현재 턴 플레이어 명시)
    ApplyingMulligans,           // 멀리건 적용 중 (카드 교체 등)
    Completed,                   // 멀리건 완료
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum DrawPhaseStatus {
    TurnPlayerDraws, // 턴 플레이어가 드로우
    EffectsTrigger,  // 드로우 시 발동하는 효과 처리
    Completed,
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum StandbyPhaseStatus {
    EffectsTrigger, // 스탠바이 페이즈 시 발동하는 효과 처리
    Completed,
}

// 우선권 구현해야함.
// 우선권이란, 해당 턴에 어떤 플레이어가 먼저 행동할 수 있는지 권리를 나타내는 것.
// 턴 플레이어가 우선권을 가지며, 체인 발생 시 ( 효과 발동 ) / 우선권 포기 시 우선권이 이동함.
#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum MainPhaseStatus {
    OpenState, // 턴 플레이어가 자유롭게 행동 가능 (몬스터 소환, 마법/함정 발동/세트 등)
               // 체인 발생 시, 또는 우선권 이동 시 세부 상태가 더 필요할 수 있음
               // 예: WaitingForChainResponse, ResolvingChain
               // 유희왕은 메인 페이즈 1과 2가 동일한 행동을 할 수 있으므로,
               // MainPhaseStatus를 공유하고, Phase enum에서 MainPhase1, MainPhase2로 구분합니다.
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum BattlePhaseStep {
    StartStep(PlayerActionStatus), // 배틀 페이즈 개시 단계 (턴 플레이어 우선권)
    BattleStep(PlayerActionStatus), // 배틀 스텝 (몬스터 공격 선언 또는 종료)
    DamageStep(DamageStepSubPhase), // 데미지 스텝 (세부 단계로 진입)
    EndStep(PlayerActionStatus),   // 배틀 페이즈 종료 단계
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum DamageStepSubPhase {
    StartOfDamageStep,        // 데미지 스텝 개시시 (공격 대상이 앞면 표시가 됨 등)
    BeforeDamageCalculation,  // 데미지 계산 전 (공/수 증감 효과 발동)
    PerformDamageCalculation, // 데미지 계산 실행
    AfterDamageCalculation,   // 데미지 계산 후 (전투로 파괴된 몬스터 묘지로, 리버스 효과 발동 등)
    EndOfDamageStep,          // 데미지 스텝 종료시 (파괴 확정된 몬스터 묘지로 등)
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum EndPhaseStatus {
    EffectsTrigger, // 엔드 페이즈 시 발동하는 효과 처리
    TurnEnd,        // 실제 턴 종료
}

// --- 최종 Phase Enum ---
#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum Phase {
    Mulligan(MulliganStatus),

    DrawPhase(DrawPhaseStatus),       // DP: 턴 플레이어가 1장 드로우
    StandbyPhase(StandbyPhaseStatus), // SP: 특정 효과 발동
    MainPhase1(MainPhaseStatus), // MP1: 몬스터 소환/반전소환/특수소환, 마법/함정 발동/세트, 효과 발동, 표시 형식 변경

    BattlePhase(BattlePhaseStep), // BP: 전투 수행
    // BattlePhaseStep enum이 세부 스텝(Start, Battle, Damage, End)을 관리
    MainPhase2(MainPhaseStatus), // MP2: MP1과 동일한 행동 가능 (공격한 몬스터는 표시 형식 변경 불가 등 일부 제약)
    EndPhase(EndPhaseStatus),    // EP: 특정 효과 발동, 턴 종료
}

impl Phase {
    /// 다음 페이즈로 진행합니다.
    /// 현재 턴 플레이어 정보가 필요할 수 있습니다.
    pub fn next(self, current_turn_player: PlayerKind) -> Self {
        match self {
            Phase::Mulligan(status) => match status {
                MulliganStatus::Completed => Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws),
                _ => self, // 멀리건 내부 상태 진행은 별도 로직으로 처리
            },
            Phase::DrawPhase(status) => match status {
                DrawPhaseStatus::Completed => {
                    Phase::StandbyPhase(StandbyPhaseStatus::EffectsTrigger)
                }
                _ => self,
            },
            Phase::StandbyPhase(status) => match status {
                StandbyPhaseStatus::Completed => Phase::MainPhase1(MainPhaseStatus::OpenState),
                _ => self,
            },
            Phase::MainPhase1(_) => {
                Phase::BattlePhase(BattlePhaseStep::StartStep(PlayerActionStatus::NotYetActed))
            } // MP1에서 BP로 가는 것은 플레이어 선택
            Phase::BattlePhase(step) => match step {
                BattlePhaseStep::EndStep(PlayerActionStatus::ActedOrPassed) => {
                    Phase::MainPhase2(MainPhaseStatus::OpenState)
                }
                // 데미지 스텝의 각 하위 단계 진행은 BattlePhaseStep 내부 로직으로 처리
                _ => self,
            },
            Phase::MainPhase2(_) => Phase::EndPhase(EndPhaseStatus::EffectsTrigger), // MP2에서는 EP로 강제 진행
            Phase::EndPhase(status) => match status {
                EndPhaseStatus::TurnEnd => {
                    // 턴이 실제로 종료되면 다음 플레이어의 드로우 페이즈로 넘어감
                    // 이 때 current_turn_player가 변경되어야 함 (이 함수 외부에서 처리)
                    Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws)
                }
                _ => self,
            },
        }
    }

    // 메인 페이즈에서 엔드 페이즈로 바로 넘어갈 수 있는 경우 (플레이어가 배틀 페이즈 스킵 선택)
    pub fn skip_to_end_phase(self) -> Result<Self, GameError> {
        match self {
            Phase::MainPhase1(_) | Phase::MainPhase2(_) => {
                Ok(Phase::EndPhase(EndPhaseStatus::EffectsTrigger))
            }
            _ => Err(GameError::State(StateError::InvalidPhaseTransition)), // 다른 페이즈에서는 스킵 불가
        }
    }
}
</file>

<file path="simulator_core/src/game/state.rs">
use std::collections::HashMap;

use tracing::info;

use crate::{card::types::PlayerKind, game::phase::DrawPhaseStatus};

use super::phase::Phase;

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum GamePhase {
    Aborted,
    AlreadyCancelled,
    UnexpectedGamePhase,
    Initial, // 액터 생성 직후
    WaitingForPlayers,
    Mulligan,
    PlayerTurn(PlayerKind, Phase), // 현재 턴인 플레이어와 해당 턴의 세부 페이즈
    GameOver,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PlayerConnectionStatus {
    Disconnected,
    Connected,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PlayerMulliganStatus {
    NotStarted,
    CardsDealt,
    WaitingForDecision,
    Completed,
}

#[derive(Debug, Clone)]
pub struct PlayerState {
    connection_status: PlayerConnectionStatus,
    mulligan_status: PlayerMulliganStatus,
}

impl PlayerState {
    fn new() -> Self {
        PlayerState {
            connection_status: PlayerConnectionStatus::Disconnected,
            mulligan_status: PlayerMulliganStatus::NotStarted,
        }
    }
}

#[derive(Clone)] // 디버깅 등을 위해 필요할 수 있음
pub struct GameStateManager {
    current_phase: GamePhase,
    pub player_states: HashMap<PlayerKind, PlayerState>,
}

impl GameStateManager {
    pub fn new() -> Self {
        Self {
            current_phase: GamePhase::Initial, // 초기 상태
            player_states: HashMap::new(),     // 빈 HashMap으로 시작
        }
    }

    pub fn current_phase(&self) -> GamePhase {
        self.current_phase.clone()
    }

    pub fn count_connected_players(&self) -> usize {
        // player_states에 있는 플레이어 수가 곧 연결된 플레이어 수
        self.player_states.len()
    }

    pub fn is_player_connected_by_kind(&self, player_kind: PlayerKind) -> Option<()> {
        // player_states에 해당 플레이어가 있으면 연결된 것
        self.player_states.get(&player_kind).map(|_| ())
    }

    // 플레이어 연결 시 player_states에 추가
    pub fn add_connected_player(&mut self, player: PlayerKind) {
        let mut player_state = PlayerState::new();
        player_state.connection_status = PlayerConnectionStatus::Connected;
        self.player_states.insert(player, player_state);
        info!("Player {:?} added to game state as Connected", player);
        self.check_and_transition_phase_after_connection();
    }

    // 플레이어 연결 해제 시 player_states에서 제거
    pub fn remove_connected_player(&mut self, player: PlayerKind) -> bool {
        if let Some(_) = self.player_states.remove(&player) {
            info!("Player {:?} removed from game state", player);
            true
        } else {
            info!(
                "Player {:?} was not in game state, nothing to remove",
                player
            );
            false
        }
    }

    // 기존 메서드 유지 (하위 호환성)
    pub fn update_player_connection_status(&mut self, player: PlayerKind, connected: bool) {
        if connected {
            self.add_connected_player(player);
        } else {
            self.remove_connected_player(player);
        }
    }

    fn check_and_transition_phase_after_connection(&mut self) {
        // 두 플레이어가 모두 연결되었는지 확인 (HashMap에 Player1과 Player2가 모두 있는지)
        if self.current_phase == GamePhase::Initial && self.count_connected_players() == 2 {
            self.transition_to_phase_internal(GamePhase::Mulligan);
        }
    }

    pub fn is_all_players_connected(&self) -> bool {
        // 실제로 연결된 플레이어가 2명인지 확인
        self.count_connected_players() == 2
    }

    fn are_all_players_connected_internal(&self) -> bool {
        self.count_connected_players() == 2
    }

    // 상태 전이 로직
    pub fn transition_to_phase(&mut self, new_phase: GamePhase) {
        info!(
            "Game phase transitioning from {:?} to {:?}",
            self.current_phase, new_phase
        );
        self.current_phase = new_phase;
        // 새 페이즈에 따른 플레이어 상태 초기화 등 추가 로직
        match self.current_phase {
            GamePhase::Mulligan => {
                for state in self.player_states.values_mut() {
                    state.mulligan_status = PlayerMulliganStatus::NotStarted;
                }
            }
            // 다른 페이즈 전환 시 초기화 로직
            _ => {}
        }
    }

    // 내부용 (self를 &mut로 받지 않음)
    fn transition_to_phase_internal(&mut self, new_phase: GamePhase) {
        info!(
            "Game phase transitioning from {:?} to {:?}",
            self.current_phase, new_phase
        );
        self.current_phase = new_phase;
        match self.current_phase {
            GamePhase::Mulligan => {
                for state in self.player_states.values_mut() {
                    state.mulligan_status = PlayerMulliganStatus::NotStarted;
                }
            }
            _ => {}
        }
    }

    pub fn get_player_mulligan_status(&self, player: PlayerKind) -> Option<PlayerMulliganStatus> {
        self.player_states
            .get(&player)
            .map(|s| s.mulligan_status.clone())
    }

    pub fn update_player_mulligan_status(
        &mut self,
        player: PlayerKind,
        new_status: PlayerMulliganStatus,
    ) {
        if let Some(state) = self.player_states.get_mut(&player) {
            info!(
                "Player {:?} mulligan status updated from {:?} to {:?}",
                player, state.mulligan_status, new_status
            );
            state.mulligan_status = new_status.clone();

            // 두 플레이어 모두 멀리건 완료 시 다음 단계로 전환하는 로직 예시
            if new_status == PlayerMulliganStatus::Completed {
                if self.all_players_mulligan_completed() {
                    // 예시: Player1의 턴, DrawPhase로 전환
                    self.transition_to_phase(GamePhase::PlayerTurn(
                        PlayerKind::Player1,
                        Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws),
                    ));
                }
            }
        }
    }

    fn all_players_mulligan_completed(&self) -> bool {
        // 연결된 모든 플레이어의 멀리건이 완료되었는지 확인
        self.player_states.len() == 2
            && self
                .player_states
                .values()
                .all(|s| s.mulligan_status == PlayerMulliganStatus::Completed)
    }
}
</file>

<file path="simulator_dedicated_server/Cargo.toml">
[package]
name = "dedicated_server"
version = "0.1.0"
edition = "2021"
description = "card backend"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
simulator_core = { path = "../simulator_core" }
tokio = { version = "1.15", features = ["full", "tracing"] }
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
actix-web = "4.9.0"
actix = "=0.13.5"
actix-ws = "0.3.0"
async-tungstenite = {version="0.28.2", features = ["tokio-runtime"]}
reqwest = "0.12.12"
url = "2.5.4"
uuid = { version = "1.14.0", features = ["v4", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rand_core = "0.6"
rand = "0.8.5"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
ctor = "0.4.1"
</file>

<file path="simulator_core/src/card/types.rs">
use std::fmt::{self, Display};
use std::hash::{Hash, Hasher};

use actix::Addr;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    exception::{GameError, GameplayError}, game::GameActor, resource::CardSpecsResource, utils::json::CardJson,
};

use super::modifier::Modifier;

#[derive(Clone)]
pub struct CardSpecs {
    attack: CardSpecsResource,
    defense: CardSpecsResource,
    cost: i32,
}

impl CardSpecs {
    pub fn new(json: &CardJson) -> Self {
        Self {
            attack: CardSpecsResource::new(json.attack.unwrap()),
            defense: CardSpecsResource::new(json.health.unwrap()),
            cost: json.cost.unwrap(),
        }
    }
}

// CardStatus 구조체 (카드의 현재 상태)
#[derive(Clone, Default)]
pub struct CardStatus {
    is_negated: bool,
    is_disabled: bool,
    modifiers: Vec<Modifier>,
}

impl CardStatus {
    pub fn new() -> Self {
        Self {
            is_negated: false,
            is_disabled: false,
            modifiers: vec![],
        }
    }

    pub fn is_negated(&self) -> bool {
        self.is_negated
    }

    pub fn is_disabled(&self) -> bool {
        self.is_disabled
    }
}

#[derive(Clone, PartialEq, Eq, Copy)]
pub enum ModifierType {
    AttackBoost,
    DefenseBoost,
    CostChange,
    EffectNegation,
    AttributeChange,
}

#[derive(Clone, Copy)]
pub enum Duration {
    Permanent,
    UntilEndOfTurn,
    UntilEndOfPhase,
    ForXTurns(usize),
}

impl CardStatus {
    // 수정자 추가
    pub fn add_modifier(&mut self, modifier: Modifier) {
        self.modifiers.push(modifier);
    }

    // 수정자 제거
    pub fn remove_modifier(&mut self, index: usize) {
        self.modifiers.remove(index);
    }

    // 특정 타입의 수정자 모두 제거
    pub fn remove_modifiers_of_type(&mut self, modifier_type: ModifierType) {
        self.modifiers
            .retain(|m| m.get_modifier_type() != modifier_type);
    }

    // 만료된 수정자 제거
    pub fn cleanup_expired_modifiers(&mut self, game: Addr<GameActor>) {
        todo!()
        // self.modifiers.retain(|modifier| {
        //     !modifier.is_expired(game.get_turn().get_turn_count(), game.get_phase())
        // });
    }

    // 특정 타입의 수정자 총합 계산
    pub fn get_total_modifier(&self, modifier_type: ModifierType) -> i32 {
        self.modifiers
            .iter()
            .filter(|m| m.get_modifier_type() == modifier_type)
            .map(|m| m.get_value())
            .sum()
    }
}

#[derive(Debug, PartialEq, Clone, Eq, Copy, Hash)]
pub enum SpellType {
    SlowSpell,
    FastSpell,
}

#[derive(Eq, PartialEq, Hash, Clone, Copy)]
pub enum CardType {
    Dummy,
    Unit,
    Spell,
    Field,
    Ace,
    Trap,
    Game,
    Any,
}

impl CardType {
    pub fn from_json(json: &CardJson) -> Result<Self, GameError> {
        match &json.r#type {
            Some(type_str) => match type_str.as_str() {
                "Dummy" => Ok(CardType::Dummy),
                "Unit" => Ok(CardType::Unit),
                "Spell" => Ok(CardType::Spell),
                "Field" => Ok(CardType::Field),
                "Ace" => Ok(CardType::Ace),
                "Trap" => Ok(CardType::Trap),
                "Game" => Ok(CardType::Game),
                _ => Err(GameError::Gameplay(GameplayError::InvalidAction { reason: "Invalid card type".to_string() })),
            },
            None => Err(GameError::Gameplay(GameplayError::InvalidAction { reason: "Invalid card type".to_string() })),
        }
    }

    // 추가 유틸리티 메서드들
    pub fn to_string(&self) -> &'static str {
        match self {
            CardType::Dummy => "Dummy",
            CardType::Unit => "Unit",
            CardType::Spell => "Spell",
            CardType::Field => "Field",
            CardType::Ace => "Ace",
            CardType::Trap => "Trap",
            CardType::Game => "Game",
            CardType::Any => "Any",
        }
    }

    pub fn is_unit(&self) -> bool {
        matches!(self, CardType::Unit)
    }

    pub fn is_spell(&self) -> bool {
        matches!(self, CardType::Spell)
    }

    pub fn is_field(&self) -> bool {
        matches!(self, CardType::Field)
    }

    pub fn is_trap(&self) -> bool {
        matches!(self, CardType::Trap)
    }
    // 카드 타입별 특성 확인
    pub fn can_be_played_as_action(&self) -> bool {
        matches!(self, CardType::Spell | CardType::Trap)
    }

    pub fn stays_on_field(&self) -> bool {
        matches!(self, CardType::Unit | CardType::Field)
    }

    pub fn is_permanent(&self) -> bool {
        matches!(self, CardType::Field | CardType::Game)
    }

    // 카드 타입별 제한사항
    pub fn max_copies_allowed(&self) -> i32 {
        match self {
            CardType::Ace => 1,
            CardType::Game => 1,
            _ => 3,
        }
    }
}

impl fmt::Display for CardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            CardType::Dummy => "Dummy",
            CardType::Unit => "Unit",
            CardType::Spell => "Spell",
            CardType::Field => "Field",
            CardType::Ace => "Ace",
            CardType::Trap => "Trap",
            CardType::Game => "Game",
            CardType::Any => "Any",
        };
        write!(f, "{}", s)
    }
}

impl fmt::Debug for CardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Debug 구현 시 Display 구현을 재사용합니다.
        write!(f, "{}", self)
    }
}

#[derive(Copy, Clone)]
pub enum StatType {
    Attack,
    Defense,
}

///
/// 백엔드을 실행하는건 Host 역할을 부여 받은 플레이어쪽임.
/// 백엔드에서 Host 는 Player1 혹은 Self_ 로 취급되고
/// Client 는 Player2 혹은 Opponent 로 취급함.
///

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OwnerType {
    Self_,    // 자신 (현재 턴 플레이어)
    Opponent, // 상대방
    Any,      // 아무나 (자신 또는 상대)
    None,     // 소유자 없음
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PlayerKind {
    Player1,
    Player2,
}

impl Display for PlayerKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl PlayerKind {
    pub fn as_str(&self) -> &'static str {
        match self {
            PlayerKind::Player1 => "Player1",
            PlayerKind::Player2 => "Player2",
        }
    }

    pub fn to_string(&self) -> String {
        match self {
            PlayerKind::Player1 => "Player1".to_string(),
            PlayerKind::Player2 => "Player2".to_string(),
        }
    }

    pub fn reverse(&self) -> Self {
        match self {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }
}

impl From<String> for PlayerKind {
    fn from(s: String) -> Self {
        match s.as_str() {
            "Player1" => PlayerKind::Player1,
            "Player2" => PlayerKind::Player2,
            _ => panic!("Invalid PlayerKind string"),
        }
    }
}

impl From<PlayerKind> for String {
    fn from(player_kind: PlayerKind) -> Self {
        player_kind.to_string()
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct PlayerIdentity {
    pub id: Uuid,
    pub kind: PlayerKind,
}

impl Hash for PlayerIdentity {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        self.kind.hash(state);
    }
}
</file>

<file path="simulator_core/src/enums/mod.rs">
use std::fmt::Display;

use uuid::Uuid;

pub const CARD_ID_JSON_PATH: &str = "F:/work/simulator/simulator_core/Resource/cards_id.json";
pub const CARD_JSON_PATH: &str = "F:/work/simulator/simulator_core/Resource/cards.json";
pub const DECK_JSON_PATH_P1: &str = "F:/work/simulator/simulator_core/Datas/player1_test.json";
pub const DECK_JSON_PATH_P2: &str = "F:/work/simulator/simulator_core/Datas/player2_test.json";
pub const UUID_GENERATOR_PATH: &str = "F:/work/simulator/simulator_core/Resource/uuidgen";
pub const GAME_CONFIG_JSON_PATH: &str = "F:/work/simulator/simulator_core/Datas/config.json";

#[derive(Clone, Debug, PartialEq, Eq, Hash, Copy)]
pub enum ZoneType {
    Hand,
    Deck,
    Graveyard,
    Effect,
    Field,
    None,
}

impl ZoneType {
    pub fn to_string(&self) -> String {
        match self {
            ZoneType::Hand => "Hand".to_string(),
            ZoneType::Deck => "Deck".to_string(),
            ZoneType::Graveyard => "Graveyard".to_string(),
            ZoneType::Effect => "Effect".to_string(),
            ZoneType::Field => "Field".to_string(),
            ZoneType::None => "None".to_string(),
        }
    }
}

impl Display for ZoneType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_string())
    }
}

pub const MAX_CARD_SIZE: usize = 30;

pub type CardsUuid = Vec<Uuid>;

pub const COUNT_OF_CARDS: usize = 30;
pub const COUNT_OF_MULLIGAN_CARDS: usize = 5;
pub const PLAYER_1: usize = 0;
pub const PLAYER_2: usize = 1;

pub const UNIT_ZONE_SIZE: usize = 12;
pub const DECK_ZONE_SIZE: usize = 30;
pub const HAND_ZONE_SIZE: usize = 10;

pub const HEARTBEAT_INTERVAL: u64 = 5;
pub const CLIENT_TIMEOUT: u64 = 30; // 30초 동안 응답 없으면 연결 끊김
</file>

<file path="simulator_core/src/game/turn.rs">
use crate::card::types::PlayerKind;

use super::phase::{DrawPhaseStatus, MulliganStatus, Phase, PlayerActionStatus};

pub struct TurnState {
    pub current_turn_plyaer: PlayerKind,
    pub priority_holder: PlayerKind,
    pub turn_count: usize,
    pub current_phase: Phase,
    pub turn_player_action_status: PlayerActionStatus, // 턴 플레이어의 행동 상태
    pub non_turn_player_action_status: PlayerActionStatus,
}

impl TurnState {
    pub fn new(starting_player: PlayerKind) -> Self {
        // 초기 페이즈 (예: 멀리건 또는 드로우 페이즈) 설정
        let initial_phase = Phase::Mulligan(MulliganStatus::NotStarted); // 혹은 DrawPhase
        Self {
            current_turn_plyaer: starting_player,
            turn_count: 1, // 또는 0에서 시작
            current_phase: initial_phase,
            priority_holder: starting_player, // 턴 시작 시 턴 플레이어가 우선권을 가짐
            turn_player_action_status: PlayerActionStatus::NotYetActed,
            non_turn_player_action_status: PlayerActionStatus::NotYetActed,
        }
    }

    // 우선권 이전 로직
    pub fn pass_priority(&mut self) {
        // 현재 우선권 가진 플레이어의 상태를 ActedOrPassed로 변경
        if self.priority_holder == self.current_turn_plyaer {
            self.turn_player_action_status = PlayerActionStatus::ActedOrPassed;
        } else {
            self.non_turn_player_action_status = PlayerActionStatus::ActedOrPassed;
        }

        // 우선권을 상대방에게 넘김
        self.priority_holder = self.priority_holder.reverse();

        // 상대방의 행동 상태를 NotYetActed로 초기화 (새로 우선권을 받았으므로)
        if self.priority_holder == self.current_turn_plyaer {
            self.turn_player_action_status = PlayerActionStatus::NotYetActed;
        } else {
            self.non_turn_player_action_status = PlayerActionStatus::NotYetActed;
        }

        // 양쪽 모두 ActedOrPassed 상태면 페이즈/스텝 진행 로직 호출 가능
        if self.turn_player_action_status == PlayerActionStatus::ActedOrPassed
            && self.non_turn_player_action_status == PlayerActionStatus::ActedOrPassed
        {
            // 여기서 다음 페이즈/스텝으로 진행하거나,
            // 또는 이 함수를 호출한 곳에서 이 상태를 확인하고 진행 로직을 실행
            self.attempt_to_advance_phase_or_step();
        }
    }

    // 플레이어가 행동을 했을 때 호출 (예: 카드 발동)
    pub fn player_acted(&mut self, acting_player: PlayerKind) {
        todo!()
        // self.pass_priority();
    }

    // 페이즈/스텝 자동 진행 시도 (양쪽 플레이어가 모두 행동을 마쳤을 때)
    fn attempt_to_advance_phase_or_step(&mut self) {
        todo!()
    }

    // 다음 턴으로 넘어갈 때 호출
    pub fn advance_turn(&mut self) {
        self.current_turn_plyaer = self.current_turn_plyaer.reverse();
        self.turn_count += 1;
        self.current_phase = Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws);
        self.priority_holder = self.current_turn_plyaer;
        self.turn_player_action_status = PlayerActionStatus::NotYetActed;
        self.non_turn_player_action_status = PlayerActionStatus::NotYetActed;
    }
}

impl TurnState {
    pub fn get_turn_count(&self) -> usize {
        self.turn_count
    }

    pub fn increase_turn_count(&mut self) -> usize {
        self.turn_count += 1;
        self.turn_count
    }

    pub fn current_turn(&self) -> PlayerKind {
        self.current_turn_plyaer
    }

    pub fn change_turn(&mut self) -> PlayerKind {
        self.current_turn_plyaer = match self.current_turn_plyaer {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        };
        self.current_turn_plyaer
    }

    pub fn is_player_turn(&self) -> bool {
        self.current_turn_plyaer == PlayerKind::Player1
    }

    pub fn is_opponent_turn(&self) -> bool {
        self.current_turn_plyaer == PlayerKind::Player2
    }

    pub fn get_opponent_turn(&self) -> PlayerKind {
        match self.current_turn_plyaer {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }

    // 특정 플레이어의 턴으로 강제 설정
    pub fn set_turn(&mut self, player: PlayerKind) {
        self.current_turn_plyaer = player;
    }
}
</file>

<file path="simulator_core/src/lib.rs">
// #![allow(unused_variables, unused_labels, dead_code)]

use std::{collections::HashMap, future::Future, time::Duration};

use card::types::{PlayerIdentity, PlayerKind};
use exception::{GameError, SystemError};
use tracing::{debug, error, warn};
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use uuid::Uuid;

pub mod card;
pub mod card_gen;
pub mod effect;
pub mod enums;
pub mod exception;
pub mod game;
pub mod player;
pub mod resource;
pub mod selector;
pub mod utils;
pub mod zone;

extern crate lazy_static;

use std::sync::Once;
static INIT: Once = Once::new();
static mut GUARD: Option<tracing_appender::non_blocking::WorkerGuard> = None;
pub fn setup_logger() {
    INIT.call_once(|| {
        // 1. 파일 로거 설정
        let file_appender = RollingFileAppender::new(Rotation::DAILY, "logs", "app.log");
        let (non_blocking_file_writer, _guard) = tracing_appender::non_blocking(file_appender);

        // 2. 로그 레벨 필터 설정 (환경 변수 또는 기본값 INFO)
        let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")); // 기본 INFO 레벨

        // 3. 콘솔 출력 레이어 설정
        // let console_layer = fmt::layer()
        //     .with_writer(io::stdout) // 표준 출력으로 설정
        //     .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
        //     .with_thread_ids(true) // 스레드 ID 포함
        //     .with_thread_names(true) // 스레드 이름 포함
        //     .with_file(true) // 파일 경로 포함
        //     .with_line_number(true) // 라인 번호 포함
        //     .with_target(false) // target 정보 제외 (선택 사항)
        //     .pretty(); // 사람이 읽기 좋은 포맷

        // 4. 파일 출력 레이어 설정
        let file_layer = fmt::layer()
            .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
            .with_ansi(false) // 파일에는 ANSI 코드 제외
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .pretty();

        // 5. 레지스트리(Registry)에 필터와 레이어 결합
        tracing_subscriber::registry()
            .with(filter) // 필터를 먼저 적용
            // .with(console_layer) // 콘솔 레이어 추가
            .with(file_layer) // 파일 레이어 추가
            .init(); // 전역 Subscriber로 설정

        unsafe {
            GUARD = Some(_guard);
        }

        tracing::info!("로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.");
    });
}

pub trait StringUuidExt {
    fn to_uuid(&self) -> Result<Uuid, GameError>;
}

impl StringUuidExt for String {
    fn to_uuid(&self) -> Result<Uuid, GameError> {
        Uuid::parse_str(self).map_err(|_| GameError::System(SystemError::Internal("UUID parse failed".to_string())))
    }
}

pub trait VecUuidExt {
    fn to_vec_string(&self) -> Vec<String>;
}

impl VecUuidExt for Vec<Uuid> {
    fn to_vec_string(&self) -> Vec<String> {
        self.iter()
            .map(|uuid| uuid.to_string())
            .collect::<Vec<String>>()
    }
}

pub trait VecStringExt {
    fn to_vec_uuid(&self) -> Result<Vec<Uuid>, GameError>;
}

impl VecStringExt for Vec<String> {
    fn to_vec_uuid(&self) -> Result<Vec<Uuid>, GameError> {
        self.iter()
            .map(|uuid| Uuid::parse_str(uuid).map_err(|_| GameError::System(SystemError::Internal("UUID parse failed".to_string()))))
            .collect::<Result<Vec<Uuid>, GameError>>()
    }
}

pub trait LogExt<T, E> {
    fn log_ok(self, f: impl FnOnce()) -> Self;
    fn log_err(self, f: impl FnOnce(&E)) -> Self;
}

impl<T, E> LogExt<T, E> for Result<T, E> {
    fn log_ok(self, f: impl FnOnce()) -> Self {
        if self.is_ok() {
            f()
        }
        self
    }

    fn log_err(self, f: impl FnOnce(&E)) -> Self {
        if let Err(ref e) = self {
            f(e);
        }
        self
    }
}
pub trait PlayerHashMapExt<V> {
    fn get_by_uuid(&self, uuid_key: &Uuid) -> Option<&V>;
    fn get_by_kind(&self, kind_key: PlayerKind) -> Option<&V>;
}

impl<V> PlayerHashMapExt<V> for HashMap<PlayerIdentity, V> {
    fn get_by_uuid(&self, uuid_key: &Uuid) -> Option<&V> {
        self.iter()
            .find(|(player_identity_key, _value)| player_identity_key.id == *uuid_key)
            .map(|(_player_identity_key, value)| value)
    }

    fn get_by_kind(&self, kind_key: PlayerKind) -> Option<&V> {
        self.iter()
            .find(|(player_identity_key, _value)| player_identity_key.kind == kind_key)
            .map(|(_player_identity_key, value)| value)
    }
}

pub struct RetryConfig {
    pub max_attempts: usize,
    pub base_delay_ms: u64,
    pub backoff_multiplier: f64,
    pub max_delay_ms: u64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            base_delay_ms: 100,
            backoff_multiplier: 2.0,
            max_delay_ms: 5000,
        }
    }
}

pub async fn retry_with_condition<F, Fut, T, E>(
    operation: F,
    config: RetryConfig,
    should_retry: impl Fn(&E) -> bool,
    operation_name: &str,
) -> Result<T, E>
where
    F: Fn() -> Fut,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Debug,
{
    for attempt in 1..=config.max_attempts {
        match operation().await {
            Ok(result) => {
                if attempt > 1 {
                    debug!(
                        "{} succeeded on attempt {}/{}",
                        operation_name, attempt, config.max_attempts
                    );
                }
                return Ok(result);
            }
            Err(e) => {
                if !should_retry(&e) {
                    warn!(
                        "{} failed with non-retryable error: {:?}",
                        operation_name, e
                    );
                    return Err(e);
                }
                if attempt == config.max_attempts {
                    error!(
                        "{} failed after {} attempts. Final error: {:?}",
                        operation_name, config.max_attempts, e
                    );
                    return Err(e);
                }

                warn!(
                    "{} failed on attempt {}/{}. Error: {:?}. Retrying...",
                    operation_name, attempt, config.max_attempts, e
                );

                let delay_ms = (config.base_delay_ms as f64
                    * config.backoff_multiplier.powi(attempt as i32 - 1))
                .min(config.max_delay_ms as f64) as u64;

                tokio::time::sleep(Duration::from_millis(delay_ms)).await;
            }
        }
    }

    // 이 부분은 실제로 도달하지 않아야 함
    unreachable!()
}

pub async fn retry<F, Fut, T, E>(
    operation: F,
    config: RetryConfig,
    operation_name: &str,
) -> Result<T, E>
where
    F: Fn() -> Fut,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Debug,
{
    for attempt in 1..=config.max_attempts {
        match operation().await {
            Ok(result) => {
                if attempt > 1 {
                    debug!(
                        "{} succeeded on attempt {}/{}",
                        operation_name, attempt, config.max_attempts
                    );
                }
                return Ok(result);
            }
            Err(e) => {
                if attempt == config.max_attempts {
                    error!(
                        "{} failed after {} attempts. Final error: {:?}",
                        operation_name, config.max_attempts, e
                    );
                    return Err(e);
                }

                warn!(
                    "{} failed on attempt {}/{}. Error: {:?}. Retrying...",
                    operation_name, attempt, config.max_attempts, e
                );

                let delay_ms = (config.base_delay_ms as f64
                    * config.backoff_multiplier.powi(attempt as i32 - 1))
                .min(config.max_delay_ms as f64) as u64;

                tokio::time::sleep(Duration::from_millis(delay_ms)).await;
            }
        }
    }

    // 이 부분은 실제로 도달하지 않아야 함
    unreachable!()
}
</file>

<file path="simulator_core/src/player/mod.rs">
use actix::{Actor, Addr, Context};
use tracing::{debug, instrument};
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::TopTake, types::PlayerKind, Card},
    enums::ZoneType,
    exception::GameError,
    selector::{mulligan::MulliganState, TargetCount},
    utils::deckcode_to_cards_single,
    zone::{
        deck::Deck, effect::Effect, field::Field, graveyard::Graveyard, hand::Hand, zone::Zone,
    },
};

pub mod message;

pub struct Resoruce {}
impl Resoruce {
    pub fn new(a: usize, b: usize) -> Self {
        Self {}
    }
}

pub struct PlayerActor {
    opponent: Option<Addr<PlayerActor>>,
    player_type: PlayerKind,
    mulligan_state: MulliganState,
    cards: Cards,
    cost: Resoruce,
    mana: Resoruce,

    hand: Hand,
    deck: Deck,
    graveyard: Graveyard,
    effect: Effect,
    field: Field,
}

impl Actor for PlayerActor {
    type Context = Context<Self>;
}

impl PlayerActor {
    pub fn new(player_type: PlayerKind, deck_code: String) -> Self {
        let cards = deckcode_to_cards_single(deck_code).unwrap();
        Self {
            player_type,
            opponent: None,
            mulligan_state: MulliganState::new(),
            cards: cards.clone(),
            cost: Resoruce::new(0, 0),
            mana: Resoruce::new(0, 0),
            hand: Hand::new(),
            deck: Deck::new(cards),
            graveyard: Graveyard::new(),
            effect: Effect::new(),
            field: Field::new(),
        }
    }

    pub fn restore_cards(&mut self, card: &[Card], target_zone: ZoneType) -> Result<(), GameError> {
        match target_zone {
            ZoneType::Hand => todo!(),
            ZoneType::Deck => todo!(),
            ZoneType::Graveyard => todo!(),
            ZoneType::Effect => todo!(),
            ZoneType::Field => todo!(),
            ZoneType::None => todo!(),
        }
    }

    pub fn get_cards_by_uuids(&self, uuids: &[Uuid]) -> Result<Vec<Card>, GameError> {
        todo!()
    }

    #[instrument(skip(self), fields(player_type = ?player_type.into()))]
    pub fn get_new_mulligan_cards<T: Into<PlayerKind> + Copy>(
        &mut self,
        player_type: T,
        count: usize,
    ) -> Result<Vec<Uuid>, GameError> {
        let player_type = player_type.into();
        debug!(
            "멀리건 카드 뽑기 시도: player={:?}, count={}",
            player_type, count
        );

        let take_result = self
            .deck
            .take_card(Box::new(TopTake(TargetCount::Exact(count))))?;

        let uuids = take_result
            .iter()
            .map(|card| card.get_uuid())
            .collect::<Vec<_>>();

        debug!(
            "멀리건 카드 뽑기 완료: player={:?}, card_count={}",
            player_type,
            uuids.len()
        );

        Ok(uuids)
    }

    pub fn get_cards_mut(&mut self) -> &mut Cards {
        &mut self.cards
    }

    pub fn get_cards(&self) -> &Cards {
        &self.cards
    }
}

//         #[instrument(skip(self), fields(player_type = ?player_type.into()))]
//         pub fn add_select_cards<T: Into<PlayerType> + Copy>(
//             &mut self,
//             cards: Vec<Uuid>,
//             player_type: T,
//         ) {
//             let player_type = player_type.into();
//             debug!(
//                 "멀리건 상태에 카드 추가 시작: player={:?}, cards={:?}",
//                 player_type, cards
//             );

//             let mut player = self.get_player_by_type(player_type).get();

//             player
//                 .get_mulligan_state_mut()
//                 .add_select_cards(cards.clone());
//             debug!("멀리건 상태에 카드 추가 완료: player={:?}", player_type);
//         }

//         pub fn add_reroll_cards<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//             payload_cards: Vec<Uuid>,
//             rerolled_cards: Vec<Uuid>,
//         ) {
//             let player_type = player_type.into();
//             debug!("선택 카드 제거: player={:?}", player_type);
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .remove_select_cards(payload_cards);

//             debug!("리롤된 카드 추가: player={:?}", player_type);
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .add_select_cards(rerolled_cards);
//         }

//         pub fn reroll_request<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//             cards: Vec<Uuid>,
//         ) -> Result<Vec<Uuid>, GameError> {
//             let player_type = player_type.into();
//             // 플레이어가 이미 준비 상태인 경우
//             if self
//                 .get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .is_ready()
//             {
//                 warn!("플레이어가 이미 준비 상태: player={:?}", player_type);
//                 return Err(GameError::AlreadyReady);
//                 // try_send_error!(session, GameError::AlreadyReady, retry 3);
//             }

//             // 플레이어가 선택한 카드가 유효한지 확인합니다.
//             debug!("선택한 카드 유효성 검사: player={:?}", player_type);
//             if let Err(e) = self.get_cards_by_uuids(cards.clone()) {
//                 error!("유효하지 않은 카드 선택: player={:?}", player_type);
//                 return Err(e);
//             }

//             // 기존 카드를 덱의 최하단에 위치 시킨 뒤, 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장하고 json 으로 변환하여 전송합니다.
//             info!("카드 리롤 시작: player={:?}", player_type);
//             let rerolled_card = match self.restore_then_reroll_mulligan_cards(player_type, cards) {
//                 Ok(cards) => {
//                     debug!("카드 리롤 성공: card_count={}", cards.len());
//                     cards
//                 }
//                 Err(e) => {
//                     error!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
//                     panic!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
//                 }
//             };

//             Ok(rerolled_card)
//         }

//         /// 멀리건 완료 처리 함수
//         /// - 게임 객체를 받아서, 플레이어의 멀리건 상태를 완료로 변경하고, 선택한 카드들을 손으로 이동시킵니다.
//         /// - 선택한 카드들의 UUID를 반환합니다.
//         /// # Arguments
//         /// * `game` - 게임 객체
//         /// * `player_type` - 플레이어 타입
//         /// # Returns
//         /// * `Vec<Uuid>` - 선택한 카드들의 UUID

//         pub fn process_mulligan_completion<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//         ) -> Result<Vec<Uuid>, GameError> {
//             let player_type = player_type.into();

//             // 선택된 멀리건 카드들의 UUID 를 얻습니다.
//             let selected_cards = self
//                 .get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .get_select_cards();

//             // UUID -> Card 객체로 변환하는 과정입니다.
//             let cards = self.get_cards_by_uuids(selected_cards.clone())?;

//             // add_card 함수를 통해 선택된 카드들을 손으로 이동시킵니다.
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_hand_mut()
//                 .add_card(cards, Box::new(TopInsert))
//                 .map_err(|_| GameError::InternalServerError)?;

//             // 멀리건 상태를 "완료" 상태로 변경합니다.
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .confirm_selection();

//             // 그런 뒤, 선택한 카드들을 반환합니다.
//             Ok(selected_cards)
//         }

//         pub fn check_player_ready_state<T: Into<PlayerType> + Copy>(&self, player_type: T) -> bool {
//             let player_type = player_type.into();
//             self.get_player_by_type(player_type.reverse())
//                 .get()
//                 .get_mulligan_state_mut()
//                 .is_ready()
//         }
//     }
// }
</file>

<file path="simulator_core/src/utils/mod.rs">
pub mod json;

use crate::card::cards::Cards;
use crate::card::types::PlayerKind;
use crate::card_gen::{CardGenerator, Keys};
use crate::enums::*;
use crate::exception::{GameError, SystemError, GameplayError, DeckError};
use base64::{decode, encode};
use byteorder::WriteBytesExt;
use serde_json::Value;
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::io::{Cursor, Write};
use std::vec;
use tracing::warn;
use uuid::Uuid;

pub fn generate_uuid() -> Result<Uuid, GameError> {
    let uuid = Uuid::new_v4();
    Ok(uuid)
}

pub fn read_game_config_json() -> Result<json::GameConfigJson, GameError> {
    let file_path = GAME_CONFIG_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: json::GameConfigJson = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(e) => return Err(GameError::System(SystemError::Json(e))),
    };

    Ok(card_json)
}

pub fn parse_json_to_deck_code(
    p1_card_json: Option<Value>,
    p2_card_json: Option<Value>,
) -> Result<(String, String), GameError> {
    match (&p1_card_json, &p2_card_json) {
        (None, None) => return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::ParseFailed("Decode error".to_string())))),
        (None, Some(_)) => return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::CodeMissingFor(PlayerKind::Player1)))),
        (Some(_), None) => return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::CodeMissingFor(PlayerKind::Player2)))),
        _ => {}
    }

    fn parse_deck_json(
        json_value: Option<Value>,
        player_num: usize,
    ) -> Result<json::Decks, GameError> {
        if let Some(value) = json_value {
            serde_json::from_value(value).map_err(|e| GameError::System(SystemError::Json(e)))
        } else {
            let file_path = match player_num {
                PLAYER_1 => DECK_JSON_PATH_P1,
                PLAYER_2 => DECK_JSON_PATH_P2,
                _ => return Err(GameError::System(SystemError::Io(std::io::Error::new(std::io::ErrorKind::NotFound, "Path not found")))),
            };

            let mut file = File::open(file_path).map_err(|e| GameError::System(SystemError::Io(e)))?;
            let mut json_data = String::new();
            file.read_to_string(&mut json_data)
                .map_err(|e| GameError::System(SystemError::Io(e)))?;

            serde_json::from_str(&json_data).map_err(|e| GameError::System(SystemError::Json(e)))
        }
    }

    fn create_card_vector(decks: &json::Decks, keys: &Keys, num: i32) -> Vec<i32> {
        decks.decks[0]
            .cards
            .iter()
            .filter(|card| card.num == num)
            .filter_map(|card| keys.get_usize_by_string(&card.id))
            .collect()
    }

    fn generate_deck_code(
        player_num: usize,
        json_value: Option<Value>,
    ) -> Result<String, GameError> {
        let decks = parse_deck_json(json_value, player_num)?;
        let keys = Keys::new();

        // deckcode 에서 카드 1장 인 것과 2장 인 것을 따로 생성함.
        let card1 = create_card_vector(&decks, &keys, 1);
        let card2 = create_card_vector(&decks, &keys, 2);

        let dbf_hero = 930;
        let format = 2;

        Ok(deck_encode(card1, card2, dbf_hero, format))
    }

    // 두 플레이어의 덱 코드 생성
    let p1_code = generate_deck_code(PLAYER_1, p1_card_json)?;
    let p2_code = generate_deck_code(PLAYER_2, p2_card_json)?;

    Ok((p1_code, p2_code))
}

pub fn deckcode_to_cards_single(deckcode: String) -> Result<Cards, GameError> {
    // TODO: 거대한 카드 json 을 한 번에 읽어오는 것보다, 필요한 카드만 읽어오는 방법으로 개선해야함.
    //       (예: JSON 스트리밍 파서 사용 또는 데이터베이스 사용)
    let file_path = CARD_JSON_PATH;

    let mut file = File::open(file_path).map_err(|e| {
        warn!(
            "Failed to open card JSON file at {}: {}. Error: {}",
            file_path, CARD_JSON_PATH, e
        );
        GameError::System(SystemError::Io(e))
    })?;

    let mut json_data = String::new();
    file.read_to_string(&mut json_data).map_err(|e| {
        warn!(
            "Failed to read card JSON file: {}. Error: {}",
            CARD_JSON_PATH, e
        );
        GameError::System(SystemError::Io(e))
    })?;

    let all_cards_data: Vec<json::CardJson> = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(e) => {
            warn!(
                "Failed to parse card JSON data from {}. Error: {}",
                CARD_JSON_PATH, e
            );
            return Err(GameError::System(SystemError::Json(e)));
        }
    };

    let decoded_deck = match deck_decode(deckcode) {
        Ok(data) => data,
        Err(_) => {
            warn!("Failed to decode deck code.");
            return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::ParseFailed("Deck decode failed".to_string()))));
        }
    };

    let card_generator = CardGenerator::new();
    let mut deck_cards: Cards = Vec::with_capacity(MAX_CARD_SIZE);

    // all_cards_data를 dbfid 기준으로 HashMap으로 만들어 빠른 조회를 가능하게 합니다.
    let card_data_map: HashMap<i32, &json::CardJson> = all_cards_data
        .iter()
        .filter_map(|cd| cd.dbfid.map(|id| (id, cd)))
        .collect();

    // decoded_deck.0 (1장씩 있는 카드 ID 리스트) 처리
    for &dbfid in &decoded_deck.0 {
        if let Some(card_data) = card_data_map.get(&dbfid) {
            let card = card_generator.gen_card_by_id_i32(dbfid, card_data, 1);
            deck_cards.push(card);
        } else {
            warn!(
                "Card data not found for dbfid (1-copy): {}. This card will be skipped.",
                dbfid
            );
        }
    }

    // decoded_deck.1 (2장씩 있는 카드 ID 리스트) 처리
    for &dbfid in &decoded_deck.1 {
        if let Some(card_data) = card_data_map.get(&dbfid) {
            // `count`가 2이므로, `gen_card_by_id_i32`를 두 번 호출하여
            // 각각의 카드 인스턴스를 생성합니다.
            let card1 = card_generator.gen_card_by_id_i32(dbfid, card_data, 1); // 첫 번째 인스턴스
            deck_cards.push(card1);

            let card2 = card_generator.gen_card_by_id_i32(dbfid, card_data, 1); // 두 번째 인스턴스
            deck_cards.push(card2);
        } else {
            warn!(
                "Card data not found for dbfid (2-copy): {}. These cards will be skipped.",
                dbfid
            );
        }
    }

    Ok(deck_cards)
}

pub fn load_card_id() -> Result<Vec<(String, i32)>, GameError> {
    let file_path = CARD_ID_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: Vec<json::Item> = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(e) => return Err(GameError::System(SystemError::Json(e))),
    };

    let mut ids = vec![];

    for item in &card_json {
        ids.push((item.id.clone(), item.dbfid));
    }
    Ok(ids)
}

const DECK_CODE_VERSION: u32 = 1;
pub fn deck_decode(deck_code: String) -> Result<(Vec<i32>, Vec<i32>), ()> {
    let code = decode(deck_code).unwrap();
    let mut pos = 0;

    let read_varint = |pos: &mut usize| {
        let mut shift = 0;
        let mut result = 0;

        loop {
            if *pos >= code.len() {
                return Err(());
            }

            let ch = code[*pos] as usize;

            *pos += 1;

            result |= (ch & 0x7f) << shift;
            shift += 7;

            if (ch & 0x80) == 0 {
                break;
            }
        }
        return Ok(result);
    };

    if code[pos] as char != '\0' {
        println!("Invalid deck code");
        return Err(());
    }
    pos += 1;

    match read_varint(&mut pos) {
        Ok(version) => {
            if version as u32 != DECK_CODE_VERSION {
                println!("Version mismatch");
                return Err(());
            }
        }
        Err(_) => {
            println!("version err");
            return Err(());
        }
    }

    let format = read_varint(&mut pos);
    match format {
        Ok(_) => {}
        Err(_) => {
            println!("Invalid format type");
            return Err(());
        }
    }

    let num = read_varint(&mut pos);
    match num {
        Ok(data) => {
            if data != 1 {
                println!("Hero count must be 1");
                return Err(());
            }
        }
        Err(_) => return Err(()),
    }

    let hero_type = read_varint(&mut pos);
    let _hero_type = match hero_type {
        Ok(hero_id) => hero_id,
        Err(_) => {
            return Err(());
        }
    };

    //Deck deckInfo(format, hero->GetCardClass());
    let mut _1_cards = vec![];
    let mut _2_cards = vec![];

    // Single-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let card_id = read_varint(&mut pos).unwrap();
        _1_cards.push(card_id as i32);
    }

    // 2-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let card_id = read_varint(&mut pos).unwrap();
        _2_cards.push(card_id as i32);
        // deckInfo.AddCard(Cards::FindCardByDbfID(cardID)->id, 2);
    }

    // 하스스톤은 덱에서 같은 카드를 세 개 이상 구성하지 못함. ( 최대 2개 ) 근데 왜 n-copy 코드가 있는지는 잘 모르겠음..
    // n-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let _card_id = read_varint(&mut pos).unwrap();
        let _count = read_varint(&mut pos).unwrap();
        // deckInfo.AddCard(Cards::FindCardByDbfID(cardID)->id, count);
    }
    // println!("{:#?} {:#?}", _1_cards, _2_cards);
    Ok((_1_cards, _2_cards))
}

fn write_varint<W: Write>(writer: &mut W, mut value: usize) -> std::io::Result<()> {
    loop {
        let mut temp: u8 = (value & 0b01111111) as u8;
        value >>= 7;
        if value != 0 {
            temp |= 0b10000000;
        }
        writer.write_u8(temp)?;
        if value == 0 {
            break;
        }
    }
    Ok(())
}

fn deck_encode(deck1: Vec<i32>, deck2: Vec<i32>, dbf_hero: usize, format: usize) -> String {
    let mut baos = Cursor::new(Vec::new());

    write_varint(&mut baos, 0).unwrap(); // always zero
    write_varint(&mut baos, 1).unwrap(); // encoding version number
    write_varint(&mut baos, format).unwrap(); // standard = 2, wild = 1
    write_varint(&mut baos, 1).unwrap(); // number of heroes in heroes array, always 1
    write_varint(&mut baos, dbf_hero).unwrap(); // DBF ID of hero

    write_varint(&mut baos, deck1.len() as usize).unwrap(); // number of 1-quantity cards
    for dbf_id in &deck1 {
        write_varint(&mut baos, *dbf_id as usize).unwrap();
    }

    write_varint(&mut baos, deck2.len() as usize).unwrap(); // number of 2-quantity cards
    for dbf_id in &deck2 {
        write_varint(&mut baos, *dbf_id as usize).unwrap();
    }

    write_varint(&mut baos, 0).unwrap(); // the number of cards that have quantity greater than 2. Always 0 for constructed

    let deck_bytes = baos.into_inner();

    let deck_string = encode(&deck_bytes);

    deck_string
}
</file>

<file path="simulator_core/src/exception/mod.rs">
// In: simulator_core/src/exception/mod.rs

use crate::card::types::PlayerKind;
use actix::MailboxError;
use actix_web::{http::StatusCode, HttpResponse, ResponseError};
use std::fmt;
use uuid::Uuid;

// ===================================================================
// 1. 세분화된 에러 타입을 정의합니다.
// ===================================================================

/// 시스템 레벨의 에러 (네트워크, I/O, 내부 로직 등)
#[derive(Debug)]
pub enum SystemError {
    Io(std::io::Error),
    Json(serde_json::Error),
    Mailbox(MailboxError),
    LockFailed(String),
    TaskFailed(String),
    Internal(String), // 예기치 못한 내부 로직 에러
}

/// 게임 상태와 관련된 에러
#[derive(Debug, PartialEq, Clone)]
pub enum StateError {
    InvalidPhaseTransition,
    InvalidActionForPhase {
        current_phase: String,
        action: String,
    },
    GameAlreadyOver,
    GameAborted,
    PlayerNotReady(PlayerKind),
}

/// 클라이언트 연결 및 인증과 관련된 에러
#[derive(Debug, PartialEq, Clone)]
pub enum ConnectionError {
    AuthenticationFailed(String),
    SessionExists(Uuid), // 이미 세션이 존재하는 플레이어 ID
    InvalidPayload(String),
}

/// 게임 플레이 규칙과 관련된 에러
#[derive(Debug, PartialEq, Clone)]
pub enum GameplayError {
    ResourceNotFound {
        kind: &'static str,
        id: String,
    },
    DeckError(DeckError),
    InvalidTarget {
        reason: String,
    },
    InvalidAction {
        reason: String,
    },
    ChainError {
        reason: String,
    },
    NotEnoughResources {
        resource: &'static str,
        needed: i32,
        available: i32,
    },
}

/// 덱 구성 및 처리 관련 에러
#[derive(Debug, PartialEq, Clone)]
pub enum DeckError {
    ParseFailed(String),
    CodeMissingFor(PlayerKind),
    ExceededCardLimit(String),
    NoCardsLeftToDraw,
}

// ===================================================================
// 2. 최상위 GameError Enum을 새롭게 정의합니다.
// ===================================================================

#[derive(Debug)]
pub enum GameError {
    System(SystemError),
    Connection(ConnectionError),
    State(StateError),
    Gameplay(GameplayError),
}

// ===================================================================
// 3. Display 트레이트를 구현하여 명확한 로그 메시지를 생성합니다.
// ===================================================================

// 각 하위 에러 타입에 대한 Display 구현
impl fmt::Display for SystemError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SystemError::Io(e) => write!(f, "System I/O error: {}", e),
            SystemError::Json(e) => write!(f, "System JSON processing error: {}", e),
            SystemError::Mailbox(e) => write!(f, "Actor mailbox error: {}", e),
            SystemError::LockFailed(name) => write!(f, "Failed to acquire lock on '{}'", name),
            SystemError::TaskFailed(name) => write!(f, "Async task '{}' failed to complete", name),
            SystemError::Internal(msg) => write!(f, "Internal server error: {}", msg),
        }
    }
}

impl fmt::Display for StateError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            StateError::InvalidPhaseTransition => {
                write!(f, "Invalid game phase transition attempted")
            }
            StateError::InvalidActionForPhase {
                current_phase,
                action,
            } => write!(
                f,
                "Action '{}' is not allowed during phase '{}'",
                action, current_phase
            ),
            StateError::GameAlreadyOver => {
                write!(f, "Action attempted but the game is already over")
            }
            StateError::GameAborted => write!(f, "Action attempted but the game was aborted"),
            StateError::PlayerNotReady(pk) => {
                write!(f, "Player {:?} is not ready for the action", pk)
            }
        }
    }
}

impl fmt::Display for ConnectionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConnectionError::AuthenticationFailed(reason) => {
                write!(f, "Authentication failed: {}", reason)
            }
            ConnectionError::SessionExists(player_id) => write!(
                f,
                "An active session already exists for player {}",
                player_id
            ),
            ConnectionError::InvalidPayload(reason) => {
                write!(f, "Received invalid payload from client: {}", reason)
            }
        }
    }
}

impl fmt::Display for GameplayError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GameplayError::ResourceNotFound { kind, id } => {
                write!(f, "Resource not found: kind={}, id={}", kind, id)
            }
            GameplayError::DeckError(e) => write!(f, "Deck error: {}", e),
            GameplayError::InvalidTarget { reason } => write!(f, "Invalid target: {}", reason),
            GameplayError::InvalidAction { reason } => write!(f, "Invalid action: {}", reason),
            GameplayError::ChainError { reason } => write!(f, "Chain error: {}", reason),
            GameplayError::NotEnoughResources {
                resource,
                needed,
                available,
            } => write!(
                f,
                "Not enough {}: needed {}, available {}",
                resource, needed, available
            ),
        }
    }
}

impl fmt::Display for DeckError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DeckError::ParseFailed(s) => write!(f, "Failed to parse deck: {}", s),
            DeckError::CodeMissingFor(pk) => write!(f, "Deck code is missing for player {:?}", pk),
            DeckError::ExceededCardLimit(s) => write!(f, "Deck limit exceeded: {}", s),
            DeckError::NoCardsLeftToDraw => write!(f, "No cards left in the deck to draw"),
        }
    }
}

// 최상위 GameError에 대한 Display 구현
impl fmt::Display for GameError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GameError::System(e) => e.fmt(f),
            GameError::Connection(e) => e.fmt(f),
            GameError::State(e) => e.fmt(f),
            GameError::Gameplay(e) => e.fmt(f),
        }
    }
}

// ===================================================================
// 4. ResponseError를 구현하여 HTTP 응답으로 변환합니다.
// ===================================================================

impl ResponseError for GameError {
    fn status_code(&self) -> StatusCode {
        match self {
            // 시스템 에러는 모두 500번대
            GameError::System(_) => StatusCode::INTERNAL_SERVER_ERROR,
            // 상태 에러는 주로 동시성 문제나 순서 문제이므로 409 Conflict
            GameError::State(StateError::InvalidPhaseTransition) => StatusCode::CONFLICT,
            GameError::State(StateError::InvalidActionForPhase { .. }) => StatusCode::CONFLICT,
            GameError::State(_) => StatusCode::CONFLICT,
            // 연결 에러는 클라이언트의 잘못일 가능성이 높으므로 400번대
            GameError::Connection(ConnectionError::AuthenticationFailed(_)) => {
                StatusCode::UNAUTHORIZED
            }
            GameError::Connection(ConnectionError::SessionExists(_)) => StatusCode::CONFLICT,
            GameError::Connection(ConnectionError::InvalidPayload(_)) => StatusCode::BAD_REQUEST,
            // 게임플레이 에러는 규칙 위반이므로 400 Bad Request
            GameError::Gameplay(_) => StatusCode::BAD_REQUEST,
        }
    }

    fn error_response(&self) -> HttpResponse {
        let status = self.status_code();
        let error_message = self.to_string(); // Display 구현을 사용

        // 프로덕션에서는 내부 에러를 클라이언트에 노출하지 않는 것이 좋습니다.
        let client_message = if status.is_server_error() {
            "An internal server error occurred.".to_string()
        } else {
            error_message.clone()
        };

        // 서버 로그에는 상세한 에러를 남깁니다.
        tracing::error!("Request failed: {}", error_message);

        HttpResponse::build(status).json(serde_json::json!({ "error": client_message }))
    }
}

// ===================================================================
// 5. From 트레이트를 구현하여 에러 변환을 쉽게 합니다.
// ===================================================================

impl From<MailboxError> for GameError {
    fn from(e: MailboxError) -> Self {
        GameError::System(SystemError::Mailbox(e))
    }
}

impl From<serde_json::Error> for GameError {
    fn from(e: serde_json::Error) -> Self {
        GameError::System(SystemError::Json(e))
    }
}

impl From<std::io::Error> for GameError {
    fn from(e: std::io::Error) -> Self {
        GameError::System(SystemError::Io(e))
    }
}

// 기존에 정의된 GameError enum과 const 문자열들은 모두 삭제하시면 됩니다.
</file>

<file path="simulator_core/src/player/message.rs">
use crate::{
    card::{
        cards::CardVecExt,
        insert::Insert,
        take::{RandomTake, Take},
        Card,
    },
    enums::{ZoneType, COUNT_OF_MULLIGAN_CARDS},
    exception::{GameError, SystemError},
    selector::TargetCount,
    zone::zone::Zone,
};
use actix::{ActorContext, Addr, Context, Handler, Message};
use tracing::info;
use uuid::Uuid;

use super::PlayerActor;

#[derive(Message)]
#[rtype(result = "()")]
pub struct Terminate;

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct GameOver;

#[derive(Message)]
#[rtype(result = "Result<Vec<Uuid>, GameError>")]
pub struct RequestMulliganReroll {
    pub cards_to_restore: Vec<Uuid>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct SetOpponent {
    pub opponent: Addr<PlayerActor>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetCardsByUuid {
    pub uuid: Vec<Uuid>,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct AddCardsToDeck {
    pub cards: Vec<Card>,
    pub insert: Box<dyn Insert>,
}

#[derive(Message)]
#[rtype(result = "Result<Vec<Card>, GameError>")]
pub struct GetCardFromDeck {
    pub take: Box<dyn Take>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetDeckCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetHandCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetFieldCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetGraveyardCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetMulliganDealCards;

impl Handler<Terminate> for PlayerActor {
    type Result = ();

    fn handle(&mut self, _: Terminate, ctx: &mut Context<Self>) -> Self::Result {
        info!("PLAYER ACTOR [{:?}]: Handling Terminate", self.player_type);
        ctx.stop();
    }
}

impl Handler<GameOver> for PlayerActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, _: GameOver, ctx: &mut Context<Self>) -> Self::Result {
        info!("PLAYER ACTOR [{:?}]: Handling GameOver", self.player_type);

        // 필요시 리소스 해제

        ctx.stop();
        Ok(())
    }
}

impl Handler<GetMulliganDealCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetMulliganDealCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetMulliganDealCards",
            self.player_type
        );

        self.deck
            .take_card(Box::new(RandomTake(TargetCount::Exact(
                COUNT_OF_MULLIGAN_CARDS,
            ))))
            .unwrap()
            .into_iter()
            .map(|card| card.clone())
            .collect::<Vec<_>>()
    }
}

impl Handler<RequestMulliganReroll> for PlayerActor {
    type Result = Result<Vec<Uuid>, GameError>;

    fn handle(&mut self, msg: RequestMulliganReroll, ctx: &mut Context<Self>) -> Self::Result {
        println!(
            "PLAYER ACTOR [{:?}]: Handling RequestMulliganReroll",
            self.player_type
        );

        // 카드를 복원
        let cards_to_restore = self.get_cards_by_uuids(&msg.cards_to_restore)?;
        self.restore_cards(&cards_to_restore, ZoneType::Deck)?;

        // 복원 시킨 카드 갯수 만큼 카드를 뽑음.
        let new_cards = self.get_new_mulligan_cards(
            self.player_type,
            cards_to_restore.len(), // 뽑을 카드 갯수
        )?;

        // 뽑은 카드의 갯수를 확인
        if new_cards.len() != cards_to_restore.len() {
            return Err(GameError::System(SystemError::Internal("Card count mismatch after mulligan".to_string())));
        }

        // 뽑은 카드를 mulligan state 에 넣음.
        self.mulligan_state.add_select_cards(new_cards.clone());

        // 뽑은 카드 목록을 반환
        Ok(new_cards)
    }
}

impl Handler<SetOpponent> for PlayerActor {
    type Result = ();

    fn handle(&mut self, msg: SetOpponent, ctx: &mut Context<Self>) -> Self::Result {
        println!(
            "PLAYER ACTOR [{:?}]: Handling SetOpponent",
            self.player_type
        );

        // 상대방 플레이어를 설정
        self.opponent = Some(msg.opponent);
    }
}

impl Handler<GetCardsByUuid> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, msg: GetCardsByUuid, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetCardsByUuid",
            self.player_type
        );

        // UUID에 해당하는 카드 목록을 반환
        let mut result = vec![];
        for uuid in msg.uuid {
            if let Some(card) = self.get_cards().find_by_uuid(uuid) {
                result.push(card.clone());
            } else {
                return vec![]; // 카드가 없으면 빈 벡터 반환
            }
        }
        result
    }
}

impl Handler<AddCardsToDeck> for PlayerActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: AddCardsToDeck, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling AddCardsToDeck",
            self.player_type
        );

        self.deck.add_card(msg.cards, msg.insert)
    }
}

impl Handler<GetCardFromDeck> for PlayerActor {
    type Result = Result<Vec<Card>, GameError>;

    fn handle(&mut self, msg: GetCardFromDeck, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetCardFromDeck",
            self.player_type
        );

        // 덱에서 카드를 가져옴
        let cards = self.deck.take_card(msg.take)?;
        Ok(cards)
    }
}

impl Handler<GetDeckCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetDeckCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetDeckCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.deck.get_cards().clone()
    }
}

impl Handler<GetHandCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetHandCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetHandCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.hand.get_cards().clone()
    }
}

impl Handler<GetFieldCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetFieldCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetFieldCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.field.get_cards().clone()
    }
}

impl Handler<GetGraveyardCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetGraveyardCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetGraveyardCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.graveyard.get_cards().clone()
    }
}
</file>

<file path="simulator_core/src/game/mod.rs">
use std::{collections::HashMap, sync::Arc, time::Duration};

use actix::{
    fut, Actor, ActorFutureExt, Addr, AsyncContext, Context, Handler, Message, Recipient, ResponseFuture, Running, SpawnHandle
};
use futures::future::join_all;
use msg::GameEvent;
use state::GameStateManager;
use tokio::sync::Mutex;
use tracing::{error, info, warn};
use turn::TurnState;
use uuid::Uuid;

use crate::{
    card::{
        types::{PlayerIdentity, PlayerKind},
        Card,
    },
    exception::{GameError, SystemError},
    player::{
        message::{GameOver, SetOpponent, Terminate},
        PlayerActor,
    },
};

pub mod choice;
pub mod phase;
pub mod state;
pub mod turn;
pub mod msg;

pub struct GameConfig {}

pub struct GameActor {
    // 플레이어 액터들의 주소 저장 (PlayerActor 정의 필요)
    pub players: HashMap<PlayerIdentity, Addr<PlayerActor>>,
    pub connections: Arc<Mutex<HashMap<Uuid, Recipient<GameEvent>>>>, // 플레이어의 ConnectionActor 주소 저장
    pub player_connection_ready: HashMap<PlayerKind, bool>, // 각 플레이어 초기화 완료 여부
    pub opponent_wait_timer_handle: Option<SpawnHandle>,
    pub opponent_player_kind: Option<PlayerKind>,

    // 게임의 현재 페이즈와 턴
    pub turn: TurnState,

    pub all_cards: HashMap<PlayerKind, Vec<Card>>,
    pub game_state: Arc<Mutex<GameStateManager>>,
    pub is_game_over: bool,
    pub game_id: Uuid,

    // gsm lock 에 실패한 경우 등에 사용되는 플래그
    pub unexpected_stop: bool,
    pub cleanup_initiated: bool, 
}

impl Actor for GameActor {
    type Context = Context<Self>;

    fn stopping(&mut self, ctx: &mut Context<Self>) -> Running {
        if self.cleanup_initiated {
            info!(
                "GameActor [{}]: stopping() called again, but cleanup is already in progress. Ignoring.",
                self.game_id
            );
            // 이미 정리 작업이 진행 중이므로, 해당 작업이 끝날 때까지 액터를 살려둬야 합니다.
            return Running::Continue; 
        }
        // 정리 작업이 처음 시작됨을 표시합니다.
        self.cleanup_initiated = true;
        
        info!(
            "GameActor [{}] is stopping. Initiating comprehensive cleanup.",
            self.game_id
        );

        // 1. GameStateManager 정리
        let game_state = self.game_state.clone();
        let connections = self.connections.clone();
        let player_addrs: Vec<Addr<PlayerActor>> = self.players.values().cloned().collect();
        let game_id_clone = self.game_id;

        let cleanup_future = async move {
            info!(
                "GameActor [{}]: Starting comprehensive cleanup task.",
                game_id_clone
            );

            // 1. GameStateManager에서 모든 연결된 플레이어 제거
            {
                let mut gsm = game_state.lock().await;
                let connected_players: Vec<_> = gsm.player_states.keys().cloned().collect();
                for player_kind in connected_players {
                    gsm.remove_connected_player(player_kind);
                }
                info!(
                    "GameActor [{}]: All players removed from GameStateManager.",
                    game_id_clone
                );
            }

            // 2. 모든 연결 정리
            {
                let mut connections_guard = connections.lock().await;
                connections_guard.clear();
                info!(
                    "GameActor [{}]: All connections cleared.",
                    game_id_clone
                );
            }

            // 3. PlayerActor들에게 GameOver 전송
            let mut send_futures = Vec::new();
            for player_addr in player_addrs {
                info!(
                    "GameActor [{}]: Preparing to send GameOver to PlayerActor ({:?}).",
                    game_id_clone, player_addr
                );
                let fut = player_addr.send(GameOver);
                send_futures.push(async move { 
                    match fut.await {
                        Ok(_) => info!("GameActor [{}]: Successfully sent GameOver to PlayerActor ({:?})", game_id_clone, player_addr),
                        Err(e) => {
                            warn!(
                                "GameActor [{}]: Failed to send GameOver to PlayerActor ({:?}): {:?}. Attempting Terminate.",
                                game_id_clone, player_addr, e
                            );
                            player_addr.do_send(Terminate);
                        }
                    }
                });
            }

            join_all(send_futures).await;

            info!(
                "GameActor [{}]: Comprehensive cleanup task completed.",
                game_id_clone
            );
        };

        let stop_self_after_cleanup = fut::wrap_future(cleanup_future).then(
            move |_, act: &mut GameActor, _ctx_then: &mut Context<GameActor>| {
                info!(
                    "GameActor [{}]: All cleanup completed.",
                    act.game_id
                );
                fut::ready(())
            },
        );

        ctx.spawn(stop_self_after_cleanup);

        info!("GameActor [{}]: stopping() method finished, comprehensive cleanup scheduled.", self.game_id);
        Running::Continue
    }

    fn stopped(&mut self, ctx: &mut Self::Context) {
        info!("GameActor [{}] has stopped.", self.game_id);
    }
}

impl GameActor {
    /// 새로운 게임 세션을 위한 GameActor를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `game_id` - 이 게임 세션의 고유 ID.
    /// * `attacker_player_type` - 선공 플레이어의 타입.
    ///
    /// # Returns
    ///
    /// 새로운 GameActor 인스턴스.
    pub fn new(
        game_id: Uuid,
        player1_id: Uuid,
        player2_id: Uuid,
        player1_deck_code: String,
        player2_deck_code: String,
        attacker_player_type: PlayerKind,
    ) -> Self {
        let p1_identity = PlayerIdentity {
            id: player1_id,
            kind: PlayerKind::Player1,
        };
        let p2_identity = PlayerIdentity {
            id: player2_id,
            kind: PlayerKind::Player2,
        };

        let mut player_actors_map = HashMap::new();

        // PlayerActor 생성 및 맵에 추가
        let p1_addr =
            PlayerActor::create(|_ctx| PlayerActor::new(p1_identity.kind, player1_deck_code));
        let p2_addr =
            PlayerActor::create(|_ctx| PlayerActor::new(p2_identity.kind, player2_deck_code));
        player_actors_map.insert(p1_identity, p1_addr.clone());
        player_actors_map.insert(p2_identity, p2_addr.clone());

        actix::spawn(async move {
            while !p1_addr.connected() {
                tokio::time::sleep(Duration::from_millis(5)).await;
            }
            info!(
                "PlayerActor 1 connected ( not session connection! ), P1 can now receive messages."
            );

            while !p2_addr.connected() {
                tokio::time::sleep(Duration::from_millis(5)).await;
            }
            info!(
                "PlayerActor 2 connected ( not session connection! ), P2 can now receive messages."
            );

            info!("Both players actor connected. ( not session connection! ) Sending SetOpponent messages.");
            p1_addr.do_send(SetOpponent {
                opponent: p2_addr.clone(),
            });
            p2_addr.do_send(SetOpponent {
                opponent: p1_addr.clone(),
            });
        });

        GameActor {
            players: player_actors_map,
            connections: Arc::new(Mutex::new(HashMap::new())),
            player_connection_ready: HashMap::new(),
            all_cards: HashMap::new(),
            turn: TurnState::new(attacker_player_type),
            is_game_over: false,
            game_id,
            game_state: Arc::new(Mutex::new(GameStateManager::new())),
            opponent_wait_timer_handle: None,
            opponent_player_kind: None,
            unexpected_stop: false,
            cleanup_initiated: false,
        }
    }

    pub fn all_players_ready(&self) -> bool {
        self.player_connection_ready.len() == 2
            && self
                .player_connection_ready
                .get(&PlayerKind::Player1)
                .is_some()
            && self
                .player_connection_ready
                .get(&PlayerKind::Player2)
                .is_some()
    }

    fn get_player_info_by_kind(&self, target_kind: PlayerKind) -> Option<(Uuid, &PlayerIdentity)> {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return Some((identity.id, identity));
            }
        }
        None
    }

    fn get_player_identity_by_kind(&self, target_kind: PlayerKind) -> Option<&PlayerIdentity> {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return Some(identity);
            }
        }
        None
    }

    fn get_player_identity_by_uuid(&self, player_id: Uuid) -> Option<&PlayerIdentity> {
        for (identity, _) in &self.players {
            if identity.id == player_id {
                return Some(identity);
            }
        }
        None
    }

    /// PlayerKind를 기반으로 PlayerActor의 주소(Addr)를 가져옵니다.
    pub fn get_player_addr_by_kind(&self, target_kind: PlayerKind) -> Addr<PlayerActor> {
        for (identity, addr) in &self.players {
            if identity.kind == target_kind {
                return addr.clone();
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with kind {:?} not found", target_kind)
    }

    pub fn get_player_type_by_uuid(&self, player_id: Uuid) -> PlayerKind {
        for (identity, _) in &self.players {
            if identity.id == player_id {
                return identity.kind;
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with ID {} not found", player_id)
    }
    pub fn get_player_uuid_by_kind(&self, target_kind: PlayerKind) -> Uuid {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return identity.id;
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with kind {:?} not found", target_kind)
    }

    /// PlayerKind를 기반으로 ConnectionActor의 주소(Addr)를 가져옵니다.
    pub fn get_connection_addr_by_kind(
        &self,
        target_kind: PlayerKind,
    ) -> Option<Recipient<GameEvent>> {
        todo!()
    }

    /// PlayerKind를 기반으로 해당 PlayerActor에게 메시지를 보내고 결과를 기다립니다. (send 버전)
    ///
    /// # Arguments
    /// * `target_kind` - 메시지를 보낼 대상 플레이어의 PlayerKind.
    /// * `msg` - 보낼 메시지.
    ///
    /// # Returns
    /// * `ResponseFuture<Result<M::Result, GameActorError>>` -
    ///   비동기적으로 PlayerActor 핸들러의 결과 또는 에러를 반환합니다.
    ///   `GameActorError`는 플레이어를 찾지 못했거나 Mailbox 에러를 포함할 수 있습니다.
    pub fn send_to_player_actor<M>(
        &self,
        target_kind: PlayerKind,
        msg: M,
    ) -> ResponseFuture<Result<M::Result, GameError>>
    where
        M: Message + Send + 'static, // 메시지 제약 조건
        M::Result: Send,             // 결과 제약 조건
        PlayerActor: Handler<M>,     // PlayerActor가 이 메시지를 처리할 수 있어야 함
    {
        // 1. target_kind에 해당하는 PlayerActor의 주소(Addr)를 찾습니다.
        let addr = self.get_player_addr_by_kind(target_kind);
        // 2. 주소를 찾았으면, send 메서드를 호출하고 결과를 await합니다.
        //    send의 결과는 Result<M::Result, MailboxError> 입니다.
        //    이를 GameError로 매핑하여 반환합니다.

        let game_id = self.game_id;
        Box::pin(async move {
            info!(
                "GAME ACTOR [{}]: Sending message to PlayerActor ({:?}) and awaiting response.",
                // self.game_id, // self 직접 접근 불가, 필요시 game_id를 클론해서 전달
                game_id,
                target_kind
            );
            match addr.send(msg).await {
                Ok(handler_result) => {
                    // PlayerActor 핸들러가 반환한 M::Result
                    // 이 M::Result 자체가 Result<T, E>일 수 있음 (핸들러가 오류를 반환하는 경우)
                    // 여기서는 M::Result를 그대로 반환 (필요시 내부 Result 처리)
                    Ok(handler_result)
                }
                Err(mailbox_error) => {
                    error!(
                        "GAME ACTOR: Mailbox error sending message to PlayerActor ({:?}): {:?}",
                        target_kind, mailbox_error
                    );
                    Err(GameError::System(SystemError::Mailbox(mailbox_error)))
                }
            }
        })
    }

    /// PlayerKind를 기반으로 해당 PlayerActor에게 메시지를 보냅니다. (do_send 버전)
    pub fn do_send_to_player_actor<M>(&self, target_kind: PlayerKind, msg: M)
    where
        M: Message + Send + 'static,
        M::Result: Send,
        // PlayerActor: Handler<M>, // Handler 제약은 받는 쪽에서 필요, 보내는 쪽에서는 불필요
    {
        todo!()
    }

    /// PlayerKind를 기반으로 해당 ConnectionActor에게 메시지를 보냅니다. (do_send 버전)
    /// (GameEvent 등을 보낼 때 사용)
    pub fn send_to_connection<M>(&self, target_kind: PlayerKind, msg: M)
    where
        M: Message + Send + 'static,
        M::Result: Send,
        // ConnectionActor: Handler<M>, // 받는 쪽에서 필요
    {
        todo!()
    }

    /// 게임 내 모든 플레이어의 ConnectionActor에게 메시지를 브로드캐스트합니다.
    pub fn broadcast_to_connections<M>(&self, msg: M)
    where
        M: Message + Send + Clone + 'static, // Clone 필요
        M::Result: Send,
        // ConnectionActor: Handler<M>, // 받는 쪽에서 필요
    {
        todo!()
    }
}
</file>

<file path="Cargo.toml">
[workspace.package]
version = "0.1.0"
edition = "2021"
description = "card backend"

[workspace]
members = [
    "simulator_core",
    "simulator_dedicated_server",
    "simulator_match_server",
]

resolver = "2"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</file>

</files>
