This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.repomixignore
Cargo.toml
flow.md
jwt.md
repomix.config.json
simulator_auth_server/.sqlx/query-10c463dca64ab573b22438e02cd9e1fa5bc9cb27ad42219f806aa18107b5a98e.json
simulator_auth_server/Cargo.toml
simulator_auth_server/migrations/001_create_extensions_and_functions.sql
simulator_auth_server/migrations/002_create_enum_types.sql
simulator_auth_server/migrations/003_create_players_table.sql
simulator_auth_server/migrations/004_create_tiers_table.sql
simulator_auth_server/migrations/005_create_player_profiles_table.sql
simulator_auth_server/migrations/006_create_game_modes_table.sql
simulator_auth_server/migrations/007_create_match_history_table.sql
simulator_auth_server/migrations/008_create_match_participants_table.sql
simulator_auth_server/migrations/009_create_cards_table.sql
simulator_auth_server/migrations/010_create_player_card_collection_table.sql
simulator_auth_server/migrations/011_create_player_decks_table.sql
simulator_auth_server/migrations/012_create_deck_cards_table.sql
simulator_auth_server/migrations/init.sql
simulator_auth_server/reset_and_migrate.bat
simulator_auth_server/src/auth_server/db_operation.rs
simulator_auth_server/src/auth_server/end_point.rs
simulator_auth_server/src/auth_server/errors.rs
simulator_auth_server/src/auth_server/mod.rs
simulator_auth_server/src/auth_server/model.rs
simulator_auth_server/src/auth_server/types.rs
simulator_auth_server/src/lib.rs
simulator_auth_server/src/main.rs
simulator_auth_server/steam_appid.txt
simulator_auth_server/tests/test.rs
simulator_client/.gitignore
simulator_client/package.json
simulator_client/README.md
simulator_client/src-tauri/.gitignore
simulator_client/src-tauri/.taurignore
simulator_client/src-tauri/build.rs
simulator_client/src-tauri/capabilities/default.json
simulator_client/src-tauri/Cargo.toml
simulator_client/src-tauri/src/lib.rs
simulator_client/src-tauri/src/main.rs
simulator_client/src-tauri/steam_appid.txt
simulator_client/src-tauri/tauri.conf.json
simulator_client/src/app.css
simulator_client/src/app.html
simulator_client/src/routes/+layout.ts
simulator_client/src/routes/+page.svelte
simulator_client/static/svelte.svg
simulator_client/static/tauri.svg
simulator_client/static/vite.svg
simulator_client/svelte.config.js
simulator_client/tsconfig.json
simulator_client/vite.config.js
simulator_core/.cargo/config.toml
simulator_core/.claude/settings.local.json
simulator_core/.github/workflows/main.yml
simulator_core/.gitignore
simulator_core/benches/bench.rs
simulator_core/build.rs
simulator_core/Cargo.toml
simulator_core/Datas/config.json
simulator_core/Datas/game_behaivor.csv
simulator_core/Datas/mock.json
simulator_core/Datas/player1_test.json
simulator_core/Datas/player2_test.json
simulator_core/GameData/cards-json.txt
simulator_core/GameData/hero.txt
simulator_core/GameData/task.txt
simulator_core/GameData/turn-structure.txt
simulator_core/Resource/card_data
simulator_core/Resource/cards_id.json
simulator_core/Resource/cards.json
simulator_core/src/card_gen/builder.rs
simulator_core/src/card_gen/human.rs
simulator_core/src/card_gen/mod.rs
simulator_core/src/card_gen/monster.rs
simulator_core/src/card_gen/monster.rs.backup
simulator_core/src/card_gen/public.rs
simulator_core/src/card_gen/public.rs.backup
simulator_core/src/card/cards.rs
simulator_core/src/card/insert.rs
simulator_core/src/card/mod.rs
simulator_core/src/card/modifier.rs
simulator_core/src/card/take.rs
simulator_core/src/card/types.rs
simulator_core/src/effect/effects.rs
simulator_core/src/effect/effects.rs.backup
simulator_core/src/effect/mod.rs
simulator_core/src/effect/types.rs
simulator_core/src/enums/mod.rs
simulator_core/src/exception/mod.rs
simulator_core/src/game_old/chain copy.rs
simulator_core/src/game_old/chain.rs
simulator_core/src/game_old/choice.rs
simulator_core/src/game_old/game_step.rs
simulator_core/src/game_old/getter.rs
simulator_core/src/game_old/helper.rs
simulator_core/src/game_old/mod.rs
simulator_core/src/game_old/phase.rs
simulator_core/src/game_old/turn_manager.rs
simulator_core/src/game/choice.rs
simulator_core/src/game/mod.rs
simulator_core/src/game/msg/connection.rs
simulator_core/src/game/msg/error_message.rs
simulator_core/src/game/msg/gameplay.rs
simulator_core/src/game/msg/helper.rs
simulator_core/src/game/msg/lifecycle.rs
simulator_core/src/game/msg/mod.rs
simulator_core/src/game/msg/mulligan.rs
simulator_core/src/game/msg/system.rs
simulator_core/src/game/msg/zones.rs
simulator_core/src/game/phase.rs
simulator_core/src/game/state.rs
simulator_core/src/game/turn.rs
simulator_core/src/lib.rs
simulator_core/src/main.rs
simulator_core/src/player/message.rs
simulator_core/src/player/mod.rs
simulator_core/src/resource.rs
simulator_core/src/selector/automatic.rs
simulator_core/src/selector/complex.rs
simulator_core/src/selector/mod.rs
simulator_core/src/selector/mulligan.rs
simulator_core/src/selector/multi.rs
simulator_core/src/selector/single.rs
simulator_core/src/sync/messages.rs
simulator_core/src/sync/mod.rs
simulator_core/src/sync/snapshots.rs
simulator_core/src/sync/types.rs
simulator_core/src/utils/json.rs
simulator_core/src/utils/mod.rs
simulator_core/src/zone/deck.rs
simulator_core/src/zone/effect.rs
simulator_core/src/zone/field.rs
simulator_core/src/zone/graveyard.rs
simulator_core/src/zone/hand.rs
simulator_core/src/zone/mod.rs
simulator_core/src/zone/zone.rs
simulator_dedicated_server/.github/workflows/main.yml
simulator_dedicated_server/.gitignore
simulator_dedicated_server/Cargo.toml
simulator_dedicated_server/src/connection/connection.rs
simulator_dedicated_server/src/connection/messages.rs
simulator_dedicated_server/src/connection/mod.rs
simulator_dedicated_server/src/connection/types.rs
simulator_dedicated_server/src/enums.rs
simulator_dedicated_server/src/lib.rs
simulator_dedicated_server/src/main.rs
simulator_dedicated_server/src/room/mod.rs
simulator_dedicated_server/src/server/mod.rs
simulator_dedicated_server/src/test/mod.rs
simulator_dedicated_server/tests/test.rs
simulator_match_server/.github/workflows/main.yml
simulator_match_server/.gitignore
simulator_match_server/Cargo.toml
simulator_match_server/config/development.toml
simulator_match_server/config/production.toml
simulator_match_server/src/env.rs
simulator_match_server/src/lib.rs
simulator_match_server/src/main.rs
simulator_match_server/src/matchmaker/actor.rs
simulator_match_server/src/matchmaker/message.rs
simulator_match_server/src/matchmaker/mod.rs
simulator_match_server/src/util.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="simulator_client/src-tauri/.taurignore">
# Ignore other simulator projects
../simulator_auth_server/
../simulator_core/
../simulator_dedicated_server/
../simulator_match_server/
</file>

<file path="simulator_client/src-tauri/steam_appid.txt">
480
</file>

<file path="simulator_client/src/app.css">
@import "tailwindcss";
@plugin "daisyui";
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

# Python 관련 파일들
*.py
*.pyc
*.pyo
*.pyd
__pycache__/
*.egg-info/
.pytest_cache/
venv/
env/
.venv/
.env/
gemini_env/
.python-version
pip-log.txt
pip-delete-this-directory.txt

# Rust 빌드 캐시
target/
Cargo.lock
*.rs.bk

# 로그 파일들
*.log
logs/

# IDE 설정 파일들
.vscode/
.idea/

# 임시 파일들
*.tmp
*.temp
.DS_Store
Thumbs.db

# repomix 출력 파일들
repomix-*.xml
repomix-*.md
documentation_plan.json
clean_documentation_plan.json
</file>

<file path="flow.md">
### 최종 아키텍처 요약 (Steam 연동 카드 게임 서버)

#### 1. 주요 구성 요소 (서버 컴포넌트)

| 컴포넌트                              | 역할                                                                                                        | 주요 기술/패턴                                           |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- |
| **Auth Server (인증 서버)**           | - 스팀 인증 티켓 검증<br>- JWT(세션 토큰) 발급 및 갱신<br>- 신규 플레이어 DB 등록                           | Rust (Actix/Axum 등), Steamworks Web API, JWT 라이브러리 |
| **Matchmaking Server (매칭 서버)**    | - JWT로 플레이어 인가<br>- MMR 기반 플레이어 매칭<br>- 게임 서버 인스턴스 할당 및 접속 정보 전달            | Rust, **Redis (Sorted Set)**                             |
| **Game Dedicated Server (게임 서버)** | - 실제 게임 로직 처리 (1v1 카드 배틀)<br>- 게임 결과 처리 및 DB 기록 요청                                   | Rust                                                     |
| **PostgreSQL DB**                     | - **영구 데이터 저장소**<br>- 플레이어 정보, 프로필(MMR), 카드/덱 정보, 매치 기록 등 저장                   | PostgreSQL                                               |
| **Redis**                             | - **휘발성/상태 데이터 저장소**<br>- 매치메이킹 대기열(Queue) 관리<br>- (선택) 빠른 조회를 위한 데이터 캐싱 | Redis                                                    |
| **Load Balancer**                     | - Auth Server, Matchmaking Server 앞단에 위치<br>- 트래픽 분산 및 고가용성 확보                             | Nginx, AWS ELB, Cloudflare 등                            |

#### 2. 데이터베이스 스키마 (PostgreSQL)

- **`players`**: `SteamID64` (BIGINT, PK)를 키로 사용. 자체 인증 정보 없이 스팀 계정과 게임 데이터를 매핑.
- **`player_profiles`**: `player_id` (BIGINT, FK)를 통해 `players`와 연결. `MMR`, `레벨`, `경험치` 등 게임 고유의 성장 데이터만 저장.
- **`cards`, `player_card_collection`, `player_decks`, `deck_cards`**: 카드 및 덱 관련 정보 저장. `player_id`는 모두 `BIGINT` 타입.
- **`match_history`, `match_participants`**: 게임 결과 기록. `player_id`는 `BIGINT` 타입.

#### 3. 핵심 데이터 흐름 (End-to-End Flow)

**A. 최초 로그인 (인증 및 세션 생성)**

1.  **(Client)** 게임 실행 → 로컬 스팀 클라이언트로부터 **인증 티켓** 발급.
2.  **(Client → Auth Server)** `/login` API에 **인증 티켓**을 담아 요청.
3.  **(Auth Server ↔ Steam Auth Server)** 티켓 유효성 검증.
4.  **(Auth Server → DB)** 검증 성공 시, 신뢰할 수 있는 `SteamID64`로 DB(`players` 테이블) 조회 또는 신규 생성.
5.  **(Auth Server → Client)** 서버의 비밀 키로 서명된 **JWT(세션 토큰)** 발급하여 클라이언트에게 전달.

---

**B. 매치메이킹 시작**

1.  **(Client → Matchmaking Server)** `/queue/start` API 요청. `Authorization` 헤더에 **JWT** 포함.
2.  **(Matchmaking Server)**
    - JWT 서명 검증 (Auth Server와 동일한 비밀 키 사용).
    - 검증 성공 시, JWT에서 `SteamID64` 추출하여 사용자 식별.
3.  **(Matchmaking Server → DB/Redis Cache)** `SteamID64`를 키로 사용하여 `player_profiles`에서 **MMR** 등 매칭 정보 조회.
4.  **(Matchmaking Server → Redis)** 조회된 MMR과 `SteamID64`를 **Redis의 Sorted Set (대기열)**에 `ZADD` 명령어로 추가.

---

**C. 매칭 성공 및 게임 시작**

1.  **(Matchmaking Server)** Redis의 Sorted Set을 주기적으로 스캔하여 조건에 맞는 플레이어 탐색 (`ZRANGEBYSCORE`).
2.  **(Matchmaking Server)** 매칭 성사 시, Redis 대기열에서 해당 플레이어들 제거 (`ZREM`).
3.  **(Matchmaking Server)**
    - 사용 가능한 **Game Dedicated Server** 인스턴스 확보.
    - 해당 게임 세션 전용 **임시 접속 토큰** 생성.
4.  **(Matchmaking Server → Clients)** 매칭된 모든 클라이언트에게 **Game Dedicated Server의 IP/Port**와 **임시 접속 토큰**을 전송.
5.  **(Clients → Game Dedicated Server)** 전달받은 정보로 게임 서버에 접속 시도 (임시 토큰 포함).
6.  **(Game Dedicated Server)** 토큰을 검증하고 모든 플레이어 입장이 확인되면 게임 시작.

---

**D. 게임 종료 및 결과 처리**

1.  **(Game Dedicated Server)** 게임 종료 시, 최종 결과(승패, 스탯 등)를 집계.
2.  **(Game Dedicated Server → DB)** 집계된 데이터를 `match_history` 및 `match_participants` 테이블에 저장.
3.  **(Game Dedicated Server → DB)** Glicko-2 알고리즘 등으로 계산된 새로운 MMR, 랭크 포인트, 경험치 등을 `player_profiles` 테이블에 업데이트.
4.  **(Game Dedicated Server → Clients)** 클라이언트에게 결과 화면을 보여주기 위한 최종 데이터 전송 후, 연결 종료 및 인스턴스 반환.

---

### 아키텍처 다이어그램 (개념도)

```
[ Game Client ] <--(HTTPS/WSS)--> [ Load Balancer ]
      |                                    /         \
      |                            [ Auth Server ]  [ Matchmaking Server ]
      | (스팀 클라이언트 API)               |         /         \
      |                                    | (JWT Secret)  | (Redis)
[ Steam Client ] <-------------------- [ PostgreSQL DB ] -- [ Redis ]
      |
      | (인증)
      |
[ Steam Auth Server ]


[ Game Client ] <--(UDP/TCP)--> [ Game Dedicated Server ]
                                      |
                                      | (DB 쓰기)
                                      V
                                [ PostgreSQL DB ]
```
</file>

<file path="jwt.md">
네, 아주 좋은 질문입니다. JWT(JSON Web Token) 도입은 "로그인 성공" 이후의 상태 관리를 위한 완벽한 다음 단계입니다. 현재 시스템은 1회성 인증만 처리하므로, JWT를 통해 "인증된 세션"을 만들어 클라이언트가 후속 요청에서 자신을 증명할 수 있게 됩니다.

제가 단계별로 아주 자세하게 설명해 드릴게요.

### **JWT 도입의 핵심 개념: 새로운 인증 흐름**

현재:

1.  **클라이언트** -> **서버**: "이 스팀 티켓 좀 봐줘."
2.  **서버** -> **스팀**: "이 티켓 유효해?"
3.  **스팀** -> **서버**: "응, 유효하고 SteamID는 OOO야."
4.  **서버** -> **클라이언트**: "인증 성공했어."
5.  (끝. 다음 요청 시 클라이언트가 누군지 알 수 없음)

JWT 도입 후:

1.  **클라이언트** -> **서버**: "이 스팀 티켓 좀 봐줘."
2.  **서버** -> **스팀**: "이 티켓 유효해?"
3.  **스팀** -> **서버**: "응, 유효하고 SteamID는 OOO야."
4.  **서버**: (DB에 플레이어 정보 저장 후) **"이 플레이어를 위한 JWT를 발급해야겠다!"**
5.  **서버**: JWT 생성 (내용: `playerId: OOO`, `만료시간: 7일 뒤`) 및 비밀 키로 서명.
6.  **서버** -> **클라이언트**: "인증 성공했어. 앞으로 이걸 신분증처럼 써. **(JWT 전달)**"
7.  --- (이후 모든 요청) ---
8.  **클라이언트**: (예: 내 프로필 정보 요청) "내 프로필 정보 줘. 내 신분증은 이거야. (`Authorization: Bearer [JWT]` 헤더에 추가)"
9.  **서버**: 클라이언트가 보낸 JWT를 자신의 비밀 키로 검증.
10. **서버**: "음, 서명이 유효하고 만료되지 않았군. 요청한 사람은 SteamID가 OOO인 플레이어야. 프로필 정보를 찾아서 줘야겠다."

자, 이제 이걸 코드로 구현해 보겠습니다.

---

### **1단계: JWT 라이브러리 추가**

가장 널리 쓰이는 `jsonwebtoken` 라이브러리를 `Cargo.toml`에 추가합니다.

```toml
[dependencies]
# ... 기존 의존성들
jsonwebtoken = "9.3.0"
chrono = { version = "0.4.41", features = ["serde"] } # chrono는 이미 있지만 serde 기능이 필요합니다.
```

### **2단계: JWT 비밀 키 설정**

JWT는 서버만 아는 비밀 키로 서명되어야 합니다. 이 키가 유출되면 누구나 유효한 토큰을 만들 수 있으므로, **절대로 코드에 하드코딩하면 안 됩니다.** `.env` 파일을 사용합시다.

1.  **.env 파일에 비밀 키 추가:**

    ```dotenv
    # .env
    DATABASE_URL=...
    STEAM_WEB_API_KEY=...
    EXPECTED_IDENTITY=...

    # 새로 추가
    JWT_SECRET="your-super-secret-and-long-key-that-no-one-can-guess"
    ```

    (실제로는 더 복잡하고 긴 문자열을 사용하세요.)

2.  **AppState에 JWT 비밀 키 추가:**
    `main.rs`에서 비밀 키를 로드하고, `AppState`를 수정하여 키를 저장합니다.

    `src/auth_server/types.rs`:

    ```rust
    // src/auth_server/types.rs

    #[derive(Clone)]
    pub struct AppState {
        pub http_client: reqwest::Client,
        pub db_pool: PgPool,
        pub steam_web_api_key: String,
        pub app_id: u32,
        pub expected_identity: String,
        pub jwt_secret: String, // 새로 추가
    }
    // ...
    ```

    `src/main.rs`:

    ```rust
    // src/main.rs
    async fn main() -> std::io::Result<()> {
        // ...
        let steam_web_api_key =
            std::env::var("STEAM_WEB_API_KEY").expect("STEAM_WEB_API_KEY must be set in .env file");

        // 새로 추가
        let jwt_secret = std::env::var("JWT_SECRET").expect("JWT_SECRET must be set in .env file");

        // ...
        let app_state = AppState {
            http_client: reqwest::Client::new(),
            db_pool,
            steam_web_api_key: steam_web_api_key.clone(),
            app_id: 480,
            expected_identity: std::env::var("EXPECTED_IDENTITY")
                .expect("EXPECTED_IDENTITY must be set in .env file"),
            jwt_secret, // 새로 추가
        };
        // ...
    }
    ```

### **3단계: JWT 페이로드(Claims) 정의**

토큰에 어떤 정보를 담을지 정의합니다. 필수 정보는 **누구인지(`sub`)**와 **언제까지 유효한지(`exp`)** 입니다.

`src/auth_server/types.rs` 에 추가하세요.

```rust
// src/auth_server/types.rs
use serde::{Deserialize, Serialize};

// ... AppState ...

// JWT Claims 구조체 (토큰의 내용)
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String, // Subject (여기서는 Player's SteamID)
    pub exp: usize,  // Expiration time (timestamp)
    pub iat: usize,  // Issued at (timestamp)
}
// ...
```

### **4단계: 로그인 핸들러에서 JWT 생성 및 반환 (핵심!)**

이제 "로그인 성공 후 뭘 해야할지"에 대한 직접적인 답변입니다. `steam_authentication_handler`에서 인증이 성공하고 DB 작업이 끝나면, JWT를 생성해서 클라이언트에게 돌려줍니다.

`src/auth_server/end_point.rs`를 수정합니다.

```rust
use actix_web::{web, HttpResponse};
use serde::{Deserialize, Serialize};
use jsonwebtoken::{encode, Header, EncodingKey};
use chrono::{Utc, Duration};

use crate::auth_server::{
    db_operation,
    errors::AuthError,
    types::{AppState, SteamApiResponse, Claims}, // Claims 추가
};

// ... SteamAuthRequest ...

#[derive(Deserialize, Serialize)]
struct AuthSuccessResponse {
    message: String,
    steam_id: String,
    token: String, // 새로 추가: JWT 토큰
}

// ...

#[actix_web::post("/steam")]
pub async fn steam_authentication_handler(
    state: web::Data<AppState>,
    req_body: web::Json<SteamAuthRequest>,
) -> Result<HttpResponse, AuthError> {
    // ... 기존 스팀 인증 로직 ...

    if let Some(params) = steam_response.response.params {
        if params.result == "OK" {
            let steam_id_u64 = params.steamid.parse::<u64>().map_err(|_| {
                AuthError::InternalServerError(anyhow::anyhow!("Steam returned invalid SteamID"))
            })?;

            tracing::info!(
                "Steam Web API authentication successful for SteamID: {}",
                steam_id_u64
            );

            // =========================================================
            // <<<<< 여기가 바로 JWT를 생성할 지점입니다! >>>>>
            // 1. (주석 해제) DB에 플레이어 정보 저장/업데이트
            let temp_username = format!("user_{}", steam_id_u64); // 실제로는 스팀에서 닉네임을 가져와야 함
            db_operation::upsert_player_on_login(
                &state.db_pool,
                steam_id_u64 as i64,
                &temp_username,
            )
            .await?;

            // 2. JWT Claims 생성
            let now = Utc::now();
            let iat = now.timestamp() as usize;
            let exp = (now + Duration::days(7)).timestamp() as usize; // 7일 유효기간
            let claims = Claims {
                sub: steam_id_u64.to_string(),
                iat,
                exp,
            };

            // 3. JWT 토큰 생성
            let token = encode(
                &Header::default(),
                &claims,
                &EncodingKey::from_secret(state.jwt_secret.as_ref()),
            )
            .map_err(|e| AuthError::InternalServerError(anyhow::anyhow!(e)))?;

            // 4. 성공 응답에 토큰 포함하여 반환
            Ok(HttpResponse::Ok().json(AuthSuccessResponse {
                message: "Steam Web API authentication successful.".to_string(),
                steam_id: steam_id_u64.to_string(),
                token, // 생성된 토큰을 응답에 포함
            }))
            // =========================================================

        } else {
            // ... 기존 에러 처리 ...
            Err(AuthError::Unauthorized(format!(
                "Steam validation failed with result: {}",
                params.result
            )))
        }
    } else if let Some(error) = steam_response.response.error {
        // ... 기존 에러 처리 ...
        Err(AuthError::Unauthorized(format!(
            "Steam API Error {}: {}",
            error.errorcode, error.errordesc
        )))
    } else {
        // ... 기존 에러 처리 ...
        Err(AuthError::InternalServerError(anyhow::anyhow!(
            "Invalid response structure from Steam API"
        )))
    }
}
```

이제 로그인에 성공한 클라이언트는 `token` 필드에 담긴 JWT를 받게 됩니다.

### **5단계: 보호된 엔드포인트와 JWT 검증 미들웨어**

이제 JWT를 사용하는 방법을 만들어야 합니다. "내 프로필 정보 가져오기"와 같이 **로그인한 사용자만 접근할 수 있는 엔드포인트**를 보호해야 합니다.

가장 깔끔한 방법은 Actix-web의 `Extractor`를 만드는 것입니다. 요청이 핸들러에 도달하기 전에 헤더에서 JWT를 꺼내 검증하는 역할을 합니다.

1.  **새로운 파일 `src/auth_server/middleware.rs` 생성:**

    ```rust
    // src/auth_server/middleware.rs

    use actix_web::{dev::Payload, FromRequest, HttpRequest, web};
    use jsonwebtoken::{decode, Validation, DecodingKey};
    use std::future::{ready, Ready};

    use crate::auth_server::{
        errors::AuthError,
        types::{AppState, Claims},
    };

    pub struct AuthenticatedUser {
        pub id: i64, // 파싱된 플레이어 ID
    }

    impl FromRequest for AuthenticatedUser {
        type Error = AuthError;
        type Future = Ready<Result<Self, Self::Error>>;

        fn from_request(req: &HttpRequest, _: &mut Payload) -> Self::Future {
            let state = req.app_data::<web::Data<AppState>>().unwrap();

            // 1. Authorization 헤더에서 토큰 추출
            let auth_header = match req.headers().get("Authorization") {
                Some(h) => h.to_str().unwrap_or(""),
                None => return ready(Err(AuthError::Unauthorized("Missing Authorization header".to_string()))),
            };

            if !auth_header.starts_with("Bearer ") {
                return ready(Err(AuthError::Unauthorized("Invalid token format".to_string())));
            }

            let token = &auth_header[7..];

            // 2. 토큰 디코딩 및 검증
            let claims = match decode::<Claims>(
                token,
                &DecodingKey::from_secret(state.jwt_secret.as_ref()),
                &Validation::default(),
            ) {
                Ok(c) => c.claims,
                Err(e) => {
                    let reason = format!("Token validation failed: {}", e);
                    return ready(Err(AuthError::Unauthorized(reason)));
                }
            };

            // 3. Claims에서 사용자 ID 파싱
            let user_id = match claims.sub.parse::<i64>() {
                Ok(id) => id,
                Err(_) => return ready(Err(AuthError::Unauthorized("Invalid user ID in token".to_string()))),
            };

            // 4. 성공 시 AuthenticatedUser 반환
            ready(Ok(AuthenticatedUser { id: user_id }))
        }
    }
    ```

2.  **`src/auth_server/mod.rs` 에 `middleware` 모듈 추가:**

    ```rust
    pub mod db_operation;
    pub mod end_point;
    pub mod errors;
    pub mod model;
    pub mod types;
    pub mod middleware; // 새로 추가
    ```

3.  **보호된 엔드포인트에서 Extractor 사용하기:**
    예시로 "내 프로필 정보"를 가져오는 엔드포인트를 만들어 보겠습니다.

    `src/auth_server/end_point.rs`에 추가:

    ```rust
    // ... 다른 use 구문들
    use crate::auth_server::middleware::AuthenticatedUser; // Extractor 임포트

    // ... 다른 핸들러들 ...

    #[actix_web::get("/me")]
    pub async fn get_my_profile(
        state: web::Data<AppState>,
        auth_user: AuthenticatedUser, // <<-- 여기! 이 인자 하나로 JWT 검증이 끝납니다.
    ) -> Result<HttpResponse, AuthError> {
        // 이 핸들러가 실행되었다는 것은 이미 JWT가 유효하다는 뜻입니다.
        // auth_user.id 에는 인증된 사용자의 SteamID가 들어있습니다.
        let player_id = auth_user.id;

        let profile = db_operation::get_player_profile(&state.db_pool, player_id)
            .await?
            .ok_or_else(|| AuthError::BadRequest(format!("Profile not found for player {}", player_id)))?;

        Ok(HttpResponse::Ok().json(profile))
    }
    ```

4.  **`main.rs`에 새 엔드포인트 등록:**
    ```rust
    // src/main.rs
    use simulator_auth_server::auth_server::{
        end_point::{steam_authentication_handler, get_my_profile}, // get_my_profile 추가
        types::AppState,
    };
    // ...
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .service(
                web::scope("/auth") // `/auth` 경로 그룹화
                    .service(steam_authentication_handler)
                    .service(get_my_profile) // 새로운 엔드포인트 등록
            )
    })
    // ...
    ```

### **정리**

이제 당신의 서버는 완벽한 JWT 기반 인증 흐름을 갖추게 되었습니다.

1.  클라이언트는 `POST /auth/steam`으로 로그인하고 JWT를 받습니다.
2.  클라이언트는 받은 JWT를 안전한 곳(예: 로컬 저장소)에 저장합니다.
3.  이후 `/auth/me`와 같은 보호된 API를 호출할 때마다, HTTP 요청의 `Authorization` 헤더에 `Bearer [JWT]` 형식으로 토큰을 담아 보냅니다.
4.  서버는 `AuthenticatedUser` Extractor를 통해 자동으로 토큰을 검증하고, 유효한 경우에만 핸들러 로직을 실행합니다.

이제 다른 API 엔드포인트(예: 덱 생성, 카드 목록 조회 등)를 만들 때 핸들러 인자에 `auth_user: AuthenticatedUser`만 추가하면 손쉽게 인증을 적용할 수 있습니다.
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="simulator_auth_server/.sqlx/query-10c463dca64ab573b22438e02cd9e1fa5bc9cb27ad42219f806aa18107b5a98e.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT id, username, hashed_password, email, email_verified_at, status, created_at, updated_at, last_login_at FROM players WHERE username = $1",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Uuid"
      },
      {
        "ordinal": 1,
        "name": "username",
        "type_info": "Varchar"
      },
      {
        "ordinal": 2,
        "name": "hashed_password",
        "type_info": "Text"
      },
      {
        "ordinal": 3,
        "name": "email",
        "type_info": "Varchar"
      },
      {
        "ordinal": 4,
        "name": "email_verified_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 5,
        "name": "status",
        "type_info": "Varchar"
      },
      {
        "ordinal": 6,
        "name": "created_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 7,
        "name": "updated_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 8,
        "name": "last_login_at",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": [
        "Text"
      ]
    },
    "nullable": [
      false,
      false,
      false,
      true,
      true,
      false,
      false,
      false,
      true
    ]
  },
  "hash": "10c463dca64ab573b22438e02cd9e1fa5bc9cb27ad42219f806aa18107b5a98e"
}
</file>

<file path="simulator_auth_server/Cargo.toml">
[package]
name = "simulator_auth_server"
version.workspace = true
edition.workspace = true
description.workspace = true

[dependencies]
sqlx = { version = "0.8", features = [ "runtime-tokio", "postgres", "tls-rustls-ring-native-roots", "uuid", "chrono", "json" ] }
# sqlx-cli = {version = "0.8.6", features = ["native-tls", "postgres"] } 
actix-web = "4.9.0"
ctor = "0.4.1"
actix-http = "3.11.0"
actix = "=0.13.5"
hex = "0.4.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.140"
tokio = { version = "1.15", features = ["full", "tracing"] }
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
dotenvy = "0.15.7"
uuid = { version = "1.14.0", features = ["v4", "serde"] }
reqwest = { version = "0.12.12", features = ["json"] }
anyhow = "1.0.98"
chrono = { version = "0.4.41", features = ["serde"] }
steamworks = "0.12.0"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
once_cell = "1.21.3"
crossbeam-utils = "0.8.21"

[env]
url = "postgres://postgres:root@localhost:5432/auth"
</file>

<file path="simulator_auth_server/migrations/001_create_extensions_and_functions.sql">
-- 데이터베이스에 uuid-ossp 확장 기능 활성화 (여전히 다른 테이블에서 UUID를 사용할 수 있으므로 유지)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- updated_at 컬럼 자동 갱신을 위한 트리거 함수
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';
</file>

<file path="simulator_auth_server/migrations/002_create_enum_types.sql">
-- Custom ENUM types
DO $$ BEGIN
    CREATE TYPE player_status AS ENUM ('active', 'suspended', 'banned');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE card_rarity AS ENUM ('common', 'rare', 'epic', 'legendary');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;
</file>

<file path="simulator_auth_server/migrations/003_create_players_table.sql">
-- Players table for Steam Player Account Mapping
CREATE TABLE IF NOT EXISTS players (
    id BIGINT PRIMARY KEY, -- SteamID64 as primary key
    last_known_username VARCHAR(64), -- Steam nickname snapshot
    status player_status NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);
COMMENT ON TABLE players IS 'Core table linking Steam player accounts with game data';
COMMENT ON COLUMN players.id IS 'Unique player ID (SteamID64)';
COMMENT ON COLUMN players.last_known_username IS 'Last known player Steam nickname';
COMMENT ON COLUMN players.status IS 'Account status (ENUM: active, suspended, banned)';
CREATE TRIGGER trigger_players_updated_at
BEFORE UPDATE ON players
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
</file>

<file path="simulator_auth_server/migrations/004_create_tiers_table.sql">
-- Tiers master data table
CREATE TABLE IF NOT EXISTS tiers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    order_key INT UNIQUE NOT NULL,
    icon_url TEXT
);
COMMENT ON TABLE tiers IS 'Game tier/rank definition master table';
-- Insert sample tier data
INSERT INTO tiers (id, name, order_key, icon_url) VALUES
(1, 'Bronze', 1, '/icons/tiers/bronze.png'),
(2, 'Silver', 2, '/icons/tiers/silver.png'),
(3, 'Gold', 3, '/icons/tiers/gold.png'),
(4, 'Platinum', 4, '/icons/tiers/platinum.png'),
(5, 'Diamond', 5, '/icons/tiers/diamond.png')
ON CONFLICT (id) DO NOTHING;
</file>

<file path="simulator_auth_server/migrations/005_create_player_profiles_table.sql">
-- Player profiles table for game-specific profile and stats
CREATE TABLE IF NOT EXISTS player_profiles (
    player_id BIGINT PRIMARY KEY REFERENCES players(id) ON DELETE CASCADE,
    mmr DOUBLE PRECISION NOT NULL DEFAULT 1500.0,
    rd DOUBLE PRECISION NOT NULL DEFAULT 350.0,
    volatility DOUBLE PRECISION NOT NULL DEFAULT 0.06,
    last_rating_update_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    tier_id INT NOT NULL REFERENCES tiers(id),
    rank_points INT NOT NULL DEFAULT 0,
    experience_points BIGINT NOT NULL DEFAULT 0,
    level INT NOT NULL DEFAULT 1,
    -- Game-specific profile customization items
    -- custom_profile_icon_id VARCHAR(100),
    -- custom_profile_banner_id VARCHAR(100),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE player_profiles IS 'In-game player profiles, rank, and stats information';
COMMENT ON COLUMN player_profiles.player_id IS 'Player SteamID64';
CREATE INDEX IF NOT EXISTS idx_player_profiles_mmr ON player_profiles(mmr);
CREATE TRIGGER trigger_player_profiles_updated_at
BEFORE UPDATE ON player_profiles
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
</file>

<file path="simulator_auth_server/migrations/006_create_game_modes_table.sql">
-- Game modes master data table
CREATE TABLE IF NOT EXISTS game_modes (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_ranked BOOLEAN NOT NULL DEFAULT FALSE,
    player_count_per_team INT NOT NULL DEFAULT 1,
    team_count INT NOT NULL DEFAULT 2,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE game_modes IS 'Game mode definition master table';
INSERT INTO game_modes (id, internal_name, display_name, is_ranked, player_count_per_team, team_count) VALUES
(1, 'ranked_1v1', '1v1 Ranked Game', TRUE, 1, 2),
(2, 'unranked_1v1', '1v1 Casual Game', FALSE, 1, 2)
ON CONFLICT (id) DO NOTHING;
</file>

<file path="simulator_auth_server/migrations/007_create_match_history_table.sql">
-- Match history table for completed games
CREATE TABLE IF NOT EXISTS match_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    game_mode_id INT NOT NULL REFERENCES game_modes(id),
    started_at TIMESTAMPTZ NOT NULL,
    ended_at TIMESTAMPTZ NOT NULL,
    duration_seconds INT GENERATED ALWAYS AS (EXTRACT(EPOCH FROM (ended_at - started_at))::INT) STORED,
    winning_team_id INT,
    additional_data JSONB
);
COMMENT ON TABLE match_history IS 'Records of all completed games';
CREATE INDEX IF NOT EXISTS idx_match_history_started_at ON match_history(started_at DESC);
</file>

<file path="simulator_auth_server/migrations/008_create_match_participants_table.sql">
-- Match participants table for player performance in matches
CREATE TABLE IF NOT EXISTS match_participants (
    match_id UUID NOT NULL REFERENCES match_history(id) ON DELETE CASCADE,
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE SET NULL,
    team_id INT NOT NULL,
    is_winner BOOLEAN NOT NULL,
    initial_mmr DOUBLE PRECISION NOT NULL,
    final_mmr DOUBLE PRECISION NOT NULL,
    mmr_change DOUBLE PRECISION GENERATED ALWAYS AS (final_mmr - initial_mmr) STORED,
    score INT,
    stats JSONB,
    disconnected BOOLEAN NOT NULL DEFAULT FALSE,
    PRIMARY KEY (match_id, player_id)
);
COMMENT ON TABLE match_participants IS 'Match participant and performance information';
CREATE INDEX IF NOT EXISTS idx_match_participants_player_id ON match_participants(player_id);
</file>

<file path="simulator_auth_server/migrations/009_create_cards_table.sql">
-- Cards master data table
CREATE TABLE IF NOT EXISTS cards (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    rarity card_rarity,
    mana_cost INT NOT NULL DEFAULT 0,
    attack INT,
    health INT,
    card_type VARCHAR(50),
    image_url TEXT,
    attributes JSONB,
    is_collectible BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE cards IS 'Master table for all card information in the game';
-- Insert sample card data
INSERT INTO cards (id, internal_name, display_name, rarity, mana_cost, attack, health, card_type, is_collectible) VALUES
(1, 'fireball', 'Fireball', 'common', 4, 6, 0, 'spell', TRUE),
(2, 'frost_golem', 'Frost Golem', 'rare', 5, 4, 5, 'minion', TRUE)
ON CONFLICT (id) DO NOTHING;
</file>

<file path="simulator_auth_server/migrations/010_create_player_card_collection_table.sql">
-- Player card collection table
CREATE TABLE IF NOT EXISTS player_card_collection (
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
    is_new BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (player_id, card_id)
);
COMMENT ON TABLE player_card_collection IS 'List of cards owned by players';
</file>

<file path="simulator_auth_server/migrations/011_create_player_decks_table.sql">
-- Player decks table
CREATE TABLE IF NOT EXISTS player_decks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    deck_name VARCHAR(100) NOT NULL,
    cover_card_id INT REFERENCES cards(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (player_id, deck_name)
);
COMMENT ON TABLE player_decks IS 'List of decks created by players';
CREATE TRIGGER trigger_player_decks_updated_at
BEFORE UPDATE ON player_decks
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
</file>

<file path="simulator_auth_server/migrations/012_create_deck_cards_table.sql">
-- Deck cards table for deck composition
CREATE TABLE IF NOT EXISTS deck_cards (
    deck_id UUID NOT NULL REFERENCES player_decks(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL CHECK (quantity > 0 AND quantity <= 2),
    PRIMARY KEY (deck_id, card_id)
);
COMMENT ON TABLE deck_cards IS 'Information about cards included in each deck';
</file>

<file path="simulator_auth_server/migrations/init.sql">
-- 데이터베이스에 uuid-ossp 확장 기능 활성화 (여전히 다른 테이블에서 UUID를 사용할 수 있으므로 유지)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- updated_at 컬럼 자동 갱신을 위한 트리거 함수
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- =================================================================
-- 0. 커스텀 ENUM 타입 정의 (Custom ENUM Types)
-- =================================================================
DO $$ BEGIN
    CREATE TYPE player_status AS ENUM ('active', 'suspended', 'banned'); -- [수정됨] pending_verification 제거
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE card_rarity AS ENUM ('common', 'rare', 'epic', 'legendary');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;


-- =================================================================
-- 1. 플레이어 계정 (Steam Player Account Mapping)
-- [수정됨] 스팀 연동에 맞게 테이블 구조 대폭 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS players (
    id BIGINT PRIMARY KEY, -- SteamID64를 기본 키로 사용
    last_known_username VARCHAR(64), -- 스팀 닉네임 스냅샷 (선택 사항)
    status player_status NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);
COMMENT ON TABLE players IS '스팀 플레이어 계정과 게임 데이터를 연결하는 핵심 테이블';
COMMENT ON COLUMN players.id IS '고유 플레이어 ID (SteamID64)';
COMMENT ON COLUMN players.last_known_username IS '마지막으로 알려진 플레이어의 스팀 닉네임';
COMMENT ON COLUMN players.status IS '계정 상태 (ENUM: active, suspended, banned)';
CREATE TRIGGER trigger_players_updated_at
BEFORE UPDATE ON players
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();


-- =================================================================
-- 2. 티어 정보 (Master Data - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS tiers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    order_key INT UNIQUE NOT NULL,
    icon_url TEXT
);
COMMENT ON TABLE tiers IS '게임의 티어(등급) 정의 마스터 테이블';
-- 예시 티어 데이터 삽입
INSERT INTO tiers (id, name, order_key, icon_url) VALUES
(1, 'Bronze', 1, '/icons/tiers/bronze.png'),
(2, 'Silver', 2, '/icons/tiers/silver.png'),
(3, 'Gold', 3, '/icons/tiers/gold.png'),
(4, 'Platinum', 4, '/icons/tiers/platinum.png'),
(5, 'Diamond', 5, '/icons/tiers/diamond.png')
ON CONFLICT (id) DO NOTHING;


-- =================================================================
-- 3. 플레이어 프로필 (Game-specific Profile & Stats)
-- [수정됨] 스팀 연동에 맞게 컬럼 축소 및 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS player_profiles (
    player_id BIGINT PRIMARY KEY REFERENCES players(id) ON DELETE CASCADE,
    mmr DOUBLE PRECISION NOT NULL DEFAULT 1500.0,
    rd DOUBLE PRECISION NOT NULL DEFAULT 350.0,
    volatility DOUBLE PRECISION NOT NULL DEFAULT 0.06,
    last_rating_update_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    tier_id INT NOT NULL REFERENCES tiers(id),
    rank_points INT NOT NULL DEFAULT 0,
    experience_points BIGINT NOT NULL DEFAULT 0,
    level INT NOT NULL DEFAULT 1,
    -- 게임 고유의 프로필 꾸미기 아이템이 있다면 아래 컬럼들을 사용
    -- custom_profile_icon_id VARCHAR(100),
    -- custom_profile_banner_id VARCHAR(100),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE player_profiles IS '게임 내 플레이어 프로필, 랭크, 스탯 정보';
COMMENT ON COLUMN player_profiles.player_id IS '플레이어의 SteamID64';
CREATE INDEX IF NOT EXISTS idx_player_profiles_mmr ON player_profiles(mmr);
CREATE TRIGGER trigger_player_profiles_updated_at
BEFORE UPDATE ON player_profiles
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();


-- =================================================================
-- 4. 게임 모드 (Master Data - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS game_modes (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_ranked BOOLEAN NOT NULL DEFAULT FALSE,
    player_count_per_team INT NOT NULL DEFAULT 1,
    team_count INT NOT NULL DEFAULT 2,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE game_modes IS '게임 모드 정의 마스터 테이블';
INSERT INTO game_modes (id, internal_name, display_name, is_ranked, player_count_per_team, team_count) VALUES
(1, 'ranked_1v1', '1v1 랭크 게임', TRUE, 1, 2),
(2, 'unranked_1v1', '1v1 일반 게임', FALSE, 1, 2)
ON CONFLICT (id) DO NOTHING;


-- =================================================================
-- 5. 게임 기록 (Match History - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS match_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    game_mode_id INT NOT NULL REFERENCES game_modes(id),
    started_at TIMESTAMPTZ NOT NULL,
    ended_at TIMESTAMPTZ NOT NULL,
    duration_seconds INT GENERATED ALWAYS AS (EXTRACT(EPOCH FROM (ended_at - started_at))::INT) STORED,
    winning_team_id INT,
    additional_data JSONB
);
COMMENT ON TABLE match_history IS '완료된 모든 게임의 기록';
CREATE INDEX IF NOT EXISTS idx_match_history_started_at ON match_history(started_at DESC);


-- =================================================================
-- 6. 매치 참여자 정보 (Match Participants)
-- [수정됨] player_id의 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS match_participants (
    match_id UUID NOT NULL REFERENCES match_history(id) ON DELETE CASCADE,
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE SET NULL,
    team_id INT NOT NULL,
    is_winner BOOLEAN NOT NULL,
    initial_mmr DOUBLE PRECISION NOT NULL,
    final_mmr DOUBLE PRECISION NOT NULL,
    mmr_change DOUBLE PRECISION GENERATED ALWAYS AS (final_mmr - initial_mmr) STORED,
    score INT,
    stats JSONB,
    disconnected BOOLEAN NOT NULL DEFAULT FALSE,
    PRIMARY KEY (match_id, player_id)
);
COMMENT ON TABLE match_participants IS '각 매치의 참여자 및 성과 정보';
CREATE INDEX IF NOT EXISTS idx_match_participants_player_id ON match_participants(player_id);


-- =================================================================
-- 7. 친구 관계 (Friendships)
-- [제거됨] 스팀 친구 시스템을 사용하므로 테이블 전체를 제거합니다.
-- =================================================================


-- =================================================================
-- 8. 카드 마스터 테이블 (Card Master Data - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS cards (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    rarity card_rarity,
    mana_cost INT NOT NULL DEFAULT 0,
    attack INT,
    health INT,
    card_type VARCHAR(50),
    image_url TEXT,
    attributes JSONB,
    is_collectible BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE cards IS '게임 내 모든 카드 정보 마스터 테이블';
-- 예시 카드 데이터 삽입
INSERT INTO cards (id, internal_name, display_name, rarity, mana_cost, attack, health, card_type, is_collectible) VALUES
(1, 'fireball', 'Fireball', 'common', 4, 6, 0, 'spell', TRUE),
(2, 'frost_golem', 'Frost Golem', 'rare', 5, 4, 5, 'minion', TRUE)
ON CONFLICT (id) DO NOTHING;


-- =================================================================
-- 9. 플레이어 소유 카드 (Player Card Collection)
-- [수정됨] player_id의 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS player_card_collection (
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
    is_new BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (player_id, card_id)
);
COMMENT ON TABLE player_card_collection IS '플레이어가 소유한 카드 목록';


-- =================================================================
-- 10. 플레이어 덱 (Player Decks)
-- [수정됨] player_id의 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS player_decks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    deck_name VARCHAR(100) NOT NULL,
    cover_card_id INT REFERENCES cards(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (player_id, deck_name)
);
COMMENT ON TABLE player_decks IS '플레이어가 생성한 덱 목록';
CREATE TRIGGER trigger_player_decks_updated_at
BEFORE UPDATE ON player_decks
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();


-- =================================================================
-- 11. 덱 구성 카드 (Deck Card Entries - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS deck_cards (
    deck_id UUID NOT NULL REFERENCES player_decks(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL CHECK (quantity > 0 AND quantity <= 2),
    PRIMARY KEY (deck_id, card_id)
);
COMMENT ON TABLE deck_cards IS '각 덱에 포함된 카드 정보';


-- =================================================================
-- 스크립트 실행 완료
-- =================================================================
SELECT 'Database schema setup for Steam integration finished successfully.';
</file>

<file path="simulator_auth_server/reset_and_migrate.bat">
@echo off
chcp 65001 >nul
echo ========================================
echo PostgreSQL Database Reset and Migration
echo ========================================

set PGPASSWORD=root
set DB_USER=postgres
set DB_HOST=localhost
set DB_PORT=5432
set DB_NAME=auth
set DEFAULT_DB=postgres
set PGCLIENTENCODING=UTF8

echo Dropping database '%DB_NAME%'...
psql -h %DB_HOST% -p %DB_PORT% -U %DB_USER% -d %DEFAULT_DB% -c "DROP DATABASE IF EXISTS %DB_NAME%;"

if %errorlevel% neq 0 (
    echo Error: Failed to drop database
    pause
    exit /b 1
)

echo Creating database '%DB_NAME%'...
psql -h %DB_HOST% -p %DB_PORT% -U %DB_USER% -d %DEFAULT_DB% -c "CREATE DATABASE %DB_NAME%;"

if %errorlevel% neq 0 (
    echo Error: Failed to create database
    pause
    exit /b 1
)

echo Running migrations...
for %%f in (migrations\0*.sql) do (
    echo Applying migration: %%f
    psql -h %DB_HOST% -p %DB_PORT% -U %DB_USER% -d %DB_NAME% -f "%%f"
    if %errorlevel% neq 0 (
        echo Error: Failed to apply migration %%f
        pause
        exit /b 1
    )
)

echo ========================================
echo Database reset and migration completed successfully!
echo ========================================
pause
</file>

<file path="simulator_auth_server/src/auth_server/db_operation.rs">
// src/auth/db_operation.rs

use crate::auth_server::model::*;
use anyhow::Result;
use sqlx::PgPool;
use uuid::Uuid;

// =================================================================
// 1. 플레이어 계정 (Players) - 스팀 연동 버전
// =================================================================

/// 신규 플레이어를 생성하거나, 기존 플레이어의 로그인 정보를 업데이트합니다.
/// 스팀 인증 성공 후 호출되며, 플레이어 프로필이 없으면 함께 생성합니다.
pub async fn upsert_player_on_login(
    pool: &PgPool,
    steam_id: i64,
    username: &str,
) -> Result<Player> {
    // 트랜잭션 시작
    let mut tx = pool.begin().await?;

    // 플레이어 정보 INSERT 또는 UPDATE
    let player = sqlx::query_as!(
        Player,
        r#"
        INSERT INTO players (id, last_known_username, last_login_at)
        VALUES ($1, $2, NOW())
        ON CONFLICT (id) DO UPDATE
        SET last_known_username = EXCLUDED.last_known_username,
            last_login_at = NOW(),
            updated_at = NOW()
        RETURNING id, last_known_username, status AS "status: _", created_at, updated_at, last_login_at
        "#,
        steam_id,
        username,
    )
    .fetch_one(&mut *tx) // 트랜잭션 내에서 실행
    .await?;

    // 플레이어 프로필이 없는 경우에만 생성 (기본 티어 ID: 1)
    sqlx::query!(
        "INSERT INTO player_profiles (player_id, tier_id) VALUES ($1, 1) ON CONFLICT (player_id) DO NOTHING",
        steam_id
    )
    .execute(&mut *tx)
    .await?;

    // 트랜잭션 커밋
    tx.commit().await?;

    Ok(player)
}

pub async fn get_player_by_id(pool: &PgPool, player_id: i64) -> Result<Option<Player>> {
    sqlx::query_as!(
        Player,
        r#"SELECT id, last_known_username, status AS "status: _", created_at, updated_at, last_login_at FROM players WHERE id = $1"#,
        player_id
    )
    .fetch_optional(pool)
    .await
    .map_err(Into::into)
}

pub async fn update_player_status(
    pool: &PgPool,
    player_id: i64,
    new_status: PlayerStatus,
) -> Result<Player> {
    sqlx::query_as!(
        Player,
        r#"
        UPDATE players SET status = $1 WHERE id = $2
        RETURNING id, last_known_username, status AS "status: _", created_at, updated_at, last_login_at
        "#,
        new_status as _,
        player_id
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

/// 테스트용: 특정 플레이어 계정과 관련 데이터를 모두 삭제합니다.
pub async fn delete_player_by_id(pool: &PgPool, player_id: i64) -> Result<()> {
    let mut tx = pool.begin().await?;

    // 1. match_participants 테이블에서 해당 플레이어의 기록 삭제
    sqlx::query!(
        "DELETE FROM match_participants WHERE player_id = $1",
        player_id
    )
    .execute(&mut *tx)
    .await?;

    // 2. players 테이블에서 플레이어 삭제 (ON DELETE CASCADE에 의해 다른 데이터도 삭제됨)
    let result = sqlx::query!("DELETE FROM players WHERE id = $1", player_id)
        .execute(&mut *tx)
        .await?;

    tx.commit().await?;

    if result.rows_affected() == 0 {
        return Err(anyhow::anyhow!("Player with ID {} not found", player_id));
    }

    Ok(())
}

// =================================================================
// 2. 플레이어 프로필 (Player Profiles)
// =================================================================

pub async fn get_player_profile(pool: &PgPool, player_id: i64) -> Result<Option<PlayerProfile>> {
    sqlx::query_as!(
        PlayerProfile,
        "SELECT * FROM player_profiles WHERE player_id = $1",
        player_id
    )
    .fetch_optional(pool)
    .await
    .map_err(Into::into)
}

pub async fn update_player_mmr(
    pool: &PgPool,
    player_id: i64,
    new_mmr: f64,
    new_rd: f64,
    new_volatility: f64,
) -> Result<PlayerProfile> {
    sqlx::query_as!(
        PlayerProfile,
        r#"
        UPDATE player_profiles
        SET mmr = $1, rd = $2, volatility = $3, last_rating_update_at = NOW()
        WHERE player_id = $4
        RETURNING *
        "#,
        new_mmr,
        new_rd,
        new_volatility,
        player_id
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 3. 티어 정보 (Tiers) - 변경 없음
// =================================================================
pub async fn get_all_tiers(pool: &PgPool) -> Result<Vec<Tier>> {
    sqlx::query_as!(Tier, "SELECT * FROM tiers ORDER BY order_key")
        .fetch_all(pool)
        .await
        .map_err(Into::into)
}

// =================================================================
// 5 & 6. 게임 기록 (Match History & Participants)
// =================================================================
pub struct MatchResult<'a> {
    pub player_id: i64, // Uuid -> i64
    pub team_id: i32,
    pub is_winner: bool,
    pub initial_mmr: f64,
    pub final_mmr: f64,
    pub score: Option<i32>,
    pub stats: Option<&'a serde_json::Value>,
}

pub async fn record_match_result(
    pool: &PgPool,
    game_mode_id: i32,
    winning_team_id: Option<i32>,
    participants: &[MatchResult<'_>],
) -> Result<MatchHistory> {
    let mut tx = pool.begin().await?;

    let now = chrono::Utc::now();
    let match_history = sqlx::query_as!(
        MatchHistory,
        r#"
        INSERT INTO match_history (game_mode_id, started_at, ended_at, winning_team_id)
        VALUES ($1, $2, $3, $4) RETURNING *
        "#,
        game_mode_id,
        now,
        now,
        winning_team_id
    )
    .fetch_one(&mut *tx)
    .await?;

    for p in participants {
        sqlx::query!(
            r#"
            INSERT INTO match_participants (match_id, player_id, team_id, is_winner, initial_mmr, final_mmr, score, stats)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            "#,
            match_history.id,
            p.player_id,
            p.team_id,
            p.is_winner,
            p.initial_mmr,
            p.final_mmr,
            p.score,
            p.stats
        )
        .execute(&mut *tx)
        .await?;

        // MMR 업데이트
        sqlx::query!(
            "UPDATE player_profiles SET mmr = $1 WHERE player_id = $2",
            p.final_mmr,
            p.player_id
        )
        .execute(&mut *tx)
        .await?;
    }

    tx.commit().await?;
    Ok(match_history)
}

pub async fn get_player_match_history(
    pool: &PgPool,
    player_id: i64, // Uuid -> i64
    limit: i64,
) -> Result<Vec<MatchHistory>> {
    sqlx::query_as!(
        MatchHistory,
        r#"
        SELECT mh.*
        FROM match_history mh
        JOIN match_participants mp ON mh.id = mp.match_id
        WHERE mp.player_id = $1
        ORDER BY mh.started_at DESC
        LIMIT $2
        "#,
        player_id,
        limit
    )
    .fetch_all(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 9. 플레이어 카드 컬렉션 (Player Card Collection)
// =================================================================

pub async fn add_card_to_collection(
    pool: &PgPool,
    player_id: i64, // Uuid -> i64
    card_id: i32,
    quantity: i32,
) -> Result<PlayerCardCollection> {
    sqlx::query_as!(
        PlayerCardCollection,
        r#"
        INSERT INTO player_card_collection (player_id, card_id, quantity)
        VALUES ($1, $2, $3)
        ON CONFLICT (player_id, card_id)
        DO UPDATE SET quantity = player_card_collection.quantity + EXCLUDED.quantity
        RETURNING *
        "#,
        player_id,
        card_id,
        quantity
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

pub async fn get_player_card_collection(
    pool: &PgPool,
    player_id: i64,
) -> Result<Vec<PlayerCardCollection>> {
    sqlx::query_as!(
        PlayerCardCollection,
        "SELECT * FROM player_card_collection WHERE player_id = $1",
        player_id
    )
    .fetch_all(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 10 & 11. 덱 및 덱 카드 (Player Decks & Deck Cards)
// =================================================================

pub async fn create_deck(pool: &PgPool, player_id: i64, deck_name: &str) -> Result<PlayerDeck> {
    sqlx::query_as!(
        PlayerDeck,
        "INSERT INTO player_decks (player_id, deck_name) VALUES ($1, $2) RETURNING *",
        player_id,
        deck_name
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

pub async fn add_card_to_deck(
    pool: &PgPool,
    deck_id: Uuid,
    card_id: i32,
    quantity: i32,
) -> Result<DeckCard> {
    sqlx::query_as!(
        DeckCard,
        r#"
        INSERT INTO deck_cards (deck_id, card_id, quantity)
        VALUES ($1, $2, $3)
        ON CONFLICT (deck_id, card_id) DO UPDATE SET quantity = EXCLUDED.quantity
        RETURNING *
        "#,
        deck_id,
        card_id,
        quantity
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

// 덱 정보와 카드 목록을 함께 가져오는 함수
#[derive(Debug)]
pub struct DeckWithCards {
    pub deck_info: PlayerDeck,
    pub cards: Vec<DeckCard>,
}

pub async fn get_deck_with_cards(pool: &PgPool, deck_id: Uuid) -> Result<Option<DeckWithCards>> {
    let deck_info = match sqlx::query_as!(
        PlayerDeck,
        "SELECT * FROM player_decks WHERE id = $1",
        deck_id
    )
    .fetch_optional(pool)
    .await?
    {
        Some(deck) => deck,
        None => return Ok(None),
    };

    let cards = sqlx::query_as!(
        DeckCard,
        "SELECT * FROM deck_cards WHERE deck_id = $1",
        deck_id
    )
    .fetch_all(pool)
    .await?;

    Ok(Some(DeckWithCards { deck_info, cards }))
}

pub async fn get_player_decks(pool: &PgPool, player_id: i64) -> Result<Vec<PlayerDeck>> {
    sqlx::query_as!(
        PlayerDeck,
        "SELECT * FROM player_decks WHERE player_id = $1",
        player_id
    )
    .fetch_all(pool)
    .await
    .map_err(Into::into)
}
</file>

<file path="simulator_auth_server/src/auth_server/end_point.rs">
use actix_web::{web, HttpResponse};
use serde::{Deserialize, Serialize};
use tracing::info;

use crate::auth_server::{
    db_operation,
    errors::AuthError,
    types::{AppState, SteamApiResponse},
};

// --- HTTP 요청 본문 구조체 ---
#[derive(Deserialize)]
struct SteamAuthRequest {
    ticket: String,
}

#[derive(Deserialize, Serialize)]
struct AuthSuccessResponse {
    message: String,
    steam_id: String,
}

#[derive(Serialize)]
struct GenericSuccessResponse {
    message: String,
}

// --- 엔드포인트 핸들러 ---
/// POST /auth/steam
/// 클라이언트로부터 스팀 티켓을 받아 인증을 처리합니다.
#[actix_web::post("/steam")]
pub async fn steam_authentication_handler(
    state: web::Data<AppState>,
    req_body: web::Json<SteamAuthRequest>,
) -> Result<HttpResponse, AuthError> {
    info!("Received Steam authentication request with ticket",);
    let api_url = "https://api.steampowered.com/ISteamUserAuth/AuthenticateUserTicket/v1/";

    // 1. 스팀 웹 API에 GET 요청을 보냅니다.
    let res = state
        .http_client
        .get(api_url)
        .query(&[
            ("key", &state.steam_web_api_key),
            ("appid", &state.app_id.to_string()),
            ("ticket", &req_body.ticket),
            ("identity", &state.expected_identity),
        ])
        .send()
        .await
        .map_err(|e| AuthError::InternalServerError(anyhow::anyhow!(e)))?;

    // 2. 응답 상태 코드 확인
    if !res.status().is_success() {
        return Err(AuthError::GatewayTimeout(format!(
            "Steam API returned non-success status: {}",
            res.status()
        )));
    }

    // 3. JSON 응답 파싱
    let steam_response = res
        .json::<SteamApiResponse>()
        .await
        .map_err(|e| AuthError::InternalServerError(anyhow::anyhow!(e)))?;

    // 4. 스팀 응답의 유효성 검사
    if let Some(params) = steam_response.response.params {
        if params.result == "OK" {
            // 성공!
            let steam_id_u64 = params.steamid.parse::<u64>().map_err(|_| {
                AuthError::InternalServerError(anyhow::anyhow!("Steam returned invalid SteamID"))
            })?;

            info!(
                "Steam Web API authentication successful for SteamID: {}",
                steam_id_u64
            );

            // 5. DB 작업 수행
            let temp_username = format!("user_{}", steam_id_u64);
            db_operation::upsert_player_on_login(
                &state.db_pool,
                steam_id_u64 as i64,
                &temp_username,
            )
            .await?;

            Ok(HttpResponse::Ok().json(AuthSuccessResponse {
                message: "Steam Web API authentication successful.".to_string(),
                steam_id: steam_id_u64.to_string(),
            }))
        } else {
            // 결과가 "OK"가 아닌 경우
            Err(AuthError::Unauthorized(format!(
                "Steam validation failed with result: {}",
                params.result
            )))
        }
    } else if let Some(error) = steam_response.response.error {
        // 스팀 API가 에러를 반환한 경우
        Err(AuthError::Unauthorized(format!(
            "Steam API Error {}: {}",
            error.errorcode, error.errordesc
        )))
    } else {
        Err(AuthError::InternalServerError(anyhow::anyhow!(
            "Invalid response structure from Steam API"
        )))
    }
}

/// DELETE /test/player/{steam_id}
/// 테스트용으로 생성된 플레이어 계정과 관련 데이터를 삭제합니다.
#[actix_web::delete("/player/{steam_id}")]
pub async fn delete_player_handler(
    state: web::Data<AppState>,
    path: web::Path<i64>,
) -> Result<HttpResponse, AuthError> {
    let steam_id = path.into_inner();

    info!("Attempting to delete player data for SteamID: {}", steam_id);

    db_operation::delete_player_by_id(&state.db_pool, steam_id).await?;

    info!("Successfully deleted player data for SteamID: {}", steam_id);

    Ok(HttpResponse::Ok().json(GenericSuccessResponse {
        message: format!(
            "Player {} and all related data have been deleted.",
            steam_id
        ),
    }))
}
</file>

<file path="simulator_auth_server/src/auth_server/errors.rs">
// src/auth/error.rs

use actix_web::{http::StatusCode, HttpResponse, ResponseError};
use serde_json::json;
use std::fmt;

// 애플리케이션의 모든 에러를 통합 관리하는 Enum
#[derive(Debug)]
pub enum AuthError {
    BadRequest(String),
    Unauthorized(String),
    GatewayTimeout(String),
    InternalServerError(anyhow::Error),
}

// 에러 메시지를 예쁘게 출력하기 위한 Display 구현
impl fmt::Display for AuthError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AuthError::BadRequest(reason) => write!(f, "Bad Request: {}", reason),
            AuthError::Unauthorized(reason) => write!(f, "Unauthorized: {}", reason),
            AuthError::GatewayTimeout(reason) => write!(f, "Gateway Timeout: {}", reason),
            AuthError::InternalServerError(e) => write!(f, "Internal Server Error: {:?}", e),
        }
    }
}

// Actix-web이 에러를 HTTP 응답으로 변환할 수 있도록 ResponseError 구현
impl ResponseError for AuthError {
    // 각 에러 타입에 맞는 HTTP 상태 코드를 반환합니다.
    fn status_code(&self) -> StatusCode {
        match self {
            AuthError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AuthError::Unauthorized(_) => StatusCode::UNAUTHORIZED,
            AuthError::GatewayTimeout(_) => StatusCode::GATEWAY_TIMEOUT,
            AuthError::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    // 실제 HTTP 응답 본문을 생성합니다.
    fn error_response(&self) -> HttpResponse {
        // 모든 에러를 서버 로그에 기록합니다 (중요!)
        tracing::error!("{}", self);

        let status = self.status_code();
        let message = match self {
            // 5xx 서버 에러는 클라이언트에게 상세 내용을 노출하지 않는 것이 보안상 좋습니다.
            AuthError::InternalServerError(_) => "An internal server error occurred.".to_string(),
            // 4xx 클라이언트 에러는 원인을 알려주는 것이 좋습니다.
            _ => self.to_string(),
        };

        HttpResponse::build(status).json(json!({ "error": message }))
    }
}

// 다른 라이브러리의 에러를 우리 AuthError로 쉽게 변환하기 위한 `From` 구현
impl From<actix::MailboxError> for AuthError {
    fn from(e: actix::MailboxError) -> Self {
        AuthError::InternalServerError(anyhow::anyhow!(e))
    }
}

impl From<anyhow::Error> for AuthError {
    fn from(e: anyhow::Error) -> Self {
        AuthError::InternalServerError(e)
    }
}

impl From<sqlx::Error> for AuthError {
    fn from(e: sqlx::Error) -> Self {
        AuthError::InternalServerError(anyhow::anyhow!(e))
    }
}
</file>

<file path="simulator_auth_server/src/auth_server/mod.rs">
pub mod db_operation;
pub mod end_point;
pub mod errors;
pub mod model;
pub mod types;
</file>

<file path="simulator_auth_server/src/auth_server/model.rs">
// src/auth/model.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use uuid::Uuid;

// =================================================================
// ENUM 타입 정의 (Type-safe Enums)
// =================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "player_status", rename_all = "snake_case")]
pub enum PlayerStatus {
    Active,
    Suspended,
    Banned,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "card_rarity", rename_all = "snake_case")]
pub enum CardRarity {
    Common,
    Rare,
    Epic,
    Legendary,
}

// =================================================================
// 테이블 매핑 구조체 (Table Mapping Structs)
// =================================================================

// 1. 플레이어 계정 (Steam Player Account)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct Player {
    pub id: i64, // [수정됨] SteamID64 (BIGINT)
    pub last_known_username: Option<String>,
    pub status: PlayerStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub last_login_at: Option<DateTime<Utc>>,
}

// 2. 플레이어 프로필 (Game-specific Profile)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct PlayerProfile {
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub mmr: f64,
    pub rd: f64,
    pub volatility: f64,
    pub last_rating_update_at: DateTime<Utc>,
    pub tier_id: i32,
    pub rank_points: i32,
    pub experience_points: i64,
    pub level: i32,
    pub updated_at: DateTime<Utc>,
}

// 3. 티어 정보 (Master Data - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct Tier {
    pub id: i32,
    pub name: String,
    pub order_key: i32,
    pub icon_url: Option<String>,
}

// 4. 게임 모드 (Master Data - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct GameMode {
    pub id: i32,
    pub internal_name: String,
    pub display_name: String,
    pub description: Option<String>,
    pub is_ranked: bool,
    pub player_count_per_team: i32,
    pub team_count: i32,
    pub is_active: bool,
}

// 5. 게임 기록 (Match History)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct MatchHistory {
    pub id: Uuid,
    pub game_mode_id: i32,
    pub started_at: DateTime<Utc>,
    pub ended_at: DateTime<Utc>,
    pub duration_seconds: Option<i32>, // DB에서는 GENERATED 이지만, Rust에서는 읽기 전용이므로 Option<i32>
    pub winning_team_id: Option<i32>,
    pub additional_data: Option<serde_json::Value>,
}

// 6. 매치 참여자 (Match Participants)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct MatchParticipant {
    pub match_id: Uuid,
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub team_id: i32,
    pub is_winner: bool,
    pub initial_mmr: f64,
    pub final_mmr: f64,
    pub mmr_change: f64, // DB에서는 GENERATED 이지만, Rust에서는 읽기 전용
    pub score: Option<i32>,
    pub stats: Option<serde_json::Value>,
    pub disconnected: bool,
}

// 7. 친구 관계 (Friendships) - [제거됨]

// 8. 카드 마스터 (Card Master Data - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct Card {
    pub id: i32,
    pub internal_name: String,
    pub display_name: String,
    pub description: Option<String>,
    pub rarity: Option<CardRarity>,
    pub mana_cost: i32,
    pub attack: Option<i32>,
    pub health: Option<i32>,
    pub card_type: Option<String>,
    pub image_url: Option<String>,
    pub attributes: Option<serde_json::Value>,
    pub is_collectible: bool,
}

// 9. 플레이어 소유 카드 (Player Card Collection)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct PlayerCardCollection {
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub card_id: i32,
    pub quantity: i32,
    pub is_new: bool,
}

// 10. 플레이어 덱 (Player Decks)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct PlayerDeck {
    pub id: Uuid,
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub deck_name: String,
    pub cover_card_id: Option<i32>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

// 11. 덱 구성 카드 (Deck Card Entries - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct DeckCard {
    pub deck_id: Uuid,
    pub card_id: i32,
    pub quantity: i32,
}
</file>

<file path="simulator_auth_server/src/auth_server/types.rs">
use sqlx::PgPool;

// --- AppState: 서버 전체에서 공유될 상태 ---
// 액터 주소와 DB 커넥션 풀을 포함합니다.
#[derive(Clone)]
pub struct AppState {
    pub http_client: reqwest::Client,
    pub db_pool: PgPool,
    pub steam_web_api_key: String,
    pub app_id: u32,
    pub expected_identity: String,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiResponse {
    pub response: SteamApiResponseDetails,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiResponseDetails {
    pub params: Option<SteamApiResponseParams>,
    pub error: Option<SteamApiError>,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiResponseParams {
    pub result: String,
    pub steamid: String,
    pub ownersteamid: String,
    pub vacbanned: bool,
    pub publisherbanned: bool,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiError {
    pub errorcode: i32,
    pub errordesc: String,
}
</file>

<file path="simulator_auth_server/src/lib.rs">
pub mod auth_server;

use std::{io, sync::Once};

use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

static INIT: Once = Once::new();
static mut GUARD: Option<tracing_appender::non_blocking::WorkerGuard> = None;
pub fn setup_logger() {
    INIT.call_once(|| {
        // 1. 파일 로거 설정
        let file_appender = RollingFileAppender::new(Rotation::DAILY, "logs", "app.log");
        let (non_blocking_file_writer, _guard) = tracing_appender::non_blocking(file_appender);

        // 2. 로그 레벨 필터 설정 (환경 변수 또는 기본값 INFO)
        let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")); // 기본 INFO 레벨

        // 3. 콘솔 출력 레이어 설정
        let console_layer = fmt::layer()
            .with_writer(io::stdout) // 표준 출력으로 설정
            .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
            .with_thread_ids(true) // 스레드 ID 포함
            .with_thread_names(true) // 스레드 이름 포함
            .with_file(true) // 파일 경로 포함
            .with_line_number(true) // 라인 번호 포함
            .with_target(false) // target 정보 제외 (선택 사항)
            .pretty(); // 사람이 읽기 좋은 포맷

        // 4. 파일 출력 레이어 설정
        let file_layer = fmt::layer()
            .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
            .with_ansi(false) // 파일에는 ANSI 코드 제외
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .pretty();

        // 5. 레지스트리(Registry)에 필터와 레이어 결합
        tracing_subscriber::registry()
            .with(filter) // 필터를 먼저 적용
            .with(console_layer) // 콘솔 레이어 추가
            .with(file_layer) // 파일 레이어 추가
            .init(); // 전역 Subscriber로 설정

        unsafe {
            GUARD = Some(_guard);
        }

        tracing::info!("로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.");
    });
}
</file>

<file path="simulator_auth_server/src/main.rs">
use actix_web::{web, App, HttpServer};
use simulator_auth_server::{
    auth_server::{
        end_point::{delete_player_handler, steam_authentication_handler},
        types::AppState,
    },
    setup_logger,
};
use sqlx::postgres::PgPoolOptions;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    dotenvy::dotenv().ok();
    std::fs::write("steam_appid.txt", "480")?;

    setup_logger();
    tracing::info!("Steamworks SDK Initialized.");

    let database_url =
        std::env::var("DATABASE_URL").expect("DATABASE_URL must be set in .env file");
    let steam_web_api_key =
        std::env::var("STEAM_WEB_API_KEY").expect("STEAM_WEB_API_KEY must be set in .env file");
    let db_pool = PgPoolOptions::new()
        .max_connections(10)
        .connect(&database_url)
        .await
        .expect("Failed to create database connection pool");
    tracing::info!("Database connection pool created.");

    let app_state = AppState {
        http_client: reqwest::Client::new(),
        db_pool,
        steam_web_api_key: steam_web_api_key.clone(),
        app_id: 480,
        expected_identity: std::env::var("EXPECTED_IDENTITY")
            .expect("EXPECTED_IDENTITY must be set in .env file"),
    };
    let bind_address = "127.0.0.1:3000";
    tracing::info!("Starting Actix-Web server on {}", bind_address);

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .service(web::scope("/auth").service(steam_authentication_handler))
            .service(web::scope("/test").service(delete_player_handler))
    })
    .bind(bind_address)?
    .run()
    .await
}
</file>

<file path="simulator_auth_server/steam_appid.txt">
480
</file>

<file path="simulator_auth_server/tests/test.rs">
use actix_web::{test, web, App};
use serde_json::json;
use simulator_auth_server::auth_server::{
    db_operation,
    end_point::{delete_player_handler, steam_authentication_handler},
    types::AppState,
};
use sqlx::PgPool;
use std::sync::Once;
use steamworks::{Client, TicketForWebApiResponse};
use tracing::info;

static INIT: Once = Once::new();

fn setup_test_environment() {
    INIT.call_once(|| {
        dotenvy::dotenv().ok();
        let _ = tracing_subscriber::fmt().with_env_filter("info").try_init();
        std::fs::write("steam_appid.txt", "480").expect("Failed to write steam_appid.txt for test");
    });
}

/// 웹 API용 티켓을 발급받는 헬퍼 함수
fn get_web_api_ticket() -> (u64, String) {
    let client = Client::init().unwrap();
    let steam_id = client.user().steam_id().raw();

    let (tx, rx) = std::sync::mpsc::channel();

    let _cb = client.register_callback(move |resp: TicketForWebApiResponse| {
        if resp.result.is_ok() {
            let ticket_hex = hex::encode(resp.ticket);
            tx.send(Some(ticket_hex)).unwrap();
        } else {
            tx.send(None).unwrap();
        }
    });

    // 웹 API용 티켓을 요청합니다.
    client
        .user()
        .authentication_session_ticket_for_webapi("test_identity");

    for _ in 0..100 {
        client.run_callbacks();
        if let Ok(Some(ticket)) = rx.try_recv() {
            return (steam_id, ticket);
        }
        std::thread::sleep(std::time::Duration::from_millis(50));
    }
    panic!("Failed to get web api ticket");
}

async fn setup_test_app() -> (
    impl actix_web::dev::Service<
        actix_http::Request,
        Response = actix_web::dev::ServiceResponse,
        Error = actix_web::Error,
    >,
    PgPool,
    u64,
    String,
) {
    setup_test_environment();

    let db_pool = PgPool::connect(&std::env::var("DATABASE_URL").unwrap())
        .await
        .unwrap();
    let http_client = reqwest::Client::new();
    let steam_web_api_key = std::env::var("STEAM_WEB_API_KEY").unwrap();
    let (my_steam_id, steam_ticket_hex) = tokio::task::spawn_blocking(get_web_api_ticket)
        .await
        .unwrap();

    let app_state = AppState {
        http_client,
        db_pool: db_pool.clone(),
        steam_web_api_key,
        app_id: 480,
        expected_identity: std::env::var("EXPECTED_IDENTITY")
            .unwrap_or("test_identity".to_string()),
    };

    let app = test::init_service(
        App::new()
            .app_data(web::Data::new(app_state))
            .service(web::scope("/auth").service(steam_authentication_handler))
            .service(web::scope("/test").service(delete_player_handler)),
    )
    .await;

    (app, db_pool, my_steam_id, steam_ticket_hex)
}

#[actix_web::test]
async fn test_web_api_auth_and_delete_flow() {
    let (app, db_pool, my_steam_id, steam_ticket_hex) = setup_test_app().await;

    // 1. 인증 엔드포인트 호출하여 플레이어 생성
    let req_body = json!({ "ticket": steam_ticket_hex });
    let req = test::TestRequest::post()
        .uri("/auth/steam")
        .insert_header(("Content-Type", "application/json"))
        .set_json(&req_body)
        .to_request();

    let resp = test::call_service(&app, req).await;
    assert!(
        resp.status().is_success(),
        "Auth request failed with status: {}",
        resp.status()
    );

    // DB에 플레이어가 생성되었는지 확인
    let player = db_operation::get_player_by_id(&db_pool, my_steam_id as i64)
        .await
        .unwrap()
        .expect("Player should exist after auth");
    assert_eq!(player.id, my_steam_id as i64);
    info!("✅ Player created successfully.");

    // 2. 삭제 엔드포인트 호출
    let req = test::TestRequest::delete()
        .uri(&format!("/test/player/{}", my_steam_id))
        .to_request();

    let resp = test::call_service(&app, req).await;
    assert!(
        resp.status().is_success(),
        "Delete request failed with status: {}",
        resp.status()
    );

    // DB에서 플레이어가 삭제되었는지 확인
    let player = db_operation::get_player_by_id(&db_pool, my_steam_id as i64)
        .await
        .unwrap();
    assert!(player.is_none(), "Player should not exist after deletion");
    info!("✅ Player deleted successfully.");
}
</file>

<file path="simulator_client/.gitignore">
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
</file>

<file path="simulator_client/package.json">
{
  "name": "simulator_client",
  "version": "0.1.0",
  "description": "",
  "type": "module",
  "scripts": {
    "dev": "vite dev",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
    "check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
    "tauri": "tauri"
  },
  "license": "MIT",
  "dependencies": {
    "@tailwindcss/vite": "^4.1.11",
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-http": "^2.5.0",
    "@tauri-apps/plugin-opener": "^2",
    "tailwindcss": "^4.1.11"
  },
  "devDependencies": {
    "@sveltejs/adapter-static": "^3.0.6",
    "@sveltejs/kit": "^2.9.0",
    "@sveltejs/vite-plugin-svelte": "^5.0.0",
    "@tauri-apps/cli": "^2",
    "daisyui": "^5.0.43",
    "svelte": "^5.0.0",
    "svelte-check": "^4.0.0",
    "typescript": "~5.6.2",
    "vite": "^6.0.3"
  }
}
</file>

<file path="simulator_client/README.md">
# Tauri + SvelteKit + TypeScript

This template should help get you started developing with Tauri, SvelteKit and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer).
</file>

<file path="simulator_client/src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="simulator_client/src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="simulator_client/src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "main-capability",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    {
      "identifier": "http:default",
      "allow": [{ "url": "http://127.0.0.1:*" }, { "url": "http://localhost:3000/*" }]
    }
  ]
}
</file>

<file path="simulator_client/src-tauri/Cargo.toml">
[package]
name = "simulator_client"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "simulator_client_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-http = "2.5.0"
tauri-plugin-opener = "2.4.0"
tokio = { version = "1.15", features = ["full", "tracing"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
steamworks = "0.12.0"
hex = "0.4.3"
</file>

<file path="simulator_client/src-tauri/src/lib.rs">
use steamworks::{Client, TicketForWebApiResponse};

// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[tauri::command]
async fn get_steam_ticket() -> Result<(u64, String), String> {
    // This is a blocking operation, so we run it in a separate thread
    tokio::task::spawn_blocking(|| {
        let client = Client::init().map_err(|e| e.to_string())?;
        let steam_id = client.user().steam_id().raw();

        let (tx, rx) = std::sync::mpsc::channel();

        let _cb = client.register_callback(move |resp: TicketForWebApiResponse| {
            if resp.result.is_ok() {
                let ticket_hex = hex::encode(resp.ticket);
                tx.send(Some(ticket_hex)).unwrap();
            } else {
                tx.send(None).unwrap();
            }
        });

        client
            .user()
            .authentication_session_ticket_for_webapi("test_identity");

        // Wait for the ticket callback
        for _ in 0..100 {
            client.run_callbacks();
            if let Ok(Some(ticket)) = rx.try_recv() {
                return Ok((steam_id, ticket));
            }
            std::thread::sleep(std::time::Duration::from_millis(50));
        }

        Err("Failed to get web api ticket".to_string())
    })
    .await
    .map_err(|e| e.to_string())?
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    // Create steam_appid.txt for Steamworks initialization
    std::fs::write("steam_appid.txt", "480").expect("Failed to write steam_appid.txt");

    tauri::Builder::default()
        .plugin(tauri_plugin_http::init())
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![greet, get_steam_ticket])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="simulator_client/src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    simulator_client_lib::run()
}
</file>

<file path="simulator_client/src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "simulator_client",
  "version": "0.1.0",
  "identifier": "com.blast.simulator_client",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../build"
  },
  "app": {
    "windows": [
      {
        "title": "simulator_client",
        "width": 800,
        "height": 600
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}
</file>

<file path="simulator_client/src/app.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.png" />
    <link href="/src/app.css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tauri + SvelteKit + Typescript App</title>
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>
</file>

<file path="simulator_client/src/routes/+layout.ts">
export const ssr = false;
</file>

<file path="simulator_client/src/routes/+page.svelte">
<script lang="ts">
	import { onMount } from 'svelte';
	import { fetch } from '@tauri-apps/plugin-http';
	import { invoke } from '@tauri-apps/api/core';

	let loginStatus: 'idle' | 'pending' | 'success' | 'error' = 'idle';
	let statusMessage = '';
	let steamId = '';

	async function handleLogin() {
		loginStatus = 'pending';
		statusMessage = '로그인 중...';

		try {
			// Tauri 커맨드를 호출하여 Steam 티켓을 가져옵니다.
			const [id, ticket] = await invoke<(number | string)[]>('get_steam_ticket');
			steamId = String(id); // Steam ID를 상태에 저장

			const authServerUrl = 'http://localhost:3000/auth';

			const response = await fetch(`${authServerUrl}/steam`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({ ticket })
			});

			if (response.ok) {
				const data = (await response.json()) as { message: string; steam_id: string };
				loginStatus = 'success';
				statusMessage = `로그인 성공! (서버 메시지: ${data.message})`;
				steamId = data.steam_id;
			} else {
				loginStatus = 'error';
				const errorText = await response.json(); // 오류 응답도 json일 수 있으므로 파싱
				statusMessage = `로그인 실패: ${response.status} - ${JSON.stringify(errorText)}`;
			}
		} catch (e) {
			loginStatus = 'error';
			statusMessage = `로그인 요청 중 오류 발생: ${e}`;
		}
	}

	onMount(() => {
		handleLogin();
	});
</script>

<div class="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen">
	<div class="card w-96 bg-base-100 shadow-xl">
		<div class="card-body">
			<h2 class="card-title">Tauri App</h2>

			{#if loginStatus === 'pending'}
				<div class="flex items-center space-x-2">
					<span class="loading loading-spinner loading-md"></span>
					<p>{statusMessage}</p>
				</div>
			{:else if loginStatus === 'success'}
				<div role="alert" class="alert alert-success">
					<svg
						xmlns="http://www.w3.org/2000/svg"
						class="h-6 w-6 shrink-0 stroke-current"
						fill="none"
						viewBox="0 0 24 24"
						><path
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
							d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
						/></svg
					>
					<span>{statusMessage}</span>
				</div>
				<p class="text-lg">Steam ID: <span class="font-bold">{steamId}</span></p>
			{:else if loginStatus === 'error'}
				<div role="alert" class="alert alert-error">
					<svg
						xmlns="http://www.w3.org/2000/svg"
						class="h-6 w-6 shrink-0 stroke-current"
						fill="none"
						viewBox="0 0 24 24"
						><path
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
							d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"
						/></svg
					>
					<span>{statusMessage}</span>
				</div>
			{/if}

			<div class="card-actions justify-end mt-4">
				<button class="btn btn-primary" on:click={handleLogin} disabled={loginStatus === 'pending'}>
					{#if loginStatus === 'pending'}
						<span class="loading loading-spinner"></span>
					{/if}
					다시 시도
				</button>
			</div>
		</div>
	</div>
</div>
</file>

<file path="simulator_client/static/svelte.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="26.6" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 308"><path fill="#FF3E00" d="M239.682 40.707C211.113-.182 154.69-12.301 113.895 13.69L42.247 59.356a82.198 82.198 0 0 0-37.135 55.056a86.566 86.566 0 0 0 8.536 55.576a82.425 82.425 0 0 0-12.296 30.719a87.596 87.596 0 0 0 14.964 66.244c28.574 40.893 84.997 53.007 125.787 27.016l71.648-45.664a82.182 82.182 0 0 0 37.135-55.057a86.601 86.601 0 0 0-8.53-55.577a82.409 82.409 0 0 0 12.29-30.718a87.573 87.573 0 0 0-14.963-66.244"></path><path fill="#FFF" d="M106.889 270.841c-23.102 6.007-47.497-3.036-61.103-22.648a52.685 52.685 0 0 1-9.003-39.85a49.978 49.978 0 0 1 1.713-6.693l1.35-4.115l3.671 2.697a92.447 92.447 0 0 0 28.036 14.007l2.663.808l-.245 2.659a16.067 16.067 0 0 0 2.89 10.656a17.143 17.143 0 0 0 18.397 6.828a15.786 15.786 0 0 0 4.403-1.935l71.67-45.672a14.922 14.922 0 0 0 6.734-9.977a15.923 15.923 0 0 0-2.713-12.011a17.156 17.156 0 0 0-18.404-6.832a15.78 15.78 0 0 0-4.396 1.933l-27.35 17.434a52.298 52.298 0 0 1-14.553 6.391c-23.101 6.007-47.497-3.036-61.101-22.649a52.681 52.681 0 0 1-9.004-39.849a49.428 49.428 0 0 1 22.34-33.114l71.664-45.677a52.218 52.218 0 0 1 14.563-6.398c23.101-6.007 47.497 3.036 61.101 22.648a52.685 52.685 0 0 1 9.004 39.85a50.559 50.559 0 0 1-1.713 6.692l-1.35 4.116l-3.67-2.693a92.373 92.373 0 0 0-28.037-14.013l-2.664-.809l.246-2.658a16.099 16.099 0 0 0-2.89-10.656a17.143 17.143 0 0 0-18.398-6.828a15.786 15.786 0 0 0-4.402 1.935l-71.67 45.674a14.898 14.898 0 0 0-6.73 9.975a15.9 15.9 0 0 0 2.709 12.012a17.156 17.156 0 0 0 18.404 6.832a15.841 15.841 0 0 0 4.402-1.935l27.345-17.427a52.147 52.147 0 0 1 14.552-6.397c23.101-6.006 47.497 3.037 61.102 22.65a52.681 52.681 0 0 1 9.003 39.848a49.453 49.453 0 0 1-22.34 33.12l-71.664 45.673a52.218 52.218 0 0 1-14.563 6.398"></path></svg>
</file>

<file path="simulator_client/static/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="simulator_client/static/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="simulator_client/svelte.config.js">
// Tauri doesn't have a Node.js server to do proper SSR
// so we use adapter-static with a fallback to index.html to put the site in SPA mode
// See: https://svelte.dev/docs/kit/single-page-apps
// See: https://v2.tauri.app/start/frontend/sveltekit/ for more info
import adapter from "@sveltejs/adapter-static";
import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: vitePreprocess(),
  kit: {
    adapter: adapter({
      fallback: "index.html",
    }),
  },
};

export default config;
</file>

<file path="simulator_client/tsconfig.json">
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "sourceMap": true,
    "strict": true,
    "moduleResolution": "bundler"
  }
  // Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
  // except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
  //
  // If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
  // from the referenced tsconfig.json - TypeScript does not merge them in
}
</file>

<file path="simulator_client/vite.config.js">
import { defineConfig } from "vite";
import { sveltekit } from "@sveltejs/kit/vite";
import tailwindcss from "@tailwindcss/vite";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
  plugins: [sveltekit(), tailwindcss()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent Vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell Vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));
</file>

<file path="simulator_core/.cargo/config.toml">
[build]
rustflags = ["--cfg", "tokio_unstable"]
</file>

<file path="simulator_core/.claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(cargo check:*)"
    ],
    "deny": []
  }
}
</file>

<file path="simulator_core/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_core/.gitignore">
/target
</file>

<file path="simulator_core/build.rs">
use std::fs;
use std::io::Write;
use std::path::Path;

pub fn main() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("card_registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // 카드 모듈 디렉토리 스캔
    let modules = ["human", "monster", "public"];
    let mut card_registrations = Vec::new();

    for module in modules {
        let path = format!("src/card_gen/{}.rs", module);
        let content = fs::read_to_string(&path).unwrap();

        // 함수 이름 찾기 (예: HM_001, MT_001 등)
        for line in content.lines() {
            if line.contains("pub fn")
                && (line.contains("HM_") || line.contains("MT_") || line.contains("PB_"))
            {
                let func_name = line.split("fn ").nth(1).unwrap().split("(").next().unwrap();
                card_registrations.push(format!("    {}::{}", module, func_name));
            }
        }
    }

    // 매크로 호출 생성
    write!(
        f,
        r#"
        generate_card_map! {{
        {}
        }}
    "#,
        card_registrations.join(",\n")
    )
    .unwrap();
}
</file>

<file path="simulator_core/Datas/config.json">
{
  "DeckCodes": [
    {
      "code1": "",
      "code2": ""
    }
  ],
  "Attacker": 1,
  "Names": [
    {
      "name1": "player1",
      "name2": "player2"
    }
  ]
}
</file>

<file path="simulator_core/Datas/game_behaivor.csv">
PlayerType,Message
Player1
</file>

<file path="simulator_core/Datas/mock.json">
{
  "player_type": "player",
  "cards": ["CARD_UUID_1", "CARD_UUID_2", "CARD_UUID_3", "CARD_UUID_4"]
}
</file>

<file path="simulator_core/Datas/player1_test.json">
{
  "decks": [
    {
      "Hero": [
        {
          "name": "player1"
        }
      ],
      "cards": [
        {
          "id": "HM_001",
          "num": 2
        },
        {
          "id": "HM_002",
          "num": 2
        },
        {
          "id": "HM_003",
          "num": 2
        },
        {
          "id": "HM_004",
          "num": 2
        }
      ]
    }
  ]
}
</file>

<file path="simulator_core/Datas/player2_test.json">
{
  "decks": [
    {
      "Hero": [
        {
          "name": "player2"
        }
      ],
      "cards": [
        {
          "id": "HM_001",
          "num": 2
        },
        {
          "id": "HM_002",
          "num": 2
        },
        {
          "id": "HM_003",
          "num": 2
        },
        {
          "id": "HM_004",
          "num": 2
        }
      ]
    }
  ]
}
</file>

<file path="simulator_core/GameData/cards-json.txt">
datas 폴더엔 플레이어의 덱 정보가 담긴 json 파일이 있다.
구조는 다음과 같다.
[
    {
        "id": "ID",
        "num": INT
    }
]
{ } 블럭은 단일 카드에 대한 id 정보와 갯수를 포함한다.

Resource 폴더에 있는 cards.json 은 게임에 있는 모든 카드의 정보를 담는다.
구조는 위와 비슷하지만 포함하는 정보량이 다르다.
이 json 파일은 카드에 대한 모든 정보(예를 들어 공격력, 체력, 효과 등)를 담기 때문에, 덱에서 id 를 가져온 뒤 해당 json 파일에서 카드 정보를 가져오는
방식으로 한다.
</file>

<file path="simulator_core/GameData/hero.txt">
이 게임에서는 사전 구성된 덱을 가지고 플레이어가 게임에 참여한다.
이 때 덱을 구성하는 카드는 각자의 진영을 갖고 있는데,
진영을 대표하는 카드를 히어로라고 한다.

덱에서 동시에 존재할 수 있는 히어로의 갯수는 최대 2개이다.

히어로는
</file>

<file path="simulator_core/GameData/task.txt">
카드 게임에서 존재하는 모든 행동을, 함수/열거형으로 정의한다.
그리고 카드는 자신이 가진 능력과 관련된 함수들을 table 로 가진다.

모든 행동은 하나의 queue 에 task 형식으로 저장되어, 순차적으로 처리된다.

task_queue 는 후입선출 방식으로 처리한다.
</file>

<file path="simulator_core/GameData/turn-structure.txt">
턴 구조는 유희왕과 비슷하다.
</file>

<file path="simulator_core/Resource/card_data">
월인/달토끼 (MH)

링고[몬스터/달토끼] [코스트3]
스탯 1/4
상시 : 경단을 사용한 턴 2/1를 얻는다.
조건 : 소환 성공 및 공격선언 시 발동한다.
효과 : 패에 "경단" 2장을 넣는다.
디메리트 : 경단을 사용하지 않은 턴 종료시에 2의 데미지를 받는다.

경단[행동/대응]
상시 : 1턴에 1번만 발동할 수 있다.
효과 : 달토끼에게 영구적으로 1/1를 부여한다. 

악마 (DM)

소악마[행동]
① : 자신은 2장 드로우한다. 그 후 데몬 카드 1장을 버린다. 만약 버릴수 없을 경우 자신의 패를 전부 덱으로 되돌린다.

레밀리아 스칼렛[몬스터] [코스트 2]
스탯 2/3
"상시 : 이 카드의 ①, ② 효과는 1턴에 1번만 발동할 수 있다.\n① : 자신 필드에 "플랑드르 스칼렛"이 없다면 발동할 수 있다. 패, 덱, 묘지에서 "플랑드르 스칼렛" 1장을 소환한다. \n② : 자신 필드에 "플랑드르 스칼렛"이 존재하고 이 카드가 소환 되었을 경우 발동 할 수있다. 자신은 1장 드로우한다.",

플랑드르 스칼렛[몬스터] [코스트 2]
스탯 3/2
"상시 : 이 카드의 ①, ② 효과는 1턴에 1번만 발동할 수 있다.\n① : 자신 필드에 "레밀리아 스칼렛"이 없다면 발동할 수 있다. 패, 덱, 묘지에서 "레밀리아 스칼렛" 1장을 소환한다. \n② : 자신 필드에 "레밀리아 스칼렛"이 존재하고 이 카드가 소환 되었을 경우 상대 필드 카드 1장을 대상으로 발동할 수 있다. 그카드를 파괴한다.",

인간 (HM)

히에다노 아큐[필드]
① : 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.

모토오리 코스즈[필드]
"① : 자신 필드에 "인간"이 존재할 경우 발동할 수 있다. 상대 패에 존재하는 카드 1장을 자신의 패에 추가한다. \n② : 그 카드를 사용하지 않은 턴 종료시 에 발동한다. 그 카드를 상대패에 추가한다.",


이자요이 사쿠야[행동]
"① : 이 카드에 빛이 존재할 경우 발동할 수 있다. 이턴 인간 카드의 비용이 0이 된다. \n② : ①효과를 발동한 엔드페이즈에 발동한다. 자신 필드 어둠 4개를을 생성한다.",
//②효과는 강제발동이다.

파츄리 널릿지[행동]
"이 카드의 ①은 1턴에 1번만 발동할 수 있으며, 빛이 존재하지 않을 경우 무효화 된다. \n① : 자신 덱에서 "인간"진형 카드 2장을 패에 넣는다. 그 후 패 1장을 버린다.",


하쿠레이 레이무[몬스터] [코스트 1]
스탯 0/1 
"빛에 존재하는 이 카드는 대상이 되지 않는다. \n① : 이 카드를 소환했을 때 발동할 수 있다. 덱에서 "인간"진형 카드 1장을 패에 넣는다.",


우사미 스미레코[행동/대응]
"이 카드의 ①의 효과는 상대턴에도 발동 가능하다. \n① : 필드에 빛 또는 어둠이 존재할 경우 다른 필드에 대상으로 발동할 수 있다. 필드에 존재하는 빛 또는 어둠 1개만 대상으로 한 곳으로 이동한다.",


코치야 사나에[몬스터] [코스트 3]
스탯 ?/? [신]
"이카드는 자신필드에 존재하는 모든 "인간"카드를 묘지로 보내야만 소환할 수 있다.\n이 카드의 공격력과 생명력은 이카드를 소환하기 위해 보내진 "인간"카드 1장당 2/2씩 얻는다. \n① : 이 카드에 빛이 존재하고, 상대가 몬스터/행동 카드의 효과를 발동했을 때 발동할 수 있다. 이카드의 스탯 2/2를 감소시키고 그 발동을 무효로 한다. \n② : 이 카드에 어둠이 존재하고, 이카드 이외에 다른 카드가 공격대상이 되었을 경우 발동할 수 있다. 공격대상을 이카드로 바꾼다.",

엘리스 마가트로이드[몬스터] [코스트 4]
리워크 예정

후지와라노 모코우[몬스터] [코스트 2] [인형]
리워크 예정

키라사메 마리사[몬스터] [코스트 1]
리워크 예정

카미시라사와 케이네[몬스터] [코스트 6]
스탯 6/5
"이카드의 ①, ②효과는 상대턴에도 발동 할 수 있으며, 1턴에 1번만 발동할 수 있다. \n① : 이 카드에 어둠이 있을경우 발동할 수 있다. 덱에서 인간카드 1장을 패에 추가한다. \n② : 이카드에 빛이 있을경우 발동할 수 있다. 이 카드를 덱으로 되돌리고 덱에서 인간 몬스터 1장을 소환한다.",

마에리베리 한[몬스터] [코스트 10]
리워크 예정

요괴 (MT)

루미아[행동/대응]
① : 낮일 경우 발동할 수 있다. 자신 필드에 어둠 1개를 생성한다.

미스티아 로렐라이[행동/대응]
① : 어둠이 존재 할때 발동할 수 있다. 필드에 어둠 2개를 생성한다.

나즈린[행동]
① : 자신 덱에서 "요과"카드 한장을 가져온다.

이누바시리 모미지[행동]
이 카드의 ① 효과는 1턴에 1번만 발동 할 수 있다. \n① : 어둠이 존재할 경우 발동할 수 있다. 자신의 덱 맨 위에서 3장을 공개하고 그중 1장을 패에 넣는다.",
    //선택받지 못한 카드는 덱으로 간다

미야코 요시카[몬스터] [코스트 3]
스탯 3/4 [강시]
어둠에 존재하는 카드 1장당 이 카드의 스탯 1/1 상승한다.\n① : 필드에 어둠이 존재할 경우 발동할 수 있다. 필드 1개에 어둠을 생성한다.", 
//필드에 어둠이 존재하고 그 위에 다른 카드가 존재해야 이 카드의 스탯이 오름.

야쿠모 란[몬스터] [코스트 4]
스탯 3/4
① : 자신 필드에 "첸"이 존재하지 않을 경우 발동할 수 있다. 덱/묘지에서 첸을 소환한다.\n② : 필드에 첸이 존재할 경우 발동할 수 있다. 첸 아래에 존재하는 카드 1개를 묘지로 보내고 아래에 효과를 적용한다. \n몬스터 : 이번 턴 자신의 몬스터는 체력 1 미만으로 내려가지 않는다. \n행동 : 자신은 1장 드로우한다. \n대응 : 자신 묘지에 존재하는 카드 1장을 자신의 패로 가져온다. \n필드 : 이번 턴 필드의 효과는 무효화 된다.",


첸[몬스터] [코스트 2]
스탯 0/4
이카드는 이카드 아래에 존재하는 카드 1장당 0/1 스탯을 얻는다.\n① : 어둠에 이 카드가 존재할 경우 드로우 페이즈에 발동할 수 있다. 상대 덱 맨 위에 카드를 1장 이카드 아래에 둔다.",

Yukari Yakumo [몬스터] [코스트 8]
스탯 10/6 
"자신 필드에 "야쿠모 란", "첸"이 존재하지 않을경우 이카드는 소환 및 효과 발동을 할 수 없다.\n① : 상대가 몬스터/행동 효과를 발동했을 때 발동할 수 있다. "첸" 아래에 있는 카드를 1장 묘지로 보내고 그 효과를 무효로 하고 파괴한다.\n ② : 자신 필드에 "야쿠모 란", "첸", "야쿠모 유카리"만 존재할 경우 발동할 수 있다. 이 턴 종료시 까지 자신 필드의 "야쿠모 란", "첸"은 자신 필드의 "야쿠모 유카리"의 공격력과 수비력을 가진다.",

이마이즈미 카게로[몬스터] [코스트 3]
스탯 2/4
"빛에 존재하는 이 카드는 공격할 수 없다.\n어둠에 있을때 이 카드는 5/4가 된다. \n이카드는 2번 공격할 수 있다.", 

공용 (PB)

릴리 화이트[행동/대응]
필드존에 카드가 없어야 발동 할 수 있다. 덱에서 "필드카드" 1장을 필드존에 놓는다.

서니 밀크[필드]
이 카드가 존재하는 한 필드 3개를 빛으로 취급한다.
//이 효과를 발동한 플레이어만 정한다.

루나 차일드[필드]
이 카드가 존재하는 한 필드 3개를 어둠으로 취급한다.
//이 효과를 발동한 플레이어만 정한다.

아키 시즈하[행동/대응]
1턴에 1번 필드존의 카드가 존재할 경우에만 발동할 수 있다. 필드존의 카드를 파괴한다.

아키 미노리코[행동대]
1턴에 1번 "필드카드"가 존재하면 발동할 수 있다. 자신은 2장 드로우한다.

치르노[행동/대응]
리워크 예정

스타 사파이어[몬스터] [코스트 1]
리워크 예정

레티 화이트락[행동 / 대응]
1턴에 1번 패에서 이 카드를 버리고 몬스터를 대상으로 발동할 수 있다. 대상 몬스터는 효과 무효 및 공격을 할 수 없으며, 공격대상또한 되지 않는다.
</file>

<file path="simulator_core/Resource/cards_id.json">
[
  { "id": "HM_001", "dbfid": 20 },
  { "id": "HM_002", "dbfid": 21 },
  { "id": "HM_003", "dbfid": 22 },
  { "id": "HM_004", "dbfid": 23 },
  { "id": "HM_005", "dbfid": 24 },
  { "id": "HM_006", "dbfid": 25 },
  { "id": "HM_007", "dbfid": 26 },
  { "id": "HM_008", "dbfid": 27 },
  { "id": "MT_001", "dbfid": 28 },
  { "id": "MT_002", "dbfid": 29 },
  { "id": "MT_003", "dbfid": 30 },
  { "id": "MT_004", "dbfid": 31 },
  { "id": "MT_005", "dbfid": 32 },
  { "id": "MT_006", "dbfid": 33 },
  { "id": "MT_007", "dbfid": 34 },
  { "id": "MT_008", "dbfid": 35 },
  { "id": "MT_009", "dbfid": 36 },
  { "id": "MT_010", "dbfid": 37 },
  { "id": "PB_001", "dbfid": 38 },
  { "id": "PB_002", "dbfid": 39 },
  { "id": "PB_003", "dbfid": 40 },
  { "id": "PB_004", "dbfid": 41 },
  { "id": "PB_005", "dbfid": 42 },
  { "id": "PB_006", "dbfid": 43 },
  { "id": "PB_007", "dbfid": 44 },
  { "id": "PB_008", "dbfid": 45 },
  { "id": "PB_009", "dbfid": 46 },
  { "id": "PB_010", "dbfid": 47 },
  { "id": "PB_011", "dbfid": 48 },
  { "id": "PB_012", "dbfid": 49 },
  { "id": "PB_013", "dbfid": 50 },
  { "id": "PB_014", "dbfid": 51 },
  { "id": "PB_015", "dbfid": 52 },
  { "id": "PB_016", "dbfid": 53 },
  { "id": "PB_017", "dbfid": 54 }
]
</file>

<file path="simulator_core/Resource/cards.json">
[
  {
    "id": "HM_001",
    "dbfid": 20,
    "cardClass": "Human",
    "name": "Hieda no Akyuu",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "효과 : 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "HM_002",
    "dbfid": 21,
    "cardClass": "Human",
    "name": "Kosuzu Motoori",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 자신 필드에 \"인간\"이 존재할 경우 발동할 수 있다. \n효과 : 상대 패에 존재하는 카드 1장을 자신의 패에 추가한다. \n디메리트 : 그 카드를 사용하지 않은 턴 종료시 그 카드를 상대패에 추가한다.",
    "type": "Spell"
  },
  {
    "id": "HM_003",
    "dbfid": 22,
    "cardClass": "Human",
    "name": "Sakuya Izayoi",
    "attack": 0,
    "health": 2,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 이 카드에 \"빛\"이 존재할 경우 발동할 수 있다. \n효과 : 이턴 인간 카드의 비용이 0이 된다. \n디메리트 : 자신 필드 4개에 \"어둠\"을 생성한다.",
    "type": "Unit"
  },
  {
    "id": "HM_004",
    "dbfid": 23,
    "cardClass": "Human",
    "name": "Patchouli Knowledge",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "상시 : 이 카드는 1턴에 1번에만 발동할 수 있으며, 빛이 존재하지 않을 경우 무효화 된다. \n효과 : 자신 덱에서 \"인간\"진형 카드 2장을 패에 넣는다. 그 후 패 1장을 버린다.",
    "type": "Spell"
  },
  {
    "id": "HM_005",
    "dbfid": 24,
    "cardClass": "Human",
    "name": "Reimu Hakurei",
    "attack": 0,
    "health": 1,
    "cost": 1,
    "rarity": "A",
    "collectible": true,
    "text": "상시 : 빛에 존재하는 이 카드는 대상이 되지 않는다. \n조건 : 이 카드 소환시 발동할 수 있다. \n효과 : 덱에서 \"인간\"진형 카드 1장을 패에 넣는다.",
    "type": "Unit"
  },
  {
    "id": "HM_006",
    "dbfid": 25,
    "cardClass": "Human",
    "name": "Usami Sumireko",
    "attack": 2,
    "health": 3,
    "cost": 2,
    "rarity": "B",
    "collectible": true,
    "text": "조건 : 필드에 빛 또는 어둠이 존재할 경우 다른 필드에 대상으로 발동할 수 있다. [이 효과는 상대턴에도 발동 가능]\n효과 : 필드에 존재하는 빛 또는 어둠 1개만 대상으로 한 곳으로 이동한다.",
    "type": "Spell"
  },
  {
    "id": "HM_007",
    "dbfid": 26,
    "cardClass": "Human",
    "name": "Sanae Kochiya",
    "attack": 0,
    "health": 0,
    "cost": 3,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 이 카드는 자신 필드에 존재하는 모든 \"인간\"카드를 묘지로 보내야만 소환할 수 있다.\n이 카드의 공격력과 생명력은 이카드를 소환하기 위해 보내진 \"인간\"카드 1장당 2/2씩 얻는다. \n조건 1 : 이 카드에 빛이 존재하고, 상대가 몬스터/행동 카드의 효과를 발동했을 때 발동할 수 있다. \n효과 1 : 이카드의 스탯 2/2를 감소시키고 그 발동을 무효로 한다. \n조건 2 : 이 카드에 어둠이 존재하고, 이카드 이외에 다른 카드가 공격대상이 되었을 경우 발동할 수 있다. \n효과 2 : 공격대상을 이카드로 바꾼다.",
    "type": "Ace"
  },
  {
    "id": "HM_008",
    "dbfid": 27,
    "cardClass": "Human",
    "name": "Keine Kamishirasawa",
    "attack": 5,
    "health": 5,
    "cost": 6,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 이 카드의 효과는 상대턴에도 발동 할 수 있으며, 1턴에 1번만 발동할 수 있다. \n조건 1 : 이 카드에 어둠이 있을경우 발동할 수 있다. \n효과 1 : 덱에서 인간카드 1장을 패에 추가한다. \n조건 2 : 이카드에 빛이 있을경우 발동할 수 있다. \n효과 2 : 이 카드를 덱으로 되돌리고 덱에서 인간 몬스터 1장을 소환한다.",
    "type": "Ace"
  },
  {
    "id": "MT_001",
    "dbfid": 28,
    "cardClass": "Monster",
    "name": "Rumia",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 낮에만 발동할 수 있다. \n효과 : 자신 필드에 어둠을 1개 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_002",
    "dbfid": 29,
    "cardClass": "Monster",
    "name": "Mystia Lorelei",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 어둠이 있을 경우 발동할 수 있다. \n효과 : 필드에 어둠을 2개 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_003",
    "dbfid": 30,
    "cardClass": "Monster",
    "name": "Nazreen",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "효과 : 자신 덱에서 \"요과\"카드 한장을 가져온다.",
    "type": "Spell"
  },
  {
    "id": "MT_004",
    "dbfid": 31,
    "cardClass": "Monster",
    "name": "Inubashiri Momiji",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 어둠이 있을 경우 발동할 수 있다. \n효과 : 자신 덱 위에서 3장을 공개하고 그 중 1장을 패에 넣는다. 그 후 나머지 카드는 덱 맨 밑에 둔다.",
    "type": "Spell"
  },
  {
    "id": "MT_005",
    "dbfid": 32,
    "cardClass": "Monster",
    "name": "Miyako Yoshika",
    "attack": 3,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "상시 : 어둠에 존재하는 카드 1장당 이 카드의 스탯 1/1 상승한다. \n조건 : 필드에 어둠이 존재할 경우 발동할 수 있다. \n효과 : 사용하고 있지 않은 필드 1개에 어둠을 생성한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "MT_006",
    "dbfid": 33,
    "cardClass": "Monster",
    "name": "Ran Yakumo",
    "attack": 3,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "조건 1 : 자신 필드에 \"첸\"이 존재하지 않을 경우 발동할 수 있다. \n효과 1 : 덱/묘지에서 첸을 소환한다. \n조건 2 : 필드에 첸이 존재할 경우 발동할 수 있다. \n 효과 2 : 첸 아래에 존재하는 카드 1개를 묘지로 보내고 효과를 적용한다. \n몬스터 : 이번 턴 자신의 몬스터는 체력 1 미만으로 내려가지 않는다. \n행동 : 자신은 1장 드로우한다. \n대응 : 자신 묘지에 존재하는 카드 1장을 자신의 패로 가져온다. \n필드 : 이번 턴 필드의 효과는 무효화 된다.",
    "type": "Unit"
  },
  {
    "id": "MT_007",
    "dbfid": 34,
    "cardClass": "Monster",
    "name": "Chen",
    "attack": 0,
    "health": 4,
    "cost": 2,
    "rarity": "B",
    "collectible": true,
    "text": "상시 : 이카드는 이카드 아래에 존재하는 카드 1장당 0/1 스탯을 얻는다. \n조건 1 : 이 카드가 어둠에 존재하고 있을경우 드로우 페이즈에 발동할 수 있다. \n효과 1 : 상대 덱 맨 위에 카드를 1장 이카드 아래에 둔다.",
    "type": "Unit"
  },
  {
    "id": "MT_008",
    "dbfid": 35,
    "cardClass": "Monster",
    "name": "Yukari Yakumo",
    "attack": 0,
    "health": 0,
    "cost": 8,
    "rarity": "S",
    "collectible": true,
    "text": "상시 : 자신 필드에 \"야쿠모 란\", \"첸\"이 존재하지 않을경우 이카드는 소환 및 효과 발동을 할 수 없다. \n조건 1 : 상대가 몬스터/행동 효과를 발동했을 때 발동할 수 있다. \n효과 1 : 첸 아래에 있는 카드를 1장 묘지로 보내고 그 효과를 무효로 하고 파괴한다. \n조건 2 : 자신 필드에 \"야쿠모 란\", \"첸\", \"야쿠모 유카리\"만 존재할 경우 발동할 수 있다. \n효과 2 : 이 턴 종료시 까지 자신 필드의 \"야쿠모 란\", \"첸\"은 자신 필드의 \"야쿠모 유카리\"의 공격력과 수비력을 가진다.",
    "type": "Ace"
  },
  {
    "id": "MT_009",
    "dbfid": 36,
    "cardClass": "Monster",
    "name": "Kagerou Imaizumi",
    "attack": 2,
    "health": 4,
    "cost": 3,
    "rarity": "B",
    "collectible": true,
    "text": "상시 : 이 카드가 빛에 있을때는 이 카드는 공격할 수 없다. \n 이 카드가 어둠에 있을때 이 카드는 5/4가 된다. \n 이카드는 2번 공격할 수 있다.",
    "type": "Unit"
  },
  {
    "id": "MT_010",
    "dbfid": 37,
    "cardClass": "Monster",
    "name": "Lily White",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_001",
    "dbfid": 38,
    "cardClass": "Public",
    "name": "Lily White",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "C",
    "collectible": true,
    "text": "조건 : 필드존에 카드가 없어야 발동 할 수 있다. \n효과 : 덱에서 \"필드카드\" 1장을 필드존에 놓는다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_002",
    "dbfid": 39,
    "cardClass": "Public",
    "name": "Sunny Milk",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "효과 : 이 카드가 존재하는 한 자신 필드 3개를 빛으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_003",
    "dbfid": 40,
    "cardClass": "Public",
    "name": "Luna Child",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "효과 : 이 카드가 존재하는 한 자신 필드 3개를 어둠으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_004",
    "dbfid": 41,
    "cardClass": "Public",
    "name": "Minoriko Aki",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "B",
    "collectible": true,
    "text": "조건 : 1턴에 1번 \"필드카드\"가 존재하면 발동할 수 있다. \n효과 : 자신은 2장 드로우한다.",
    "type": "Spell"
  },
  {
    "id": "PB_005",
    "dbfid": 42,
    "cardClass": "Public",
    "name": "Shizuha Aki",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 1턴에 1번 필드존의 카드가 존재할 경우에만 발동할 수 있다. \n효과 : 자신 필드에 어둠을 생성한다.",
    "type": "Spell"
  },
  {
    "id": "PB_006",
    "dbfid": 43,
    "cardClass": "Public",
    "name": "Hina Kagiyama",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "A",
    "collectible": true,
    "text": "조건 : 필드에 카드가 없어야 발동 할 수 있다. \n효과 : 자신 필드 2개를 어둠으로 취급한다.",
    "type": "Spell",
    "behavior": "필드"
  },
  {
    "id": "PB_007",
    "dbfid": 44,
    "cardClass": "Public",
    "name": "Nitori Kawashiro",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "S",
    "collectible": true,
    "text": "효과 : 필드를 모두 초기화한다. \n조건 1 : 상대가 어둠의 효과를 발동한 턴에 발동할 수 있다. \n조건 2 : 이 카드가 필드존에 존재해야만 발동할 수 있다. \n효과 2 : 상대 필드 필드존에 있는 어둠카드는 파괴된 어둠카드에 공격력만큼의 피해를 입힌다.",
    "type": "Spell"
  },
  {
    "id": "PB_008",
    "dbfid": 45,
    "cardClass": "Public",
    "name": "Reimu Hakurei",
    "attack": 2,
    "health": 3,
    "cost": 3,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 자신 주위의 적에게 2의 피해를 입힌다.\n조건: 필드에 다른 미니언이 없을 때 발동한다.",
    "type": "Unit",
    "behavior": "대응"
  },
  {
    "id": "PB_009",
    "dbfid": 46,
    "cardClass": "Public",
    "name": "Marisa Kirisame",
    "attack": 3,
    "health": 2,
    "cost": 3,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 적 유닛 하나에게 3의 피해와 1의 관통 피해를 준다.\n조건: 주문 카드 보유 시 발동한다.",
    "type": "Unit",
    "behavior": "돌진"
  },
  {
    "id": "PB_010",
    "dbfid": 47,
    "cardClass": "Public",
    "name": "Sakuya Izayoi",
    "attack": 2,
    "health": 4,
    "cost": 4,
    "rarity": "A",
    "collectible": true,
    "text": "효과: 상대의 다음 행동 순서를 1회 지연시킨다.\n조건: 반드시 적 미니언 한 마리를 지정해야 한다.",
    "type": "Spell",
    "behavior": "전략"
  },
  {
    "id": "PB_011",
    "dbfid": 48,
    "cardClass": "Public",
    "name": "Alice Margatroid",
    "attack": 1,
    "health": 5,
    "cost": 4,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 소환한 인형마다 주문 비용이 1 감소한다.\n조건: 인형 카드가 필드에 존재할 때 발동한다.",
    "type": "Unit",
    "behavior": "필드"
  },
  {
    "id": "PB_012",
    "dbfid": 49,
    "cardClass": "Public",
    "name": "Patchouli Knowledge",
    "attack": 0,
    "health": 4,
    "cost": 5,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 모든 주문 카드의 효과를 1턴 연기시킨다.\n조건: 필드에 마법 카드가 1장 이상 있을 때 발동한다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_013",
    "dbfid": 50,
    "cardClass": "Public",
    "name": "Yuyuko Saigyouji",
    "attack": 1,
    "health": 6,
    "cost": 6,
    "rarity": "A",
    "collectible": true,
    "text": "효과: 피해를 입은 아군 미니언 한 마리를 회복시킨다.\n조건: 해당 미니언의 체력이 3 이하일 때 발동한다.",
    "type": "Unit",
    "behavior": "회복"
  },
  {
    "id": "PB_014",
    "dbfid": 51,
    "cardClass": "Public",
    "name": "Remilia Scarlet",
    "attack": 4,
    "health": 4,
    "cost": 5,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 모든 적 미니언에게 2의 피해를 준다.\n조건: 상대 턴에만 발동 가능하다.",
    "type": "Unit",
    "behavior": "광역"
  },
  {
    "id": "PB_015",
    "dbfid": 52,
    "cardClass": "Public",
    "name": "Flandre Scarlet",
    "attack": 5,
    "health": 3,
    "cost": 6,
    "rarity": "SS",
    "collectible": true,
    "text": "효과: 공격 시, 적 전장에 있는 모든 유닛에게 1의 피해를 준다.\n조건: 공격 성공 시 자동 발동한다.",
    "type": "Unit",
    "behavior": "대량"
  },
  {
    "id": "PB_016",
    "dbfid": 53,
    "cardClass": "Public",
    "name": "Nitori Kawashiro",
    "attack": 0,
    "health": 0,
    "cost": 0,
    "rarity": "S",
    "collectible": true,
    "text": "효과: 필드를 모두 초기화한다.\n조건 1: 상대가 어둠의 효과를 발동한 턴에,\n조건 2: 이 카드가 필드존에 존재할 때 발동한다.\n효과 2: 상대 필드의 어둠 카드에 피해를 입힌다.",
    "type": "Spell",
    "behavior": "대응"
  },
  {
    "id": "PB_017",
    "dbfid": 54,
    "cardClass": "Public",
    "name": "Cirno",
    "attack": 3,
    "health": 3,
    "cost": 4,
    "rarity": "B",
    "collectible": true,
    "text": "효과: 적 미니언 하나의 공격력을 1 감소시킨다.\n조건: 얼음 효과 발동 시, 대상 미니언의 공격력이 0 이하가 되지 않는다.",
    "type": "Spell",
    "behavior": "전략"
  }
]
</file>

<file path="simulator_core/src/card_gen/monster.rs.backup">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

#[allow(non_snake_case)]
pub fn MT_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

#[allow(non_snake_case)]
pub fn MT_002(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}

#[allow(non_snake_case)]
pub fn MT_003(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_004(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_005(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_006(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_007(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_008(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_009(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn MT_010(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/public.rs.backup">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

#[allow(non_snake_case)]
pub fn PB_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}
#[allow(non_snake_case)]
pub fn PB_002(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_003(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_004(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_005(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_006(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_007(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_008(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_009(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_010(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_011(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_012(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_013(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_014(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_015(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_016(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
#[allow(non_snake_case)]
pub fn PB_017(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
</file>

<file path="simulator_core/src/effect/effects.rs.backup">
use actix::Addr;

use crate::{card::Card, game::GameActor};

use super::{types::EffectSpeed, Effect};

// Effect 에 우선순위를 부여하는건 장기적으로 좋음.
pub struct Effects {
    // 항상 정렬 상태를 보장해야함.
    prioritized_effects: Vec<EffectTiming>,
}

impl Effects {
    pub fn new() -> Self {
        Self {
            prioritized_effects: vec![],
        }
    }

    pub fn add_effect(&mut self, effect: EffectTiming) {
        self.prioritized_effects.push(effect);
        self.prioritized_effects.sort_by_key(|e| e.get_priority());
    }

    pub fn get_effects(&self) -> Vec<&Box<dyn Effect>> {
        self.prioritized_effects
            .iter()
            .map(|e| e.get_effect())
            .collect::<Vec<_>>()
    }

    pub fn get_effects_mut(&mut self) -> Vec<&mut Box<dyn Effect>> {
        self.prioritized_effects
            .iter_mut()
            .map(|e| e.get_effect_mut())
            .collect::<Vec<_>>()
    }

    // 특정 조건을 만족하는 효과만 필터링 (조건을 클로저로 전달)
    pub fn filter_effects<F>(&self, filter: F) -> Vec<&EffectTiming>
    where
        F: Fn(&EffectTiming) -> bool,
    {
        self.prioritized_effects
            .iter()
            .filter(|e| filter(e))
            .collect()
    }

    // 체인 상태에서 추가 가능한 효과만 필터링
    pub fn get_chainable_effects(&self, current_chain_level: EffectSpeed) -> Vec<&EffectTiming> {
        self.prioritized_effects
            .iter()
            .filter(|e| {
                let timing = e.get_effect().get_speed();
                if timing >= current_chain_level {
                    return true;
                } else {
                    return false;
                }
            })
            .collect()
    }

    // 발동 가능한 효과만 필터링
    pub fn get_activatable_effects(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Vec<&EffectTiming> {
        todo!()
        // self.prioritized_effects
        //     .iter()
        //     .filter(|e| e.get_effect().can_activate(game, source))
        //     .collect()
    }
}

#[derive(Clone)]
pub struct EffectTiming {
    priority: u8, // 낮을수록 높은 우선순위
    speed: EffectSpeed,
    is_used: bool, // 효과가 사용되었는지 여부
    effect: Box<dyn Effect>,
}

impl EffectTiming {
    pub fn new(priority: u8, speed: EffectSpeed, effect: Box<dyn Effect>) -> Self {
        Self {
            priority,
            effect,
            speed,
            is_used: false,
        }
    }

    pub fn get_priority(&self) -> u8 {
        self.priority
    }

    pub fn get_speed(&self) -> EffectSpeed {
        self.speed
    }

    pub fn get_effect(&self) -> &Box<dyn Effect> {
        &self.effect
    }

    pub fn get_effect_mut(&mut self) -> &mut Box<dyn Effect> {
        &mut self.effect
    }
}
</file>

<file path="simulator_core/src/game_old/chain copy.rs">
use crate::{
    card::{
        effect::{Effect, EffectResult},
        types::PlayerType,
        Card, PrioritizedEffect,
    },
    exception::GameError,
    server::input_handler::InputAnswer,
};
use std::collections::HashSet;
use tracing::info;
use uuid::Uuid;

use super::{game_step::PlayCardResult, Game};

// 체인 처리 단계
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChainPhase {
    Building,  // 체인 구성 중 (효과 추가 가능)
    Resolving, // 체인 해결 중 (효과 실행 단계)
    Waiting,   // 사용자 입력 대기 중
    Completed, // 체인 처리 완료
}

impl Default for ChainPhase {
    fn default() -> Self {
        todo!()
    }
}

// 체인 아이템 구조체 (효과와 소스 카드 연결)
#[derive(Clone)]
pub struct ChainLink {
    effect: Box<dyn Effect>,
    source_card: Card,
}

#[derive(Clone, Default)]
pub struct Chain {
    // 체인 큐 (LIFO 방식으로 처리)
    links: Vec<ChainLink>,

    // 현재 체인 처리 단계
    current_phase: ChainPhase,

    // 현재 처리 중인 카드 (입력 대기 중일 때 사용)
    pending_card: Option<Card>,

    // 처리 대기 중인 효과들 (입력 후 체인에 추가 예정)
    pending_effects: Vec<PrioritizedEffect>,

    // 이미 처리된 효과 ID
    processed_effect_ids: HashSet<Uuid>,

    // 유저 입력 대기 정보
    waiting_effect_index: Option<usize>,
    waiting_input: Option<InputAnswer>,
}

impl Chain {
    pub fn new() -> Self {
        Self {
            links: Vec::new(),
            current_phase: ChainPhase::Completed, // 초기 상태는 완료
            pending_card: None,
            pending_effects: Vec::new(),
            processed_effect_ids: HashSet::new(),
            waiting_effect_index: None,
            waiting_input: None,
        }
    }

    /// 카드의 모든 효과를 처리합니다
    pub async fn process_card_effects(
        &mut self,
        game: &mut Game,
        player_type: PlayerType,
        card: Card,
    ) -> Result<PlayCardResult, GameError> {
        info!(
            "카드 효과 처리: player={:?}, card={:?}",
            player_type,
            card.get_uuid()
        );

        // 효과 처리 준비
        let effects = card.get_prioritized_effect();

        // 1. 즉발 효과 처리
        let result = self
            .process_immediate_effects(game, &card, &effects)
            .await?;

        // 2. 체인 효과 처리
        self.add_chain_effects(game, &card, &effects)?;

        // 3. 체인 해결
        if self.has_effects() {
            match self.resolve(game)? {
                ChainResolutionResult::Completed => Ok(PlayCardResult::Success),
                ChainResolutionResult::WaitingForInput(result) => Ok(result),
            }
        } else {
            Ok(PlayCardResult::Success)
        }
    }

    /// 즉발 효과 처리
    async fn process_immediate_effects(
        &mut self,
        game: &mut Game,
        card: &Card,
        effects: &[PrioritizedEffect],
    ) -> Result<Option<PlayCardResult>, GameError> {
        // 즉발 효과 수집
        let immediate_effects: Vec<_> = effects
            .iter()
            .filter(|e| e.get_effect().get_timing() == EffectLevel::Immediate)
            .collect();

        // let result = vec![];

        // 효과 처리
        for prioritized_effect in immediate_effects {
            // 이미 처리된 효과는 건너뛰기
            let effect_id = prioritized_effect.get_effect().get_id().into();
            if self.processed_effect_ids.contains(&effect_id) {
                continue;
            }

            if let Ok(effect_clone) = prioritized_effect.get_effect().clone_effect() {
                let result = effect_clone.begin_effect(game, card)?;

                match result {
                    EffectResult::Completed => {
                        // 효과 완료, 처리된 효과로 표시
                        self.processed_effect_ids.insert(effect_id);
                    }
                    EffectResult::NeedsInput { inner, handler } => {
                        let rx = game.get_input_waiter_mut().wait_for_input(inner).await?;
                        return Ok(Some(PlayCardResult::NeedInput(rx, handler)));
                    }
                }
            }
        }

        // 모든 즉발 효과가 완료됨
        Ok(None)
    }

    /// 체인 효과 추가
    fn add_chain_effects(
        &mut self,
        game: &mut Game,
        card: &Card,
        effects: &[PrioritizedEffect],
    ) -> Result<(), GameError> {
        // 체인 효과 수집
        let chain_effects: Vec<_> = effects
            .iter()
            .filter(|e| e.get_effect().get_timing() == EffectLevel::Chain)
            .collect();

        // 체인에 효과 추가
        for prioritized_effect in chain_effects {
            // 이미 처리된 효과는 건너뛰기
            let effect_id = prioritized_effect.get_effect().get_id().into();
            if self.processed_effect_ids.contains(&effect_id) {
                continue;
            }

            if let Ok(effect_clone) = prioritized_effect.get_effect().clone_effect() {
                self.add_effect(card.clone(), effect_clone);
            }
        }

        Ok(())
    }

    pub fn has_effects(&self) -> bool {
        !self.links.is_empty()
    }

    /// 체인에 효과 추가
    pub fn add_effect(&mut self, card: Card, effect: Box<dyn Effect>) {
        // 체인 구성 단계가 아니면 효과 추가 불가
        if self.current_phase != ChainPhase::Building {
            self.start_building(); // 새 체인 시작
        }

        // 효과를 체인 링크로 래핑하여 추가
        self.links.push(ChainLink {
            effect,
            source_card: card,
        });
    }

    /// 보류 중인 효과들을 체인에 추가
    pub fn pending_chain_effects(&mut self, card: Card, effects: Vec<PrioritizedEffect>) {
        // 입력 대기 상태로 변경
        self.current_phase = ChainPhase::Waiting;
        self.pending_card = Some(card);
        self.pending_effects = effects;
    }

    /// 사용자 입력 처리 후 보류 중인 효과 추가
    pub fn add_pending_effects_after_input(&mut self) -> Result<(), GameError> {
        if self.current_phase != ChainPhase::Waiting || self.pending_card.is_none() {
            return Err(GameError::InvalidChainState);
        }

        // 준비 단계로 전환
        self.current_phase = ChainPhase::Building;
        let card = self.pending_card.take().unwrap();

        // 벡터 소유권 가져오기
        let pending_effects = std::mem::take(&mut self.pending_effects);

        // 소유권을 가진 벡터 처리
        for prioritized_effect in pending_effects {
            let effect_id = prioritized_effect.get_effect().get_id();
            if !self.processed_effect_ids.contains(&effect_id.into()) {
                if let Ok(effect) = prioritized_effect.get_effect().clone_effect() {
                    self.add_effect(card.clone(), effect);
                }
            }
        }

        Ok(())
    }

    /// 체인 구성 시작
    pub fn start_building(&mut self) {
        // 이전 체인 상태 정리
        if self.current_phase == ChainPhase::Building || self.current_phase == ChainPhase::Resolving
        {
            // 이미 활성화된 체인이 있으면 처리 완료해야 함
            // 여기서는 간단히 초기화만 수행
            self.links.clear();
        }

        self.current_phase = ChainPhase::Building;
    }

    /// 체인 해결 시작
    pub fn start_resolving(&mut self) -> Result<(), GameError> {
        if self.links.is_empty() {
            return Ok(()); // 체인이 비어있으면 아무것도 안 함
        }

        self.current_phase = ChainPhase::Resolving;
        Ok(())
    }

    /// 체인의 모든 효과 해결
    pub fn resolve(&mut self, game: &mut Game) -> Result<ChainResolutionResult, GameError> {
        // 체인이 구성 중이면 해결 단계로 전환
        if self.current_phase == ChainPhase::Building {
            self.start_resolving()?;
        }

        // 해결 단계가 아니면 에러
        if self.current_phase != ChainPhase::Resolving {
            return Err(GameError::InvalidChainState);
        }

        // 대기 중인 입력이 있으면 처리
        if let Some(index) = self.waiting_effect_index {
            if let Some(input) = self.waiting_input.take() {
                let link = &self.links[index];
                let result = link.effect.handle_input(game, &link.source_card, input)?;

                match result {
                    EffectResult::Completed => {
                        // 효과 완료, 처리된 효과로 표시
                        self.processed_effect_ids
                            .insert(link.effect.get_id().into());
                        self.waiting_effect_index = None;
                    }
                    EffectResult::NeedsInput { inner, handler } => {
                        // 여전히 입력 필요
                        // return Ok(ChainResolutionResult::WaitingForInput(inner));
                    }
                }
            } else {
                // 대기 중인데 입력이 없으면 에러
                return Err(GameError::MissingInput);
            }
        }

        // LIFO 방식으로 체인 해결 (뒤에서부터 처리)
        while !self.links.is_empty() {
            let index = self.links.len() - 1;
            let link = &self.links[index];
            let effect_id = link.effect.get_id();

            // 이미 처리된 효과는 건너뛰기
            if self.processed_effect_ids.contains(&effect_id.into()) {
                self.links.pop();
                continue;
            }

            // 효과 실행
            let result = link.effect.begin_effect(game, &link.source_card)?;

            match result {
                EffectResult::Completed => {
                    // 효과 완료, 체인에서 제거
                    self.processed_effect_ids.insert(effect_id.into());
                    self.links.pop();
                }
                EffectResult::NeedsInput { inner, handler } => {
                    // 입력 대기 상태로 전환
                    self.waiting_effect_index = Some(index);
                    self.current_phase = ChainPhase::Waiting;
                    // return Ok(ChainResolutionResult::WaitingForInput(inner));
                }
            }
        }

        // 모든 효과 처리 완료
        self.current_phase = ChainPhase::Completed;
        Ok(ChainResolutionResult::Completed)
    }
}

impl Chain {
    /// 현재 체인 처리 단계 반환
    pub fn phase(&self) -> ChainPhase {
        self.current_phase
    }

    /// 현재 처리 중인 카드 참조 반환
    pub fn pending_card(&self) -> Option<&Card> {
        self.pending_card.as_ref()
    }

    /// 처리 대기 중인 효과들 참조 반환
    pub fn pending_effects(&self) -> &[PrioritizedEffect] {
        &self.pending_effects
    }

    /// 이미 처리된 효과 ID 목록 참조 반환
    // TODO: 사용된 효과는 특정 조건에 따라 다시 복구될 수 있어야함.
    pub fn processed_effect_ids(&self) -> &HashSet<Uuid> {
        &self.processed_effect_ids
    }

    /// 대기 중인 효과 인덱스 반환
    pub fn waiting_effect_index(&self) -> Option<usize> {
        self.waiting_effect_index
    }

    /// 대기 중인 사용자 입력 참조 반환
    pub fn waiting_input(&self) -> Option<&InputAnswer> {
        self.waiting_input.as_ref()
    }

    //
    // Setter 메서드 (필요한 필드만)
    //

    /// 체인 처리 단계 설정
    pub fn set_phase(&mut self, phase: ChainPhase) {
        self.current_phase = phase;
    }

    /// 처리 중인 카드 설정
    pub fn set_pending_card(&mut self, card: Option<Card>) {
        self.pending_card = card;
    }

    /// 대기 중인 효과들 설정
    pub fn set_pending_effects(&mut self, effects: Vec<PrioritizedEffect>) {
        self.pending_effects = effects;
    }

    /// 처리된 효과 ID 추가
    pub fn add_processed_effect_id(&mut self, effect_id: Uuid) {
        self.processed_effect_ids.insert(effect_id);
    }

    /// 처리된 효과 ID 목록 초기화
    pub fn clear_processed_effect_ids(&mut self) {
        self.processed_effect_ids.clear();
    }

    /// 효과가 이미 처리되었는지 확인
    pub fn is_effect_processed(&self, effect_id: &Uuid) -> bool {
        self.processed_effect_ids.contains(effect_id)
    }

    /// 대기 중인 효과 인덱스 설정
    pub fn set_waiting_effect_index(&mut self, index: Option<usize>) {
        self.waiting_effect_index = index;
    }

    /// 대기 중인 사용자 입력 설정
    pub fn set_waiting_input(&mut self, input: Option<InputAnswer>) {
        self.waiting_input = input;
    }

    //
    // 유틸리티 메서드
    //

    /// 대기 중인 효과 및 입력 정보 초기화
    pub fn clear_waiting_state(&mut self) {
        self.waiting_effect_index = None;
        self.waiting_input = None;
    }

    /// 모든 상태 초기화 (새 체인 시작용)
    pub fn reset(&mut self) {
        self.links.clear();
        self.current_phase = ChainPhase::Completed;
        self.pending_card = None;
        self.pending_effects.clear();
        self.processed_effect_ids.clear();
        self.clear_waiting_state();
    }
}

// 체인 해결 결과
pub enum ChainResolutionResult {
    Completed,                       // 모든 효과 처리 완료
    WaitingForInput(PlayCardResult), // 사용자 입력 대기
}
</file>

<file path="simulator_core/src/game_old/chain.rs">
use crate::{
    card::{types::PlayerType, Card},
    effect::{
        effects::EffectTiming,
        types::{EffectResult, EffectSpeed, HandlerType},
    },
    exception::GameError,
    server::input_handler::{InputAnswer, InputRequest},
};
use std::collections::HashSet;
use tracing::info;
use uuid::Uuid;

use super::{game_step::PlayCardResult, Game};

// 체인 처리 단계
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChainPhase {
    Idle,      // 대기 중 (새로운 체인 생서 가능)
    Building,  // 체인 구성 중 (효과 추가 가능)
    Resolving, // 체인 해결 중 (효과 실행 단계)
    Waiting,   // 사용자 입력 대기 중
    Completed, // 체인 처리 완료
}

impl Default for ChainPhase {
    fn default() -> Self {
        todo!()
    }
}

// 체인 아이템 구조체 (효과와 소스 카드 연결)
#[derive(Clone)]
pub struct ChainLink {
    effect: EffectTiming,
    source_card: Card,
}

#[derive(Clone, Default)]
pub struct Chain {
    // 체인 큐 (LIFO 방식으로 처리)
    links: Vec<ChainLink>,

    // 현재 체인 처리 단계
    current_phase: ChainPhase,

    // 이미 처리된 효과 ID
    processed_effect_ids: HashSet<Uuid>,
}

impl Chain {
    pub fn new() -> Self {
        Self {
            links: Vec::new(),
            current_phase: ChainPhase::Completed, // 초기 상태는 완료
            processed_effect_ids: HashSet::new(),
        }
    }

    /// 카드의 모든 효과를 처리합니다
    pub async fn process_card_effects(
        &mut self,
        game: &mut Game,
        player_type: PlayerType,
        card: Card,
    ) -> Result<PlayCardResult, GameError> {
        info!(
            "카드 효과 처리: player={:?}, card={:?}",
            player_type,
            card.get_uuid()
        );

        // 카드는 효과를 여러개 가질 수 있음.
        // 1. 카드의 효과는 각 게임 상태에 따라 발동 여부가 결정됨
        // 2. 개중에는 동시에 발동할 수 있는 효과도 있음 ( 이런 경우, 사용자가 무슨 효과를 발동할 지 선택함. )
        // 효과 중 이미 처리된 효과는 제외 해야함.
        // 이 때 이미 사용되었다고 해서 무조건 GameError 을 발생시키면 안됨.

        // 현재 입력된 카드의 효과를 가져옵니다.
        let effects = card.get_prioritized_effect().clone();

        // 발동 가능한 효과를 필터링 합니다.
        let activable_effects = effects
            .iter()
            .filter(|e| e.get_effect().can_activate(game, &card))
            .collect::<Vec<_>>();

        if activable_effects.is_empty() {
            // 발동 가능한 효과가 없으면 종료합니다.
            return Err(GameError::NoActivatableEffect);
        }

        // 발동 가능한 효과가 두 개 이상일 경우, 사용자로부터 선택을 받아야 합니다.
        if activable_effects.len() >= 2 {
            let rx = game
                .get_input_waiter_mut()
                .wait_for_input(InputRequest::SelectEffect {
                    source_card: card.get_uuid(),
                    potential_effects: activable_effects
                        .iter()
                        .map(|e| e.get_effect().get_id())
                        .collect(),
                })
                .await?;
            // TODO: HandlerType 넘겨서 외부 처리를 기대하는 패턴은 잘못된 것 같음.
            // 소유권, 생명 주기 관리가 어렵다
            // handle_input 에서 처리하거나 
            return Ok(PlayCardResult::NeedInput(
                rx,
                HandlerType::General(Box::new(
                    move |game: &mut Game,
                          source: &Card,
                          input: InputAnswer|
                          -> Result<EffectResult, GameError> {
                        Ok(EffectResult::Completed)
                    },
                )),
            ));
            // TODO: 무슨 효과를 발동할 지 선택 받아야함.
        }

        // 최종적으로 선택된 효과 하나를 가져옵니다.
        let activable_effect = *activable_effects.last().unwrap();

        match self.current_phase {
            // 체인이 대기 상태일 때
            ChainPhase::Idle => {
                // 바로 체인에 추가합니다.
                self.add_link_to_chain(activable_effect.clone(), card.clone());

                self.current_phase = ChainPhase::Building; // 체인 상태를 변경합니다.
            }
            // 체인이 구성 중일 때.
            ChainPhase::Building => {
                // 이전 체인 스피드를 확인하여 체인을 이어갈 수 있는지 확인합니다.
                // 체인 스피드가 같거나 빠른 경우에만 체인에 추가합니다.
                let last_effect = self.links.last().unwrap().effect.clone();

                // 현재 처리중인 효과의 이펙트 스피드가 체인보다 느릴 경우,
                if last_effect
                    .get_speed()
                    .can_it_chain(activable_effect.get_speed())
                    == false
                {
                    return Err(GameError::InvalidChainSpeed);
                }

                self.add_link_to_chain(activable_effect.clone(), card.clone());
            }
            _ => {
                // 체인 처리 중일 때는 추가할 수 없습니다.
                return Err(GameError::InvalidChainPhase);
            }
        }

        // 카드의 효과 중 발동될 수 있는 효과를 필터링 합니다.
        // 이 때 확인 사항은
        // 1. 효과가 발동될 수 있는 게임 상태인가?
        // 2. 아직 사용되지 않은 효과인가?

        todo!()
    }

    pub fn add_link_to_chain(&mut self, effect: EffectTiming, card: Card) {
        // 체인에 링크를 추가합니다.
        self.links.push(ChainLink {
            effect,
            source_card: card,
        });
    }

    pub fn can_add_to_chain(&self, effect_speed: EffectSpeed) -> bool {
        match self.current_phase {
            ChainPhase::Idle => true,
            ChainPhase::Building => {
                if let Some(last_link) = self.links.last() {
                    // 마지막 링크의 스피드와 비교하여 체인 가능 여부를 판단합니다.
                    return last_link.effect.get_speed().can_it_chain(effect_speed);
                } else {
                    // 체인이 비어있다면 추가 가능
                    return true;
                }
            }
            _ => false,
        }
    }
}

// 체인 해결 결과
pub enum ChainResolutionResult {
    Completed,                       // 모든 효과 처리 완료
    WaitingForInput(PlayCardResult), // 사용자 입력 대기
}
</file>

<file path="simulator_core/src/game_old/choice.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    card::types::PlayerType, enums::ZoneType, exception::GameError, server::jsons::game_features,
};

// ChoiceType 은 카드 선택의 종류를 나타냄
// 클라이언트 단으로 전달할 때, 게임 진행을 위한 정보가 여럿 포함되어 있는데.
// 이러한 정보들은 effect 로부터 얻어와야함.
// 대표적으로 DigEffect 의 경우, src, dest 정보가 필요함.
// src 의 경우 selector 에서 얻어오고
// dst 의 경우 insert 에서 얻어오면 될 듯?
// 근데 take, insert 는 카드를 어디서 가져오는지 정보를 가지고 있지 않음.
// 그러한 정보는 외부에서 저장되어있음.
// 그래서 Effect 자체에서 가지고 있는게 나을듯?
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChoiceType {
    Dig,          // 덱에서 카드 탐색
    Discard,      // 핸드에서 버릴 카드 선택
    SelectTarget, // 대상 선택 (유닛, 플레이어 등)
    Sacrifice,    // 희생할 카드 선택
    Rearrange,    // 카드 재배치/순서 변경
    RevealChoice, // 공개된 카드 중 선택
    MultiZone,    // 여러 영역에서 선택
}

impl ChoiceType {
    pub fn to_string(&self) -> String {
        match self {
            ChoiceType::Dig => "Dig".to_string(),
            ChoiceType::Discard => "Discard".to_string(),
            ChoiceType::SelectTarget => "SelectTarget".to_string(),
            ChoiceType::Sacrifice => "Sacrifice".to_string(),
            ChoiceType::Rearrange => "Rearrange".to_string(),
            ChoiceType::RevealChoice => "RevealChoice".to_string(),
            ChoiceType::MultiZone => "MultiZone".to_string(),
        }
    }
}

// 사용자
#[derive(Debug, Clone)]
pub struct ChoiceState {
    // 기본 정보
    player: PlayerType,
    choice_type: ChoiceType,

    // 소스 및 대상 정보
    source_card_id: Option<Uuid>,   // 선택 효과를 발동한 카드
    source_effect_id: Option<Uuid>, // 선택을 요청한 효과

    // 선택 제한 설정
    min_selections: usize, // 최소 선택 개수
    max_selections: usize, // 최대 선택 개수
    destination: ZoneType, // 선택 후 카드 목적지

    // 상태 관리
    is_open: bool,      // 선택이 활성화되어 있는지
    is_mandatory: bool, // 필수 선택 여부 (취소 불가)

    is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
}

impl Default for ChoiceState {
    fn default() -> Self {
        Self {
            player: PlayerType::Player1,
            choice_type: ChoiceType::Dig,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: true,
            is_mandatory: true,
            is_hidden_from_opponent: false,
        }
    }
}

impl ChoiceState {
    pub fn builder(player: PlayerType, choice_type: ChoiceType) -> ChoiceStateBuilder {
        ChoiceStateBuilder::new(player, choice_type)
    }

    pub fn new(
        player: PlayerType,
        choice_type: ChoiceType,
        source_card_id: Option<Uuid>,
        source_effect_id: Option<Uuid>,
        min_selections: usize,
        max_selections: usize,
        destination: ZoneType,
        is_open: bool,
        is_mandatory: bool,
        is_hidden_from_opponent: bool,
    ) -> Self {
        Self {
            player,
            choice_type,
            source_card_id,
            source_effect_id,
            min_selections,
            max_selections,
            destination,
            is_open,
            is_mandatory,
            is_hidden_from_opponent,
        }
    }

    pub fn serialize_message(&self) -> Result<String, GameError> {
        // ChoiceState의 정보를 ChoiceCardPayload로 변환
        let message = game_features::ChoiceCardRequestPayload {
            player: self.player.to_string(), // PlayerType을 문자열로 변환
            choice_type: self.choice_type.to_string(), // ChoiceType을 문자열로 변환
            source_card_id: self.source_card_id.unwrap(),
            min_selections: self.min_selections,
            max_selections: self.max_selections,
            destination: self.destination.to_string(),
            is_open: self.is_open,
            is_hidden_from_opponent: self.is_hidden_from_opponent,
        };

        // JSON 문자열로 직렬화
        serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
    }
}

pub struct ChoiceStateBuilder {
    player: PlayerType,
    choice_type: ChoiceType,
    source_card_id: Option<Uuid>,
    source_effect_id: Option<Uuid>,
    min_selections: usize,
    max_selections: usize,
    destination: ZoneType,
    is_open: bool,
    is_mandatory: bool,
    is_hidden_from_opponent: bool,
}

impl ChoiceStateBuilder {
    pub fn new(player: PlayerType, choice_type: ChoiceType) -> Self {
        Self {
            player,
            choice_type,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: false,
            is_mandatory: false,
            is_hidden_from_opponent: false,
        }
    }

    pub fn source_card(mut self, card_id: impl Into<Option<Uuid>>) -> Self {
        self.source_card_id = card_id.into();
        self
    }

    pub fn source_effect(mut self, effect_id: impl Into<Option<Uuid>>) -> Self {
        self.source_effect_id = effect_id.into();
        self
    }

    pub fn selections(mut self, min: usize, max: usize) -> Self {
        self.min_selections = min;
        self.max_selections = max;
        self
    }

    pub fn destination(mut self, destination: ZoneType) -> Self {
        self.destination = destination;
        self
    }

    pub fn open(mut self, is_open: bool) -> Self {
        self.is_open = is_open;
        self
    }

    pub fn mandatory(mut self, is_mandatory: bool) -> Self {
        self.is_mandatory = is_mandatory;
        self
    }

    pub fn hidden_from_opponent(mut self, is_hidden: bool) -> Self {
        self.is_hidden_from_opponent = is_hidden;
        self
    }

    pub fn build(self) -> ChoiceState {
        ChoiceState::new(
            self.player,
            self.choice_type,
            self.source_card_id,
            self.source_effect_id,
            self.min_selections,
            self.max_selections,
            self.destination,
            self.is_open,
            self.is_mandatory,
            self.is_hidden_from_opponent,
        )
    }
}
</file>

<file path="simulator_core/src/game_old/game_step.rs">
use std::fmt;

use tokio::sync::oneshot::Receiver;
use uuid::Uuid;

use tracing::{debug, error, info, instrument, trace, warn};

use crate::{
    card::{insert::TopInsert, take::TopTake, types::PlayerType},
    effect::types::HandlerType,
    exception::GameError,
    selector::TargetCount,
    server::input_handler::InputAnswer,
    zone::zone::Zone,
    LogExt,
};

use super::Game;

pub enum PhaseResult {
    Mulligan,
    DrawPhase,
    StandbyPhase,
    MainPhaseStart,
    MainPhase1,
    BattlePhaseStart,
    BattleStep,
    BattleDamageStepStart,
    BattleDamageStepCalculationBefore,
    BattleDamageStepCalculationStart,
    BattleDamageStepCalculationEnd,
    BattleDamageStepEnd,
    BattlePhaseEnd,
    MainPhase2,
    EndPhase,
}

type PhaseResultType = Result<PhaseResult, GameError>;

// mulligan 에 필요한 게임 함수들.
pub mod mulligan {
    use super::*;
    impl Game {
        #[instrument(skip(self), fields(player_type = ?player_type.into()))]
        pub fn get_mulligan_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            count: usize,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            debug!(
                "멀리건 카드 뽑기 시도: player={:?}, count={}",
                player_type, count
            );

            let result = self
                .get_player_by_type(player_type)
                .get()
                .get_deck_mut()
                .take_card(Box::new(TopTake(TargetCount::Exact(count))));

            match &result {
                Ok(cards) => {
                    debug!(
                        "덱에서 카드 추출 성공: player={:?}, count={}",
                        player_type,
                        cards.len()
                    );
                }
                Err(e) => {
                    // 에러 로깅 추가
                    error!(
                        "덱에서 카드 추출 실패: player={:?}, error={:?}",
                        player_type, e
                    );
                }
            }

            // 성공 시 UUID 변환
            let cards = result?
                .iter()
                .map(|card| card.get_uuid())
                .collect::<Vec<_>>();
            debug!(
                "멀리건 카드 뽑기 완료: player={:?}, card_count={}",
                player_type,
                cards.len()
            );

            Ok(cards)
        }

        #[instrument(skip(self), fields(player_type = ?player_type.into()))]
        pub fn add_select_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            cards: Vec<Uuid>,
            player_type: T,
        ) {
            let player_type = player_type.into();
            debug!(
                "멀리건 상태에 카드 추가 시작: player={:?}, cards={:?}",
                player_type, cards
            );

            let mut player = self.get_player_by_type(player_type).get();

            player
                .get_mulligan_state_mut()
                .add_select_cards(cards.clone());
            debug!("멀리건 상태에 카드 추가 완료: player={:?}", player_type);
        }

        pub fn add_reroll_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            payload_cards: Vec<Uuid>,
            rerolled_cards: Vec<Uuid>,
        ) {
            let player_type = player_type.into();
            debug!("선택 카드 제거: player={:?}", player_type);
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .remove_select_cards(payload_cards);

            debug!("리롤된 카드 추가: player={:?}", player_type);
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .add_select_cards(rerolled_cards);
        }

        pub fn reroll_request<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            cards: Vec<Uuid>,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            // 플레이어가 이미 준비 상태인 경우
            if self
                .get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .is_ready()
            {
                warn!("플레이어가 이미 준비 상태: player={:?}", player_type);
                return Err(GameError::AlreadyReady);
                // try_send_error!(session, GameError::AlreadyReady, retry 3);
            }

            // 플레이어가 선택한 카드가 유효한지 확인합니다.
            debug!("선택한 카드 유효성 검사: player={:?}", player_type);
            if let Err(e) = self.get_cards_by_uuids(cards.clone()) {
                error!("유효하지 않은 카드 선택: player={:?}", player_type);
                return Err(e);
            }

            // 기존 카드를 덱의 최하단에 위치 시킨 뒤, 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장하고 json 으로 변환하여 전송합니다.
            info!("카드 리롤 시작: player={:?}", player_type);
            let rerolled_card = match self.restore_then_reroll_mulligan_cards(player_type, cards) {
                Ok(cards) => {
                    debug!("카드 리롤 성공: card_count={}", cards.len());
                    cards
                }
                Err(e) => {
                    error!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
                    panic!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
                }
            };

            Ok(rerolled_card)
        }

        /// 멀리건 완료 처리 함수
        /// - 게임 객체를 받아서, 플레이어의 멀리건 상태를 완료로 변경하고, 선택한 카드들을 손으로 이동시킵니다.
        /// - 선택한 카드들의 UUID를 반환합니다.
        /// # Arguments
        /// * `game` - 게임 객체
        /// * `player_type` - 플레이어 타입
        /// # Returns
        /// * `Vec<Uuid>` - 선택한 카드들의 UUID

        pub fn process_mulligan_completion<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();

            // 선택된 멀리건 카드들의 UUID 를 얻습니다.
            let selected_cards = self
                .get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .get_select_cards();

            // UUID -> Card 객체로 변환하는 과정입니다.
            let cards = self.get_cards_by_uuids(selected_cards.clone())?;

            // add_card 함수를 통해 선택된 카드들을 손으로 이동시킵니다.
            self.get_player_by_type(player_type)
                .get()
                .get_hand_mut()
                .add_card(cards, Box::new(TopInsert))
                .map_err(|_| GameError::InternalServerError)?;

            // 멀리건 상태를 "완료" 상태로 변경합니다.
            self.get_player_by_type(player_type)
                .get()
                .get_mulligan_state_mut()
                .confirm_selection();

            // 그런 뒤, 선택한 카드들을 반환합니다.
            Ok(selected_cards)
        }

        pub fn check_player_ready_state<T: Into<PlayerType> + Copy>(&self, player_type: T) -> bool {
            let player_type = player_type.into();
            self.get_player_by_type(player_type.reverse())
                .get()
                .get_mulligan_state_mut()
                .is_ready()
        }
    }
}

pub enum PlayCardResult {
    Success,
    NeedInput(Receiver<InputAnswer>, HandlerType),
    Fail(GameError),
}

impl fmt::Debug for PlayCardResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PlayCardResult::Success => write!(f, "PlayCardResult::Success"),
            PlayCardResult::NeedInput(rx, _) => {
                write!(f, "PlayCardResult::NeedInput({:?}, <function>)", rx)
            }
            PlayCardResult::Fail(err) => write!(f, "PlayCardResult::Fail({:?})", err),
        }
    }
}

pub mod main_phase1 {

    use super::*;
    impl Game {
        // 카드를 처리하는 함수인데
        // 외부 ( end point ) 에서 사용하는 함수라서 카드 처리 함수는 이 함수로 유일해야함.

        // 카드의 효과 발동 방법은 다음과 같이 2 가지 유형으로 나뉘어짐.
        // 1. 카드 플레이 ( 핸드에서 필드로 카드를 낸 경우 )
        // 2. 특정 조건을 만족한 경우, 효과 발동 ( 카드 위치는 상관 없이 )
        // 이 함수는 1 번에 대해서만 처리하는 함수임.
        pub async fn proceed_card<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            card_uuid: Uuid,
        ) -> Result<PlayCardResult, GameError> {
            let player_type = player_type.into();
            info!(
                "카드 처리 시작: player={:?}, card_uuid={:?}",
                player_type, card_uuid
            );

            // 카드 조회 및 활성화 가능 여부 확인
            let card = self.get_cards_by_uuid(card_uuid)?;
            // card.can_activate(&self)?;

            // 효과 처리 다시 작업해야함.
            // 카드의 종료는 다음과 같음.
            // 1 . 프리체인 ( 체인에 안걸리고 바로 발동하는 효과들 )
            // 2 . 체인에 걸리는 효과들 ( 카드 효과들 )

            // 체인 형성 중 일반 카드 ( 일반 소환 등 )는 사용할 수 없음.
            // 카드 효과 유발에 레벨을 개념을 적용시켜야함.
            // 스펠 스피드 1, 2, 3 등으로 나눔.
            // 스펠 스피드 1 은 가장 느린 스피드를 가지는 효과로써, 체인을 이어갈 수 없음.
            // 스펠 스피드 2 는 스피드 1, 2에 효과에 대해 체인을 이어갈 수 있음.
            // 스펠 스피드 3 은 스피드 1, 2, 3에 효과에 대해 체인을 이어갈 수 있음.

            // Chain에 카드 효과 처리 위임
            let mut chain = std::mem::take(self.get_chain_mut());
            let result = chain.process_card_effects(self, player_type, card).await;
            *self.get_chain_mut() = chain;

            result
        }
    }
}

pub mod gmae_effects_funcs {

    use crate::{card::Card, effect::DigEffect};

    use super::*;

    impl Game {
        /// 카드 탐색(Digging) 기능을 수행합니다.
        ///
        /// # Arguments
        /// * `player_type` - 카드를 탐색하는 플레이어
        /// * `effect_id` - 사용할 탐색 효과의 ID
        /// * `card_uuid` - 탐색 효과가 있는 소스 카드의 UUID
        ///
        /// # Returns
        /// * `Result<Vec<Uuid>, GameError>` - 탐색 가능한 카드들의 UUID 목록
        pub fn digging_cards<T: Into<PlayerType> + Copy>(
            &mut self,
            player_type: T,
            effect_id: Uuid,
            card_uuid: Uuid,
        ) -> Result<Vec<Uuid>, GameError> {
            let player_type = player_type.into();
            info!(
                "카드 탐색 시작: player={:?}, effect_id={:?}, card={}",
                player_type, effect_id, card_uuid
            );

            // 1. 소스 카드 찾기
            let source_card = self.get_cards_by_uuid(card_uuid)?;

            // 2. 카드에서 해당 Dig 효과 찾기
            let dig_effect = self.find_dig_effect(&source_card, effect_id)?;

            // 3. 선택 가능한 카드들 찾기
            let selectable_cards = dig_effect
                .get_selector()
                .select_targets(self, &source_card)
                .map_err(|e| {
                    error!("대상 선택 실패: {:?}", e);
                    GameError::InvalidTarget
                })?;

            // 4. 선택 가능한 카드가 없는 경우 처리
            if selectable_cards.is_empty() {
                warn!("선택 가능한 카드가 없음: player={:?}", player_type);
                return Err(GameError::NoValidTargets);
            }

            // 5. UUID 목록 생성
            let card_uuids: Vec<Uuid> = selectable_cards
                .iter()
                .map(|card| card.get_uuid())
                .collect();

            debug!(
                "탐색 가능한 카드: count={}, uuids={:?}",
                card_uuids.len(),
                card_uuids
            );

            Ok(card_uuids)
        }

        /// 카드에서 특정 ID를 가진 DigEffect를 찾습니다.
        fn find_dig_effect<'a>(
            &mut self,
            card: &'a Card,
            effect_id: Uuid,
        ) -> Result<&'a DigEffect, GameError> {
            // 효과 찾기
            let effect = card
                .get_prioritized_effect()
                .iter()
                .find(|e| e.get_effect().get_id() == effect_id)
                .ok_or_else(|| {
                    error!("효과를 찾을 수 없음: effect_id={:?}", effect_id);
                    GameError::EffectNotFound
                })?;

            // DigEffect로 다운캐스팅
            effect
                .get_effect()
                .as_any()
                .downcast_ref::<DigEffect>()
                .ok_or_else(|| {
                    error!(
                        "잘못된 효과 타입: expected=DigEffect, effect_id={:?}",
                        effect_id
                    );
                    GameError::InvalidEffectType
                })
        }
    }
}

impl Game {
    // pub fn handle_phase_start(&mut self) -> PhaseResultType {
    //     match self.get_phase() {
    //         Phase::Mulligan => Ok(PhaseResult::Mulligan),
    //         Phase::DrawPhase => Ok(PhaseResult::DrawPhase),
    //         Phase::StandbyPhase => self.handle_standby_phase(),
    //         Phase::MainPhaseStart => self.handle_main_phase_start(),
    //         Phase::MainPhase1 => self.handle_main_phase_1(),
    //         Phase::BattlePhaseStart => self.handle_battle_phase_start(),
    //         Phase::BattleStep => self.handle_battle_step(),
    //         Phase::BattleDamageStepStart => self.handle_damage_step_start(),
    //         Phase::BattleDamageStepCalculationBefore => self.handle_before_damage_calculation(),
    //         Phase::BattleDamageStepCalculationStart => self.handle_damage_calculation(),
    //         Phase::BattleDamageStepCalculationEnd => self.handle_after_damage_calculation(),
    //         Phase::BattleDamageStepEnd => self.handle_damage_step_end(),
    //         Phase::BattlePhaseEnd => self.handle_battle_phase_end(),
    //         Phase::MainPhase2 => self.handle_main_phase_2(),
    //         Phase::EndPhase => self.handle_end_phase(),
    //     }
    // }

    pub fn handle_muliigan_phase(&mut self) {
        // 멀리건 페이즈 시작
        info!("멀리건 페이즈 시작");

        // 멀리건 페이즈 종료
        info!("멀리건 페이즈 종료");
    }

    #[instrument(skip(self), fields(player_type = ?player_type.into()))]
    pub fn handle_draw_phase<T: Into<PlayerType> + Copy>(
        &mut self,
        player_type: T,
    ) -> Result<Uuid, GameError> {
        let player_type = player_type.into();
        info!("드로우 페이즈 시작: player={:?}", player_type);

        trace!("드로우 페이즈 효과 발동 중...");
        // self.trigger_draw_phase_effects()?;
        debug!("드로우 페이즈 효과 발동 완료");

        let card = self
            .draw_card(player_type)
            .log_ok(|| debug!("카드 드로우 성공: player={:?}", player_type,))
            .map_err(|e| {
                error!("카드 드로우 실패: player={:?}, error={:?}", player_type, e);
                e
            })?;

        debug!(
            "카드 드로우 성공: player={:?}, card_uuid={}",
            player_type,
            card.get_uuid()
        );

        trace!("핸드에 카드 추가 시작: player={:?}", player_type);
        let mut player = self.get_player_by_type(player_type).get();

        player
            .get_hand_mut()
            .add_card(vec![card.clone()], Box::new(TopInsert))
            .log_ok(|| debug!("핸드에 카드 추가 성공: player={:?}", player_type))
            .log_err(|e| {
                warn!(
                    "핸드에 카드 추가 중 문제 발생: player={:?}, error={:?}",
                    player_type, e
                )
            })?;

        info!(
            "드로우 페이즈 완료: player={:?}, card_uuid={}",
            player_type,
            card.get_uuid()
        );
        Ok(card.get_uuid())
    }

    pub fn handle_standby_phase(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈에서 발동하는 효과들 처리
        self.trigger_standby_effects()?;
        todo!()
    }

    pub fn handle_main_phase_start(&mut self) -> PhaseResultType {
        // 메인 페이즈 1 개시시 효과 처리
        self.trigger_main_phase_start_effects()?;
        todo!()
    }

    fn handle_main_phase_1(&mut self) -> PhaseResultType {
        // 메인 페이즈 1 진입 처리
        todo!()
    }

    fn handle_battle_phase_start(&mut self) -> PhaseResultType {
        // 배틀 페이즈 개시시 효과 처리
        self.trigger_battle_phase_start_effects()?;
        todo!()
    }

    fn handle_battle_step(&mut self) -> PhaseResultType {
        // 배틀 스텝 처리
        todo!()
    }

    fn handle_damage_step_start(&mut self) -> PhaseResultType {
        // 데미지 스텝 시작 처리
        self.trigger_damage_step_start_effects()?;
        todo!()
    }

    fn handle_before_damage_calculation(&mut self) -> PhaseResultType {
        // 데미지 계산 전 효과 처리
        todo!()
    }

    fn handle_damage_calculation(&mut self) -> PhaseResultType {
        // 실제 데미지 계산 처리
        self.calculate_battle_damage()?;
        todo!()
    }

    fn handle_after_damage_calculation(&mut self) -> PhaseResultType {
        // 데미지 계산 후 효과 처리
        todo!()
    }

    fn handle_damage_step_end(&mut self) -> PhaseResultType {
        // 데미지 스텝 종료 처리
        todo!()
    }

    fn handle_battle_phase_end(&mut self) -> PhaseResultType {
        // 배틀 페이즈 종료 처리
        todo!()
    }

    fn handle_main_phase_2(&mut self) -> PhaseResultType {
        // 메인 페이즈 2 처리
        todo!()
    }

    fn handle_end_phase(&mut self) -> PhaseResultType {
        // 턴 종료 처리
        self.handle_turn_end()?;
        todo!()
    }

    /// 페이즈 종료 시 처리
    fn handle_phase_end(&mut self) -> PhaseResultType {
        // 현재 페이즈 종료 시 필요한 처리
        todo!()
    }

    /// 턴 종료 처리
    fn handle_turn_end(&mut self) -> PhaseResultType {
        todo!()
    }

    //
    fn trigger_draw_phase_effects(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈 효과 발동
        todo!()
    }

    // 유틸리티 메서드들
    fn trigger_standby_effects(&mut self) -> PhaseResultType {
        // 스탠바이 페이즈 효과 발동
        todo!()
    }

    fn trigger_main_phase_start_effects(&mut self) -> PhaseResultType {
        // 메인 페이즈 개시시 효과 발동
        todo!()
    }

    fn trigger_battle_phase_start_effects(&mut self) -> PhaseResultType {
        // 배틀 페이즈 개시시 효과 발동
        todo!()
    }

    fn trigger_damage_step_start_effects(&mut self) -> PhaseResultType {
        // 데미지 스텝 개시시 효과 발동
        todo!()
    }

    fn calculate_battle_damage(&mut self) -> PhaseResultType {
        // 전투 데미지 계산
        todo!()
    }

    fn check_hand_limit(&mut self) -> PhaseResultType {
        // 손 카드 제한(10장) 체크
        todo!()
    }
}
</file>

<file path="simulator_core/src/game_old/getter.rs">
use crate::{
    card::{types::PlayerType, Card},
    enums::ZoneType,
    zone::zone::Zone,
};

use super::Game;

impl Game {
    pub fn get_cards_by_player_and_zone_type(
        &self,
        player_type: PlayerType,
        zone_type: ZoneType,
    ) -> Vec<Card> {
        match (player_type, zone_type) {
            (PlayerType::Player1, ZoneType::Hand) => self.get_player_hand_cards(),
            (PlayerType::Player1, ZoneType::Field) => self.get_player_field_cards(),
            (PlayerType::Player1, ZoneType::Deck) => self.get_player_deck_cards(),
            (PlayerType::Player1, ZoneType::Graveyard) => self.get_player_graveyard_cards(),

            (PlayerType::Player2, ZoneType::Hand) => self.get_opponent_hand_cards(),
            (PlayerType::Player2, ZoneType::Field) => self.get_opponent_field_cards(),
            (PlayerType::Player2, ZoneType::Deck) => self.get_opponent_deck_cards(),
            (PlayerType::Player2, ZoneType::Graveyard) => self.get_opponent_graveyard_cards(),

            (_, ZoneType::Effect) => todo!(),
            (_, ZoneType::None) => panic!("Zone type is not allowed to be None"),
        }
    }

    pub fn get_player_field_cards(&self) -> Vec<Card> {
        self.get_player().get().get_field().get_cards().clone()
    }

    pub fn with_player_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_field_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_field_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_field().get_cards().clone()
    }

    pub fn with_opponent_field_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_field_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 핸드 카드
    pub fn get_player_hand_cards(&self) -> Vec<Card> {
        self.get_player().get().get_hand().get_cards().clone()
    }

    pub fn with_player_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_hand_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_hand_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_hand().get_cards().clone()
    }

    pub fn with_opponent_hand_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_hand_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 묘지 카드
    pub fn get_player_graveyard_cards(&self) -> Vec<Card> {
        self.get_player().get().get_graveyard().get_cards().clone()
    }

    pub fn with_player_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_graveyard_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_graveyard_cards(&self) -> Vec<Card> {
        self.get_opponent()
            .get()
            .get_graveyard()
            .get_cards()
            .clone()
    }

    pub fn with_opponent_graveyard_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_graveyard_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    // 덱 카드
    pub fn get_player_deck_cards(&self) -> Vec<Card> {
        self.get_player().get().get_deck().get_cards().clone()
    }

    pub fn with_player_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_player()
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }

    pub fn get_opponent_deck_cards(&self) -> Vec<Card> {
        self.get_opponent().get().get_deck().get_cards().clone()
    }

    pub fn with_opponent_deck_cards<F, C>(&mut self, mut condition: C, modifier: F)
    where
        C: FnMut(&Card) -> bool,
        F: FnMut(&mut Card),
    {
        self.get_opponent()
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .iter_mut()
            .filter(|card| condition(card))
            .for_each(modifier);
    }
}
</file>

<file path="simulator_core/src/game_old/helper.rs">
use uuid::Uuid;

use crate::{card::types::PlayerType, exception::GameError};

use super::Game;

impl Game {
    pub fn restore_then_reroll_mulligan_cards<T: Into<PlayerType>>(
        &mut self,
        player_type: T,
        exclude_cards: Vec<Uuid>,
    ) -> Result<Vec<Uuid>, GameError> {
        let player_type = player_type.into();
        self.restore_card(player_type, &exclude_cards)?;
        let new_cards = self.get_mulligan_cards(player_type, exclude_cards.len())?;
        Ok(new_cards)
    }
}

#[macro_export]
macro_rules! downcast_effect {
    ($effect:expr, $target_type:ty) => {
        if $effect.get_effect_type() == <$target_type>::static_effect_type() {
            if let Some(specific) = $effect.as_any().downcast_ref::<$target_type>() {
                Some(specific)
            } else {
                None
            }
        } else {
            None
        }
    };
}

pub async fn wait_for_input() -> Result<(), GameError> {
    todo!()
}
</file>

<file path="simulator_core/src/game_old/mod.rs">
pub mod chain;
pub mod choice;
pub mod game_step;
mod getter;
mod helper;
pub mod phase;
pub mod turn_manager;

use std::collections::HashMap;

use chain::Chain;
use phase::{Phase, PhaseState};
use turn_manager::Turn;
use uuid::Uuid;

use crate::{
    card::{cards::CardVecExt, insert::BottomInsert, take::BottomTake, types::PlayerType, Card},
    enums::DeckCode,
    exception::GameError,
    selector::TargetCount,
    server::input_handler::InputWaiter,
    unit::player::{Player, Resoruce},
    utils::deckcode_to_cards,
    zone::zone::Zone,
    OptArc,
};

pub struct GameConfig {
    /// Player's Deckcode
    pub player_1_deckcode: DeckCode,
    pub player_2_deckcode: DeckCode,

    /// 1 : Player 1,
    /// 2 : Player 2
    pub attacker: usize,
}

/// 게임의 상태를 관리/저장 하는 구조체
/// Card 로 인한 모든 변경 사항은 Task 로써 저장되며,
/// 그것을 담은 Tasks 를 Procedure 에게 전달하여 게임 결과를 계산한다.
#[derive(Clone)]
pub struct Game {
    pub player1: OptArc<Player>,
    pub player2: OptArc<Player>,
    pub phase_state: PhaseState,
    pub turn: Turn,
    pub chain: Chain,
    pub input_waiter: InputWaiter,
}

/// initialize 함수에 GameConfig 을 넣음으로써 두 플레이어의 Cards 을 설정한다.
impl Game {
    pub fn initialize(&mut self, _config: GameConfig) -> Result<(), GameError> {
        let cards = deckcode_to_cards(_config.player_1_deckcode, _config.player_2_deckcode)?;

        // TODO: Limit 을 const 로 빼야함.
        let cost = Resoruce::new(0, 10);
        let mana = Resoruce::new(0, 3);
        self.player1 = OptArc::new(Player::new(
            OptArc::none(),
            PlayerType::Player1,
            cards[0].clone(),
            cost.clone(),
            mana.clone(),
        ));
        self.player2 = OptArc::new(Player::new(
            OptArc::none(),
            PlayerType::Player2,
            cards[1].clone(),
            cost,
            mana,
        ));

        self.player1
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .extend(cards[0].clone());
        self.player2
            .get()
            .get_deck_mut()
            .get_cards_mut()
            .extend(cards[1].clone());
        Ok(())
    }
}

impl Game {
    pub fn get_player_by_type<T: Into<PlayerType> + Copy>(
        &self,
        player_type: T,
    ) -> &OptArc<Player> {
        match player_type.into() {
            PlayerType::Player1 => &self.player1,
            PlayerType::Player2 => &self.player2,
        }
    }

    pub fn get_turn(&self) -> &Turn {
        &self.turn
    }

    pub fn get_phase(&self) -> Phase {
        self.phase_state.get_phase()
    }

    pub fn get_phase_state_mut(&mut self) -> &mut PhaseState {
        &mut self.phase_state
    }

    pub fn get_phase_state(&mut self) -> &PhaseState {
        &self.phase_state
    }

    pub fn get_turn_mut(&mut self) -> &mut Turn {
        &mut self.turn
    }

    pub fn move_phase(&mut self) {
        self.phase_state.get_phase().move_to_next_phase();
    }

    pub fn get_player(&self) -> &OptArc<Player> {
        &self.player1
    }

    pub fn get_opponent(&self) -> &OptArc<Player> {
        &self.player2
    }

    pub fn get_chain_mut(&mut self) -> &mut Chain {
        &mut self.chain
    }

    pub fn get_input_waiter_mut(&mut self) -> &mut InputWaiter {
        &mut self.input_waiter
    }

    // pub fn resolve_chain(&mut self) -> Result<(), GameError> {
    //     self.chain.resolve(self)?;
    //     Ok(())
    // }

    pub fn get_chain(&self) -> &Chain {
        &self.chain
    }

    /// 플레이어의 덱에서 카드를 뽑아 손에 추가합니다.
    /// # Parameters
    /// * `player_type` - 덱에서 카드를 뽑을 플레이어의 종류입니다.
    /// # Returns
    /// * 뽑은 카드를 반환합니다.
    /// # Errors
    /// * 덱에 카드가 없을 경우 NoCardsLeft 에러를 반환합니다.
    pub fn draw_card(&mut self, player_type: PlayerType) -> Result<Card, GameError> {
        let result = self
            .get_player_by_type(player_type)
            .get()
            .get_deck_mut()
            .take_card(Box::new(BottomTake(TargetCount::Exact(1))))?;

        // TODO: 이 확인이 필요한가?
        if result.is_empty() {
            return Err(GameError::NoCardsLeft);
        }

        Ok(result[0].clone())
    }

    /// 파라미터로 들어오는 카드들을 덱의 맨 밑으로 복원합니다.
    ///
    /// # Parameters
    /// * `player_type` - 카드를 복원할 플레이어 타입
    /// * `src_cards` - 복원할 카드들의 UUID 목록
    ///
    /// # Returns
    /// * `Ok(())` - 모든 카드가 성공적으로 덱의 맨 밑에 추가됨
    /// * `Err(GameError)` - 카드 복원 중 오류 발생
    ///
    /// # Errors
    /// * `GameError::CardNotFound` - 지정된 UUID를 가진 카드를 플레이어가 소유하지 않은 경우
    /// * `GameError::ExceededCardLimit` - 덱에 자리가 없어 카드를 추가할 수 없는 경우
    ///
    pub fn restore_card(
        &mut self,
        player_type: PlayerType,
        src_cards: &Vec<Uuid>,
    ) -> Result<(), GameError> {
        for card_uuid in src_cards {
            let card = {
                let player = self.get_player_by_type(player_type).get();
                match player.get_cards().find_by_uuid(card_uuid.clone()) {
                    Some(card) => card.clone(),
                    None => return Err(GameError::CardNotFound),
                }
            };
            self.get_player_by_type(player_type)
                .get()
                .get_deck_mut()
                .add_card(vec![card.clone()], Box::new(BottomInsert))?;
        }
        Ok(())
    }

    /// 두 플레이어의 카드 목록에서 입력받은 UUID에 해당하는 카드를 순서대로 찾아 반환합니다.
    ///
    /// # 설명
    /// - 플레이어와 상대방의 모든 카드 목록을 합쳐서, 각 카드의 고유한 UUID를 key로 하는 HashMap을 생성합니다.
    /// - 입력받은 UUID 리스트의 순서대로 해당 카드들을 찾아 Vec<Card>로 반환합니다.
    ///
    /// # Parameters
    /// - `uuids`: 찾고자 하는 카드의 고유 식별자(UUID)들이 담긴 벡터입니다.
    ///             각 UUID는 고유하다고 가정합니다.
    ///
    /// # Returns
    /// - 입력받은 순서대로 찾은 카드들을 담은 Vec<Card>를 반환합니다.
    ///
    /// # Panics
    /// - 만약 입력받은 UUID 중 하나라도 플레이어와 상대방의 카드 목록에서 찾지 못하면,
    ///   GameError::CardsNotFound 에러를 반환합니다.
    pub fn get_cards_by_uuids(&self, uuids: Vec<Uuid>) -> Result<Vec<Card>, GameError> {
        let player = self.get_player().get();
        let opponent = self.get_opponent().get();

        // 두 카드 리스트를 하나의 iterator로 합칩니다.
        // UUID가 고유하다고 가정하므로, (uuid, card) 쌍을 HashMap에 저장할 수 있습니다.
        let card_map: HashMap<Uuid, Card> = player
            .get_cards()
            .iter()
            .chain(opponent.get_cards().iter())
            .map(|card| (card.get_uuid(), card.clone()))
            .collect();

        // 입력한 uuid 순서대로 카드들을 찾아서 반환합니다.
        // 입력 uuid 중 하나라도 매칭되는 카드가 없으면 panic! 합니다.
        let mut results = Vec::with_capacity(uuids.len());
        for uuid in uuids {
            if let Some(card) = card_map.get(&uuid) {
                results.push(card.clone());
            } else {
                return Err(GameError::CardsNotFound);
            }
        }
        Ok(results)
    }

    /// 두 플레이어의 카드 목록에서 입력받은 UUID에 해당하는 카드를 순서대로 찾아 반환합니다.
    ///
    /// # 설명
    /// - 플레이어와 상대방의 모든 카드 목록을 합쳐서, 각 카드의 고유한 UUID를 key로 하는 HashMap을 생성합니다.
    /// - 입력받은 UUID 리스트의 순서대로 해당 카드들을 찾아 Card로 반환합니다.
    ///
    /// # Parameters
    /// - `uuids`: 찾고자 하는 카드의 고유 식별자(UUID)들이 담긴 벡터입니다.
    ///             각 UUID는 고유하다고 가정합니다.
    ///
    /// # Returns
    /// - 입력받은 순서대로 찾은 카드들을 담은 Card를 반환합니다.
    ///
    /// # Panics
    /// - 만약 입력받은 UUID 를 가지고 플레이어와 상대방의 카드 목록에서 찾지 못하면,
    ///   GameError::CardNotFound 에러를 반환합니다.
    pub fn get_cards_by_uuid(&self, uuid: Uuid) -> Result<Card, GameError> {
        let player = self.get_player().get();
        let opponent = self.get_opponent().get();

        // 두 카드 리스트를 하나의 iterator로 합칩니다.
        // UUID가 고유하다고 가정하므로, (uuid, card) 쌍을 HashMap에 저장할 수 있습니다.
        let card_map: HashMap<Uuid, Card> = player
            .get_cards()
            .iter()
            .chain(opponent.get_cards().iter())
            .map(|card| (card.get_uuid(), card.clone()))
            .collect();

        // 입력한 uuid 순서대로 카드들을 찾아서 반환합니다.
        // 입력 uuid 중 하나라도 매칭되는 카드가 없으면 panic! 합니다.
        card_map.get(&uuid).cloned().ok_or(GameError::CardNotFound)
    }
}

// TODO: 게임의 상태를 hash 로 변환해서 제공해야함.
</file>

<file path="simulator_core/src/game_old/phase.rs">
use std::collections::HashSet;

use crate::card::types::PlayerType;

#[derive(Clone)]
pub struct PhaseState {
    current_phase: Phase,
    completed_players: HashSet<PlayerType>,
}

impl PhaseState {
    pub fn new(phase: Phase) -> Self {
        Self {
            current_phase: phase,
            completed_players: HashSet::new(),
        }
    }

    pub fn has_player_completed(&self, player_type: PlayerType) -> bool {
        self.completed_players.contains(&player_type)
    }

    pub fn mark_player_completed(&mut self, player_type: PlayerType) {
        self.completed_players.insert(player_type);
    }

    pub fn reset_player_completed(&mut self, player_type: PlayerType) {
        self.completed_players.remove(&player_type);
    }

    pub fn reset(&mut self) {
        self.completed_players.clear();
    }

    pub fn get_phase(&self) -> Phase {
        self.current_phase
    }

    pub fn set_phase(&mut self, phase: Phase) {
        self.current_phase = phase;
    }
}

#[derive(Clone, PartialEq, Eq, Copy, Debug)]
pub enum Phase {
    Heartbeat,

    Mulligan,

    // 가장 먼저 시작되는 드로우 페이즈 ( 기타 자원 등 증가함. )
    DrawPhase,

    // 메인 페이즈 진입 전 시작되는 페이즈
    StandbyPhase,

    // 메인 페이즈 개시시
    MainPhaseStart,
    // 메인 페이즈 개시중
    MainPhase1,

    // 배틀 페이즈 진입
    BattlePhaseStart,
    // 배틀 페이즈 중
    BattleStep,
    // 데미지 스텝 개시시
    BattleDamageStepStart,
    // 데미지 계산 전
    BattleDamageStepCalculationBefore,
    // 데미지 계산 중
    BattleDamageStepCalculationStart,
    // 데미지 계산 후
    BattleDamageStepCalculationEnd,
    // 데미지 스텝 종료시
    BattleDamageStepEnd,
    // 데미지 페이즈 종료
    BattlePhaseEnd,

    // 메인 페이즈2 시작
    MainPhase2,

    // 턴 종료
    EndPhase,
}

impl From<String> for Phase {
    fn from(value: String) -> Self {
        match value.to_lowercase().as_str() {
            "mulligan" => Phase::Mulligan,
            "drawphase" => Phase::DrawPhase,
            "standbyphase" => Phase::StandbyPhase,
            "mainphasestart" => Phase::MainPhaseStart,
            "mainphase1" => Phase::MainPhase1,
            "battlephasestart" => Phase::BattlePhaseStart,
            "battlestep" => Phase::BattleStep,
            "battledamagestepstart" => Phase::BattleDamageStepStart,
            "battledamagestepcalculationbefore" => Phase::BattleDamageStepCalculationBefore,
            "battledamagestepcalculationstart" => Phase::BattleDamageStepCalculationStart,
            "battledamagestepcalculationend" => Phase::BattleDamageStepCalculationEnd,
            "battledamagestepend" => Phase::BattleDamageStepEnd,
            "battlephaseend" => Phase::BattlePhaseEnd,
            "mainphase2" => Phase::MainPhase2,
            "endphase" => Phase::EndPhase,
            "heartbeat" => Phase::Heartbeat,
            _ => panic!("Invalid Phase string: {}", value),
        }
    }
}

impl PartialOrd for Phase {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Phase {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.order().cmp(&other.order())
    }
}

impl Phase {
    fn order(&self) -> u8 {
        match self {
            Phase::Mulligan => 0,
            Phase::DrawPhase => 1,
            Phase::StandbyPhase => 2,
            Phase::MainPhaseStart => 3,
            Phase::MainPhase1 => 4,
            Phase::BattlePhaseStart => 5,
            Phase::BattleStep => 6,
            Phase::BattleDamageStepStart => 7,
            Phase::BattleDamageStepCalculationBefore => 8,
            Phase::BattleDamageStepCalculationStart => 9,
            Phase::BattleDamageStepCalculationEnd => 10,
            Phase::BattleDamageStepEnd => 11,
            Phase::BattlePhaseEnd => 12,
            Phase::MainPhase2 => 13,
            Phase::EndPhase => 14,
            Phase::Heartbeat => 15,
        }
    }

    /// 현재 페이즈가 드로우 페이즈인지 확인
    pub fn is_draw_phase(&self) -> bool {
        matches!(self, Phase::DrawPhase)
    }

    /// 현재 페이즈가 스탠바이 페이즈인지 확인
    pub fn is_standby_phase(&self) -> bool {
        matches!(self, Phase::StandbyPhase)
    }

    /// 메인 페이즈 1 관련 체크
    pub fn is_main_phase_1(&self) -> bool {
        matches!(self, Phase::MainPhase1)
    }

    pub fn is_main_phase_1_start(&self) -> bool {
        matches!(self, Phase::MainPhaseStart)
    }

    /// 배틀 페이즈 관련 체크
    pub fn is_battle_phase(&self) -> bool {
        matches!(
            self,
            Phase::BattlePhaseStart
                | Phase::BattleStep
                | Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
                | Phase::BattlePhaseEnd
        )
    }

    pub fn is_battle_step(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    pub fn is_damage_step(&self) -> bool {
        matches!(
            self,
            Phase::BattleDamageStepStart
                | Phase::BattleDamageStepCalculationBefore
                | Phase::BattleDamageStepCalculationStart
                | Phase::BattleDamageStepCalculationEnd
                | Phase::BattleDamageStepEnd
        )
    }

    pub fn is_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationStart)
    }

    pub fn is_before_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationBefore)
    }

    pub fn is_after_damage_calculation(&self) -> bool {
        matches!(self, Phase::BattleDamageStepCalculationEnd)
    }

    /// 메인 페이즈 2 체크
    pub fn is_main_phase_2(&self) -> bool {
        matches!(self, Phase::MainPhase2)
    }

    /// 엔드 페이즈 체크
    pub fn is_end_phase(&self) -> bool {
        matches!(self, Phase::EndPhase)
    }

    /// 메인 페이즈 체크 (1과 2 모두)
    pub fn is_main_phase(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::MainPhase1 | Phase::MainPhase2
        )
    }

    /// 일반 소환이 가능한 페이즈인지 체크
    pub fn can_normal_summon(&self) -> bool {
        matches!(self, Phase::MainPhase1 | Phase::MainPhase2)
    }

    /// 공격이 가능한 페이즈인지 체크
    pub fn can_attack(&self) -> bool {
        matches!(self, Phase::BattleStep)
    }

    /// 현재 페이즈가 개시시인지 체크
    pub fn is_phase_start(&self) -> bool {
        matches!(
            self,
            Phase::MainPhaseStart | Phase::BattlePhaseStart | Phase::BattleDamageStepStart
        )
    }

    /// 다음 페이즈 반환
    pub fn next_phase(&self) -> Phase {
        match self {
            Phase::Mulligan => Phase::DrawPhase,
            Phase::DrawPhase => Phase::StandbyPhase,
            Phase::StandbyPhase => Phase::MainPhaseStart,
            Phase::MainPhaseStart => Phase::MainPhase1,
            Phase::MainPhase1 => Phase::BattlePhaseStart,
            Phase::BattlePhaseStart => Phase::BattleStep,
            Phase::BattleStep => Phase::BattleDamageStepStart,
            Phase::BattleDamageStepStart => Phase::BattleDamageStepCalculationBefore,
            Phase::BattleDamageStepCalculationBefore => Phase::BattleDamageStepCalculationStart,
            Phase::BattleDamageStepCalculationStart => Phase::BattleDamageStepCalculationEnd,
            Phase::BattleDamageStepCalculationEnd => Phase::BattleDamageStepEnd,
            Phase::BattleDamageStepEnd => Phase::BattlePhaseEnd,
            Phase::BattlePhaseEnd => Phase::MainPhase2,
            Phase::MainPhase2 => Phase::EndPhase,
            Phase::EndPhase => Phase::DrawPhase,
            Phase::Heartbeat => Phase::Mulligan,
        }
    }

    pub fn move_to_next_phase(&mut self) {
        *self = self.next_phase();
    }

    pub fn set_phase(&mut self, phase: Phase) {
        *self = phase;
    }

    pub fn as_str(&self) -> &'static str {
        match self {
            Phase::Mulligan => "Mulligan",
            Phase::DrawPhase => "DrawPhase",
            Phase::StandbyPhase => "StandbyPhase",
            Phase::MainPhaseStart => "MainPhaseStart",
            Phase::MainPhase1 => "MainPhase1",
            Phase::BattlePhaseStart => "BattlePhaseStart",
            Phase::BattleStep => "BattleStep",
            Phase::BattleDamageStepStart => "BattleDamageStepStart",
            Phase::BattleDamageStepCalculationBefore => "BattleDamageStepCalculationBefore",
            Phase::BattleDamageStepCalculationStart => "BattleDamageStepCalculationStart",
            Phase::BattleDamageStepCalculationEnd => "BattleDamageStepCalculationEnd",
            Phase::BattleDamageStepEnd => "BattleDamageStepEnd",
            Phase::BattlePhaseEnd => "BattlePhaseEnd",
            Phase::MainPhase2 => "MainPhase2",
            Phase::EndPhase => "EndPhase",
            Phase::Heartbeat => "Heartbeat",
        }
    }
}
</file>

<file path="simulator_core/src/game_old/turn_manager.rs">
use crate::card::types::PlayerType;

#[derive(Clone)]
pub struct Turn {
    current_turn: PlayerType,
    turn_count: usize,
}

impl Turn {
    pub fn new() -> Self {
        Turn {
            current_turn: PlayerType::Player1,
            turn_count: 0,
        }
    }

    pub fn get_turn_count(&self) -> usize {
        self.turn_count
    }

    pub fn increase_turn_count(&mut self) -> usize {
        self.turn_count += 1;
        self.turn_count
    }

    pub fn current_turn(&self) -> PlayerType {
        self.current_turn
    }

    pub fn change_turn(&mut self) -> PlayerType {
        self.current_turn = match self.current_turn {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        };
        self.current_turn
    }

    pub fn is_player_turn(&self) -> bool {
        self.current_turn == PlayerType::Player1
    }

    pub fn is_opponent_turn(&self) -> bool {
        self.current_turn == PlayerType::Player2
    }

    pub fn get_opponent_turn(&self) -> PlayerType {
        match self.current_turn {
            PlayerType::Player1 => PlayerType::Player2,
            PlayerType::Player2 => PlayerType::Player1,
        }
    }

    // 특정 플레이어의 턴으로 강제 설정
    pub fn set_turn(&mut self, player: PlayerType) {
        self.current_turn = player;
    }
}
</file>

<file path="simulator_core/src/game/msg/error_message.rs">

</file>

<file path="simulator_core/src/game/msg/mulligan.rs">
use actix::{Context, Handler, Message, ResponseFuture};
use uuid::Uuid;

use crate::{
    card::{cards::CardVecExt, insert::BottomInsert, take::RandomTake, types::PlayerKind, Card},
    exception::GameError,
    game::GameActor,
    player::message::{AddCardsToDeck, GetCardFromDeck},
    selector::TargetCount,
};

#[derive(Message)]
#[rtype(result = "Result<Vec<Card>, GameError>")]
pub struct RerollRequestMulliganCard {
    pub player_type: PlayerKind,
    pub cards: Vec<Uuid>,
}

impl Handler<RerollRequestMulliganCard> for GameActor {
    type Result = ResponseFuture<Result<Vec<Card>, GameError>>;

    fn handle(&mut self, msg: RerollRequestMulliganCard, _: &mut Context<Self>) -> Self::Result {
        let player_type = msg.player_type;

        let mut cards = vec![];
        let player_cards = self
            .all_cards
            .get(&player_type)
            .unwrap_or_else(|| panic!("Player cards not found for player type: {:?}", player_type));
        for uuid in msg.cards {
            if let Some(card) = player_cards.find_by_uuid(uuid.clone()) {
                cards.push(card.clone());
            } else {
                todo!()
            }
        }
        let addr = self.get_player_addr_by_kind(player_type);
        Box::pin(async move {
            addr.do_send(AddCardsToDeck {
                cards,
                insert: Box::new(BottomInsert),
            });

            addr.send(GetCardFromDeck {
                take: Box::new(RandomTake(TargetCount::Exact(5))),
            })
            .await?
        })
    }
}
</file>

<file path="simulator_core/src/game/msg/zones.rs">
use actix::{Context, Handler, Message, ResponseFuture};

use crate::{
    card::{types::PlayerKind, Card},
    enums::ZoneType,
    game::GameActor,
    player::message::{GetDeckCards, GetFieldCards, GetGraveyardCards, GetHandCards},
};

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetPlayerZoneCards {
    pub player_type: PlayerKind,
    pub zone: ZoneType,
}

impl Handler<GetPlayerZoneCards> for GameActor {
    type Result = ResponseFuture<Vec<Card>>;

    fn handle(&mut self, msg: GetPlayerZoneCards, _: &mut Context<Self>) -> Self::Result {
        let player_type = msg.player_type;
        let zone = msg.zone;

        let addr = self.get_player_addr_by_kind(player_type);
        Box::pin(async move {
            match zone {
                ZoneType::Deck => addr.send(GetDeckCards).await,
                ZoneType::Hand => addr.send(GetHandCards).await,
                ZoneType::Field => addr.send(GetFieldCards).await,
                ZoneType::Graveyard => addr.send(GetGraveyardCards).await,
                _ => panic!("Invalid zone type: {}", zone),
            }
            .unwrap()
        })
    }
}
</file>

<file path="simulator_core/src/selector/automatic.rs">
use super::TargetCondition;

pub enum AutoSelectType {
    Weakest,
    Strongest,
    Random,
    All,
}

// 자동 선택기 (가장 약한 카드, 가장 강한 카드 등)
pub struct AutomaticSelector {
    condition: TargetCondition,
    selection_type: AutoSelectType,
}
</file>

<file path="simulator_core/src/selector/complex.rs">
use super::{SelectorLogic, TargetCondition};

pub struct ComplexSelector {
    conditions: Vec<TargetCondition>,
    logic: SelectorLogic,
}
</file>

<file path="simulator_core/src/selector/mod.rs">
use std::sync::Arc;

pub mod automatic;
pub mod complex;
pub mod mulligan;
pub mod multi;
pub mod single;

use actix::Addr;

use crate::{
    card::{
        types::{CardType, OwnerType},
        Card,
    },
    enums::ZoneType,
    exception::GameError,
    game::GameActor,
};

pub trait TargetSelector: Send + Sync {
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError>;
    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool;
    fn get_target_count(&self) -> TargetCount;
    fn clone_selector(&self) -> Box<dyn TargetSelector>;

    fn get_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> Vec<Card> {
        // let mut valid_targets = Vec::new();

        // for location in self.get_locations() {
        //     let cards = game.get_cards_by_player_and_zone_type(self.get_owner().into(), location);

        //     for card in cards {
        //         if self.is_valid_target(&card, game, source) {
        //             valid_targets.push(card);
        //         }
        //     }
        // }

        // valid_targets
        todo!()
    }

    fn get_owner(&self) -> OwnerType;

    fn get_locations(&self) -> Vec<ZoneType>;

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool;
}

#[derive(Clone, Copy)]
pub enum TargetCount {
    Exact(usize),
    Range(usize, usize),
    Any,
    None,
}

/// 카드 선택 조건
/// - location: 카드의 위치
/// - owner: 카드의 소유자
/// - card_type: 카드의 타입
/// - custom_filter: 카드에 대한 사용자 정의 필터
#[derive(Clone)]
pub struct TargetCondition {
    location: Vec<ZoneType>,
    owner: OwnerType,
    card_type: Option<CardType>,
    custom_filter: Option<Arc<dyn Fn(&Card) -> bool + Send + Sync>>,
}

pub enum SelectorLogic {
    And,
    Or,
    Not(Box<dyn TargetSelector>),
}
</file>

<file path="simulator_core/src/selector/mulligan.rs">
use uuid::Uuid;

#[derive(Clone)]
pub struct MulliganState {
    player_ready: bool,
    select_cards: Vec<Uuid>,
}

impl MulliganState {
    pub fn new() -> Self {
        Self {
            player_ready: false,
            select_cards: vec![],
        }
    }

    pub fn confirm_selection(&mut self) {
        self.player_ready = true;
    }

    pub fn get_select_cards(&self) -> Vec<Uuid> {
        self.select_cards.clone()
    }

    pub fn add_select_cards(&mut self, cards: Vec<Uuid>) {
        self.select_cards.extend(cards);
    }

    pub fn remove_select_cards(&mut self, cards: Vec<Uuid>) {
        self.select_cards.retain(|x| !cards.contains(x));
    }

    pub fn is_ready(&self) -> bool {
        self.player_ready
    }
}
</file>

<file path="simulator_core/src/selector/multi.rs">
use actix::Addr;

use crate::{
    card::{types::OwnerType, Card},
    exception::GameError,
    game::GameActor,
};

use super::{TargetCondition, TargetCount, TargetSelector};

// 다중 카드 선택기
pub struct MultiCardSelector {
    condition: TargetCondition,
    count: TargetCount,
}

impl TargetSelector for MultiCardSelector {
    /// 다중 카드 선택기 생성자
    ///
    /// # Parameters
    /// * `game` - 게임 객체
    /// * `source` - 이벤트를 발생시킨 카드
    ///
    /// # Returns
    /// * `Ok(Vec<Card>)` - 선택된 카드 목록
    /// * `Err(GameError)` - 카드 선택 중 오류 발생
    ///
    /// # Errors
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError> {
        todo!()
    }

    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }

    fn get_target_count(&self) -> TargetCount {
        todo!()
    }

    fn clone_selector(&self) -> Box<dyn TargetSelector> {
        todo!()
    }

    fn get_owner(&self) -> OwnerType {
        todo!()
    }

    fn get_locations(&self) -> Vec<crate::enums::ZoneType> {
        todo!()
    }

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }
}
</file>

<file path="simulator_core/src/sync/messages.rs">
// ===================================================================
// 1. 클라이언트에게 전송될 동기화 페이로드 정의
// ===================================================================

use actix::{Message, Recipient};

use crate::{card::types::PlayerKind, game::msg::GameEvent, sync::types::StateChange};
// ===================================================================
// 2. SyncActor와 상호작용하기 위한 메시지 정의
// ===================================================================

/// GameActor가 SyncActor에게 상태 변경 목록을 알리기 위해 사용하는 메시지
#[derive(Message)]
#[rtype(result = "()")]
pub struct NotifyChanges(pub Vec<StateChange>);

/// GameActor가 SyncActor에게 주기적인 해시 계산 및 전송을 요청하는 메시지
#[derive(Message)]
#[rtype(result = "()")]
pub struct RequestStateHashSync;

/// ConnectionActor가 연결될 때 SyncActor에 자신을 등록하는 메시지
#[derive(Message)]
#[rtype(result = "()")]
pub struct RegisterConnectionToSync {
    pub player: PlayerKind,
    pub recipient: Recipient<GameEvent>,
}

/// ConnectionActor가 연결을 해제할 때 SyncActor에서 등록을 해제하는 메시지
#[derive(Message)]
#[rtype(result = "()")]
pub struct UnregisterConnectionFromSync {
    pub player: PlayerKind,
}
</file>

<file path="simulator_core/src/sync/snapshots.rs">
use crate::card::types::PlayerKind;
use actix::Message;
use serde::Serialize;
use uuid::Uuid; // Phase enum import

// ===================================================================
// 스냅샷을 위한 데이터 구조체들
// ===================================================================

/// 카드의 공개 정보를 담는 스냅샷 구조체
#[derive(Serialize, Clone, Debug)]
pub struct CardSnapshot {
    pub uuid: Uuid,
    pub id: String, // "HM_001"과 같은 카드 DB ID
    pub attack: i32,
    pub health: i32,
    pub cost: i32,
    pub is_tapped: bool, // 행동 완료(공격 등) 여부
                         // ... 클라이언트 UI에 필요한 카드의 모든 공개 정보
}

/// 내 손패에 있는 카드처럼 모든 정보가 공개되는 스냅샷 구조체
#[derive(Serialize, Clone, Debug)]
pub struct PrivateCardSnapshot {
    pub uuid: Uuid,
    pub id: String,
    // ... CardSnapshot의 모든 필드 포함 가능
}

/// 게임 전체의 상태를 담는 최상위 스냅샷 구조체
#[derive(Serialize, Clone, Debug, Message)]
#[rtype(result = "()")]
pub struct GameStateSnapshot {
    // --- 글로벌 게임 정보 ---
    pub seq: u64, // 이 스냅샷이 유효한 시점의 시퀀스 번호
    pub state_hash: Option<String>,
    pub current_phase: String, // Phase enum을 문자열로 변환
    pub turn_player: PlayerKind,
    pub turn_count: usize,

    // --- '나'의 관점에서의 정보 ---
    pub my_info: PlayerStateSnapshot,

    // --- '상대'의 관점에서의 정보 ---
    pub opponent_info: OpponentStateSnapshot,
}

/// 플레이어 한 명의 전체 상태를 담는 스냅샷
#[derive(Serialize, Clone, Debug)]
pub struct PlayerStateSnapshot {
    pub player_kind: PlayerKind,
    pub health: i32,
    pub mana: i32,
    pub mana_max: i32,
    pub deck_count: usize,
    pub hand: Vec<PrivateCardSnapshot>, // 내 손패는 모든 정보가 보임
    pub field: Vec<CardSnapshot>,
    pub graveyard: Vec<CardSnapshot>,
}

/// 상대방의 공개 정보만 담는 스냅샷
#[derive(Serialize, Clone, Debug)]
pub struct OpponentStateSnapshot {
    pub player_kind: PlayerKind,
    pub health: i32,
    pub mana: i32,
    pub mana_max: i32,
    pub deck_count: usize,
    pub hand_count: usize, // 상대 손패는 개수만 보임
    pub field: Vec<CardSnapshot>,
    pub graveyard: Vec<CardSnapshot>,
}
</file>

<file path="simulator_core/src/sync/types.rs">
use serde::Serialize;
use uuid::Uuid;

use crate::{card::types::PlayerKind, enums::ZoneType};

/// 상태 변경의 최소 단위를 나타내는 enum (델타)
/// Serialize를 통해 JSON으로 변환 가능해야 합니다.
#[derive(Serialize, Clone, Debug)]
pub enum StateChange {
    CardMoved {
        card_uuid: Uuid,
        from: ZoneType,
        to: ZoneType,
    },
    StatChanged {
        card_uuid: Uuid,
        new_attack: Option<i32>,
        new_health: Option<i32>,
    },
    ResourceUpdated {
        player: PlayerKind,
        new_mana: i32,
        new_cost: i32,
    },
    TurnChanged {
        new_turn_player: PlayerKind,
        turn_count: usize,
    },
    PhaseChanged {
        new_phase: String, // Phase enum을 문자열로 변환하여 전송
    },
}

/// 클라이언트에게 실제로 전송될 이벤트 묶음
/// 이 구조체가 하나의 동기화 단위를 형성합니다.
#[derive(Serialize, Clone, Debug)]
pub struct StateUpdatePayload {
    pub seq: u64,
    pub changes: Vec<StateChange>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub state_hash: Option<String>,
}
</file>

<file path="simulator_core/src/utils/json.rs">
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Item {
    pub id: String,
    pub dbfid: i32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Card {
    pub id: String,
    pub num: i32,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Hero {
    pub name: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize, Serialize)]
pub struct Deck {
    pub Hero: Vec<Hero>,
    pub cards: Vec<Card>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Decks {
    pub decks: Vec<Deck>,
}

#[derive(Debug, Deserialize)]
pub struct Names {
    pub name1: String,
    pub name2: String,
}

#[derive(Debug, Deserialize)]
pub struct DeckCodes {
    pub code1: String,
    pub code2: String,
}

#[allow(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct GameConfigJson {
    pub DeckCodes: Vec<DeckCodes>,
    pub Attacker: i32,
    pub Names: Vec<Names>,
}

/*
    "id": "AT_010",
    "attack": 3,
    "health": 3,
    "cost": 5,
    "rarity": "RARE",
    "collectible": true,
    "name": "Ram Wrangler",
    "text": "<b>Battlecry:</b> If you have a Beast, summon a\nrandom Beast.",
    "type": "Agent"
*/
#[derive(Debug, Deserialize, Serialize, Clone, Eq, PartialEq, Hash)]
pub struct CardJson {
    pub id: Option<String>,
    pub dbfid: Option<i32>,
    pub cost: Option<i32>,
    pub name: Option<String>,
    pub text: Option<String>,
    pub attack: Option<i32>,
    pub health: Option<i32>,
    pub collectible: Option<bool>,
    pub r#type: Option<String>,
}

impl CardJson {
    pub fn new() -> CardJson {
        CardJson {
            id: None,
            dbfid: None,
            cost: None,
            name: None,
            text: None,
            attack: None,
            health: None,
            collectible: None,
            r#type: None,
        }
    }
}
</file>

<file path="simulator_core/src/zone/effect.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Effect {
    zone_cards: Cards,
    zone_size: usize,
}

impl Effect {
    pub fn new() -> Effect {
        Effect {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Effect {
    fn get_cards(&self) -> &Cards {
        todo!()
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/field.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Field {
    zone_cards: Cards,
    zone_size: usize,
}

impl Zone for Field {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}

impl Field {
    pub fn new() -> Field {
        Field {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }
}
</file>

<file path="simulator_core/src/zone/graveyard.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::Take, Card},
    enums::UNIT_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Graveyard {
    zone_cards: Cards,
    zone_size: usize,
}

impl Graveyard {
    pub fn new() -> Graveyard {
        Graveyard {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Graveyard {
    fn get_cards(&self) -> &Cards {
        todo!()
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(
        &mut self,
        cards: Vec<Card>,
        insert: Box<dyn crate::card::insert::Insert>,
    ) -> Result<(), GameError> {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/mod.rs">
pub mod deck;
pub mod effect;
pub mod field;
pub mod graveyard;
pub mod hand;
pub mod zone;
</file>

<file path="simulator_core/src/zone/zone.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, insert::Insert, take::Take, Card},
    exception::GameError,
};

pub trait Zone {
    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError>;

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError>;

    fn remove_card(&mut self, uuid: Uuid);

    fn get_cards(&self) -> &Cards;

    fn get_cards_mut(&mut self) -> &mut Cards;

    fn len(&self) -> usize;
}
</file>

<file path="simulator_dedicated_server/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_dedicated_server/.gitignore">
/target
</file>

<file path="simulator_dedicated_server/src/connection/types.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GameStateSnapshot {
    pub current_phase: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PlayerInputRequest {
    pub request_id: Uuid,
    pub input_type: PlayerInputType,
    pub options: Vec<String>,
    pub message: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerInputType {
    SelectCardFromHand,
    SelectTargetOnField,
    ChooseEffect,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerInputResponse {
    MulliganRerollAnswer(Vec<Uuid>),
    CardSelection(Vec<Uuid>),
    TargetSelection(Uuid),
    EffectChoice(String),
}
</file>

<file path="simulator_dedicated_server/src/enums.rs">
pub const HEARTBEAT_INTERVAL: u64 = 5;
pub const CLIENT_TIMEOUT: u64 = 30; // 30초 동안 응답 없으면 연결 끊김
</file>

<file path="simulator_dedicated_server/src/room/mod.rs">
pub struct RoomManagerActor {}
</file>

<file path="simulator_match_server/.github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path="simulator_match_server/.gitignore">
/target
</file>

<file path="simulator_match_server/config/development.toml">
# 서버 설정
bind_address = "0.0.0.0"
port = 8080
log_level = "INFO"

# Redis 설정
redis_url = "redis://127.0.0.1:6379"

# 매치메이킹 설정
matchmaking_interval_seconds = 2
initial_mmr_range = 100
</file>

<file path="simulator_match_server/config/production.toml">
redis_url = "redis://your-production-redis-endpoint:6379"
log_level = "WARN"
password = ""
</file>

<file path="simulator_match_server/src/env.rs">
use std::env;

use config::{Config, ConfigError, Environment, File};
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub bind_address: String,
    pub port: u16,
    pub log_level: String,
}

#[derive(Debug, Deserialize)]
pub struct RedisConfig {
    pub url: String,
    pub password: Option<String>, // 필요하다면
}

#[derive(Debug, Deserialize)]
pub struct MatchmakingLogicConfig {
    pub matchmaking_interval_seconds: u64,
    pub initial_mmr_range: i32,
}

#[derive(Debug, Deserialize)]
pub struct Settings {
    pub server: ServerConfig,
    pub redis: RedisConfig,
    pub matchmaking: MatchmakingLogicConfig,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let run_mode = env::var("RUN_MODE").unwrap_or_else(|_| "development".into());

        let s = Config::builder()
            // 기본 설정 파일 로드
            .add_source(File::with_name("config/default"))
            // 환경별 설정 파일 로드 (예: config/production.toml) - 선택 사항
            .add_source(File::with_name(&format!("config/{}", run_mode)).required(false))
            // 환경 변수 로드 (예: APP_SERVER_PORT=8000)
            // APP_ 접두사를 사용하고, 구분자는 __ (더블 언더스코어)
            // 예: APP_REDIS__URL="redis://..."
            .add_source(Environment::with_prefix("app").separator("__"))
            .build()?;

        s.try_deserialize()
    }
}
</file>

<file path="simulator_match_server/src/main.rs">
#[tokio::main]
async fn main() {}
</file>

<file path="simulator_match_server/src/matchmaker/actor.rs">
use actix::{Actor, Context, Handler};

use crate::matchmaker::message::{JoinQueue, LeaveQueue, MatchmakingError, Tick};

pub struct MatchMakingActor {}

impl MatchMakingActor {
    pub fn new() -> Self {
        todo!()
    }
}

impl Actor for MatchMakingActor {
    type Context = Context<Self>;
}

impl Handler<JoinQueue> for MatchMakingActor {
    type Result = Result<(), MatchmakingError>;
    fn handle(&mut self, msg: JoinQueue, ctx: &mut Self::Context) -> Self::Result {
        todo!()
    }
}

impl Handler<LeaveQueue> for MatchMakingActor {
    type Result = Result<(), MatchmakingError>;

    fn handle(&mut self, msg: LeaveQueue, ctx: &mut Self::Context) -> Self::Result {
        todo!()
    }
}

impl Handler<Tick> for MatchMakingActor {
    type Result = Result<(), MatchmakingError>;

    fn handle(&mut self, msg: Tick, ctx: &mut Self::Context) -> Self::Result {
        todo!()
    }
}
</file>

<file path="simulator_match_server/src/matchmaker/message.rs">
// messages.rs
use actix::Message;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// 플레이어 정보 (매칭 요청 시 전달)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlayerInfo {
    pub player_id: Uuid,
    pub mmr: i32,
    pub game_mode: String,
}

// 매칭 요청 메시지
#[derive(Message, Debug)]
#[rtype(result = "Result<(), MatchmakingError>")] // 성공 또는 에러 반환
pub struct JoinQueue {
    // pub player: PlayerInfo,
}

// 매칭 취소 메시지
#[derive(Message, Debug)]
#[rtype(result = "Result<(), MatchmakingError>")]
pub struct LeaveQueue {
    pub player_id: Uuid,
    pub game_mode: String,
}

// 매칭 로직을 주기적으로 실행하기 위한 내부 메시지
// 분산락의 도입으로 Tick 이 실패
#[derive(Message, Debug)]
#[rtype(result = "Result<(), MatchmakingError>")]
pub struct Tick;

// 매칭 성공 시 다른 Actor (예: GameSessionManagerActor)에게 보낼 메시지
#[derive(Message, Debug, Clone)]
#[rtype(result = "()")]
pub struct MatchFound {
    pub game_id: Uuid,
    // pub players: Vec<PlayerInfo>,
}

// 에러 타입
#[derive(Debug, thiserror::Error)]
pub enum MatchmakingError {
    #[error("Redis error: {0}")]
    RedisError(#[from] redis::RedisError),
    #[error("Player not found in queue")]
    PlayerNotFound,
    #[error("Internal server error: {0}")]
    InternalError(String),
    #[error("Failed to acquire lock")]
    LockError,
}
</file>

<file path="simulator_match_server/src/matchmaker/mod.rs">
pub mod actor;
pub mod message;
</file>

<file path="simulator_match_server/src/util.rs">
use std::env;

pub async fn connect_to_redis_with_auth() -> redis::RedisResult<()> {
    let redis_url =
        env::var("REDIS_URL").expect("REDIS_URL must be set, e.g., redis://:password@host:port");

    let client = redis::Client::open(redis_url)?;
    let _ = client.get_async_connection().await?;

    Ok(())
}
</file>

<file path="simulator_core/benches/bench.rs">
use criterion::{criterion_group, criterion_main, Criterion};
// use tokio::runtime::Runtime;

fn bench_spawn_server(_c: &mut Criterion) {
    // Tokio 런타임 생성
    // let rt = Runtime::new().unwrap();

    // c.bench_function("spawn_server", |b| {
    //     b.iter(|| {
    //         // 런타임 내에서 비동기 작업 실행
    //         rt.block_on(async {
    //             let _ = spawn_server().await;
    //         });
    //     });
    // });
}

criterion_group!(benches, bench_spawn_server);
criterion_main!(benches);
</file>

<file path="simulator_core/src/card_gen/human.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;
// -------------------------------------------------- FIELD
// [HM_001] Hieda no Akyuu - COST:?? [ATK:??/HP:?]
// - Set: Human, Rarity: C
// --------------------------------------------------------
// Text: 낮동안 인간 카드를 사용할 때 마다 서로 1장 드로우 한다.
// --------------------------------------------------------
// Behaviors:
// - ListenOtherEvent
// - DrawCardFromDeck
// --------------------------------------------------------
#[allow(non_snake_case)]
/// `HM_001` 함수는 주어진 `CardJson`과 개수를 기반으로 특정 인간 카드(히에다노 아큐)를 생성합니다.
///
/// 이 카드는 다음과 같은 효과를 가집니다:
/// * 2장 드로우
/// * 모든 카드의 공격력을 2 증가
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
// TODO: 효과에 대한 설명을 더 자세하게 기술 (예: 드로우 효과의 주체, 공격력 증가의 지속 시간 등).
// TODO: 카드 이름과 설명을 주석에 포함 (히에다노 아큐에 대한 설명).
pub fn HM_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

#[allow(non_snake_case)]
/// `HM_002` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_002의 기능이 HM_001과 동일하다면, HM_002의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_002(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}

#[allow(non_snake_case)]
/// `HM_003` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_003의 기능이 HM_001과 동일하다면, HM_003의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_003(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
/// `HM_004` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_004의 기능이 HM_001과 동일하다면, HM_004의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_004(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
/// `HM_005` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_005의 기능이 HM_001과 동일하다면, HM_005의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_005(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
/// `HM_006` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_006의 기능이 HM_001과 동일하다면, HM_006의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_006(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
/// `HM_007` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_007의 기능이 HM_001과 동일하다면, HM_007의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_007(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
#[allow(non_snake_case)]
/// `HM_008` 함수는 `HM_001` 함수를 호출하여 카드를 생성합니다. 현재는 `HM_001`과 동일한 동작을 수행합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보를 담고 있는 `CardJson` 구조체에 대한 참조.
/// * `count` - 카드의 개수 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 인스턴스.
// TODO: HM_008의 기능이 HM_001과 동일하다면, HM_008의 존재 이유를 명확히 하거나 제거를 고려.
// TODO: 만약 다른 기능을 수행하도록 변경될 예정이라면, 변경될 기능에 대한 주석을 추가.
// TODO: count 매개변수가 실제로 사용되는지 확인하고, 사용되지 않는다면 제거하거나 활용 방법을 고려.
pub fn HM_008(card_json: &CardJson, count: i32) -> Card {
    HM_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/mod.rs">
mod builder;
mod human;
mod monster;
mod public;

use crate::card::Card;
use crate::{utils, utils::json::CardJson};

use once_cell::sync::Lazy;
use std::collections::HashMap;

type CardGeneratorFn = fn(&CardJson, i32) -> Card;

macro_rules! generate_card_map {
    ($($module:ident :: $func:ident),* $(,)?) => {
        static CARD_GENERATORS: Lazy<HashMap<String, CardGeneratorFn>> = Lazy::new(|| {
            let mut m = HashMap::new();
            $(
                m.insert(stringify!($func).to_string(), $module::$func as CardGeneratorFn);
            )*
            m
        });
    };
}

include!(concat!(env!("OUT_DIR"), "/card_registry.rs"));

type Key = Vec<(String, i32)>;
/// `CardGenerator`는 카드 생성을 관리하는 구조체입니다.
/// `keys`는 카드 ID와 문자열 ID 간의 매핑을 저장하고, `card_generators`는 ID별 카드 생성 함수를 저장합니다.
// TODO: 필드에 대한 더 자세한 설명 추가
pub struct CardGenerator {
    keys: Keys,
    card_generators: HashMap<i32, CardGeneratorFn>,
}

/// `Keys`는 카드 ID와 문자열 ID 간의 매핑 정보를 담는 구조체입니다.
/// `keys` 필드는 벡터 형태로 매핑 정보를 저장합니다.
// TODO: `keys` 필드의 구체적인 데이터 형태 (예: `Vec<(String, i32)>`) 명시
pub struct Keys {
    pub keys: Key,
}

/// `Keys` 구조체에 대한 구현 블록입니다.
impl Keys {
    /// `new`는 `CardGenerator` 구조체의 생성자 함수입니다.
    /// `Keys`를 초기화하고, `CARD_GENERATORS`에 등록된 함수들을 기반으로 카드 생성 함수 매핑을 수행합니다.
    // TODO: 초기화 과정에 대한 더 자세한 설명 추가
    pub fn new() -> Keys {
        let keys = match utils::load_card_id() {
            Ok(data) => data,
            Err(_) => panic!("Unknown Err fun: Keys initialize"),
        };
        Keys { keys }
    }

    /// `get_usize_by_string`은 문자열 ID를 사용하여 해당 ID에 매핑된 숫자 ID를 가져오는 함수입니다.
    ///
    /// # Arguments
    ///
    /// * `key` - 찾고자 하는 문자열 ID입니다.
    ///
    /// # Returns
    ///
    /// 매핑된 숫자 ID가 존재하면 `Some(i32)`를 반환하고, 존재하지 않으면 `None`을 반환합니다.
    pub fn get_usize_by_string(&self, key: &str) -> Option<i32> {
        self.keys
            .iter()
            .find(|&(item_key, _)| item_key == key)
            .map(|&(_, value)| value)
    }

    /// `get_string_by_usize`는 숫자 ID를 사용하여 해당 ID에 매핑된 문자열 ID를 가져오는 함수입니다.
    ///
    /// # Arguments
    ///
    /// * `key` - 찾고자 하는 숫자 ID입니다.
    ///
    /// # Returns
    ///
    /// 매핑된 문자열 ID가 존재하면 `Some(String)`을 반환하고, 존재하지 않으면 `None`을 반환합니다.
    pub fn get_string_by_usize(&self, key: i32) -> Option<String> {
        self.keys
            .iter()
            .find(|&(_, item_key)| item_key == &key)
            .map(|(value, _)| value.clone())
    }
}

/// `CardGenerator` 구조체에 대한 구현 블록입니다.
impl CardGenerator {
    pub fn new() -> CardGenerator {
        let keys = Keys::new();
        let mut card_generators = HashMap::new();

        for (str_id, func) in CARD_GENERATORS.iter() {
            if let Some(id) = keys.get_usize_by_string(str_id) {
                card_generators.insert(id, *func);
            }
        }

        CardGenerator {
            keys,
            card_generators,
        }
    }

    /// `gen_card_by_id_i32`는 숫자 ID를 사용하여 카드를 생성하는 함수입니다.
    ///
    /// # Arguments
    ///
    /// * `id` - 카드 ID입니다.
    /// * `card_json` - 카드 생성에 필요한 JSON 데이터입니다.
    /// * `count` - 생성할 카드 갯수입니다.
    ///
    /// # Returns
    ///
    /// 생성된 `Card` 인스턴스를 반환합니다.
    ///
    /// # Panics
    /// 알 수 없는 ID를 받으면 패닉을 발생시킵니다.
    // TODO: 패닉 발생 조건에 대한 더 자세한 설명 추가
    pub fn gen_card_by_id_i32(&self, id: i32, card_json: &CardJson, count: i32) -> Card {
        if let Some(generator) = self.card_generators.get(&id) {
            generator(card_json, count)
        } else {
            panic!("Unknown ID: {}", id);
        }
    }

    /// `gen_card_by_id_string`은 문자열 ID를 사용하여 카드를 생성하는 함수입니다.
    ///
    /// # Arguments
    ///
    /// * `key` - 카드 문자열 ID입니다.
    /// * `card_json` - 카드 생성에 필요한 JSON 데이터입니다.
    /// * `count` - 생성할 카드 갯수입니다.
    ///
    /// # Returns
    ///
    /// 생성된 `Card` 인스턴스를 반환합니다.
    ///
    /// # Panics
    /// 알 수 없는 ID를 받으면 패닉을 발생시킵니다.
    // TODO: 패닉 발생 조건에 대한 더 자세한 설명 추가
    pub fn gen_card_by_id_string(&self, key: String, card_json: &CardJson, count: i32) -> Card {
        match self.keys.get_usize_by_string(&key[..]) {
            Some(id) => self.gen_card_by_id_i32(id, card_json, count),
            None => panic!("Unknown ID: {}", key),
        }
    }
}
</file>

<file path="simulator_core/src/card_gen/monster.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

/// `MT_001` 함수는 주어진 `CardJson`과 개수를 사용하여 새로운 `Card`를 생성합니다.
///
/// 이 함수는 `CardBuilder`를 사용하여 카드를 생성하고, 드로우 효과와 스탯 변경 효과를 추가합니다.
#[allow(non_snake_case)]
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_001 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_001(&card_json, 1);
/// ```
pub fn MT_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}

/// `MT_002` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_002 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_002(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_002(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}

/// `MT_003` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_003 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_003(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_003(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_004` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_004 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_004(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_004(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_005` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_005 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_005(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_005(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_006` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_006 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_006(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_006(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_007` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_007 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_007(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_007(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_008` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_008 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_008(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_008(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_009` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_009 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_009(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_009(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
/// `MT_010` 함수는 `MT_001` 함수를 호출하여 새로운 `Card`를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드의 정보를 담고 있는 `CardJson` 구조체에 대한 참조자입니다.
/// * `count` - 카드의 개수입니다. 현재는 사용되지 않습니다.
///
/// # Returns
///
/// * 생성된 `Card` 객체를 반환합니다.
///
/// # Examples
///
/// ```
/// // MT_010 함수를 사용하는 예제
/// // CardJson 구조체가 미리 정의되어 있어야 합니다.
/// // let card_json = CardJson { ... };
/// // let card = MT_010(&card_json, 1);
/// ```
#[allow(non_snake_case)]
pub fn MT_010(card_json: &CardJson, count: i32) -> Card {
    MT_001(card_json, count)
}
</file>

<file path="simulator_core/src/card_gen/public.rs">
use crate::{
    card::{
        types::{OwnerType, StatType},
        Card,
    },
    effect::{DrawEffect, ModifyStatEffect},
    enums::ZoneType,
    selector::single::SingleCardSelector,
    utils::json::CardJson,
};

use super::builder::CardBuilder;

/// 카드 ID `PB_001`에 해당하는 카드를 생성합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_001(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_001(card_json: &CardJson, count: i32) -> Card {
    CardBuilder::new(card_json)
        .unwrap()
        .add_effect(DrawEffect { count: 2 })
        .add_effect(ModifyStatEffect {
            stat_type: StatType::Attack,
            amount: 2,
            target_selector: Box::new(SingleCardSelector::new(ZoneType::None, OwnerType::Any)),
        })
        .build()
}
/// 카드 ID `PB_002`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_002(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_002(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_003`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_003(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_003(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_004`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_004(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_004(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_005`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_005(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_005(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_006`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_006(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_006(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_007`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_007(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_007(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_008`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_008(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_008(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_009`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_009(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_009(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_010`에 해당하는 카드를 생성합니다. `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_010(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_010(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_011`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_011(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_011(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_012`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_012(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_012(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_013`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_013(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_013(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_014`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_014(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_014(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_015`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_015(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_015(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_016`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_016(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_016(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
/// 카드 ID `PB_017`에 해당하는 카드를 생성합니다.  `PB_001`과 동일한 로직을 사용합니다.
///
/// # Arguments
///
/// * `card_json` - 카드 정보가 담긴 JSON 데이터.
/// * `count` - 카드의 수량 (현재 사용되지 않음).
///
/// # Returns
///
/// 생성된 `Card` 객체.
///
/// # Examples
///
/// ```
/// // let card_json = ...; // CardJson 객체를 초기화합니다.
/// // let card = PB_017(&card_json, 1);
/// // ...
/// ```
#[allow(non_snake_case)]
pub fn PB_017(card_json: &CardJson, count: i32) -> Card {
    PB_001(card_json, count)
}
</file>

<file path="simulator_core/src/card/cards.rs">
use super::Card;
use uuid::Uuid;

/// `Card` 타입의 `Vec`에 대한 별칭입니다.
///
/// 카드들의 목록을 나타내는 데 사용됩니다.
///
/// # Examples
///
/// ```
/// use simulator_core::card::Card;
/// use simulator_core::card::cards::Cards;
/// use uuid::Uuid;
///
/// let mut cards: Cards = Vec::new();
/// let card1 = Card { uuid: Uuid::new_v4() };
/// let card2 = Card { uuid: Uuid::new_v4() };
/// cards.push(card1);
/// cards.push(card2);
///
/// assert_eq!(cards.len(), 2);
/// ```
pub type Cards = Vec<Card>;

/// `Vec<Card>`를 확장하는 트레이트입니다.
///
/// 카드 벡터에 대한 추가적인 기능들을 제공합니다.
///
/// # Examples
///
/// ```
/// use simulator_core::card::Card;
/// use simulator_core::card::cards::{Cards, CardVecExt};
/// use uuid::Uuid;
///
/// let mut cards: Cards = Vec::new();
/// let card1 = Card { uuid: Uuid::new_v4() };
/// let card2 = Card { uuid: Uuid::new_v4() };
/// cards.push(card1);
/// cards.push(card2);
///
/// let uuid_to_find = card1.uuid;
///
/// assert_eq!(cards.contains_uuid(uuid_to_find), true);
/// ```
pub trait CardVecExt {
    /// 벡터에 특정 UUID를 가진 카드가 존재하는지 확인합니다.
    ///
    /// # Arguments
    ///
    /// * `uuid` - 확인할 UUID
    ///
    /// # Returns
    ///
    /// * `true` - 벡터에 해당 UUID를 가진 카드가 존재하는 경우
    /// * `false` - 벡터에 해당 UUID를 가진 카드가 존재하지 않는 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_find = card1.uuid;
    ///
    /// assert_eq!(cards.contains_uuid(uuid_to_find), true);
    /// ```
    fn contains_uuid<U: Into<Uuid>>(&self, uuid: U) -> bool;

    /// 벡터에서 특정 UUID를 가진 카드를 찾아 반환합니다 (불변 참조).
    ///
    /// # Arguments
    ///
    /// * `uuid` - 찾을 UUID
    ///
    /// # Returns
    ///
    /// * `Some(&Card)` - 해당 UUID를 가진 카드를 찾은 경우, 해당 카드에 대한 불변 참조를 반환합니다.
    /// * `None` - 해당 UUID를 가진 카드를 찾지 못한 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_find = card1.uuid;
    ///
    /// if let Some(found_card) = cards.find_by_uuid(uuid_to_find) {
    ///     assert_eq!(found_card.uuid, uuid_to_find);
    /// } else {
    ///     panic!("Card not found");
    /// }
    /// ```
    fn find_by_uuid<U: Into<Uuid>>(&self, uuid: U) -> Option<&Card>;

    /// 벡터에서 특정 UUID를 가진 카드를 찾아 반환합니다 (가변 참조).
    ///
    /// # Arguments
    ///
    /// * `uuid` - 찾을 UUID
    ///
    /// # Returns
    ///
    /// * `Some(&mut Card)` - 해당 UUID를 가진 카드를 찾은 경우, 해당 카드에 대한 가변 참조를 반환합니다.
    /// * `None` - 해당 UUID를 가진 카드를 찾지 못한 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_find = card1.uuid;
    ///
    /// if let Some(found_card) = cards.find_by_uuid_mut(uuid_to_find) {
    ///     found_card.uuid = Uuid::new_v4(); // Modify the card
    /// } else {
    ///     panic!("Card not found");
    /// }
    /// ```
    fn find_by_uuid_mut<U: Into<Uuid>>(&mut self, uuid: U) -> Option<&mut Card>;

    /// 주어진 조건을 만족하는 모든 카드를 찾아 벡터로 반환합니다 (불변 참조).
    ///
    /// # Arguments
    ///
    /// * `predicate` - 각 카드에 적용할 조건 함수
    ///
    /// # Returns
    ///
    /// * `Vec<&Card>` - 조건을 만족하는 카드들의 벡터
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let found_cards = cards.find_all(|card| true); // Find all cards
    ///
    /// assert_eq!(found_cards.len(), 2);
    /// ```
    fn find_all<F>(&self, predicate: F) -> Vec<&Card>
    where
        F: Fn(&Card) -> bool;

    /// 주어진 조건을 만족하는 모든 카드를 찾아 벡터로 반환합니다 (가변 참조).
    ///
    /// # Arguments
    ///
    /// * `predicate` - 각 카드에 적용할 조건 함수
    ///
    /// # Returns
    ///
    /// * `Vec<&mut Card>` - 조건을 만족하는 카드들의 벡터
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let mut found_cards = cards.find_all_mut(|card| true); // Find all cards
    ///
    /// for card in &mut found_cards {
    ///     card.uuid = Uuid::new_v4(); // Modify the cards
    /// }
    /// ```
    fn find_all_mut<F>(&mut self, predicate: F) -> Vec<&mut Card>
    where
        F: Fn(&Card) -> bool;

    /// 벡터의 카드들을 무작위로 섞습니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// cards.shuffle();
    /// ```
    fn shuffle(&mut self);

    /// 주어진 조건을 만족하는 카드들의 개수를 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `predicate` - 각 카드에 적용할 조건 함수
    ///
    /// # Returns
    ///
    /// * `usize` - 조건을 만족하는 카드들의 개수
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let count = cards.count(|card| true); // Count all cards
    ///
    /// assert_eq!(count, 2);
    /// ```
    fn count<F>(&self, predicate: F) -> usize
    where
        F: Fn(&Card) -> bool;
    // 새로 추가할 메소드들

    /// 특정 UUID를 가진 카드를 찾아 벡터에서 제거하고 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `uuid` - 제거할 카드의 UUID
    ///
    /// # Returns
    ///
    /// * `Some(Card)` - 해당 UUID를 가진 카드가 발견되어 제거된 경우
    /// * `None` - 해당 UUID를 가진 카드가 없는 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_remove = card1.uuid;
    ///
    /// if let Some(removed_card) = cards.remove_by_uuid(uuid_to_remove) {
    ///     assert_eq!(removed_card.uuid, uuid_to_remove);
    /// } else {
    ///     panic!("Card not found");
    /// }
    /// ```
    fn remove_by_uuid<U: Into<Uuid>>(&mut self, uuid: U) -> Option<Card>;

    /// 특정 조건을 만족하는 모든 카드를 벡터에서 제거하고 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `predicate` - 제거할 카드를 선택하는 조건 함수
    ///
    /// # Returns
    ///
    /// * `Vec<Card>` - 제거된 카드들의 벡터 (조건을 만족하는 카드가 없으면 빈 벡터)
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let removed_cards = cards.remove_all(|card| true); // Remove all cards
    ///
    /// assert_eq!(removed_cards.len(), 2);
    /// ```
    fn remove_all<F>(&mut self, predicate: F) -> Vec<Card>
    where
        F: Fn(&Card) -> bool;
}

impl CardVecExt for Vec<Card> {
    /// 특정 UUID를 가진 카드를 찾아 벡터에서 제거하고 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `uuid` - 제거할 카드의 UUID
    ///
    /// # Returns
    ///
    /// * `Some(Card)` - 해당 UUID를 가진 카드가 발견되어 제거된 경우
    /// * `None` - 해당 UUID를 가진 카드가 없는 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_remove = card1.uuid;
    ///
    /// if let Some(removed_card) = cards.remove_by_uuid(uuid_to_remove) {
    ///     assert_eq!(removed_card.uuid, uuid_to_remove);
    /// } else {
    ///     panic!("Card not found");
    /// }
    /// ```
    fn remove_by_uuid<U: Into<Uuid>>(&mut self, uuid: U) -> Option<Card> {
        let uuid = uuid.into();
        let position = self.iter().position(|card| card.uuid == uuid)?;
        Some(self.remove(position))
    }

    /// 특정 조건을 만족하는 모든 카드를 벡터에서 제거하고 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `predicate` - 제거할 카드를 선택하는 조건 함수
    ///
    /// # Returns
    ///
    /// * `Vec<Card>` - 제거된 카드들의 벡터 (조건을 만족하는 카드가 없으면 빈 벡터)
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let removed_cards = cards.remove_all(|card| true); // Remove all cards
    ///
    /// assert_eq!(removed_cards.len(), 2);
    /// ```
    fn remove_all<F>(&mut self, predicate: F) -> Vec<Card>
    where
        F: Fn(&Card) -> bool,
    {
        // 제거할 카드 인덱스들 수집 (역순으로 정렬해야 함)
        let mut indices: Vec<usize> = self
            .iter()
            .enumerate()
            .filter(|(_, card)| predicate(card))
            .map(|(i, _)| i)
            .collect();

        // 역순으로 정렬 (뒤에서부터 제거해야 인덱스가 변하지 않음)
        indices.sort_by(|a, b| b.cmp(a));

        // 카드 제거하고 수집
        let mut removed = Vec::with_capacity(indices.len());
        for index in indices {
            removed.push(self.remove(index));
        }

        // 원래 순서대로 뒤집기
        removed.reverse();
        removed
    }
    /// Vec<Card> 에서 특정 Uuid 를 가진 Card 가 존재하는지 확인합니다.
    ///
    /// # Arguments
    ///
    /// * `uuid`: 확인할 UUID
    ///
    /// # Returns
    ///
    /// * `true` - 존재하는 경우
    /// * `false` - 존재하지 않는 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_find = card1.uuid;
    ///
    /// assert_eq!(cards.contains_uuid(uuid_to_find), true);
    /// ```
    fn contains_uuid<U: Into<Uuid>>(&self, uuid: U) -> bool {
        let uuid = uuid.into();
        self.iter().any(|card| card.uuid == uuid)
    }

    /// Vec<Card> 에서 특정 Uuid 를 가진 Card 를 찾습니다.
    ///
    /// # Arguments
    ///
    /// * `uuid`: 찾을 UUID
    ///
    /// # Returns
    ///
    /// * `Some(&Card)` - 존재하는 경우 해당 Card 의 불변 참조
    /// * `None` - 존재하지 않는 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_find = card1.uuid;
    ///
    /// if let Some(found_card) = cards.find_by_uuid(uuid_to_find) {
    ///     assert_eq!(found_card.uuid, uuid_to_find);
    /// }
    /// ```
    fn find_by_uuid<U: Into<Uuid>>(&self, uuid: U) -> Option<&Card> {
        let uuid = uuid.into();
        self.iter().find(|card| card.uuid == uuid)
    }

    /// Vec<Card> 에서 특정 Uuid 를 가진 Card 를 찾고 가변 참조를 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `uuid`: 찾을 UUID
    ///
    /// # Returns
    ///
    /// * `Some(&mut Card)` - 존재하는 경우 해당 Card 의 가변 참조
    /// * `None` - 존재하지 않는 경우
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let uuid_to_find = card1.uuid;
    ///
    /// if let Some(found_card) = cards.find_by_uuid_mut(uuid_to_find) {
    ///     found_card.uuid = Uuid::new_v4(); // modify the card
    /// }
    /// ```
    fn find_by_uuid_mut<U: Into<Uuid>>(&mut self, uuid: U) -> Option<&mut Card> {
        let uuid = uuid.into();
        self.iter_mut().find(|card| card.uuid == uuid)
    }

    /// 주어진 조건을 만족하는 모든 Card 를 찾아 Vec<&Card> 로 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `predicate`: 각 Card 에 적용할 조건 함수
    ///
    /// # Returns
    ///
    /// * `Vec<&Card>` - 조건을 만족하는 Card 들의 Vec
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let found_cards = cards.find_all(|card| true); // Find all cards
    ///
    /// assert_eq!(found_cards.len(), 2);
    /// ```
    fn find_all<F>(&self, predicate: F) -> Vec<&Card>
    where
        F: Fn(&Card) -> bool,
    {
        self.iter().filter(|card| predicate(card)).collect()
    }

    /// 주어진 조건을 만족하는 모든 Card 를 찾아 Vec<&mut Card> 로 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `predicate`: 각 Card 에 적용할 조건 함수
    ///
    /// # Returns
    ///
    /// * `Vec<&mut Card>` - 조건을 만족하는 Card 들의 Vec
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let mut found_cards = cards.find_all_mut(|card| true); // Find all cards
    ///
    /// for card in &mut found_cards {
    ///     card.uuid = Uuid::new_v4(); // modify the card
    /// }
    /// ```
    fn find_all_mut<F>(&mut self, predicate: F) -> Vec<&mut Card>
    where
        F: Fn(&Card) -> bool,
    {
        self.iter_mut().filter(|card| predicate(card)).collect()
    }

    /// 벡터의 카드들을 무작위로 섞습니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// cards.shuffle();
    /// ```
    fn shuffle(&mut self) {
        use rand::seq::SliceRandom;
        let mut rng = rand::thread_rng();
        self.as_mut_slice().shuffle(&mut rng);
    }

    /// 주어진 조건을 만족하는 카드들의 개수를 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `predicate`: 각 카드에 적용할 조건 함수
    ///
    /// # Returns
    ///
    /// * `usize`: 조건을 만족하는 카드들의 개수
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::Card;
    /// use simulator_core::card::cards::{Cards, CardVecExt};
    /// use uuid::Uuid;
    ///
    /// let mut cards: Cards = Vec::new();
    /// let card1 = Card { uuid: Uuid::new_v4() };
    /// let card2 = Card { uuid: Uuid::new_v4() };
    /// cards.push(card1);
    /// cards.push(card2);
    ///
    /// let count = cards.count(|card| true); // Count all cards
    ///
    /// assert_eq!(count, 2);
    /// ```
    fn count<F>(&self, predicate: F) -> usize
    where
        F: Fn(&Card) -> bool,
    {
        self.iter().filter(|card| predicate(card)).count()
    }
}
</file>

<file path="simulator_core/src/card/mod.rs">
//! mod.rs
//! 
//! 게임 시뮬레이터의 핵심 모듈
//! 이 모듈은 card와 관련된 기능을 제공합니다.

pub mod cards;
pub mod insert;
pub mod modifier;
pub mod take;
pub mod types;

use std::fmt;

use actix::Addr;
use types::{CardSpecs, CardStatus, OwnerType, StatType};
use uuid::Uuid;

use crate::{
    card::types::CardType,
    effect::{effects::EffectTiming, Effect},
    exception::GameError,
    game::GameActor,
    utils::json::CardJson,
};

/// `Card` 구조체는 게임 내의 카드 정보를 담고 있습니다.
///
/// 각 카드는 고유한 UUID, 이름, 타입, 효과, 스펙, 상태, 소유자, 그리고 JSON 데이터를 가집니다.
/// 이 구조체를 사용하여 게임 내 카드 객체를 표현하고 관리합니다.
#[derive(Clone)]
pub struct Card {
    uuid: Uuid,
    name: String,
    card_type: CardType,
    effects: Vec<EffectTiming>,
    specs: CardSpecs,
    status: CardStatus,
    owner: OwnerType,
    json_data: CardJson,
}

impl fmt::Debug for Card {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Card")
            .field("uuid", &self.uuid)
            .field("name", &self.name)
            .field("card_type", &self.card_type)
            .field("owner", &self.owner)
            // .field("effects", &self.effects)
            // .field("specs", &self.specs)
            // .field("status", &self.status)
            // .field("json_data", &self.json_data)
            .finish()
    }
}

impl PartialEq for Card {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl Eq for Card {}

impl Clone for Box<dyn Effect> {
    fn clone(&self) -> Self {
        self.clone_effect().unwrap()
    }
}

impl Card {
    /// 새로운 `Card` 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `owner` - 카드의 소유자 타입 (`OwnerType`).
    /// * `uuid` - 카드의 고유 UUID (`Uuid`).
    /// * `name` - 카드의 이름 (`String`).
    /// * `effects` - 카드에 적용될 효과들의 벡터 (`Vec<EffectTiming>`).
    /// * `r#type` - 카드의 타입 (`CardType`).
    /// * `specs` - 카드의 스펙 (`CardSpecs`).
    /// * `status` - 카드의 상태 (`CardStatus`).
    /// * `json_data` - 카드의 JSON 데이터 (`CardJson`).
    ///
    /// # Returns
    ///
    /// 새로운 `Card` 인스턴스.
    ///
    /// # Examples
    ///
    /// ```
    /// use uuid::Uuid;
    /// use simulator_core::card::{Card, types::{CardType, CardSpecs, CardStatus, OwnerType}};
    /// use simulator_core::effect::effects::EffectTiming;
    /// use simulator_core::utils::json::CardJson;
    ///
    /// let owner = OwnerType::Player(1);
    /// let uuid = Uuid::new_v4();
    /// let name = "Test Card".to_string();
    /// let effects = Vec::new();
    /// let card_type = CardType::Normal;
    /// let specs = CardSpecs::default();
    /// let status = CardStatus::default();
    /// let json_data = CardJson::default();
    ///
    /// let card = Card::new(owner, uuid, name, effects, card_type, specs, status, json_data);
    /// ```
    pub fn new(
        owner: OwnerType,
        uuid: Uuid,
        name: String,
        effects: Vec<EffectTiming>,
        r#type: CardType,
        specs: CardSpecs,
        status: CardStatus,
        json_data: CardJson,
    ) -> Self {
        Self {
            uuid,
            name,
            card_type: r#type,
            effects,
            specs,
            status,
            owner,
            json_data,
        }
    }

    /// 카드를 활성화합니다.
    ///
    /// # Arguments
    ///
    /// * `game` - 게임 액터의 주소 (`Addr<GameActor>`).
    ///
    /// # Returns
    ///
    /// 성공하면 `Ok(())`, 실패하면 `Err(GameError)`.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn activate(&self, game: Addr<GameActor>) -> Result<(), GameError> {
        todo!()
    }

    /// 카드가 타겟팅될 수 있는지 여부를 반환합니다.
    ///
    /// # Returns
    ///
    /// 타겟팅 가능하면 `true`, 불가능하면 `false`.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn can_be_targeted(&self) -> bool {
        todo!()
    }

    /// 카드의 UUID를 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 UUID (`Uuid`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_uuid(&self) -> Uuid {
        self.uuid
    }

    /// 카드의 이름을 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 이름 (`&str`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_name(&self) -> &str {
        &self.name
    }

    /// 카드의 타입을 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 타입 (`&CardType`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_type(&self) -> &CardType {
        &self.card_type
    }

    /// 카드의 소유자를 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 소유자 (`OwnerType`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_owner(&self) -> OwnerType {
        self.owner
    }

    /// 카드의 소유자를 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `player` - 새로운 소유자 (`OwnerType`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn set_owner(&mut self, player: OwnerType) {
        self.owner = player;
    }

    /// 카드의 스펙을 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 스펙 (`&CardSpecs`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_specs(&self) -> &CardSpecs {
        &self.specs
    }

    /// 카드의 상태를 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 상태 (`&CardStatus`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_status(&self) -> &CardStatus {
        &self.status
    }

    /// 카드의 가변 상태를 반환합니다.
    ///
    /// # Returns
    ///
    /// 카드의 가변 상태 (`&mut CardStatus`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_status_mut(&mut self) -> &mut CardStatus {
        &mut self.status
    }

    /// 우선순위가 지정된 효과 벡터를 반환합니다.
    ///
    /// # Returns
    ///
    /// 우선순위가 지정된 효과 벡터 (`&Vec<EffectTiming>`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_prioritized_effect(&self) -> &Vec<EffectTiming> {
        &self.effects
    }

    /// 우선순위가 지정된 가변 효과 벡터를 반환합니다.
    ///
    /// # Returns
    ///
    /// 우선순위가 지정된 가변 효과 벡터 (`&mut Vec<EffectTiming>`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn get_prioritized_effect_mut(&mut self) -> &mut Vec<EffectTiming> {
        &mut self.effects
    }

    /// 카드에 효과를 추가합니다.
    ///
    /// # Arguments
    ///
    /// * `effect` - 추가할 효과 (`E`).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn add_effect<E: Effect + 'static>(&mut self, effect: E) {
        todo!()
        // self.effects.push(Box::new(effect));
    }

    /// 카드의 스탯을 변경합니다.
    ///
    /// # Arguments
    ///
    /// * `stat_type` - 변경할 스탯의 타입 (`StatType`).
    /// * `amount` - 변경할 양 (`i32`).
    ///
    /// # Returns
    ///
    /// 성공하면 `Ok(())`, 실패하면 `Err(GameError)`.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn modify_stat(&mut self, stat_type: StatType, amount: i32) -> Result<(), GameError> {
        Ok(())
    }

    /// 새로운 UUID를 사용하여 카드를 복사합니다.
    ///
    /// # Returns
    ///
    /// 성공하면 복사된 카드 (`Ok(Self)`), 실패하면 `Err(GameError)`.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 예시 코드를 추가해야 합니다.
    /// ```
    pub fn clone_with_new_uuid(&self) -> Result<Self, GameError> {
        todo!()
        // Ok(Card {
        //     uuid: utils::generate_uuid()?,
        //     name: self.name.clone(),
        //     card_type: self.card_type.clone(),
        //     effects: self
        //         .effects
        //         .iter()
        //         .map(|e| e.clone_effect())
        //         .collect::<Result<Vec<_>, _>>()?,
        //     specs: self.specs.clone(),
        //     status: CardStatus::default(),
        //     owner: self.owner.clone(),
        //     json_data: self.json_data.clone(),
        // })
    }
}
</file>

<file path="simulator_core/src/card/modifier.rs">
use crate::game::phase::Phase;

use super::types::{Duration, ModifierType};

/// `Modifier` 구조체는 카드 효과 또는 기타 게임 메커니즘에 의해 발생하는 상태 변경을 나타냅니다.
///
/// 이 구조체는 수정자 유형, 값, 지속 시간, 출처 카드, 적용된 턴 및 페이즈와 같은 다양한 속성을 포함합니다.
/// `Modifier`는 캐릭터의 능력치 변경, 상태 이상 적용, 특정 효과 활성화 등 게임 내 다양한 기능을 구현하는 데 사용됩니다.
///
/// # Examples
///
/// ```
/// use simulator_core::card::modifier::Modifier;
/// use simulator_core::card::types::{Duration, ModifierType};
/// use simulator_core::game::phase::Phase;
///
/// let modifier = Modifier::new(
///     ModifierType::Attack,
///     10,
///     Duration::ForXTurns(2),
///     Some("ExampleCard".to_string()),
///     1,
///     Phase::Start,
/// );
///
/// assert_eq!(modifier.get_value(), 10);
/// ```
#[derive(Clone)]
pub struct Modifier {
    modifier_type: ModifierType,
    value: i32,
    duration: Duration,
    source_card: Option<String>,
    applied_turn: usize,  // 효과가 적용된 턴
    applied_phase: Phase, // 효과가 적용된 페이즈
}

impl Modifier {
    /// 수정자 유형을 반환합니다.
    ///
    /// # Returns
    ///
    /// `ModifierType`: 수정자의 유형.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_modifier_type(), ModifierType::Attack);
    /// ```
    pub fn get_modifier_type(&self) -> ModifierType {
        self.modifier_type
    }

    /// 수정자 값을 반환합니다.
    ///
    /// # Returns
    ///
    /// `i32`: 수정자의 값.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_value(), 10);
    /// ```
    pub fn get_value(&self) -> i32 {
        self.value
    }

    /// 수정자 지속 시간을 반환합니다.
    ///
    /// # Returns
    ///
    /// `Duration`: 수정자의 지속 시간.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_duration(), Duration::ForXTurns(2));
    /// ```
    pub fn get_duration(&self) -> Duration {
        self.duration
    }

    /// 수정자를 발생시킨 카드 이름을 반환합니다 (있는 경우).
    ///
    /// # Returns
    ///
    /// `Option<&String>`: 카드 이름에 대한 참조 (`Some`) 또는 수정자가 카드에서 발생하지 않은 경우 `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_source_card(), Some(&"ExampleCard".to_string()));
    /// ```
    pub fn get_source_card(&self) -> Option<&String> {
        self.source_card.as_ref()
    }

    /// 수정자가 적용된 턴을 반환합니다.
    ///
    /// # Returns
    ///
    /// `usize`: 수정자가 적용된 턴.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_applied_turn(), 1);
    /// ```
    pub fn get_applied_turn(&self) -> usize {
        self.applied_turn
    }

    /// 수정자가 적용된 페이즈를 반환합니다.
    ///
    /// # Returns
    ///
    /// `Phase`: 수정자가 적용된 페이즈.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_applied_phase(), Phase::Start);
    /// ```
    pub fn get_applied_phase(&self) -> Phase {
        self.applied_phase
    }

    /// 수정자 유형을 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `modifier_type`: 설정할 수정자 유형.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.set_modifier_type(ModifierType::Defense);
    /// assert_eq!(modifier.get_modifier_type(), ModifierType::Defense);
    /// ```
    pub fn set_modifier_type(&mut self, modifier_type: ModifierType) {
        self.modifier_type = modifier_type;
    }

    /// 수정자 값을 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `value`: 설정할 수정자 값.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.set_value(20);
    /// assert_eq!(modifier.get_value(), 20);
    /// ```
    pub fn set_value(&mut self, value: i32) {
        self.value = value;
    }

    /// 수정자 지속 시간을 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `duration`: 설정할 지속 시간.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.set_duration(Duration::Permanent);
    /// assert_eq!(modifier.get_duration(), Duration::Permanent);
    /// ```
    pub fn set_duration(&mut self, duration: Duration) {
        self.duration = duration;
    }

    /// 수정자를 발생시킨 카드 이름을 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `source_card`: 설정할 카드 이름 (있는 경우).
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.set_source_card(Some("NewCard".to_string()));
    /// assert_eq!(modifier.get_source_card(), Some(&"NewCard".to_string()));
    /// ```
    pub fn set_source_card(&mut self, source_card: Option<String>) {
        self.source_card = source_card;
    }

    /// 수정자가 적용된 턴을 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `turn`: 설정할 턴.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.set_applied_turn(2);
    /// assert_eq!(modifier.get_applied_turn(), 2);
    /// ```
    pub fn set_applied_turn(&mut self, turn: usize) {
        self.applied_turn = turn;
    }

    /// 수정자가 적용된 페이즈를 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `phase`: 설정할 페이즈.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.set_applied_phase(Phase::End);
    /// assert_eq!(modifier.get_applied_phase(), Phase::End);
    /// ```
    pub fn set_applied_phase(&mut self, phase: Phase) {
        self.applied_phase = phase;
    }

    /// 새 `Modifier` 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `modifier_type`: 수정자 유형.
    /// * `value`: 수정자 값.
    /// * `duration`: 지속 시간.
    /// * `source_card`: 출처 카드 (있는 경우).
    /// * `applied_turn`: 적용된 턴.
    /// * `applied_phase`: 적용된 페이즈.
    ///
    /// # Returns
    ///
    /// `Self`: 새 `Modifier` 인스턴스.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.get_modifier_type(), ModifierType::Attack);
    /// assert_eq!(modifier.get_value(), 10);
    /// ```
    pub fn new(
        modifier_type: ModifierType,
        value: i32,
        duration: Duration,
        source_card: Option<String>,
        applied_turn: usize,
        applied_phase: Phase,
    ) -> Self {
        Self {
            modifier_type,
            value,
            duration,
            source_card,
            applied_turn,
            applied_phase,
        }
    }

    /// 수정자가 만료되었는지 확인합니다.
    ///
    /// # Arguments
    ///
    /// * `current_turn`: 현재 턴.
    /// * `current_phase`: 현재 페이즈.
    ///
    /// # Returns
    ///
    /// `bool`: 수정자가 만료되었으면 `true`, 그렇지 않으면 `false`.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.is_expired(3, Phase::Start), false);
    /// assert_eq!(modifier.is_expired(4, Phase::Start), true);
    /// ```
    pub fn is_expired(&self, current_turn: usize, current_phase: Phase) -> bool {
        match self.duration {
            Duration::Permanent => false, // Permanent는 만료되지 않음
            Duration::UntilEndOfTurn => current_turn > self.applied_turn,
            Duration::UntilEndOfPhase => {
                current_turn > self.applied_turn
                    || (current_turn == self.applied_turn && current_phase > self.applied_phase)
            }
            Duration::ForXTurns(turns) => current_turn > self.applied_turn + turns,
        }
    }

    /// 수정자의 남은 지속 시간을 계산합니다.
    ///
    /// # Arguments
    ///
    /// * `current_turn`: 현재 턴.
    ///
    /// # Returns
    ///
    /// `Option<usize>`: 남은 턴 수 (`Some`) 또는 지속 시간이 무제한인 경우 `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// assert_eq!(modifier.remaining_duration(2), Some(1));
    /// assert_eq!(modifier.remaining_duration(3), Some(0));
    /// ```
    pub fn remaining_duration(&self, current_turn: usize) -> Option<usize> {
        match self.duration {
            Duration::Permanent => None,
            Duration::UntilEndOfTurn => {
                if current_turn > self.applied_turn {
                    Some(0)
                } else {
                    Some(1)
                }
            }
            Duration::UntilEndOfPhase => Some(if current_turn > self.applied_turn {
                0
            } else {
                1
            }),
            Duration::ForXTurns(turns) => {
                if current_turn <= self.applied_turn {
                    Some(turns)
                } else {
                    Some(turns.saturating_sub(current_turn - self.applied_turn))
                }
            }
        }
    }

    /// 새 타이밍으로 수정자 복사본을 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `turn`: 새 턴.
    /// * `phase`: 새 페이즈.
    ///
    /// # Returns
    ///
    /// `Self`: 새 타이밍으로 생성된 수정자 복사본.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// let new_modifier = modifier.copy_with_new_timing(2, Phase::End);
    /// assert_eq!(new_modifier.get_applied_turn(), 2);
    /// assert_eq!(new_modifier.get_applied_phase(), Phase::End);
    /// ```
    pub fn copy_with_new_timing(&self, turn: usize, phase: Phase) -> Self {
        let mut new = self.clone();
        new.set_applied_turn(turn);
        new.set_applied_phase(phase);
        new
    }

    /// 수정자 값을 변경합니다.
    ///
    /// # Arguments
    ///
    /// * `delta`: 변경할 값.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.modify_value(5);
    /// assert_eq!(modifier.get_value(), 15);
    /// ```
    pub fn modify_value(&mut self, delta: i32) {
        self.value += delta;
    }

    /// 지속 시간을 연장합니다.
    ///
    /// # Arguments
    ///
    /// * `additional`: 추가할 지속 시간.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::card::modifier::Modifier;
    /// use simulator_core::card::types::{Duration, ModifierType};
    /// use simulator_core::game::phase::Phase;
    ///
    /// let mut modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::ForXTurns(2),
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    ///
    /// modifier.extend_duration(Duration::ForXTurns(1));
    /// assert_eq!(modifier.get_duration(), Duration::ForXTurns(3));
    ///
    /// let mut permanent_modifier = Modifier::new(
    ///     ModifierType::Attack,
    ///     10,
    ///     Duration::Permanent,
    ///     Some("ExampleCard".to_string()),
    ///     1,
    ///     Phase::Start,
    /// );
    /// permanent_modifier.extend_duration(Duration::ForXTurns(1));
    /// assert_eq!(permanent_modifier.get_duration(), Duration::Permanent);
    /// ```
    pub fn extend_duration(&mut self, additional: Duration) {
        self.duration = match (self.duration, additional) {
            (Duration::ForXTurns(t1), Duration::ForXTurns(t2)) => Duration::ForXTurns(t1 + t2),
            (Duration::Permanent, _) => Duration::Permanent,
            _ => self.duration,
        };
    }
}
</file>

<file path="simulator_core/src/effect/effects.rs">
use actix::Addr;

use crate::{card::Card, game::GameActor};

use super::{types::EffectSpeed, Effect};

/// `Effects` 구조체는 게임 내에서 발생하는 효과들을 관리합니다.
/// 효과는 우선순위에 따라 정렬되어 저장되며, 다양한 필터링 및 접근 방법을 제공합니다.
///
/// # Examples
///
/// ```
/// use simulator_core::effect::{Effects, EffectTiming, Effect};
/// use simulator_core::effect::types::EffectSpeed;
///
/// // Example Effect (replace with a real implementation)
/// struct ExampleEffect {}
/// impl Effect for ExampleEffect {
///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
///         Ok(())
///     }
///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
///         true
///     }
///     fn get_speed(&self) -> EffectSpeed {
///         EffectSpeed::Normal
///     }
/// }
///
/// let mut effects = Effects::new();
/// let effect = Box::new(ExampleEffect {});
/// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
/// effects.add_effect(effect_timing);
///
/// assert_eq!(effects.get_effects().len(), 1);
/// ```
// Effect 에 우선순위를 부여하는건 장기적으로 좋음.
pub struct Effects {
    // 항상 정렬 상태를 보장해야함.
    prioritized_effects: Vec<EffectTiming>,
}

impl Effects {
    /// `Effects` 구조체의 새로운 인스턴스를 생성합니다.
    ///
    /// # Returns
    ///
    /// - `Effects`: 비어있는 효과 목록을 가진 새로운 `Effects` 인스턴스.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::Effects;
    ///
    /// let effects = Effects::new();
    /// assert_eq!(effects.get_effects().len(), 0);
    /// ```
    pub fn new() -> Self {
        Self {
            prioritized_effects: vec![],
        }
    }

    /// 효과를 목록에 추가하고, 우선순위에 따라 정렬합니다.
    ///
    /// # Arguments
    ///
    /// * `effect` - 추가할 `EffectTiming` 객체.
    ///
    /// # Returns
    ///
    /// 없음.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{Effects, EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let mut effects = Effects::new();
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    /// effects.add_effect(effect_timing);
    ///
    /// assert_eq!(effects.get_effects().len(), 1);
    /// ```
    pub fn add_effect(&mut self, effect: EffectTiming) {
        self.prioritized_effects.push(effect);
        self.prioritized_effects.sort_by_key(|e| e.get_priority());
    }

    /// 효과 목록에 있는 모든 효과에 대한 불변 참조 벡터를 반환합니다.
    ///
    /// # Returns
    ///
    /// - `Vec<&Box<dyn Effect>>`: 효과 목록에 있는 모든 효과에 대한 불변 참조 벡터.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{Effects, EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let mut effects = Effects::new();
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    /// effects.add_effect(effect_timing);
    ///
    /// let retrieved_effects = effects.get_effects();
    /// assert_eq!(retrieved_effects.len(), 1);
    /// ```
    pub fn get_effects(&self) -> Vec<&Box<dyn Effect>> {
        self.prioritized_effects
            .iter()
            .map(|e| e.get_effect())
            .collect::<Vec<_>>()
    }

    /// 효과 목록에 있는 모든 효과에 대한 가변 참조 벡터를 반환합니다.
    ///
    /// # Returns
    ///
    /// - `Vec<&mut Box<dyn Effect>>`: 효과 목록에 있는 모든 효과에 대한 가변 참조 벡터.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{Effects, EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let mut effects = Effects::new();
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    /// effects.add_effect(effect_timing);
    ///
    /// let retrieved_effects = effects.get_effects_mut();
    /// assert_eq!(retrieved_effects.len(), 1);
    /// ```
    pub fn get_effects_mut(&mut self) -> Vec<&mut Box<dyn Effect>> {
        self.prioritized_effects
            .iter_mut()
            .map(|e| e.get_effect_mut())
            .collect::<Vec<_>>()
    }

    /// 특정 조건을 만족하는 효과만 필터링합니다.
    ///
    /// # Arguments
    ///
    /// * `filter` - `EffectTiming` 객체를 인자로 받아 bool 값을 반환하는 클로저.
    ///
    /// # Returns
    ///
    /// - `Vec<&EffectTiming>`: 조건을 만족하는 효과들의 `EffectTiming` 객체에 대한 불변 참조 벡터.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{Effects, EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let mut effects = Effects::new();
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    /// effects.add_effect(effect_timing);
    ///
    /// let filtered_effects = effects.filter_effects(|e| e.get_priority() == 1);
    /// assert_eq!(filtered_effects.len(), 1);
    /// ```
    // 특정 조건을 만족하는 효과만 필터링 (조건을 클로저로 전달)
    pub fn filter_effects<F>(&self, filter: F) -> Vec<&EffectTiming>
    where
        F: Fn(&EffectTiming) -> bool,
    {
        self.prioritized_effects
            .iter()
            .filter(|e| filter(e))
            .collect()
    }

    /// 체인 상태에서 추가 가능한 효과만 필터링합니다.
    ///
    /// # Arguments
    ///
    /// * `current_chain_level` - 현재 체인 레벨을 나타내는 `EffectSpeed` 값.
    ///
    /// # Returns
    ///
    /// - `Vec<&EffectTiming>`: 현재 체인 레벨보다 빠르거나 같은 속도를 가진 효과들의 `EffectTiming` 객체에 대한 불변 참조 벡터.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{Effects, EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let mut effects = Effects::new();
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    /// effects.add_effect(effect_timing);
    ///
    /// let chainable_effects = effects.get_chainable_effects(EffectSpeed::Normal);
    /// assert_eq!(chainable_effects.len(), 1);
    /// ```
    // 체인 상태에서 추가 가능한 효과만 필터링
    pub fn get_chainable_effects(&self, current_chain_level: EffectSpeed) -> Vec<&EffectTiming> {
        self.prioritized_effects
            .iter()
            .filter(|e| {
                let timing = e.get_effect().get_speed();
                if timing >= current_chain_level {
                    return true;
                } else {
                    return false;
                }
            })
            .collect()
    }

    /// 발동 가능한 효과만 필터링합니다.
    ///
    /// # Arguments
    ///
    /// * `game` - `GameActor`의 주소.
    /// * `source` - 효과의 발동 주체인 `Card` 객체에 대한 참조.
    ///
    /// # Returns
    ///
    /// - `Vec<&EffectTiming>`: 발동 가능한 효과들의 `EffectTiming` 객체에 대한 불변 참조 벡터.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // TODO: 이 함수를 위한 테스트 케이스를 추가하세요. GameActor와 Card 의존성 때문에 현재는 불가능합니다.
    /// ```
    // 발동 가능한 효과만 필터링
    pub fn get_activatable_effects(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Vec<&EffectTiming> {
        todo!()
        // self.prioritized_effects
        //     .iter()
        //     .filter(|e| e.get_effect().can_activate(game, source))
        //     .collect()
    }
}

/// `EffectTiming` 구조체는 효과의 실행 시점과 우선순위, 속도 등의 정보를 담고 있습니다.
/// 효과의 발동 순서를 결정하는 데 사용됩니다.
#[derive(Clone)]
pub struct EffectTiming {
    priority: u8, // 낮을수록 높은 우선순위
    speed: EffectSpeed,
    is_used: bool, // 효과가 사용되었는지 여부
    effect: Box<dyn Effect>,
}

impl EffectTiming {
    /// `EffectTiming` 구조체의 새로운 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `priority` - 효과의 우선순위. 낮을수록 높은 우선순위를 가집니다.
    /// * `speed` - 효과의 발동 속도.
    /// * `effect` - 실행할 효과 객체. `Effect` 트레잇을 구현해야 합니다.
    ///
    /// # Returns
    ///
    /// - `EffectTiming`: 주어진 인자들을 사용하여 초기화된 새로운 `EffectTiming` 인스턴스.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    ///
    /// assert_eq!(effect_timing.get_priority(), 1);
    /// assert_eq!(effect_timing.get_speed(), EffectSpeed::Fast);
    /// ```
    pub fn new(priority: u8, speed: EffectSpeed, effect: Box<dyn Effect>) -> Self {
        Self {
            priority,
            effect,
            speed,
            is_used: false,
        }
    }

    /// 효과의 우선순위를 반환합니다.
    ///
    /// # Returns
    ///
    /// - `u8`: 효과의 우선순위 값. 낮을수록 높은 우선순위를 가집니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    ///
    /// assert_eq!(effect_timing.get_priority(), 1);
    /// ```
    pub fn get_priority(&self) -> u8 {
        self.priority
    }

    /// 효과의 발동 속도를 반환합니다.
    ///
    /// # Returns
    ///
    /// - `EffectSpeed`: 효과의 발동 속도.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    ///
    /// assert_eq!(effect_timing.get_speed(), EffectSpeed::Fast);
    /// ```
    pub fn get_speed(&self) -> EffectSpeed {
        self.speed
    }

    /// 효과 객체에 대한 불변 참조를 반환합니다.
    ///
    /// # Returns
    ///
    /// - `&Box<dyn Effect>`: 효과 객체에 대한 불변 참조.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let effect = Box::new(ExampleEffect {});
    /// let effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    ///
    /// let retrieved_effect = effect_timing.get_effect();
    /// // You can't directly assert equality on trait objects without more setup.
    /// ```
    pub fn get_effect(&self) -> &Box<dyn Effect> {
        &self.effect
    }

    /// 효과 객체에 대한 가변 참조를 반환합니다.
    ///
    /// # Returns
    ///
    /// - `&mut Box<dyn Effect>`: 효과 객체에 대한 가변 참조.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::effect::{EffectTiming, Effect};
    /// use simulator_core::effect::types::EffectSpeed;
    ///
    /// // Example Effect (replace with a real implementation)
    /// struct ExampleEffect {}
    /// impl Effect for ExampleEffect {
    ///     fn apply(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> Result<(), String> {
    ///         Ok(())
    ///     }
    ///     fn can_activate(&self, _game: actix::Addr<simulator_core::game::GameActor>, _card: &simulator_core::card::Card) -> bool {
    ///         true
    ///     }
    ///     fn get_speed(&self) -> EffectSpeed {
    ///         EffectSpeed::Normal
    ///     }
    /// }
    ///
    /// let mut effect = Box::new(ExampleEffect {});
    /// let mut effect_timing = EffectTiming::new(1, EffectSpeed::Fast, effect);
    ///
    /// let retrieved_effect = effect_timing.get_effect_mut();
    /// // You can't directly assert equality on trait objects without more setup.
    /// ```
    pub fn get_effect_mut(&mut self) -> &mut Box<dyn Effect> {
        &mut self.effect
    }
}
</file>

<file path="simulator_core/src/game/msg/gameplay.rs">
use actix::{Handler, Message};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    exception::{GameError, StateError},
    game::{phase::Phase, GameActor},
};

/// `RequestPlayCard` 메시지.
///
/// 플레이어가 카드를 사용하기 위한 요청을 나타냅니다.
///
/// # Examples
///
/// ```
/// use uuid::Uuid;
/// use crate::card::types::PlayerKind;
/// use simulator_core::game::msg::gameplay::RequestPlayCard;
///
/// let request = RequestPlayCard {
///     player_type: PlayerKind::User,
///     card_id: Uuid::new_v4(),
/// };
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RequestPlayCard {
    /// 카드를 사용하려는 플레이어의 종류.
    pub player_type: PlayerKind,
    /// 사용하려는 카드의 UUID.
    pub card_id: Uuid,
}

/// `SubmitInput` 메시지.
///
/// 플레이어가 입력을 제출하기 위한 요청을 나타냅니다.
///
/// # Examples
///
/// ```
/// use uuid::Uuid;
/// use crate::card::types::PlayerKind;
/// use simulator_core::game::msg::gameplay::SubmitInput;
///
/// let submit = SubmitInput {
///     player_type: PlayerKind::User,
///     request_id: Uuid::new_v4(),
/// };
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct SubmitInput {
    /// 입력을 제출하려는 플레이어의 종류.
    pub player_type: PlayerKind,
    /// 제출하려는 입력의 UUID.
    pub request_id: Uuid,
}

/// `RequestInput` 메시지.
///
/// 플레이어에게 입력을 요청하기 위한 메시지입니다.
///
/// # Examples
///
/// ```
/// use uuid::Uuid;
/// use crate::card::types::PlayerKind;
/// use simulator_core::game::msg::gameplay::RequestInput;
///
/// let request = RequestInput {
///     player_type: PlayerKind::User,
///     request_id: Uuid::new_v4(),
/// };
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RequestInput {
    /// 입력을 요청받을 플레이어의 종류.
    pub player_type: PlayerKind,
    /// 요청의 UUID.
    pub request_id: Uuid,
}

/// `IsCorrectPhase` 메시지.
///
/// 현재 게임 단계가 예상 단계와 일치하는지 확인하는 데 사용됩니다.
///
/// # Examples
///
/// ```
/// use simulator_core::game::phase::Phase;
/// use simulator_core::game::msg::gameplay::IsCorrectPhase;
///
/// let is_correct = IsCorrectPhase {
///     phase: Phase::Start,
/// };
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct IsCorrectPhase {
    /// 확인하려는 단계.
    pub phase: Phase,
}

/// `ChoiceCardRequestPayload` 구조체.
///
/// 카드 선택 요청에 필요한 데이터를 담는 구조체입니다.
///
/// # Fields
///
/// * `player`: 선택을 요청하는 플레이어의 이름.
/// * `choice_type`: 선택의 종류. (예: "카드 선택", "대상 선택")
/// * `source_card_id`: 선택의 근원이 되는 카드의 UUID.
/// * `min_selections`: 최소 선택 횟수.
/// * `max_selections`: 최대 선택 횟수.
/// * `destination`: 선택 결과를 저장할 위치.
/// * `is_open`: 선택이 공개적인지 여부.
/// * `is_hidden_from_opponent`: 상대방에게 숨겨지는지 여부.
///
/// # Examples
///
/// ```
/// use uuid::Uuid;
/// use simulator_core::game::msg::gameplay::ChoiceCardRequestPayload;
///
/// let payload = ChoiceCardRequestPayload {
///     player: "Player1".to_string(),
///     choice_type: "CardSelection".to_string(),
///     source_card_id: Uuid::new_v4(),
///     min_selections: 1,
///     max_selections: 3,
///     destination: "Hand".to_string(),
///     is_open: true,
///     is_hidden_from_opponent: false,
/// };
/// ```
pub struct ChoiceCardRequestPayload {
    /// 선택을 요청하는 플레이어의 이름.
    pub player: String,
    /// 선택의 종류. (예: "카드 선택", "대상 선택")
    pub choice_type: String,
    /// 선택의 근원이 되는 카드의 UUID.
    pub source_card_id: Uuid,
    /// 최소 선택 횟수.
    pub min_selections: usize,
    /// 최대 선택 횟수.
    pub max_selections: usize,
    /// 선택 결과를 저장할 위치.
    pub destination: String,
    /// 선택이 공개적인지 여부.
    pub is_open: bool,
    /// 상대방에게 숨겨지는지 여부.
    pub is_hidden_from_opponent: bool,
}

impl Handler<RequestPlayCard> for GameActor {
    type Result = Result<(), GameError>;

    /// `RequestPlayCard` 메시지를 처리합니다.
    ///
    /// # Arguments
    ///
    /// * `msg`: 처리할 `RequestPlayCard` 메시지.
    /// * `_`: 액터 컨텍스트 (사용되지 않음).
    ///
    /// # Returns
    ///
    /// 성공하면 `Ok(())`, 실패하면 `Err(GameError)`.
    ///
    /// # Examples
    ///
    /// ```
    /// // GameActor의 handle 메서드를 직접 호출하는 예제 (실제로는 Actix 프레임워크를 통해 호출됨)
    /// use actix::Context;
    /// use uuid::Uuid;
    /// use crate::card::types::PlayerKind;
    /// use simulator_core::game::msg::gameplay::RequestPlayCard;
    /// use simulator_core::game::GameActor;
    ///
    /// let mut actor = GameActor::new();
    /// let mut ctx = Context::new();
    /// let msg = RequestPlayCard {
    ///     player_type: PlayerKind::User,
    ///     card_id: Uuid::new_v4(),
    /// };
    /// let result = actor.handle(msg, &mut ctx);
    /// assert!(result.is_ok());
    /// ```
    fn handle(&mut self, msg: RequestPlayCard, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<SubmitInput> for GameActor {
    type Result = Result<(), GameError>;

    /// `SubmitInput` 메시지를 처리합니다.
    ///
    /// # Arguments
    ///
    /// * `msg`: 처리할 `SubmitInput` 메시지.
    /// * `_`: 액터 컨텍스트 (사용되지 않음).
    ///
    /// # Returns
    ///
    /// 성공하면 `Ok(())`, 실패하면 `Err(GameError)`.
    ///
    /// # Examples
    ///
    /// ```
    /// // GameActor의 handle 메서드를 직접 호출하는 예제 (실제로는 Actix 프레임워크를 통해 호출됨)
    /// use actix::Context;
    /// use uuid::Uuid;
    /// use crate::card::types::PlayerKind;
    /// use simulator_core::game::msg::gameplay::SubmitInput;
    /// use simulator_core::game::GameActor;
    ///
    /// let mut actor = GameActor::new();
    /// let mut ctx = Context::new();
    /// let msg = SubmitInput {
    ///     player_type: PlayerKind::User,
    ///     request_id: Uuid::new_v4(),
    /// };
    /// let result = actor.handle(msg, &mut ctx);
    /// assert!(result.is_ok());
    /// ```
    fn handle(&mut self, msg: SubmitInput, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<RequestInput> for GameActor {
    type Result = Result<(), GameError>;

    /// `RequestInput` 메시지를 처리합니다.
    ///
    /// # Arguments
    ///
    /// * `msg`: 처리할 `RequestInput` 메시지.
    /// * `_`: 액터 컨텍스트 (사용되지 않음).
    ///
    /// # Returns
    ///
    /// 성공하면 `Ok(())`, 실패하면 `Err(GameError)`.
    ///
    /// # Examples
    ///
    /// ```
    /// // GameActor의 handle 메서드를 직접 호출하는 예제 (실제로는 Actix 프레임워크를 통해 호출됨)
    /// use actix::Context;
    /// use uuid::Uuid;
    /// use crate::card::types::PlayerKind;
    /// use simulator_core::game::msg::gameplay::RequestInput;
    /// use simulator_core::game::GameActor;
    ///
    /// let mut actor = GameActor::new();
    /// let mut ctx = Context::new();
    /// let msg = RequestInput {
    ///     player_type: PlayerKind::User,
    ///     request_id: Uuid::new_v4(),
    /// };
    /// let result = actor.handle(msg, &mut ctx);
    /// assert!(result.is_ok());
    /// ```
    fn handle(&mut self, msg: RequestInput, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<IsCorrectPhase> for GameActor {
    type Result = Result<(), GameError>;

    /// `IsCorrectPhase` 메시지를 처리합니다.
    ///
    /// # Arguments
    ///
    /// * `msg`: 처리할 `IsCorrectPhase` 메시지.
    /// * `_`: 액터 컨텍스트 (사용되지 않음).
    ///
    /// # Returns
    ///
    /// 현재 게임 단계가 메시지의 `phase`와 같으면 `Ok(())`를 반환합니다.
    /// 그렇지 않으면 `Err(GameError)`를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// // GameActor의 handle 메서드를 직접 호출하는 예제 (실제로는 Actix 프레임워크를 통해 호출됨)
    /// use actix::Context;
    /// use simulator_core::game::phase::Phase;
    /// use simulator_core::game::msg::gameplay::IsCorrectPhase;
    /// use simulator_core::game::GameActor;
    ///
    /// let mut actor = GameActor::new();
    /// actor.turn.current_phase = Phase::Start; // 현재 단계를 Start로 설정
    /// let mut ctx = Context::new();
    /// let msg = IsCorrectPhase {
    ///     phase: Phase::Start,
    /// };
    /// let result = actor.handle(msg, &mut ctx);
    /// assert!(result.is_ok());
    ///
    /// let msg_wrong_phase = IsCorrectPhase {
    ///     phase: Phase::Draw,
    /// };
    /// let result_wrong_phase = actor.handle(msg_wrong_phase, &mut ctx);
    /// assert!(result_wrong_phase.is_err());
    /// ```
    fn handle(&mut self, msg: IsCorrectPhase, _: &mut Self::Context) -> Self::Result {
        if self.turn.current_phase == msg.phase {
            Ok(())
        } else {
            Err(GameError::State(StateError::InvalidActionForPhase { current_phase: format!("{:?}", self.turn.current_phase), action: format!("{:?}", msg.phase) }))
        }
    }
}
</file>

<file path="simulator_core/src/game/msg/helper.rs">
use crate::{
    card::Card,
    sync::snapshots::{CardSnapshot, PrivateCardSnapshot},
};

/// `Card`를 `CardSnapshot`으로 변환하는 헬퍼 함수입니다.
/// `CardSnapshot`은 `Card`의 공개된 정보만 담고 있습니다.
///
/// # Arguments
///
/// * `card` - 변환할 `Card` 객체에 대한 참조입니다.
///
/// # Returns
///
/// `Card`의 공개 정보를 담은 `CardSnapshot` 객체입니다.
///
/// # Examples
///
/// ```
/// // TODO: 예제 코드 추가
/// ```
pub fn to_card_snapshot(card: &Card) -> CardSnapshot {
    // Card의 공개 정보를 바탕으로 CardSnapshot 생성
    todo!()
}

/// `Card`를 `PrivateCardSnapshot`으로 변환하는 헬퍼 함수입니다.
/// `PrivateCardSnapshot`은 `Card`의 모든 정보를 담고 있습니다.
///
/// # Arguments
///
/// * `card` - 변환할 `Card` 객체에 대한 참조입니다.
///
/// # Returns
///
/// `Card`의 모든 정보를 담은 `PrivateCardSnapshot` 객체입니다.
///
/// # Examples
///
/// ```
/// // TODO: 예제 코드 추가
/// ```
pub fn to_private_card_snapshot(card: &Card) -> PrivateCardSnapshot {
    // Card의 모든 정보를 바탕으로 PrivateCardSnapshot 생성
    todo!()
}
</file>

<file path="simulator_core/src/game/msg/lifecycle.rs">
use actix::{Context, Handler, Message};
use tracing::info;

use crate::{
    card::types::PlayerKind,
    exception::{GameError, GameplayError},
    game::GameActor,
    game::GameConfig,
};

/// `InitializeGame` 메시지는 게임 액터를 초기화하는 데 사용됩니다.
/// 이 메시지는 게임 설정 정보를 담고 있으며, 게임 액터가 시작될 때 전송됩니다.
///
/// # Examples
///
/// ```
/// use simulator_core::game::msg::lifecycle::InitializeGame;
/// use simulator_core::game::GameConfig;
///
/// let config = GameConfig::default(); // 또는 사용자 정의 설정
/// let init_msg = InitializeGame(config);
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct InitializeGame(pub GameConfig);

/// `RemovePlayerActor` 메시지는 게임에서 특정 플레이어 액터를 제거하는 데 사용됩니다.
/// 이 메시지는 제거할 플레이어의 종류를 지정합니다.
///
/// # Examples
///
/// ```
/// use simulator_core::game::msg::lifecycle::RemovePlayerActor;
/// use simulator_core::card::types::PlayerKind;
///
/// let remove_msg = RemovePlayerActor { player_kind: PlayerKind::Human };
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RemovePlayerActor {
    pub player_kind: PlayerKind,
}

/// `PlayerReady` 메시지는 플레이어가 게임에 참여할 준비가 되었음을 알리는 데 사용됩니다.
/// 이 메시지는 준비된 플레이어의 종류를 지정합니다.
///
/// # Examples
///
/// ```
/// use simulator_core::game::msg::lifecycle::PlayerReady;
/// use simulator_core::card::types::PlayerKind;
///
/// let ready_msg = PlayerReady(PlayerKind::Human);
/// ```
#[derive(Message)]
#[rtype(result = "()")]
pub struct PlayerReady(pub PlayerKind);

/// `CheckReEntry` 메시지는 플레이어가 게임에 재진입할 수 있는지 확인하는 데 사용됩니다.
/// 이 메시지는 확인하려는 플레이어의 종류를 지정합니다.
///
/// # Examples
///
/// ```
/// use simulator_core::game::msg::lifecycle::CheckReEntry;
/// use simulator_core::card::types::PlayerKind;
///
/// let check_msg = CheckReEntry { player_type: PlayerKind::Human };
/// ```
#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct CheckReEntry {
    pub player_type: PlayerKind,
}

impl Handler<InitializeGame> for GameActor {
    type Result = Result<(), GameError>;

    /// `InitializeGame` 메시지를 처리합니다.
    /// 현재는 아무 작업도 수행하지 않고 성공을 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `msg` - `InitializeGame` 메시지.
    /// * `_` - 액터 컨텍스트.
    ///
    /// # Returns
    ///
    /// * `Result<(), GameError>` - 항상 `Ok(())`를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// // 이 핸들러는 실제로 호출되는 예시를 보여주기 어렵습니다.
    /// // 액터 시스템 내부에서 호출되기 때문입니다.
    /// ```
    fn handle(&mut self, msg: InitializeGame, _: &mut Self::Context) -> Self::Result {
        Ok(())
    }
}

impl Handler<RemovePlayerActor> for GameActor {
    type Result = Result<(), GameError>;

    /// `RemovePlayerActor` 메시지를 처리합니다.
    /// 지정된 플레이어 액터를 게임에서 제거합니다.
    ///
    /// # Arguments
    ///
    /// * `msg` - `RemovePlayerActor` 메시지.
    /// * `_` - 액터 컨텍스트.
    ///
    /// # Returns
    ///
    /// * `Result<(), GameError>` - 성공하면 `Ok(())`, 플레이어를 찾을 수 없으면 `Err(GameError)`를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// // 이 핸들러는 실제로 호출되는 예시를 보여주기 어렵습니다.
    /// // 액터 시스템 내부에서 호출되기 때문입니다.
    /// ```
    fn handle(&mut self, msg: RemovePlayerActor, _: &mut Self::Context) -> Self::Result {
        info!("Removing player actor: {:?}", msg.player_kind);
        let player_identity = self
            .get_player_identity_by_kind(msg.player_kind)
            .cloned()
            .ok_or_else(|| {
                GameError::Gameplay(GameplayError::ResourceNotFound {
                    kind: "player_identity",
                    id: format!("{:?}", msg.player_kind),
                })
            })?;
        if let None = self.players.remove(&player_identity) {
            return Err(GameError::Gameplay(GameplayError::ResourceNotFound {
                kind: "player_identity",
                id: format!("{:?}", msg.player_kind),
            }));
        }
        Ok(())
    }
}

impl Handler<PlayerReady> for GameActor {
    type Result = ();

    /// `PlayerReady` 메시지를 처리합니다.
    /// 현재는 아무 작업도 수행하지 않습니다.
    ///
    /// # Arguments
    ///
    /// * `msg` - `PlayerReady` 메시지.
    /// * `_` - 액터 컨텍스트.
    ///
    /// # Returns
    ///
    /// * `()` - 항상 `()`를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// // 이 핸들러는 실제로 호출되는 예시를 보여주기 어렵습니다.
    /// // 액터 시스템 내부에서 호출되기 때문입니다.
    /// ```
    fn handle(&mut self, msg: PlayerReady, _: &mut Self::Context) -> Self::Result {}
}

impl Handler<CheckReEntry> for GameActor {
    type Result = Result<(), GameError>;

    /// `CheckReEntry` 메시지를 처리합니다.
    /// 플레이어의 재진입을 확인하는 로직을 구현해야 합니다.
    ///
    /// # Arguments
    ///
    /// * `msg` - `CheckReEntry` 메시지.
    /// * `_` - 액터 컨텍스트.
    ///
    /// # Returns
    ///
    /// * `Result<(), GameError>` - 성공하면 `Ok(())`, 실패하면 `Err(GameError)`를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// // 이 핸들러는 실제로 호출되는 예시를 보여주기 어렵습니다.
    /// // 액터 시스템 내부에서 호출되기 때문입니다.
    /// ```
    fn handle(&mut self, msg: CheckReEntry, _: &mut Context<Self>) -> Self::Result {
        todo!() // TODO: 재진입 로직 구현
    }
}
</file>

<file path="simulator_core/src/game/msg/mod.rs">
pub mod connection;
pub mod error_message;
pub mod gameplay;
pub mod helper;
pub mod lifecycle;
pub mod mulligan;
pub mod system;
pub mod zones;

use actix::Message;
use uuid::Uuid;

use crate::sync::{snapshots::GameStateSnapshot, types::StateUpdatePayload};

#[derive(Message, Clone)]
#[rtype(result = "()")]
pub enum GameEvent {
    GameStopped,
    SendMulliganDealCards { cards: Vec<Uuid> },
    SyncState { snapshot: GameStateSnapshot },
    StateUpdate(StateUpdatePayload), // 신규: 델타 업데이트를 위한 variant
}
</file>

<file path="simulator_core/src/game/msg/system.rs">
use actix::{ActorContext, Context, Handler, Message};
use tracing::info;

use crate::{
    exception::GameError,
    game::{
        msg::helper::{to_card_snapshot, to_private_card_snapshot},
        GameActor,
    },
    player::PlayerActor,
    sync::snapshots::PlayerStateSnapshot,
    zone::zone::Zone,
};

#[derive(Message)]
#[rtype(result = "()")]
pub struct Terminate;

impl Handler<Terminate> for GameActor {
    type Result = ();

    fn handle(&mut self, _: Terminate, ctx: &mut Context<Self>) -> Self::Result {
        info!("GAME ACTOR [{}]: Handling Terminate", self.game_id);
        ctx.stop();
    }
}

#[derive(Message)]
#[rtype(result = "Result<PlayerStateSnapshot, GameError>")]
pub struct GetPlayerStateSnapshot;

impl Handler<GetPlayerStateSnapshot> for PlayerActor {
    type Result = Result<PlayerStateSnapshot, GameError>;

    fn handle(&mut self, _msg: GetPlayerStateSnapshot, _ctx: &mut Context<Self>) -> Self::Result {
        Ok(PlayerStateSnapshot {
            player_kind: self.player_type,
            health: self.health, // 가상의 필드
            mana: self.mana.get_current(),
            mana_max: self.mana.get_max(),
            deck_count: self.deck.len(),
            hand: self
                .hand
                .get_cards()
                .iter()
                .map(to_private_card_snapshot)
                .collect(),
            field: self
                .field
                .get_cards()
                .iter()
                .map(to_card_snapshot)
                .collect(),
            graveyard: self
                .graveyard
                .get_cards()
                .iter()
                .map(to_card_snapshot)
                .collect(),
        })
    }
}
</file>

<file path="simulator_core/src/resource.rs">
///
/// 수정 가능한 자원에 대해서 증감 및 관련 편의 메소드를 제공하는 trait
///

pub trait Resource {
    /// 현재 값을 가져옴
    fn get_value(&self) -> i32;

    /// 기본 값을 가져옴
    fn get_base_value(&self) -> i32;

    /// 현재 값을 설정
    fn set_value(&mut self, value: i32);

    /// 값을 증가
    fn increase(&mut self, amount: i32) {
        self.set_value(self.get_value() + amount);
    }

    /// 값을 감소
    fn decrease(&mut self, amount: i32) {
        self.set_value(self.get_value() - amount);
    }

    /// 최소값 제한
    fn get_min_value(&self) -> Option<i32> {
        None // 기본적으로는 제한 없음
    }

    /// 최대값 제한
    fn get_max_value(&self) -> Option<i32> {
        None // 기본적으로는 제한 없음
    }

    /// 제한을 고려한 값 설정
    fn set_value_with_limits(&mut self, value: i32) {
        let value = if let Some(min) = self.get_min_value() {
            value.max(min)
        } else {
            value
        };

        let value = if let Some(max) = self.get_max_value() {
            value.min(max)
        } else {
            value
        };

        self.set_value(value);
    }

    /// 퍼센트 기반 증가
    fn increase_percent(&mut self, percent: f32) {
        let increase = (self.get_base_value() as f32 * percent).round() as i32;
        self.increase(increase);
    }
}

/// `Resource` 트레이트를 확장하여 자원에 대한 추가적인 편의 메소드를 제공합니다.
/// 주로 현재 값과 기본 값 간의 비교, 초기화 등에 사용됩니다.
// TODO: 더 많은 확장 기능 (예: 버프/디버프 적용/해제) 추가 고려
// TODO: 특정 조건에 따라 값을 변경하는 로직 추가 고려
pub trait ResourceExtension: Resource {
    /// 기본값으로 초기화
    fn reset_to_base(&mut self) {
        self.set_value(self.get_base_value());
    }

    /// 현재 값이 기본값보다 높은지 확인
    fn is_buffed(&self) -> bool {
        self.get_value() > self.get_base_value()
    }

    /// 현재 값이 기본값보다 낮은지 확인
    fn is_debuffed(&self) -> bool {
        self.get_value() < self.get_base_value()
    }

    /// 현재 값이 기본값과 다른지 확인
    fn is_modified(&self) -> bool {
        self.get_value() != self.get_base_value()
    }

    /// 버프/디버프의 차이값 반환
    fn get_modification_amount(&self) -> i32 {
        self.get_value() - self.get_base_value()
    }
}

#[derive(Clone)]
/// 카드 스펙에 사용되는 자원을 나타내는 구조체입니다.
/// `value`는 현재 값, `base`는 기본 값을 저장합니다.
// TODO: 자원 타입에 대한 제네릭 파라미터 추가 고려 (현재는 i32로 고정)
// TODO: 디버깅 편의를 위한 `Debug` 트레이트 구현 고려
pub struct CardSpecsResource {
    value: i32,
    base: i32,
}

/// `CardSpecsResource` 구조체에 `Resource` 트레이트를 구현합니다.
impl Resource for CardSpecsResource {
    fn get_value(&self) -> i32 {
        self.value
    }

    fn get_base_value(&self) -> i32 {
        self.base
    }

    fn set_value(&mut self, value: i32) {
        self.value = value;
    }
}

/// `CardSpecsResource` 구조체에 `ResourceExtension` 트레이트를 구현합니다.
impl ResourceExtension for CardSpecsResource {}

impl CardSpecsResource {
    /// 새로운 `CardSpecsResource` 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `value` - 자원의 초기 값 및 기본 값으로 설정될 값입니다.
    pub fn new(value: i32) -> Self {
        Self { value, base: value }
    }
}
</file>

<file path="simulator_core/src/selector/single.rs">
use std::sync::Arc;

use actix::Addr;

use crate::{
    card::{
        types::{CardType, OwnerType},
        Card,
    },
    enums::ZoneType,
    exception::GameError,
    game::GameActor,
};

use super::{TargetCondition, TargetCount, TargetSelector};

pub struct SingleCardSelector {
    condition: TargetCondition,
}

impl SingleCardSelector {
    pub fn new(location: ZoneType, owner: OwnerType) -> Self {
        Self {
            condition: TargetCondition {
                location: vec![location],
                owner,
                card_type: None,
                custom_filter: None,
            },
        }
    }

    pub fn with_card_type(mut self, card_type: CardType) -> Self {
        self.condition.card_type = Some(card_type);
        self
    }

    pub fn with_filter<F>(mut self, filter: F) -> Self
    where
        F: Fn(&Card) -> bool + Send + Sync + 'static,
    {
        self.condition.custom_filter = Some(Arc::new(filter));
        self
    }
}

impl TargetSelector for SingleCardSelector {
    fn select_targets(&self, game: Addr<GameActor>, source: &Card) -> Result<Vec<Card>, GameError> {
        // let valid_targets = self.get_valid_targets(game, source);

        // if valid_targets.is_empty() {
        //     return Err(GameError::NoValidTargets);
        // }

        // // 실제 게임에서는 플레이어가 선택
        // Ok(vec![valid_targets[0].clone()])
        todo!()
    }

    fn has_valid_targets(&self, game: Addr<GameActor>, source: &Card) -> bool {
        // !self.get_valid_targets(game, source).is_empty()
        todo!()
    }

    fn get_target_count(&self) -> TargetCount {
        // TargetCount::Exact(1)
        todo!()
    }

    fn clone_selector(&self) -> Box<dyn TargetSelector> {
        Box::new(Self {
            condition: self.condition.clone(),
        })
    }

    fn get_owner(&self) -> OwnerType {
        todo!()
    }

    fn get_locations(&self) -> Vec<ZoneType> {
        todo!()
    }

    fn is_valid_target(&self, card: &Card, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }
}
</file>

<file path="simulator_core/src/zone/deck.rs">
use uuid::Uuid;

use crate::{
    card::{cards::Cards, insert::Insert, take::Take, Card},
    enums::DECK_ZONE_SIZE,
    exception::GameError,
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Deck {
    zone_cards: Cards,
    zone_size: usize,
}

impl Deck {
    pub fn new(zone_cards: Cards) -> Deck {
        Deck {
            zone_cards,
            zone_size: DECK_ZONE_SIZE,
        }
    }

    /// 현재 Zone 에 카드를 추가 합니다.
    /// TODO: 무슨 방식으로(eg. 랜덤, 맨 위, 맨 아래) 넣을지 구현해야함.

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, _card: Card) -> Result<(), GameError> {
        // 카드 관리 방법 변경에 따라, 재작성해야함.
        todo!();
    }
}

impl Zone for Deck {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        &mut self.zone_cards
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError> {
        for card in cards {
            insert.insert(self, card)?;
        }
        Ok(())
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn take_card(&mut self, mut take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        take_type.as_mut().take(self)
    }
}
</file>

<file path="simulator_core/src/zone/hand.rs">
use uuid::Uuid;

use crate::{
    card::{
        cards::{CardVecExt, Cards},
        insert::Insert,
        take::Take,
        Card,
    },
    enums::UNIT_ZONE_SIZE,
    exception::{GameError, GameplayError},
};

use super::zone::Zone;

#[derive(Clone)]
pub struct Hand {
    zone_cards: Cards,
    zone_size: usize,
}

impl Hand {
    pub fn new() -> Hand {
        Hand {
            zone_cards: Cards::new(),
            zone_size: UNIT_ZONE_SIZE,
        }
    }

    /// 특정 카드를 현재 Zone 으로부터 삭제합니다.
    pub fn remove_card(&mut self, card: Card) -> Result<(), GameError> {
        self.zone_cards
            .remove_by_uuid(card.get_uuid())
            .map(|_| ())
            .ok_or(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "card", id: card.get_uuid().to_string() }))
    }
}

impl Zone for Hand {
    fn get_cards(&self) -> &Cards {
        &self.zone_cards
    }

    fn get_cards_mut(&mut self) -> &mut Cards {
        todo!()
    }

    fn remove_card(&mut self, uuid: Uuid) {
        todo!()
    }

    fn len(&self) -> usize {
        todo!()
    }

    fn add_card(&mut self, cards: Vec<Card>, insert: Box<dyn Insert>) -> Result<(), GameError> {
        for card in cards {
            insert.insert(self, card)?;
        }
        Ok(())
    }

    fn take_card(&mut self, take_type: Box<dyn Take>) -> Result<Vec<Card>, GameError> {
        todo!()
    }
}
</file>

<file path="simulator_dedicated_server/src/lib.rs">
pub mod connection;
pub mod enums;
pub mod room;
pub mod server;
pub mod test;
</file>

<file path="simulator_match_server/src/lib.rs">
pub mod env;
pub mod matchmaker;
pub mod util;
</file>

<file path="simulator_core/Cargo.toml">
[package]
name = "simulator_core"
version = "0.1.0"
edition = "2021"
description = "card backend"
build = "build.rs"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[build-dependencies]

[[bench]]
name = "bench"
harness = false

[dependencies]
rand_core = "0.6"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.18.0"
base64 = "0.13.1"
byteorder = "1.5.0"
rayon = "1.8.0"
clap = {version="4.5.26", features = ["derive"]}
ctor = "0.4.1"

actix-web = "4.9.0"
actix = "=0.13.5"
actix-ws = "0.3.0"
async-tungstenite = {version="0.28.2", features = ["tokio-runtime"]}
reqwest = "0.12.12"

futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
argon2 = "0.5.3"
dotenv = "0.15.0"

gnuplot = "0.0.45"
criterion = "0.5.1"
url = "2.5.4"

tokio = { version = "1.15", features = ["full", "tracing"] }
tokio-console = "0.1.13"
console-subscriber = "0.4.1"

uuid = { version = "1.14.0", features = ["v4", "serde"] }
lazy_static = "1.5.0"
structopt = "=0.3.26"
rand = "0.8.5"
hex = "0.4.3"
parking_lot = "0.12.3"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
paste = "1.0.15"
cargo-llvm-cov = "0.6.16"

serial_test = "3.2.0"
</file>

<file path="simulator_core/src/card_gen/builder.rs">
use uuid::Uuid;

use crate::{
    card::{
        types::{CardSpecs, CardStatus, CardType, OwnerType},
        Card,
    },
    effect::{effects::EffectTiming, types::EffectSpeed, Effect},
    exception::{GameError, GameplayError},
    utils::{self, json::CardJson},
};

/// `CardBuilder`는 카드 생성을 위한 빌더 패턴을 구현합니다.
/// 카드 속성을 설정하고 `Card` 인스턴스를 생성하는 데 사용됩니다.
pub struct CardBuilder {
    uuid: Uuid,
    name: String,
    card_type: CardType,
    effects: Vec<EffectTiming>,
    json_data: CardJson,
    owner: OwnerType,
    /// CardSpecs는 카드의 스펙 정보(공격력, 방어력 등)를 담고 있습니다.  `CardBuilder`를 통해 설정됩니다.
    pub specs: CardSpecs,
    status: CardStatus,
}

impl CardBuilder {
    /// `new`는 `CardBuilder`의 새 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `card_json` - 카드 정보가 담긴 JSON 데이터에 대한 참조.
    ///
    /// # Returns
    ///
    /// * `Result<Self, GameError>` - 성공하면 `CardBuilder` 인스턴스, 실패하면 `GameError`.
    pub fn new(card_json: &CardJson) -> Result<Self, GameError> {
        Ok(Self {
            uuid: utils::generate_uuid().unwrap(),
            name: card_json.name.clone().ok_or(GameError::Gameplay(GameplayError::InvalidAction { reason: "Invalid card data".to_string() }))?,
            card_type: CardType::from_json(card_json)?,
            effects: vec![],
            json_data: card_json.clone(),
            owner: OwnerType::None,
            specs: CardSpecs::new(card_json),
            status: CardStatus::new(),
        })
    }

    pub fn add_effect<E: Effect + 'static>(mut self, effect: E) -> Self {
        // TODO: priority 설정
        self.effects
            .push(EffectTiming::new(1, EffectSpeed::Medium, Box::new(effect)));
        self
    }

    // // UUID 설정
    // pub fn uuid(mut self, uuid: UUID) -> Self {
    //     self.uuid = uuid;
    //     self
    // }

    // // 이름 설정
    // pub fn name(mut self, name: String) -> Self {
    //     self.name = name;
    //     self
    // }

    // // 카드 타입 설정
    // pub fn card_type(mut self, card_type: CardType) -> Self {
    //     self.card_type = card_type;
    //     self
    // }

    // // 효과 목록 한번에 설정
    // pub fn effects(mut self, effects: Vec<Box<dyn Effect>>) -> Self {
    //     self.effects = effects;
    //     self
    // }

    // // JSON 데이터 설정
    // pub fn json_data(mut self, json_data: CardJson) -> Self {
    //     self.json_data = json_data;
    //     self
    // }

    // // 소유자 설정
    // pub fn owner(mut self, owner: OwnerType) -> Self {
    //     self.owner = owner;
    //     self
    // }

    // // 스펙 설정
    // pub fn specs(mut self, specs: CardSpecs) -> Self {
    //     self.specs = specs;
    //     self
    // }

    // pub fn status(mut self, status: CardStatus) -> Self {
    //     self.status = status;
    //     self
    // }

    /// `build`는 설정된 속성을 사용하여 `Card` 인스턴스를 생성합니다.
    ///
    /// # Returns
    ///
    /// * `Card` - 생성된 카드 인스턴스.
    pub fn build(self) -> Card {
        // owner: OwnerType,
        // uuid: UUID,
        // name: String,
        // effects: Vec<Box<dyn Effect>>,
        // r#type: CardType,
        // specs: CardSpecs,
        // status: CardStatus,
        // json_data: CardJson)
        Card::new(
            self.owner,
            self.uuid,
            self.name,
            self.effects,
            self.card_type,
            self.specs,
            self.status,
            self.json_data,
        )
    }
}
</file>

<file path="simulator_core/src/card/insert.rs">
use uuid::Uuid;

use crate::{exception::{GameError, GameplayError}, zone::zone::Zone};

use super::Card;

pub trait Insert: Send + Sync {
    /// 카드를 지정된 영역에 삽입합니다.
    ///
    /// # Arguments
    /// * `zone` - 카드를 삽입할 영역
    /// * `card` - 삽입할 카드
    ///
    /// # Returns
    /// * `Result<(), GameError>` - 삽입 성공 여부
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError>;

    /// 자기 자신의 복제본을 Box로 반환합니다.
    fn clone_box(&self) -> Box<dyn Insert>;
}
pub struct GeneralInsert;
pub struct TopInsert;
pub struct BottomInsert;
/// 카드를 영역 내 임의의 위치에 삽입하는 전략을 나타내는 구조체입니다.
pub struct RandomInsert;
/// 카드를 특정 카드 위 또는 아래에 삽입하는 전략을 나타내는 구조체입니다.
pub struct SpecificPositionInsert {
    target_card_uuid: Uuid,
    is_above: bool,
}

// Top 구현
impl Insert for TopInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인 (Zone 타입에 따라 다르게 처리할 수 있음)

        cards.push(card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(TopInsert)
    }
}

// Bottom 구현
impl Insert for BottomInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        cards.insert(0, card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(BottomInsert)
    }
}

// Random 구현
impl Insert for RandomInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        use rand::Rng;
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        let mut rng = rand::thread_rng();
        let position = rng.gen_range(0..=cards.len());
        cards.insert(position, card);
        Ok(())
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(RandomInsert)
    }
}

// 특정 위치 구현
impl SpecificPositionInsert {
    /// `SpecificPositionInsert` 구조체의 생성자입니다.
    ///
    /// # Arguments
    ///
    /// * `target_card_uuid` - 삽입 위치를 결정하는 대상 카드의 UUID
    /// * `is_above` - `true`이면 대상 카드 위에, `false`이면 대상 카드 아래에 삽입합니다.
    ///
    /// # Returns
    ///
    /// * `SpecificPositionInsert` - 새로 생성된 `SpecificPositionInsert` 인스턴스
    pub fn new(target_card_uuid: Uuid, is_above: bool) -> Self {
        Self {
            target_card_uuid,
            is_above,
        }
    }
}

impl Insert for SpecificPositionInsert {
    fn insert(&self, zone: &mut dyn Zone, card: Card) -> Result<(), GameError> {
        let cards = zone.get_cards_mut();

        // 영역 용량 확인

        if let Some(pos) = cards
            .iter()
            .position(|c| c.get_uuid() == self.target_card_uuid)
        {
            let insert_pos = if self.is_above { pos } else { pos + 1 };
            cards.insert(insert_pos, card);
            Ok(())
        } else {
            Err(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "card", id: self.target_card_uuid.to_string() }))
        }
    }

    fn clone_box(&self) -> Box<dyn Insert> {
        Box::new(Self {
            target_card_uuid: self.target_card_uuid,
            is_above: self.is_above,
        })
    }
}
</file>

<file path="simulator_core/src/card/take.rs">
use uuid::Uuid;

use crate::{exception::{GameError, SystemError, GameplayError, DeckError}, selector::TargetCount, zone::zone::Zone};

use super::Card;
use crate::card::cards::CardVecExt;

pub trait Take: Send + Sync {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError>;
    fn clone_box(&self) -> Box<dyn Take>;
}

// TopTake: 덱/존의 위에서 카드를 가져옴
#[derive(Clone)]
pub struct TopTake(pub TargetCount);

/// `TopTake` 구조체를 위한 `Take` 트레이트 구현입니다.
///
/// 덱이나 영역의 위에서부터 지정된 개수의 카드를 가져옵니다.
///
/// # Errors
///
/// * `GameError::System(SystemError::Internal)`: 사용 가능한 카드 수가 요청한 카드 수보다 적을 경우 발생합니다.
// TODO: 오류 발생 조건에 대한 더 자세한 설명이 필요합니다. 예를 들어, `TargetCount`의 설정에 따라 어떤 경우에 오류가 발생하는지 명확히 기술해야 합니다.
// TODO: 성능 개선을 위해 `drain` 대신 다른 방법을 사용할 수 있는지 검토해 볼 수 있습니다.
impl Take for TopTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::System(SystemError::Internal("Not enough cards available".to_string())));
        }

        // drain은 앞에서부터 제거하므로, 뒤에서부터 가져오려면 인덱스 계산 필요
        let start_index = available.saturating_sub(count);
        Ok(cards.drain(start_index..).collect()) // drain은 역순으로 반환하지 않음, 순서 유지됨
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone()) // Clone을 이용해 간단히 구현
    }
}

// BottomTake: 덱/존의 아래에서 카드를 가져옴
#[derive(Clone)]
pub struct BottomTake(pub TargetCount);

/// `BottomTake` 구조체를 위한 `Take` 트레이트 구현입니다.
///
/// 덱이나 영역의 아래에서부터 지정된 개수의 카드를 가져옵니다.
///
/// # Errors
///
/// * `GameError::System(SystemError::Internal)`: 사용 가능한 카드 수가 요청한 카드 수보다 적을 경우 발생합니다.
// TODO: 오류 발생 조건에 대한 더 자세한 설명이 필요합니다. 예를 들어, `TargetCount`의 설정에 따라 어떤 경우에 오류가 발생하는지 명확히 기술해야 합니다.
// TODO: 성능 개선을 위해 `drain` 대신 다른 방법을 사용할 수 있는지 검토해 볼 수 있습니다.
impl Take for BottomTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::System(SystemError::Internal("Not enough cards available".to_string())));
        }

        // 앞에서부터 count만큼 제거
        Ok(cards.drain(0..count).collect())
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// RandomTake: 덱/존에서 무작위로 카드를 가져옴
#[derive(Clone)]
pub struct RandomTake(pub TargetCount);

/// `RandomTake` 구조체를 위한 `Take` 트레이트 구현입니다.
///
/// 덱이나 영역에서 무작위로 지정된 개수의 카드를 가져옵니다.
///
/// # Errors
///
/// * `GameError::System(SystemError::Internal)`: 사용 가능한 카드 수가 요청한 카드 수보다 적을 경우 발생합니다.
// TODO: 오류 발생 조건에 대한 더 자세한 설명이 필요합니다. 예를 들어, `TargetCount`의 설정에 따라 어떤 경우에 오류가 발생하는지 명확히 기술해야 합니다.
// TODO: 무작위 선택 알고리즘의 시간 복잡도에 대한 언급이 필요합니다. 큰 덱에서 성능 문제가 발생할 수 있는지 고려해야 합니다.
// TODO: 현재 구현은 무작위로 선택된 카드를 제거된 순서의 역순으로 반환합니다. 이는 의도된 동작인지 명확히 해야 하며, 필요에 따라 원래 뽑힌 순서대로 반환하도록 수정할 수 있습니다.
impl Take for RandomTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();
        let available = cards.len();

        let count = calculate_take_count(self.0, available)?;

        if count == 0 {
            return Ok(Vec::new());
        }
        if count > available {
            return Err(GameError::System(SystemError::Internal("Not enough cards available".to_string())));
        }

        // 1. 무작위 인덱스를 count만큼 중복 없이 뽑기
        let mut rng = rand::thread_rng();
        let indices_to_take: Vec<usize> =
            rand::seq::index::sample(&mut rng, available, count).into_vec();

        // 2. 인덱스를 내림차순으로 정렬하여 제거 시 다른 인덱스에 영향을 주지 않도록 함
        let mut sorted_indices = indices_to_take;
        sorted_indices.sort_unstable_by(|a, b| b.cmp(a)); // 내림차순 정렬

        // 3. 정렬된 인덱스를 사용하여 카드 제거 및 수집
        let mut taken_cards = Vec::with_capacity(count);
        for index in sorted_indices {
            // remove는 요소를 제거하고 뒤의 요소들을 앞으로 당김
            taken_cards.push(cards.remove(index));
        }

        // 4. 원래 뽑힌 순서대로 돌려주려면 taken_cards를 reverse 해야 함 (선택적)
        // 현재는 제거된 순서의 역순으로 반환됨. 무작위 선택이므로 순서가 중요하지 않을 수 있음.
        // taken_cards.reverse();

        Ok(taken_cards)
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// SpecificTake: 특정 UUID의 카드를 가져옴
#[derive(Clone)]
pub struct SpecificTake(pub Uuid);

/// `SpecificTake` 구조체를 위한 `Take` 트레이트 구현입니다.
///
/// 특정 UUID를 가진 카드를 덱이나 영역에서 가져옵니다.
///
/// # Errors
///
/// * `GameError::Gameplay(GameplayError::ResourceNotFound)`: 지정된 UUID를 가진 카드가 없을 경우 발생합니다.
// TODO: 만약 동일한 UUID를 가진 카드가 여러 장 존재할 경우, 어떤 카드가 선택되는지에 대한 설명이 필요합니다.
// TODO: 만약 특정 UUID를 가진 카드가 여러 장 존재할 경우, 모든 카드를 가져오는 기능을 추가할 수 있습니다.
impl Take for SpecificTake {
    fn take(&mut self, zone: &mut dyn Zone) -> Result<Vec<Card>, GameError> {
        let cards = zone.get_cards_mut();

        match cards.remove_by_uuid(self.0) {
            Some(card) => Ok(vec![card]),
            None => Err(GameError::Gameplay(GameplayError::ResourceNotFound { kind: "card", id: self.0.to_string() })),
        }
    }

    fn clone_box(&self) -> Box<dyn Take> {
        Box::new(self.clone())
    }
}

// --- Helper Function ---

/// 가져올 카드의 수를 계산하는 헬퍼 함수
fn calculate_take_count(target_count: TargetCount, available: usize) -> Result<usize, GameError> {
    use std::cmp::min; // 함수 내에서만 사용

    match target_count {
        TargetCount::Exact(n) => {
            if n > available {
                // 정확히 n개를 가져와야 하는데 부족한 경우 -> 에러 처리 또는 정책 결정 필요
                // 여기서는 일단 에러로 처리 (혹은 0개를 반환할 수도 있음)
                Err(GameError::Gameplay(GameplayError::DeckError(DeckError::NoCardsLeftToDraw)))
            } else {
                Ok(n)
            }
        }
        TargetCount::Range(low, high) => {
            if available < low {
                // 최소 요구량보다 적으면 에러 또는 0 반환
                Err(GameError::Gameplay(GameplayError::DeckError(DeckError::NoCardsLeftToDraw)))
            } else {
                // low 이상 high 이하, 그리고 available 이하의 값을 반환
                Ok(min(high, available))
            }
        }
        TargetCount::Any => {
            // 가능한 모든 카드
            Ok(available)
        }
        TargetCount::None => {
            // 0개
            Ok(0)
        }
    }
}

// --- 새로운 에러 타입 정의 (선택적) ---
// exception/mod.rs 에 추가
// #[derive(Debug, PartialEq, Clone)]
// pub enum GameError {
//     // ... 기존 에러들 ...
//     NotEnoughCards(usize, usize), // 필요한 카드 수, 실제 있는 카드 수
//     // ...
// }
//
// impl fmt::Display for GameError {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self {
//             // ...
//             Self::NotEnoughCards(needed, available) => write!(f, "Not enough cards: needed {}, available {}", needed, available),
//             // ...
//         }
//     }
// }
</file>

<file path="simulator_core/src/effect/mod.rs">
pub mod effects;
pub mod types;
use std::any::Any;

use actix::Addr;
use types::{EffectInfo, EffectResult, EffectSpeed, EffectType};
use uuid::Uuid;

use crate::{
    card::{insert::Insert, take::Take, types::StatType, Card},
    exception::GameError,
    game::GameActor,
    selector::TargetSelector,
};

// 이 카드명의 "카드"는 1턴에 1장밖에 "발동"할 수 없다.
// 이 카드명의 "효과"는 1턴에 1장밖에 "사용"할 수 없다.
pub trait Effect: Send + Sync {
    /// 효과를 발동합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `Result<EffectResult, GameError>`
    /// # Errors
    /// * `GameError` - 효과 적용에 실패한 경우.
    fn begin_effect(&self, game: Addr<GameActor>, source: &Card)
        -> Result<EffectResult, GameError>;

    /// 효과를 발동할 수 있는지 확인합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `bool`
    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool;

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError>;

    fn get_effect_type(&self) -> EffectType;

    fn as_any(&self) -> &dyn Any;

    fn as_any_mut(&mut self) -> &mut dyn Any;

    fn get_id(&self) -> Uuid;

    fn get_speed(&self) -> EffectSpeed;
}

pub struct DigEffect {
    pub selector: Box<dyn TargetSelector>,
    pub insert: Box<dyn Insert>,
    pub take: Box<dyn Take>,
    pub info: EffectInfo,
}

impl DigEffect {
    pub fn new(
        selector: Box<dyn TargetSelector>,
        insert: Box<dyn Insert>,
        take: Box<dyn Take>,
        info: EffectInfo,
    ) -> Self {
        Self {
            selector,
            insert,
            take,
            info,
        }
    }

    pub fn get_selector(&self) -> &Box<dyn TargetSelector> {
        &self.selector
    }

    pub fn get_selector_mut(&mut self) -> &mut Box<dyn TargetSelector> {
        &mut self.selector
    }

    pub fn get_effect_type(&self) -> EffectType {
        EffectType::Dig
    }
}

impl Effect for DigEffect {
    /// dig 효과를 발동합니다.
    /// # Arguments
    /// * `game` - 게임 객체
    /// * `source` - 해당 효과를 발동시킨 카드
    /// # Returns
    /// * `Result<EffectResult, GameError>`
    /// # Errors
    /// * `GameError` - 효과 적용에 실패한 경우.
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        // // select_targets 으로 대상 카드를 가져옵니다.
        // let potential_targets = self.selector.select_targets(game, source)?;

        // if potential_targets.is_empty() {
        //     // 파낼 카드가 없으면 효과 종료 (또는 다른 처리)
        //     return Ok(EffectResult::Completed);
        // }

        // // Vec<Card> -> Vec<Uuid> 변환
        // let potential_targets_uuids = potential_targets
        //     .iter()
        //     .map(|card| card.get_uuid())
        //     .collect::<Vec<Uuid>>();

        // Ok(EffectResult::NeedsInput {
        //     inner: InputRequest::Dig {
        //         source_card: source.get_uuid(),
        //         source_effect_uuid: self.info.effect_id,
        //         potential_cards: potential_targets_uuids,
        //     },
        //     handler: HandlerType::General(Box::new(move |game, source, input| {
        //         Ok(EffectResult::Completed)
        //     })),
        // })
        todo!()
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        todo!()
    }

    fn get_effect_type(&self) -> EffectType {
        EffectType::Dig
    }

    fn as_any(&self) -> &dyn Any {
        self
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }

    fn get_id(&self) -> Uuid {
        self.info.effect_id
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}

pub struct DrawEffect {
    pub count: usize,
}

impl Effect for DrawEffect {
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        todo!()
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        todo!()
        // game.get_player_by_type(source.get_owner())
        //     .get()
        //     .get_deck()
        //     .len()
        //     >= self.count
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        Ok(Box::new(Self { count: self.count }))
    }

    fn get_effect_type(&self) -> EffectType {
        todo!()
    }

    fn as_any(&self) -> &dyn Any {
        todo!()
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        todo!()
    }

    fn get_id(&self) -> Uuid {
        todo!()
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}

pub struct ModifyStatEffect {
    pub stat_type: StatType,
    pub amount: i32,
    pub target_selector: Box<dyn TargetSelector>,
}

impl Effect for ModifyStatEffect {
    fn begin_effect(
        &self,
        game: Addr<GameActor>,
        source: &Card,
    ) -> Result<EffectResult, GameError> {
        todo!()
        // let targets = self.target_selector.select_targets(game, source)?;
        // for mut target in targets {
        //     target.modify_stat(self.stat_type, self.amount)?;
        // }
        // Ok(())
    }

    fn can_activate(&self, game: Addr<GameActor>, source: &Card) -> bool {
        self.target_selector.has_valid_targets(game, source)
    }

    fn clone_effect(&self) -> Result<Box<dyn Effect>, GameError> {
        Ok(Box::new(Self {
            stat_type: self.stat_type,
            amount: self.amount,
            target_selector: self.target_selector.clone_selector(),
        }))
    }

    fn get_effect_type(&self) -> EffectType {
        todo!()
    }

    fn as_any(&self) -> &dyn Any {
        todo!()
    }

    fn as_any_mut(&mut self) -> &mut dyn Any {
        todo!()
    }

    fn get_id(&self) -> Uuid {
        todo!()
    }

    fn get_speed(&self) -> EffectSpeed {
        todo!()
    }
}
</file>

<file path="simulator_core/src/effect/types.rs">
use uuid::Uuid;

use crate::enums::ZoneType;

pub struct EffectInfo {
    pub effect_id: Uuid,
    pub effect_type: EffectType,
    pub from_location: ZoneType,
    pub to_location: ZoneType,
}

impl EffectInfo {
    pub fn new(
        effect_id: Uuid,
        effect_type: EffectType,
        from_location: ZoneType,
        to_location: ZoneType,
    ) -> Self {
        Self {
            effect_id,
            effect_type,
            from_location,
            to_location,
        }
    }
}

pub enum EffectResult {
    // 효과가 완전히 실행됨
    Completed,
}

#[derive(PartialEq, Eq, PartialOrd, Clone, Copy)]
pub enum EffectSpeed {
    Quick = 3,  // 스피드 3
    Medium = 2, // 스피드 2
    Slow = 1,   // 스피드 1
}

impl EffectSpeed {
    pub fn is_faster_than(&self, other: EffectSpeed) -> bool {
        self > &other
    }
    pub fn is_slower_than(&self, other: EffectSpeed) -> bool {
        self < &other
    }
    pub fn is_equal_to(&self, other: EffectSpeed) -> bool {
        self == &other
    }
    pub fn can_it_chain(&self, other: EffectSpeed) -> bool {
        self.is_faster_than(other) || self.is_equal_to(other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EffectType {
    Dig,
    Draw,
    ModifyStat,
}

#[derive(Debug, Clone, Copy)]
pub enum EffectProcessPhase {
    ImmediatePhase, // 즉발 효과 처리 중
    ChainPhase,     // 체인 효과 처리 중
    InputWaiting,   // 사용자 입력 대기 중
}
</file>

<file path="simulator_core/src/game/choice.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{card::types::PlayerKind, enums::ZoneType, exception::GameError};

// ChoiceType 은 카드 선택의 종류를 나타냄
// 클라이언트 단으로 전달할 때, 게임 진행을 위한 정보가 여럿 포함되어 있는데.
// 이러한 정보들은 effect 로부터 얻어와야함.
// 대표적으로 DigEffect 의 경우, src, dest 정보가 필요함.
// src 의 경우 selector 에서 얻어오고
// dst 의 경우 insert 에서 얻어오면 될 듯?
// 근데 take, insert 는 카드를 어디서 가져오는지 정보를 가지고 있지 않음.
// 그러한 정보는 외부에서 저장되어있음.
// 그래서 Effect 자체에서 가지고 있는게 나을듯?
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChoiceType {
    Dig,          // 덱에서 카드 탐색
    Discard,      // 핸드에서 버릴 카드 선택
    SelectTarget, // 대상 선택 (유닛, 플레이어 등)
    Sacrifice,    // 희생할 카드 선택
    Rearrange,    // 카드 재배치/순서 변경
    RevealChoice, // 공개된 카드 중 선택
    MultiZone,    // 여러 영역에서 선택
}

impl ChoiceType {
    pub fn to_string(&self) -> String {
        match self {
            ChoiceType::Dig => "Dig".to_string(),
            ChoiceType::Discard => "Discard".to_string(),
            ChoiceType::SelectTarget => "SelectTarget".to_string(),
            ChoiceType::Sacrifice => "Sacrifice".to_string(),
            ChoiceType::Rearrange => "Rearrange".to_string(),
            ChoiceType::RevealChoice => "RevealChoice".to_string(),
            ChoiceType::MultiZone => "MultiZone".to_string(),
        }
    }
}

// 사용자
#[derive(Debug, Clone)]
pub struct ChoiceState {
    // 기본 정보
    player: PlayerKind,
    choice_type: ChoiceType,

    // 소스 및 대상 정보
    source_card_id: Option<Uuid>,   // 선택 효과를 발동한 카드
    source_effect_id: Option<Uuid>, // 선택을 요청한 효과

    // 선택 제한 설정
    min_selections: usize, // 최소 선택 개수
    max_selections: usize, // 최대 선택 개수
    destination: ZoneType, // 선택 후 카드 목적지

    // 상태 관리
    is_open: bool,      // 선택이 활성화되어 있는지
    is_mandatory: bool, // 필수 선택 여부 (취소 불가)

    is_hidden_from_opponent: bool, // 상대방에게 숨김 여부
}

impl Default for ChoiceState {
    fn default() -> Self {
        Self {
            player: PlayerKind::Player1,
            choice_type: ChoiceType::Dig,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: true,
            is_mandatory: true,
            is_hidden_from_opponent: false,
        }
    }
}

impl ChoiceState {
    pub fn builder(player: PlayerKind, choice_type: ChoiceType) -> ChoiceStateBuilder {
        ChoiceStateBuilder::new(player, choice_type)
    }

    pub fn new(
        player: PlayerKind,
        choice_type: ChoiceType,
        source_card_id: Option<Uuid>,
        source_effect_id: Option<Uuid>,
        min_selections: usize,
        max_selections: usize,
        destination: ZoneType,
        is_open: bool,
        is_mandatory: bool,
        is_hidden_from_opponent: bool,
    ) -> Self {
        Self {
            player,
            choice_type,
            source_card_id,
            source_effect_id,
            min_selections,
            max_selections,
            destination,
            is_open,
            is_mandatory,
            is_hidden_from_opponent,
        }
    }

    pub fn serialize_message(&self) -> Result<String, GameError> {
        // ChoiceState의 정보를 ChoiceCardPayload로 변환
        // let message = game_features::ChoiceCardRequestPayload {
        //     player: self.player.to_string(), // PlayerType을 문자열로 변환
        //     choice_type: self.choice_type.to_string(), // ChoiceType을 문자열로 변환
        //     source_card_id: self.source_card_id.unwrap(),
        //     min_selections: self.min_selections,
        //     max_selections: self.max_selections,
        //     destination: self.destination.to_string(),
        //     is_open: self.is_open,
        //     is_hidden_from_opponent: self.is_hidden_from_opponent,
        // };

        // // JSON 문자열로 직렬화
        // serde_json::to_string(&message).map_err(|_| GameError::InternalServerError)
        todo!()
    }
}

pub struct ChoiceStateBuilder {
    player: PlayerKind,
    choice_type: ChoiceType,
    source_card_id: Option<Uuid>,
    source_effect_id: Option<Uuid>,
    min_selections: usize,
    max_selections: usize,
    destination: ZoneType,
    is_open: bool,
    is_mandatory: bool,
    is_hidden_from_opponent: bool,
}

impl ChoiceStateBuilder {
    pub fn new(player: PlayerKind, choice_type: ChoiceType) -> Self {
        Self {
            player,
            choice_type,
            source_card_id: None,
            source_effect_id: None,
            min_selections: 1,
            max_selections: 1,
            destination: ZoneType::Hand,
            is_open: false,
            is_mandatory: false,
            is_hidden_from_opponent: false,
        }
    }

    pub fn source_card(mut self, card_id: impl Into<Option<Uuid>>) -> Self {
        self.source_card_id = card_id.into();
        self
    }

    pub fn source_effect(mut self, effect_id: impl Into<Option<Uuid>>) -> Self {
        self.source_effect_id = effect_id.into();
        self
    }

    pub fn selections(mut self, min: usize, max: usize) -> Self {
        self.min_selections = min;
        self.max_selections = max;
        self
    }

    pub fn destination(mut self, destination: ZoneType) -> Self {
        self.destination = destination;
        self
    }

    pub fn open(mut self, is_open: bool) -> Self {
        self.is_open = is_open;
        self
    }

    pub fn mandatory(mut self, is_mandatory: bool) -> Self {
        self.is_mandatory = is_mandatory;
        self
    }

    pub fn hidden_from_opponent(mut self, is_hidden: bool) -> Self {
        self.is_hidden_from_opponent = is_hidden;
        self
    }

    pub fn build(self) -> ChoiceState {
        ChoiceState::new(
            self.player,
            self.choice_type,
            self.source_card_id,
            self.source_effect_id,
            self.min_selections,
            self.max_selections,
            self.destination,
            self.is_open,
            self.is_mandatory,
            self.is_hidden_from_opponent,
        )
    }
}
</file>

<file path="simulator_core/src/game/msg/connection.rs">
use std::time::Duration;

use actix::{
    AsyncContext, Context, Handler, Message, ResponseFuture,
};
use tracing::{error, info, warn};
use uuid::Uuid;

use crate::{
    card::types::PlayerKind,
    enums::CLIENT_TIMEOUT,
    exception::{ConnectionError, GameError, StateError, SystemError},
    game::{msg::{connection, system::Terminate}, state::GamePhase, GameActor},
};

use super::GameEvent;

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct RegisterConnection {
    pub player_id: Uuid,
    pub recipient: actix::Recipient<GameEvent>,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct UnRegisterConnection {
    pub player_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct HandleOpponentWaitTimer {
    // 기다리는 상대의 종류
    pub opponent_kind: PlayerKind,
    pub player_uuid: Uuid,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct CancelOpponentWaitTimer;

impl Handler<UnRegisterConnection> for GameActor {
    type Result = ResponseFuture<Result<(), GameError>>;

    fn handle(&mut self, msg: UnRegisterConnection, ctx: &mut Self::Context) -> Self::Result {
        let player_kind = self.get_player_type_by_uuid(msg.player_id);
        info!(
            "GAME ACTOR [{}]: Handling UnRegisterConnection for player {}",
            self.game_id, player_kind
        );

        let game_id_clone = self.game_id.clone();
        let player_id = msg.player_id;
        let connections = self.connections.clone();
        let game_state = self.game_state.clone();
        let addr = ctx.address(); // 자기 자신의 주소

        Box::pin(async move {
            // connections 맵 업데이트
            {
                let mut connections_guard = connections.lock().await;
                if connections_guard.remove(&player_id).is_none() {
                    return Ok(()); // 이미 처리됨
                }
            }

            // GameState 업데이트
            let should_abort;
            {
                let mut gsm = game_state.lock().await;
                gsm.update_player_connection_status(player_kind, false);
                
                // 게임 시작 전이고, 이제 연결된 플레이어가 아무도 없다면 게임을 중단해야 함
                info!("player cont = {}", gsm.count_connected_players());
                should_abort = gsm.is_in_waiting_phase() && gsm.count_connected_players() == 0;
            }

            if should_abort {
                info!("[{}] Last player disconnected before game start. Aborting game session.", game_id_clone);
                addr.do_send(CancelOpponentWaitTimer); // 타이머 취소
                addr.do_send(Terminate); // 액터 종료
            } else {
                // 게임 진행 중에 연결이 끊긴 경우 (재접속 타이머 로직)
                info!("[{}] Player {} disconnected during the game.", game_id_clone, player_kind);
            }

            Ok(())
        })
    }
}

impl Handler<RegisterConnection> for GameActor {
    type Result = ResponseFuture<Result<(), GameError>>;

    fn handle(&mut self, msg: RegisterConnection, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "GAME ACTOR [{}]: Handling RegisterConnection for player {}",
            self.game_id, msg.player_id
        );

        let game_id_clone = self.game_id.clone();
        let player_id = msg.player_id;
        let connection_recipient = msg.recipient.clone();

        let game_state = self.game_state.clone();
        let game_actor_addr = ctx.address().clone();
        let players = self.players.clone();
        let connections = self.connections.clone();
        let gsm = self.game_state.clone();

        let player_kind = self.get_player_type_by_uuid(player_id);
        let opponent_kind = self.opponent_player_kind.clone();
        let opponent_wait_timer_handle = self.opponent_wait_timer_handle.clone();

        Box::pin(async move {
            // --- 0. 기존 연결 확인 및 connections 맵 업데이트 ---
            {
                let gsm = gsm.lock().await;
                if gsm.current_phase() == GamePhase::Aborted {
                    info!(
                        "GAME ACTOR [{}]: Game is already aborted. Rejecting connection for player {}.",
                        game_id_clone, player_id
                    );
                    return Err(GameError::State(StateError::GameAborted));
                }
            }

            {
                let mut connections_guard = connections.lock().await;

                if connections_guard.contains_key(&player_id) {
                    info!(
                        "GAME ACTOR [{}]: Player {} already has an active connection. Rejecting new connection.",
                        game_id_clone, player_id
                    );
                    return Err(GameError::Connection(ConnectionError::SessionExists(
                        player_id,
                    )));
                }

                connections_guard.insert(player_id, connection_recipient.clone());
                info!(
                    "GAME ACTOR [{}]: Connection for player {} registered successfully. Total connections: {}",
                    game_id_clone, player_id, connections_guard.len()
                );
            }

            // --- 1. GameState 업데이트 ---
            let is_all_players_connected;
            let mut current_phase;
            {
                let mut gsm = game_state.lock().await;
                info!(
                    "GAME ACTOR [{}]: Game state locked for player {}",
                    game_id_clone, player_id
                );

                gsm.update_player_connection_status(player_kind, true);
                info!(
                    "GAME ACTOR [{}]: Player {} connection status updated in GameStateManager.",
                    game_id_clone, player_id
                );

                is_all_players_connected = gsm.is_all_players_connected();
                current_phase = gsm.current_phase();

                if current_phase == GamePhase::Initial && is_all_players_connected {
                    info!(
                        "GAME ACTOR [{}]: All players connected. Transitioning to Mulligan phase.",
                        game_id_clone
                    );
                    gsm.transition_to_phase(GamePhase::Mulligan);
                    current_phase = gsm.current_phase();
                }
            }

            // --- 2. WaitTimer 처리 ---
            if let Some(kind) = opponent_kind {
                if kind != player_kind {
                    warn!(
                        "GAME ACTOR [{}]: Opponent kind mismatch: expected {:?}, got {:?}.",
                        game_id_clone, kind, player_kind
                    );
                    return Err(GameError::Connection(
                        ConnectionError::AuthenticationFailed("Player kind mismatch".to_string()),
                    ));
                }

                if let Some(_) = opponent_wait_timer_handle {
                    info!(
                        "GAME ACTOR [{}]: Cancelling opponent wait timer for player {}.",
                        game_id_clone, kind
                    );
                    game_actor_addr.do_send(CancelOpponentWaitTimer);
                } else {
                    warn!(
                        "GAME ACTOR [{}]: No opponent wait timer to cancel for player {}.",
                        game_id_clone, kind
                    );
                    return Err(GameError::System(SystemError::Internal(
                        "Timer handle not found".to_string(),
                    )));
                }
            }

            // --- 3. 게임 로직 진행 ---
            // TODO: callback 으로 바꾸면 좋을 것 같음.
            // 현재 RegisterConnection 핸들러가 두 개 이상의 책임을 가지고 있음
            // 1. 플레이어 연결 등록
            // 2. 멀리건 카드 전송
            // then 같은 메소드를 활용해서 분리하면 좋을듯.
            if current_phase == GamePhase::Mulligan && is_all_players_connected {
                info!(
                    "GAME ACTOR [{}]: Proceeding with Mulligan card distribution.",
                    game_id_clone
                );

                use crate::game::state::PlayerMulliganStatus;
                use crate::player::message::GetMulliganDealCards;

                for (player_identity, player_addr) in players.iter() {
                    let connection_addr = {
                        let connections_snapshot = connections.lock().await;
                        connections_snapshot
                            .get(&player_identity.id)
                            .ok_or_else(|| {
                                error!(
                                    "Connection not found for player {} in connections_snapshot",
                                    player_identity.id
                                );
                                GameError::System(SystemError::Internal(
                                    "Connection not found".to_string(),
                                ))
                            })?
                            .clone()
                    };

                    match player_addr.send(GetMulliganDealCards).await {
                        Ok(cards) => {
                            let card_uuids: Vec<Uuid> =
                                cards.iter().map(|c| c.get_uuid()).collect();
                            if let Err(e) = connection_addr
                                .send(GameEvent::SendMulliganDealCards {
                                    cards: card_uuids.clone(),
                                })
                                .await
                            {
                                warn!(
                                    "Failed to send mulligan cards to {}: {:?}",
                                    player_identity.id, e
                                );
                            } else {
                                info!(
                                    "Sent mulligan cards ({} count) to player {}",
                                    card_uuids.len(),
                                    player_identity.id
                                );
                                let mut gsm_update = game_state.lock().await;
                                gsm_update.update_player_mulligan_status(
                                    player_identity.kind,
                                    PlayerMulliganStatus::CardsDealt,
                                );
                            }
                        }
                        Err(mailbox_err) => {
                            error!(
                                "Mailbox error getting mulligan cards for {}: {:?}",
                                player_identity.id, mailbox_err
                            );
                        }
                    }
                }
            } else if current_phase != GamePhase::Initial {
                warn!(
                    "GAME ACTOR [{}]: Player {} connected, but not all players are ready or in an unexpected game phase: {:?}.",
                    game_id_clone, player_id, current_phase
                );
            } else if is_all_players_connected == false {
                info!(
                    "GAME ACTOR [{}]: Player {} connected, but not all players are ready. Waiting for others.",
                    game_id_clone, player_id
                );
                if current_phase == GamePhase::Aborted {
                    return Err(GameError::State(StateError::GameAborted));
                }
                game_actor_addr.do_send(HandleOpponentWaitTimer {
                    opponent_kind: player_kind.reverse(),
                    player_uuid: player_id,
                });
            }

            Ok(())
        })
    }
}

impl Handler<HandleOpponentWaitTimer> for GameActor {
    type Result = ();

    fn handle(&mut self, msg: HandleOpponentWaitTimer, ctx: &mut Context<Self>) {
        if self.opponent_wait_timer_handle.is_some() {
            warn!("Opponent wait timer already started. Ignoring new request.");
            return;
        }
        info!(
            "Starting opponent wait timer for first player: {}",
            msg.opponent_kind
        );
        
        let connections = self.connections.clone();
        let uuid = msg.player_uuid;
        self.opponent_player_kind = Some(msg.opponent_kind);

        let handle = ctx.run_later(Duration::from_secs(CLIENT_TIMEOUT), move |act, ctx_later| {
            let game_state = act.game_state.clone();
            let game_id = act.game_id.clone();
            let ctx_inner = ctx_later.address();
            
            actix::spawn(async move {
                let mut gsm = game_state.lock().await;

                // 현재 GamePhase 가 Initial이고, 연결된 플레이어가 1명이며( count_connected_players ), 상대방이 미접속 상태인( is_player_connected_by_kind ) 경우
                if gsm.current_phase() == GamePhase::Initial
                    && gsm.count_connected_players() == 1
                    && gsm.is_player_connected(msg.opponent_kind) == false
                {
                    warn!(
                        "GAME ACTOR [{}]: Opponent wait timeout for player {}. Aborting game.",
                        game_id,
                        msg.opponent_kind
                    );
                    gsm.transition_to_phase(GamePhase::Aborted);
                    
                    ctx_inner.do_send(Terminate);

                    {
                        let connections = connections.lock().await;
                        if let Some(connection) = connections.get(&uuid){
                            connection.do_send(GameEvent::GameStopped);
                        }
                    }


                } else if gsm.current_phase() == GamePhase::Aborted {
                    info!(
                        "GAME ACTOR [{}]: OpponentWaitTimeout for player {} triggered, but situation already resolved.",
                        game_id, msg.opponent_kind
                    );
                    gsm.transition_to_phase(GamePhase::AlreadyCancelled);
                } else {
                    warn!(
                        "GAME ACTOR [{}]: Opponent wait timeout for player {} but game is in unexpected phase: {:?}.",
                        game_id, msg.opponent_kind, gsm.current_phase()
                    );
                    gsm.transition_to_phase(GamePhase::UnexpectedGamePhase);
                }
            });
        });

        self.opponent_wait_timer_handle = Some(handle);
    }
}

impl Handler<CancelOpponentWaitTimer> for GameActor {
    type Result = ();

    fn handle(&mut self, _msg: CancelOpponentWaitTimer, ctx: &mut Context<Self>) {
        if let Some(handle) = self.opponent_wait_timer_handle.take() {
            info!("Cancelling opponent wait timer.");
            if ctx.cancel_future(handle) {
                info!("Opponent wait timer cancelled successfully.");
            } else {
                warn!("Failed to cancel opponent wait timer, it may have already been cancelled or expired.");
            }
            self.opponent_player_kind = None;
            self.opponent_wait_timer_handle = None;
        } else {
            info!("No opponent wait timer to cancel, or already cancelled.");
        }
    }
}
</file>

<file path="simulator_core/src/main.rs">
//! main.rs
//! 
//! 게임 시뮬레이터의 핵심 모듈
//! 이 모듈은 src와 관련된 기능을 제공합니다.

use std::fs;
use std::io::Write;
use std::path::Path;

use actix_web::{App, HttpServer};
use simulator_core::setup_logger;

use clap::Parser;
use uuid::Uuid;

// main
#[derive(Parser)]
#[command(
    name = "card game backend",           // 프로그램 이름
    author = env!("CARGO_PKG_AUTHORS"),       // 작성자
    version = env!("CARGO_PKG_VERSION"),           // 버전
    about = env!("CARGO_PKG_DESCRIPTION"),   // 짧은 설명
    long_about = None,         // 긴 설명 (None은 미사용)
)]
/// 명령줄 인수를 파싱하기 위한 구조체입니다.
/// 플레이어 덱 코드와 공격자를 지정합니다.
///
/// # Examples
/// ```
/// use clap::Parser;
/// #[derive(Parser)]
/// struct Args {
///     #[arg(long = "p1_deck")]
///     #[arg(required = true)]
///     player_1_deckcode: String,
///
///     #[arg(long = "p2_deck")]
///     #[arg(required = true)]
///     player_2_deckcode: String,
///
///     #[arg(required = true)]
///     attacker: usize,
/// }
///
/// // Args 구조체를 사용한 예시
/// ```
struct Args {
    /// 플레이어 1의 덱 코드입니다.
    #[arg(long = "p1_deck")]
    #[arg(required = true)]
    player_1_deckcode: String,

    /// 플레이어 2의 덱 코드입니다.
    #[arg(long = "p2_deck")]
    #[arg(required = true)]
    player_2_deckcode: String,

    /// 공격자를 지정합니다.
    #[arg(required = true)]
    attacker: usize,
}

// TODO: 매칭으로 만난 두 플레이어의 닉네임을 받은 뒤, 게임 공용 서버인 valid server 에 전송하여 실제 플레이어가 맞는지 확인 후, key 값을 리턴 받음.
/// 매칭된 두 플레이어의 세션을 확인하고 고유 세션 키를 생성합니다.
///
/// # Arguments
///
/// * `_nick1`: 첫 번째 플레이어의 닉네임입니다.
/// * `_nick2`: 두 번째 플레이어의 닉네임입니다.
///
/// # Returns
///
/// 두 플레이어에 대한 UUID 쌍 (세션 키)을 반환합니다. 현재는 `todo!()`로 구현되어 있습니다.
///
/// # Examples
///
/// ```
/// use uuid::Uuid;
///
/// // 가상의 닉네임
/// let nick1 = "player1".to_string();
/// let nick2 = "player2".to_string();
///
/// // check_session 함수 호출 (실제 구현은 todo!()로 되어 있음)
/// // let (session_key1, session_key2) = check_session(nick1, nick2);
///
/// // 세션 키가 UUID인지 확인 (실제로는 항상 에러 발생)
/// // assert!(session_key1.is_uuid());
/// // assert!(session_key2.is_uuid());
/// ```
// TODO: valid server 통신 구현
// TODO: 에러 핸들링 추가
pub fn check_session(_nick1: String, _nick2: String) -> (Uuid, Uuid) {
    todo!()
}

#[actix_web::main]
/// 프로그램의 진입점입니다.
/// 카드 레지스트리를 생성하고, Actix 웹 서버를 시작합니다.
/// HTTP 요청을 받아 처리하고 게임 로직을 실행합니다.
///
/// # Arguments
///
/// 이 함수는 인수를 받지 않습니다.
///
/// # Returns
///
/// `std::io::Result<()>`를 반환합니다. 이는 프로그램 실행 결과를 나타냅니다.
/// 성공하면 `Ok(())`를, 실패하면 `Err`를 반환합니다.
///
/// # Examples
///
/// ```rust,no_run
/// #[actix_web::main]
/// async fn main() -> std::io::Result<()> {
///     // ... Actix 웹 서버 초기화 및 실행 ...
///     Ok(())
/// }
/// ```
// TODO: panic 처리
// TODO: 명령줄 인수 파싱 및 게임 초기화
// TODO: deckcode 파싱 로직 구현
// TODO: actix-web handler 구현
async fn main() -> std::io::Result<()> {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("card_registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // 카드 모듈 디렉토리 스캔
    let modules = ["human", "monster", "public"];
    let mut card_registrations = Vec::new();

    for module in modules {
        let path = format!("src/card_gen/{}.rs", module);
        let content = fs::read_to_string(&path).unwrap();

        // 함수 이름 찾기
        for line in content.lines() {
            if line.contains("pub fn")
                && (line.contains("HM_") || line.contains("MT_") || line.contains("PB_"))
            {
                let func_name = line.split("fn ").nth(1).unwrap().split("(").next().unwrap();
                card_registrations.push(format!("    {}::{}", module, func_name));
            }
        }
    }

    // 매크로 호출 생성
    write!(
        f,
        r#"
        // 자동 생성된 카드 레지스트리
        generate_card_map! {{
            {}
        }}
        "#,
        card_registrations.join(",\n")
    )
    .unwrap();

    // let (deck_json, _) = generate_random_deck_json();
    // let (deck_json2, _) = generate_random_deck_json();

    // // 2. JSON을 덱 코드로 변환
    // let deck_codes = parse_json_to_deck_code(Some(deck_json), Some(deck_json2))
    //     .expect("Failed to parse deck code");

    // let app = initialize_app(deck_codes.0, deck_codes.1, 0);

    // let session_keys = check_session("".to_string(), "".to_string());

    // let state = web::Data::new(ServerState {
    //     game: Mutex::new(app.game),
    //     player_cookie: session_keys.0,
    //     opponent_cookie: session_keys.1,
    //     session_manager: PlayerSessionManager::new(CLIENT_TIMEOUT),
    // });

    setup_logger();
    HttpServer::new(move || {
        App::new()
        // .app_data(state.clone())
        // .service(mulligan_phase)
        // .service(draw_phase)
        // .service(standby_phase)
        // .service(main_phase_start_phase)
        // .service(heartbeat)
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
</file>

<file path="simulator_core/src/sync/mod.rs">
pub mod messages;
pub mod snapshots;
pub mod types;

use std::collections::HashMap;

use actix::{dev::SendError, Actor, Addr, Context, Handler, Recipient};
use tracing::{info, warn};

use crate::{
    card::types::PlayerKind,
    game::{msg::GameEvent, GameActor},
    sync::{
        messages::{
            NotifyChanges, RegisterConnectionToSync, RequestStateHashSync,
            UnregisterConnectionFromSync,
        },
        types::StateUpdatePayload,
    },
};

/// `SyncActor`는 게임 상태 동기화를 담당합니다.
// TODO: 상태 동기화 로직 개선
// TODO: 최적화
pub struct SyncActor {
    game_addr: Addr<GameActor>,
    connections: HashMap<PlayerKind, Recipient<GameEvent>>,
    event_sequence: u64,
}

impl SyncActor {
    /// SyncActor의 새 인스턴스를 생성합니다.
    pub fn new(game_addr: Addr<GameActor>) -> Self {
        info!("SyncActor created.");
        Self {
            game_addr,
            connections: HashMap::new(),
            event_sequence: 0,
        }
    }

    /// 모든 연결된 클라이언트에게 페이로드를 브로드캐스트합니다.
    fn broadcast(&mut self, payload: StateUpdatePayload) {
        let event = GameEvent::StateUpdate(payload);

        let mut dead_recipients = Vec::new();

        for (player, recipient) in &self.connections {
            match recipient.try_send(event.clone()) {
                Ok(_) => {}
                Err(SendError::Full(_)) => {
                    warn!("Mailbox for player {:?} is full. Update might be delayed or dropped if it happens frequently.", player);
                }
                Err(SendError::Closed(_)) => {
                    warn!(
                        "Mailbox for player {:?} is closed. Marking for removal.",
                        player
                    );
                    dead_recipients.push(*player);
                }
            }
        }

        // 루프가 끝난 후 죽은 수신자들을 정리
        for player in dead_recipients {
            self.connections.remove(&player);
        }
    }
}

impl Actor for SyncActor {
    type Context = Context<Self>;

    fn started(&mut self, _ctx: &mut Context<Self>) {
        info!("SyncActor started and is ready to handle sync events.");
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        info!("SyncActor stopped.");
    }
}

/// GameActor로부터 상태 변경 알림을 처리하는 핸들러
impl Handler<NotifyChanges> for SyncActor {
    type Result = ();

    fn handle(&mut self, msg: NotifyChanges, _ctx: &mut Context<Self>) {
        if msg.0.is_empty() {
            return;
        }

        self.event_sequence += 1;
        info!(
            "Handling NotifyChanges with seq: {}. Delta count: {}",
            self.event_sequence,
            msg.0.len()
        );

        let payload = StateUpdatePayload {
            seq: self.event_sequence,
            changes: msg.0,
            state_hash: None, // 일반 업데이트에는 해시를 포함하지 않음
        };

        self.broadcast(payload);
    }
}

/// 주기적인 해시 동기화 요청을 처리하는 핸들러
impl Handler<RequestStateHashSync> for SyncActor {
    type Result = ();

    fn handle(&mut self, _msg: RequestStateHashSync, _ctx: &mut Context<Self>) {
        info!("Handling RequestStateHashSync. Fetching hash from GameActor.");
        // GameActor에게 현재 상태의 해시를 요청합니다.
        // GameActor는 GetStateHash 메시지에 대한 핸들러가 필요합니다.
        // let future = self.game_addr.send(GetStateHash).into_actor(self).then(|res, act, _| {
        //     match res {
        //         Ok(hash) => {
        //             act.event_sequence += 1;
        //             let payload = StateUpdatePayload {
        //                 seq: act.event_sequence,
        //                 changes: vec![], // 해시 동기화에는 델타가 없을 수 있음
        //                 state_hash: Some(hash),
        //             };
        //             act.broadcast(payload);
        //         }
        //         Err(e) => {
        //             error!("Failed to get state hash from GameActor: {}", e);
        //         }
        //     }
        //     fut::ready(())
        // });
        // ctx.spawn(future);

        todo!()
    }
}

/// 새로운 클라이언트 연결을 등록하는 핸들러
impl Handler<RegisterConnectionToSync> for SyncActor {
    type Result = ();

    fn handle(&mut self, msg: RegisterConnectionToSync, _ctx: &mut Context<Self>) {
        info!("Registering connection for player {:?}.", msg.player);
        self.connections.insert(msg.player, msg.recipient);
    }
}

/// 클라이언트 연결 해제를 처리하는 핸들러
impl Handler<UnregisterConnectionFromSync> for SyncActor {
    type Result = ();

    fn handle(&mut self, msg: UnregisterConnectionFromSync, _ctx: &mut Context<Self>) {
        info!("Unregistering connection for player {:?}.", msg.player);
        self.connections.remove(&msg.player);
    }
}
</file>

<file path="simulator_dedicated_server/src/connection/mod.rs">
use serde::{Deserialize, Serialize};
use simulator_core::exception::{ConnectionError, GameError, StateError};
use types::PlayerInputResponse;
use uuid::Uuid;

pub mod connection;
pub mod messages;
pub mod types;

#[derive(Deserialize, Debug, Clone)]
#[serde(tag = "action")]
pub enum UserAction {
    #[serde(rename = "rerollRequestMulliganCard")]
    RerollRequestMulliganCard { card_id: Vec<Uuid> },
    #[serde(rename = "completeMulligan")]
    CompleteMulligan,
    #[serde(rename = "playCard")]
    PlayCard {
        card_id: Uuid,
        target_id: Option<Uuid>,
    },
    #[serde(rename = "attack")]
    Attack {
        attacker_id: Uuid,
        defender_id: Uuid,
    },
    #[serde(rename = "endTurn")]
    EndTurn,
    #[serde(rename = "submitInput")]
    SubmitInput {
        request_id: Uuid,
        #[serde(flatten)]
        response_data: PlayerInputResponse,
    },
}

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(tag = "type")]
pub enum ServerMessage {
    #[serde(rename = "heartbeat_connected")]
    HeartbeatConnected { player: String, session_id: Uuid },
    #[serde(rename = "mulligan_deal")]
    MulliganDealCards { player: String, cards: Vec<Uuid> },

    #[serde(rename = "error")]
    Error(ErrorMessagePayload),
}

impl ServerMessage {
    pub fn to_json(&self) -> String {
        serde_json::to_string(self)
            .unwrap_or_else(|_| "{\"error\":\"json serialization failed\"}".to_string())
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")] // JSON에서는 "ACTIVE_SESSION_EXISTS"와 같이 변환
pub enum ServerErrorCode {
    ActiveSessionExists,
    GameAborted,
    InvalidAction,
    InternalServerError,
}

/// 클라이언트에게 전송될 에러 메시지의 실제 내용입니다.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ErrorMessagePayload {
    pub code: ServerErrorCode,
    pub message: String,
}

impl From<GameError> for ServerMessage {
    fn from(err: GameError) -> Self {
        // 서버 로그에는 변환 전의 상세한 에러를 기록합니다.
        tracing::warn!("Converting GameError to a client-facing message: {}", err);

        let (code, message) = match &err {
            // 시스템 에러는 내부 구현을 노출하지 않습니다.
            GameError::System(_) => (
                ServerErrorCode::InternalServerError,
                "An internal server error occurred.".to_string(),
            ),

            // 클라이언트가 명확히 처리할 수 있는 특정 에러들
            GameError::Connection(ConnectionError::SessionExists(_)) => {
                (ServerErrorCode::ActiveSessionExists, err.to_string())
            }
            GameError::State(StateError::GameAborted) => {
                (ServerErrorCode::GameAborted, err.to_string())
            }

            // 그 외 모든 에러는 클라이언트의 유효하지 않은 액션으로 간주합니다.
            // Display 트레이트 구현이 클라이언트에게 유용한 정보를 제공합니다.
            GameError::Connection(_) | GameError::State(_) | GameError::Gameplay(_) => {
                (ServerErrorCode::InvalidAction, err.to_string())
            }
        };

        ServerMessage::Error(ErrorMessagePayload { code, message })
    }
}
</file>

<file path="simulator_dedicated_server/src/main.rs">
//! main.rs
//!
//! 게임 시뮬레이터의 핵심 모듈
//! 이 모듈은 src와 관련된 기능을 제공합니다.

fn main() {}
</file>

<file path="simulator_dedicated_server/src/server/mod.rs">
use std::{future::Future, pin::Pin};

use actix::{Actor, AsyncContext, Context};
use actix_web::{get, web, FromRequest, HttpRequest, HttpResponse};
use actix_ws::handle;
use simulator_core::{
    card::types::PlayerKind,
    exception::{ConnectionError, GameError, SystemError},
};
use tracing::{debug, error, info, instrument, warn};
use uuid::Uuid;

use crate::{connection::connection::ConnectionActor, test::ServerState};

#[derive(Debug, Clone, Copy)]
pub struct AuthPlayer {
    ptype: PlayerKind,
    id: Uuid,
}

impl AuthPlayer {
    fn new(ptype: PlayerKind, id: Uuid) -> Self {
        Self { ptype, id }
    }
}

impl FromRequest for AuthPlayer {
    type Error = GameError;
    type Future = Pin<Box<dyn Future<Output = Result<Self, Self::Error>>>>;

    fn from_request(req: &HttpRequest, _payload: &mut actix_web::dev::Payload) -> Self::Future {
        let req = req.clone();
        Box::pin(async move {
            debug!("AuthPlayer::from_request 시작: 인증 처리 중...");

            let Some(player_id_cookie) = req.cookie("user_id") else {
                error!("쿠키 누락: 'user_id' 쿠키를 찾을 수 없음");
                return Err(GameError::Connection(ConnectionError::InvalidPayload(
                    "Missing 'user_id' cookie".to_string(),
                )));
            };

            let player_id_string = player_id_cookie.to_string().replace("user_id=", "");
            debug!("쿠키 파싱 완료: player_name={}", player_id_string);

            if let Some(state) = req.app_data::<web::Data<ServerState>>() {
                let player_id = match Uuid::parse_str(&player_id_string) {
                    Ok(id) => id,
                    Err(e) => {
                        warn!(
                            "Failed to parse player_id from cookie: '{}'. Error: {}",
                            player_id_string, e
                        );
                        return Err(GameError::System(SystemError::Internal(format!(
                            "Invalid UUID format in cookie: '{}'",
                            player_id_string
                        ))));
                    }
                };

                // 서버 상태에서 플레이어 ID 가져오기 (state: &web::Data<ServerState>)
                let p1_key = state.player1_id;
                let p2_key = state.player2_id;

                // if-else if-else 로 PlayerType 결정
                let player_type = if player_id == p1_key {
                    debug!("Player authenticated as Player1 (ID: {})", player_id);
                    PlayerKind::Player1
                } else if player_id == p2_key {
                    debug!("Player authenticated as Player2 (ID: {})", player_id);
                    PlayerKind::Player2
                } else {
                    // 알 수 없는 ID 처리 (명확한 오류 반환)
                    error!(
                        "Authentication failed: Unknown player ID '{}' from cookie. Expected {} or {}.",
                        player_id, p1_key, p2_key
                    );
                    // 인증 실패 또는 잘못된 플레이어 오류 반환
                    return Err(GameError::Connection(ConnectionError::InvalidPayload(format!(
                        "Authentication failed: Unknown player ID '{}' from cookie. Expected {} or {}.",
                        player_id, p1_key, p2_key)
                    )));
                };

                debug!("Request Guard 통과: player_type={:?}", player_type);

                Ok(AuthPlayer::new(player_type, player_id))
            } else {
                error!("서버 상태 객체를 찾을 수 없음");
                Err(GameError::System(SystemError::Internal(
                    "Can't not found server state".to_string(),
                )))
            }
        })
    }
}

impl From<AuthPlayer> for PlayerKind {
    fn from(value: AuthPlayer) -> Self {
        value.ptype
    }
}

impl From<AuthPlayer> for String {
    fn from(value: AuthPlayer) -> Self {
        value.ptype.to_string()
    }
}

/// Game 의 전반적인 기능을 책임지는 end point
#[get("/create_room")]
// #[instrument(skip(state, req, payload), fields(player_type = ?player.ptype))]
pub async fn create_room(
    _player: AuthPlayer,
    _state: web::Data<ServerState>,
    _req: HttpRequest,
    _payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    todo!()
}

/// Game 의 전반적인 기능을 책임지는 end point
#[get("/game")]
#[instrument(skip(state, req, payload), fields(player_type = ?player.ptype))]
pub async fn game(
    player: AuthPlayer,
    state: web::Data<ServerState>,
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse, GameError> {
    let player_type = player.ptype;
    let player_id = player.id;
    debug!("플레이어 타입 설정: {:?}", player_type);

    // Http 업그레이드: 이때 session과 stream이 반환됩니다.
    debug!("WebSocket 연결 업그레이드 시작");
    let (response, session, message_stream) = match handle(&req, payload) {
        Ok(result) => {
            info!(
                "WebSocket handshake successful for player_id: {}",
                player_id
            );
            result
        }
        Err(e) => {
            error!(
                "WebSocket handshake failed for player_id: {}: {:?}",
                player_id, e
            );
            return Ok(
                HttpResponse::InternalServerError().body(format!("WS Handshake Error: {}", e))
            );
        }
    };

    ConnectionActor::create(|ctx: &mut Context<ConnectionActor>| {
        let new_actor = ConnectionActor::new(session, state.game.clone(), player_id, player_type);
        ctx.add_stream(message_stream);
        new_actor
    });

    Ok(response)
}
</file>

<file path="simulator_dedicated_server/src/test/mod.rs">
use std::{
    io::Read,
    net::{SocketAddr, TcpListener},
    time::Duration,
};

use actix::{Actor, Addr};
use actix_web::{
    dev::ServerHandle,
    web::{self, Data},
    App, HttpServer,
};
use async_tungstenite::tungstenite::{self, error::UrlError, http::Request, Message};
use ctor::ctor;
use futures::{SinkExt, StreamExt};
use rand::{seq::SliceRandom, thread_rng};
use serde::de::DeserializeOwned;
use serde_json::{json, Value};
use simulator_core::{
    card::{types::PlayerKind, Card},
    card_gen::CardGenerator,
    enums::{CARD_JSON_PATH, CLIENT_TIMEOUT, HEARTBEAT_INTERVAL, MAX_CARD_SIZE},
    game::GameActor,
    setup_logger,
    utils::{json, parse_json_to_deck_code},
};
use tracing::info;
use url::Url;
use uuid::Uuid;

use crate::server::game;

pub struct ServerState {
    pub game: Addr<GameActor>,
    pub player1_id: Uuid,
    pub player2_id: Uuid,
}

pub fn generate_random_deck_json() -> (Value, Vec<Card>) {
    // 카드 JSON 파일 로드
    let file_path = CARD_JSON_PATH;
    let mut file = std::fs::File::open(file_path).expect("Failed to open cards.json");
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let cards: Vec<json::CardJson> =
        serde_json::from_str(&json_data).expect("Failed to parse JSON");

    let mut rng = thread_rng();
    let selected_cards: Vec<json::CardJson> = cards
        .into_iter()
        .filter(|card| card.collectible == Some(true))
        .collect::<Vec<_>>()
        .choose_multiple(&mut rng, MAX_CARD_SIZE)
        .cloned()
        .collect();

    // 선택된 카드로 덱 JSON 생성
    let deck_json = json!({
        "decks": [{
            "Hero": [{
                "name": "player1"
            }],
            "cards": selected_cards.iter().map(|card| {
                json!({
                    "id": card.id.clone(),
                    "num": 1
                })
            }).collect::<Vec<_>>()
        }]
    });

    // 원본 카드 정보 저장
    let card_generator = CardGenerator::new();
    let original_cards: Vec<Card> = selected_cards
        .iter()
        .map(|card| card_generator.gen_card_by_id_string(card.id.clone().unwrap(), card, 0))
        .collect();
    (deck_json, original_cards)
}

pub fn create_server_state() -> web::Data<ServerState> {
    let (deck_json, _original_cards) = generate_random_deck_json();
    let (deck_json2, _) = generate_random_deck_json();

    let deck_codes = parse_json_to_deck_code(Some(deck_json), Some(deck_json2))
        .expect("Failed to parse deck code");

    let player1_id = Uuid::new_v4();
    let player2_id = Uuid::new_v4();

    let game_actor = GameActor::create(|_ctx| {
        let game_actor = GameActor::new(
            Uuid::new_v4(),
            player1_id,
            player2_id,
            deck_codes.0,
            deck_codes.1,
            PlayerKind::Player1,
        );

        game_actor
    });

    web::Data::new(ServerState {
        game: game_actor,
        player1_id: player1_id,
        player2_id: player2_id,
    })
}

pub async fn spawn_server() -> (SocketAddr, Data<ServerState>, ServerHandle) {
    let server_state = create_server_state();
    let server_state_clone = server_state.clone();
    let listener = TcpListener::bind("127.0.0.1:0").unwrap();
    let addr = listener.local_addr().unwrap();

    let server = HttpServer::new(move || App::new().app_data(server_state.clone()).service(game))
        .listen(listener)
        .unwrap()
        .run();

    let handle = server.handle();
    tokio::spawn(server);

    (addr, server_state_clone, handle)
}

pub struct RequestTest {
    pub response: String,
}

impl RequestTest {
    pub async fn connect(
        step: &str,
        addr: SocketAddr,
        cookie: String,
    ) -> Result<Self, reqwest::Error> {
        let client = reqwest::Client::new();
        let response = client
            .get(format!("http://{}/{}", addr, step))
            .header("Cookie", cookie)
            .send()
            .await?;

        Ok(RequestTest {
            response: response.text().await.expect("Failed to get response"),
        })
    }

    /// 특정 타입의 메세지를 예상합니다. 예상한 메세지가 아닌 경우, panic! 합니다.
    pub fn expect_message<T, F, R>(&mut self, extractor: F) -> R
    where
        T: DeserializeOwned,
        F: Fn(T) -> R,
    {
        info!("[TEST] Response: {}", self.response);
        let msg = serde_json::from_str::<T>(self.response.as_str())
            .expect("Failed to parse JSON (expect_message)");
        extractor(msg)
    }
}

pub struct WebSocketTest {
    pub stream: futures_util::stream::SplitStream<
        async_tungstenite::WebSocketStream<
            async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
        >,
    >,
    pub sink: futures_util::stream::SplitSink<
        async_tungstenite::WebSocketStream<
            async_tungstenite::tokio::TokioAdapter<tokio::net::TcpStream>,
        >,
        Message,
    >,
}
//-------------------------------
// WebSocketTest 구현
//-------------------------------

impl WebSocketTest {
    pub async fn connect(url: String, cookie: String) -> Result<Self, tungstenite::Error> {
        // ... (connect 로직은 이전과 동일) ...
        let mut url = Url::parse(&url).unwrap();
        if url.scheme() == "http" {
            url.set_scheme("ws").unwrap()
        } else if url.scheme() != "ws" && url.scheme() != "wss" {
            return Err(tungstenite::Error::Url(UrlError::UnsupportedUrlScheme));
        }

        let host = url
            .host_str()
            .ok_or(tungstenite::Error::Url(UrlError::EmptyHostName))?;
        let host_header = if let Some(port) = url.port() {
            format!("{}:{}", host, port)
        } else {
            host.to_string()
        };

        let request = Request::builder()
            .uri(url.as_str())
            .header("Cookie", cookie)
            .header("Host", host_header)
            .header(
                "Sec-WebSocket-Key",
                tungstenite::handshake::client::generate_key(),
            )
            .header("Upgrade", "websocket")
            .header("Connection", "Upgrade")
            .header("Sec-WebSocket-Version", "13")
            .body(())?;

        let (ws_stream, response) = async_tungstenite::tokio::connect_async(request).await?;

        assert_eq!(
            response.status(),
            tungstenite::http::StatusCode::SWITCHING_PROTOCOLS
        );

        let (sink, stream) = ws_stream.split(); // 스트림과 싱크 분리

        Ok(Self { stream, sink }) // 분리된 스트림과 싱크 저장
    }

    /// Sends a close frame and attempts to gracefully close the WebSocket connection.
    /// This makes the "disconnect" action explicit and reliable for tests.
    pub async fn close(&mut self) -> Result<(), tungstenite::Error> {
        info!("[TEST_WS] Sending Close frame to server.");
        // First, send a close message to the server.
        self.sink.send(Message::Close(None)).await?;
        // Then, fully close the sink.
        self.sink.close().await
    }

    pub async fn send(&mut self, msg: impl Into<Message>) -> Result<(), tungstenite::Error> {
        self.sink.send(msg.into()).await // 싱크를 통해 메시지 전송
    }

    pub async fn expect_message_opt<T, F>(&mut self, mut extractor: F) -> T
    where
        T: DeserializeOwned,
        F: FnMut(T) -> Option<T>, // 클로저가 Option<T>를 반환하도록 변경
    {
        let callback = async {
            loop {
                match self.stream.next().await {
                    Some(Ok(Message::Text(text))) => {
                        info!("[TEST] Received message: {}", text);
                        if let Ok(parsed) = serde_json::from_str::<T>(&text) {
                            // 클로저를 실행하고, Some(T)가 반환되면 루프를 종료하고 값을 반환
                            if let Some(result) = extractor(parsed) {
                                return result;
                            }
                            // None이 반환되면, 원하는 메시지가 아니므로 계속 루프를 돕니다.
                        } else {
                            info!("[TEST] Failed to parse into expected type: {}", text);
                            continue;
                        }
                    }
                    // ... (Ping, Pong, Close 등 나머지 핸들링은 동일)
                    Some(Ok(Message::Ping(_))) => continue,
                    Some(Ok(Message::Pong(_))) => continue,
                    Some(Ok(Message::Close(reason))) => {
                        panic!("WebSocket closed unexpectedly. Reason: {:?}", reason);
                    }
                    Some(Ok(msg)) => {
                        info!("[TEST] Ignoring other message type: {:?}", msg);
                        continue;
                    }
                    Some(Err(e)) => panic!("WebSocket error: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly"),
                }
            }
        };

        match tokio::time::timeout(Duration::from_secs(CLIENT_TIMEOUT), callback).await {
            Ok(result) => result,
            Err(_) => panic!("Expected message timeout after {} seconds", CLIENT_TIMEOUT),
        }
    }

    pub async fn expect_message<T, F, R>(&mut self, extractor: F) -> R
    where
        T: DeserializeOwned,
        F: Fn(T) -> R,
    {
        let callback = async {
            loop {
                match self.stream.next().await {
                    Some(Ok(Message::Text(text))) => {
                        info!("[TEST] Received message: {}", text);
                        if let Ok(parsed) = serde_json::from_str::<T>(&text) {
                            return extractor(parsed);
                        } else {
                            info!("[TEST] Failed to parse into expected type: {}", text);
                            // 중요: 여기서 continue를 해야 다른 타입 메시지를 기다림
                            continue;
                        }
                    }
                    Some(Ok(Message::Ping(_))) => {
                        info!("[TEST] Received ping (auto-pong by tungstenite), ignoring.");
                        continue; // 자동으로 pong 처리됨
                    }
                    Some(Ok(Message::Pong(_))) => {
                        info!("[TEST] Received Pong, ignoring.");
                        continue; // Pong은 무시하고 다음 메시지 기다림
                    }
                    Some(Ok(Message::Close(reason))) => {
                        panic!("WebSocket closed unexpectedly while waiting for specific message. Reason: {:?}", reason);
                    }
                    Some(Ok(msg)) => {
                        info!("[TEST] Ignoring other message type: {:?}", msg);
                        continue; // 다른 메시지 타입 무시
                    }
                    Some(Err(e)) => panic!("WebSocket error: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly"),
                }
            }
        };

        match tokio::time::timeout(Duration::from_secs(CLIENT_TIMEOUT), callback).await {
            Ok(result) => result,
            Err(_) => panic!(
                "Expected message timeout after {} seconds",
                HEARTBEAT_INTERVAL + 5
            ),
        }
    }
}

#[ctor]
fn init() {
    setup_logger();
}
</file>

<file path="simulator_match_server/Cargo.toml">
[package]
name = "match_server"
version = "0.1.0"
edition = "2021"
description = "card backend"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html



[dependencies]
tokio = { version = "1.15", features = ["full", "tracing"] }
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
actix-web = "4.9.0"
actix = "=0.13.5"
actix-ws = "0.3.0"
async-tungstenite = {version="0.28.2", features = ["tokio-runtime"]}
reqwest = "0.12.12"
url = "2.5.4"
uuid = { version = "1.14.0", features = ["v4", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rand_core = "0.6"
rand = "0.8.5"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
ctor = "0.4.1"
redis = { version = "0.22.3", features = ["tokio-comp"] }
thiserror-core = "1.0.50"
dotenv = "0.15.0"
thiserror = "2.0.12"
config = {version = "0.15.11", features = ["toml"]}
</file>

<file path=".gitignore">
/target
/gemini_env
.env
</file>

<file path="simulator_core/src/utils/mod.rs">
pub mod json;

use crate::card::cards::Cards;
use crate::card::types::PlayerKind;
use crate::card_gen::{CardGenerator, Keys};
use crate::enums::*;
use crate::exception::{GameError, SystemError, GameplayError, DeckError};
use base64::{decode, encode};
use byteorder::WriteBytesExt;
use serde_json::Value;
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::io::{Cursor, Write};
use std::vec;
use tracing::warn;
use uuid::Uuid;

pub fn generate_uuid() -> Result<Uuid, GameError> {
    let uuid = Uuid::new_v4();
    Ok(uuid)
}

pub fn read_game_config_json() -> Result<json::GameConfigJson, GameError> {
    let file_path = GAME_CONFIG_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: json::GameConfigJson = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(e) => return Err(GameError::System(SystemError::Json(e))),
    };

    Ok(card_json)
}

pub fn parse_json_to_deck_code(
    p1_card_json: Option<Value>,
    p2_card_json: Option<Value>,
) -> Result<(String, String), GameError> {
    match (&p1_card_json, &p2_card_json) {
        (None, None) => return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::ParseFailed("Decode error".to_string())))),
        (None, Some(_)) => return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::CodeMissingFor(PlayerKind::Player1)))),
        (Some(_), None) => return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::CodeMissingFor(PlayerKind::Player2)))),
        _ => {}
    }

    fn parse_deck_json(
        json_value: Option<Value>,
        player_num: usize,
    ) -> Result<json::Decks, GameError> {
        if let Some(value) = json_value {
            serde_json::from_value(value).map_err(|e| GameError::System(SystemError::Json(e)))
        } else {
            let file_path = match player_num {
                PLAYER_1 => DECK_JSON_PATH_P1,
                PLAYER_2 => DECK_JSON_PATH_P2,
                _ => return Err(GameError::System(SystemError::Io(std::io::Error::new(std::io::ErrorKind::NotFound, "Path not found")))),
            };

            let mut file = File::open(file_path).map_err(|e| GameError::System(SystemError::Io(e)))?;
            let mut json_data = String::new();
            file.read_to_string(&mut json_data)
                .map_err(|e| GameError::System(SystemError::Io(e)))?;

            serde_json::from_str(&json_data).map_err(|e| GameError::System(SystemError::Json(e)))
        }
    }

    fn create_card_vector(decks: &json::Decks, keys: &Keys, num: i32) -> Vec<i32> {
        decks.decks[0]
            .cards
            .iter()
            .filter(|card| card.num == num)
            .filter_map(|card| keys.get_usize_by_string(&card.id))
            .collect()
    }

    fn generate_deck_code(
        player_num: usize,
        json_value: Option<Value>,
    ) -> Result<String, GameError> {
        let decks = parse_deck_json(json_value, player_num)?;
        let keys = Keys::new();

        // deckcode 에서 카드 1장 인 것과 2장 인 것을 따로 생성함.
        let card1 = create_card_vector(&decks, &keys, 1);
        let card2 = create_card_vector(&decks, &keys, 2);

        let dbf_hero = 930;
        let format = 2;

        Ok(deck_encode(card1, card2, dbf_hero, format))
    }

    // 두 플레이어의 덱 코드 생성
    let p1_code = generate_deck_code(PLAYER_1, p1_card_json)?;
    let p2_code = generate_deck_code(PLAYER_2, p2_card_json)?;

    Ok((p1_code, p2_code))
}

pub fn deckcode_to_cards_single(deckcode: String) -> Result<Cards, GameError> {
    // TODO: 거대한 카드 json 을 한 번에 읽어오는 것보다, 필요한 카드만 읽어오는 방법으로 개선해야함.
    //       (예: JSON 스트리밍 파서 사용 또는 데이터베이스 사용)
    let file_path = CARD_JSON_PATH;

    let mut file = File::open(file_path).map_err(|e| {
        warn!(
            "Failed to open card JSON file at {}: {}. Error: {}",
            file_path, CARD_JSON_PATH, e
        );
        GameError::System(SystemError::Io(e))
    })?;

    let mut json_data = String::new();
    file.read_to_string(&mut json_data).map_err(|e| {
        warn!(
            "Failed to read card JSON file: {}. Error: {}",
            CARD_JSON_PATH, e
        );
        GameError::System(SystemError::Io(e))
    })?;

    let all_cards_data: Vec<json::CardJson> = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(e) => {
            warn!(
                "Failed to parse card JSON data from {}. Error: {}",
                CARD_JSON_PATH, e
            );
            return Err(GameError::System(SystemError::Json(e)));
        }
    };

    let decoded_deck = match deck_decode(deckcode) {
        Ok(data) => data,
        Err(_) => {
            warn!("Failed to decode deck code.");
            return Err(GameError::Gameplay(GameplayError::DeckError(DeckError::ParseFailed("Deck decode failed".to_string()))));
        }
    };

    let card_generator = CardGenerator::new();
    let mut deck_cards: Cards = Vec::with_capacity(MAX_CARD_SIZE);

    // all_cards_data를 dbfid 기준으로 HashMap으로 만들어 빠른 조회를 가능하게 합니다.
    let card_data_map: HashMap<i32, &json::CardJson> = all_cards_data
        .iter()
        .filter_map(|cd| cd.dbfid.map(|id| (id, cd)))
        .collect();

    // decoded_deck.0 (1장씩 있는 카드 ID 리스트) 처리
    for &dbfid in &decoded_deck.0 {
        if let Some(card_data) = card_data_map.get(&dbfid) {
            let card = card_generator.gen_card_by_id_i32(dbfid, card_data, 1);
            deck_cards.push(card);
        } else {
            warn!(
                "Card data not found for dbfid (1-copy): {}. This card will be skipped.",
                dbfid
            );
        }
    }

    // decoded_deck.1 (2장씩 있는 카드 ID 리스트) 처리
    for &dbfid in &decoded_deck.1 {
        if let Some(card_data) = card_data_map.get(&dbfid) {
            // `count`가 2이므로, `gen_card_by_id_i32`를 두 번 호출하여
            // 각각의 카드 인스턴스를 생성합니다.
            let card1 = card_generator.gen_card_by_id_i32(dbfid, card_data, 1); // 첫 번째 인스턴스
            deck_cards.push(card1);

            let card2 = card_generator.gen_card_by_id_i32(dbfid, card_data, 1); // 두 번째 인스턴스
            deck_cards.push(card2);
        } else {
            warn!(
                "Card data not found for dbfid (2-copy): {}. These cards will be skipped.",
                dbfid
            );
        }
    }

    Ok(deck_cards)
}

pub fn load_card_id() -> Result<Vec<(String, i32)>, GameError> {
    let file_path = CARD_ID_JSON_PATH;

    // 파일 열기
    let mut file = File::open(file_path).expect("Failed to open file");

    // 파일 내용을 문자열로 읽기
    let mut json_data = String::new();
    file.read_to_string(&mut json_data)
        .expect("Failed to read file");

    let card_json: Vec<json::Item> = match serde_json::from_str(&json_data[..]) {
        Ok(data) => data,
        Err(e) => return Err(GameError::System(SystemError::Json(e))),
    };

    let mut ids = vec![];

    for item in &card_json {
        ids.push((item.id.clone(), item.dbfid));
    }
    Ok(ids)
}

const DECK_CODE_VERSION: u32 = 1;
pub fn deck_decode(deck_code: String) -> Result<(Vec<i32>, Vec<i32>), ()> {
    let code = decode(deck_code).unwrap();
    let mut pos = 0;

    let read_varint = |pos: &mut usize| {
        let mut shift = 0;
        let mut result = 0;

        loop {
            if *pos >= code.len() {
                return Err(());
            }

            let ch = code[*pos] as usize;

            *pos += 1;

            result |= (ch & 0x7f) << shift;
            shift += 7;

            if (ch & 0x80) == 0 {
                break;
            }
        }
        return Ok(result);
    };

    if code[pos] as char != '\0' {
        println!("Invalid deck code");
        return Err(());
    }
    pos += 1;

    match read_varint(&mut pos) {
        Ok(version) => {
            if version as u32 != DECK_CODE_VERSION {
                println!("Version mismatch");
                return Err(());
            }
        }
        Err(_) => {
            println!("version err");
            return Err(());
        }
    }

    let format = read_varint(&mut pos);
    match format {
        Ok(_) => {}
        Err(_) => {
            println!("Invalid format type");
            return Err(());
        }
    }

    let num = read_varint(&mut pos);
    match num {
        Ok(data) => {
            if data != 1 {
                println!("Hero count must be 1");
                return Err(());
            }
        }
        Err(_) => return Err(()),
    }

    let hero_type = read_varint(&mut pos);
    let _hero_type = match hero_type {
        Ok(hero_id) => hero_id,
        Err(_) => {
            return Err(());
        }
    };

    //Deck deckInfo(format, hero->GetCardClass());
    let mut _1_cards = vec![];
    let mut _2_cards = vec![];

    // Single-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let card_id = read_varint(&mut pos).unwrap();
        _1_cards.push(card_id as i32);
    }

    // 2-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let card_id = read_varint(&mut pos).unwrap();
        _2_cards.push(card_id as i32);
        // deckInfo.AddCard(Cards::FindCardByDbfID(cardID)->id, 2);
    }

    // 하스스톤은 덱에서 같은 카드를 세 개 이상 구성하지 못함. ( 최대 2개 ) 근데 왜 n-copy 코드가 있는지는 잘 모르겠음..
    // n-copy cards
    let num = read_varint(&mut pos).unwrap();
    for _idx in 0..num {
        let _card_id = read_varint(&mut pos).unwrap();
        let _count = read_varint(&mut pos).unwrap();
        // deckInfo.AddCard(Cards::FindCardByDbfID(cardID)->id, count);
    }
    // println!("{:#?} {:#?}", _1_cards, _2_cards);
    Ok((_1_cards, _2_cards))
}

fn write_varint<W: Write>(writer: &mut W, mut value: usize) -> std::io::Result<()> {
    loop {
        let mut temp: u8 = (value & 0b01111111) as u8;
        value >>= 7;
        if value != 0 {
            temp |= 0b10000000;
        }
        writer.write_u8(temp)?;
        if value == 0 {
            break;
        }
    }
    Ok(())
}

fn deck_encode(deck1: Vec<i32>, deck2: Vec<i32>, dbf_hero: usize, format: usize) -> String {
    let mut baos = Cursor::new(Vec::new());

    write_varint(&mut baos, 0).unwrap(); // always zero
    write_varint(&mut baos, 1).unwrap(); // encoding version number
    write_varint(&mut baos, format).unwrap(); // standard = 2, wild = 1
    write_varint(&mut baos, 1).unwrap(); // number of heroes in heroes array, always 1
    write_varint(&mut baos, dbf_hero).unwrap(); // DBF ID of hero

    write_varint(&mut baos, deck1.len() as usize).unwrap(); // number of 1-quantity cards
    for dbf_id in &deck1 {
        write_varint(&mut baos, *dbf_id as usize).unwrap();
    }

    write_varint(&mut baos, deck2.len() as usize).unwrap(); // number of 2-quantity cards
    for dbf_id in &deck2 {
        write_varint(&mut baos, *dbf_id as usize).unwrap();
    }

    write_varint(&mut baos, 0).unwrap(); // the number of cards that have quantity greater than 2. Always 0 for constructed

    let deck_bytes = baos.into_inner();

    let deck_string = encode(&deck_bytes);

    deck_string
}
</file>

<file path="simulator_dedicated_server/Cargo.toml">
[package]
name = "dedicated_server"
version = "0.1.0"
edition = "2021"
description = "card backend"


# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
simulator_core = { path = "../simulator_core" }
tokio = { version = "1.15", features = ["full", "tracing"] }
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
actix-web = "4.9.0"
actix = "=0.13.5"
actix-ws = "0.3.0"
async-tungstenite = {version="0.28.2", features = ["tokio-runtime"]}
reqwest = "0.12.12"
url = "2.5.4"
uuid = { version = "1.14.0", features = ["v4", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rand_core = "0.6"
rand = "0.8.5"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
ctor = "0.4.1"
glicko2 = "0.3.1"
</file>

<file path="simulator_dedicated_server/src/connection/connection.rs">
use std::time::{Duration, Instant};

use actix::{
    fut::wrap_future, Actor, ActorContext, Addr, AsyncContext, Context, Running, SpawnHandle,
    StreamHandler,
};
use actix_ws::{Message, ProtocolError, Session};
use simulator_core::{
    card::types::PlayerKind, exception::{ConnectionError, GameError, SystemError}, game::{
        msg::connection::{RegisterConnection, UnRegisterConnection},
        GameActor,
    }, retry_with_condition, Condition, RetryConfig
};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::{
    connection::{
        messages::{PostRegistrationSetup, StopActorOnError},
        ServerMessage,
    },
    enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
};

use super::UserAction;

/// WebSocket 연결을 관리하는 Actor
pub struct ConnectionActor {
    pub ws_session: Session,        // 웹소켓 세션 제어
    pub game_addr: Addr<GameActor>, // 연결된 GameActor 주소
    pub player_type: PlayerKind,

    pub last_pong: Instant,
    pub player_id: Uuid,       // 이 연결의 플레이어 ID
    pub cleanup_started: bool, // 중복 정리를 방지하기 위한 플래그
    pub initial_pong_received: bool,
    pub heartbeat_handle: Option<SpawnHandle>,
}

impl ConnectionActor {
    /// ConnectionActor의 새 인스턴스를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `session` - 이 액터가 관리할 웹소켓 세션 객체.
    /// * `game_addr` - 이 플레이어가 참여하는 게임을 관리하는 GameActor의 주소.
    /// * `session_id` - 이 연결에 해당하는 플레이어의 고유 식별자.
    /// * `session_manager` - 세션 타임아웃 및 정리를 관리하는 PlayerSessionManager.
    ///
    /// # Returns
    ///
    /// 새로운 ConnectionActor 인스턴스를 반환합니다.
    pub fn new(
        session: Session,
        game_addr: Addr<GameActor>,
        player_id: Uuid,
        player_type: PlayerKind,
    ) -> Self {
        Self {
            ws_session: session,
            game_addr,
            player_id,
            last_pong: Instant::now(),
            player_type,
            cleanup_started: false,
            initial_pong_received: false,
            heartbeat_handle: None,
        }
    }

    pub fn send_ping(&self, ctx: &mut Context<Self>) {
        info!(
            "Spawning heartbeat ping task for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );

        let mut session_clone = self.ws_session.clone();
        let player_type_log = self.player_type;
        let session_id_log = self.player_id;
        let connection_addr = ctx.address().clone(); // Corrected: use ctx.address()

        ctx.spawn(wrap_future::<_, Self>(async move {
            if let Err(e) = session_clone.ping(b"heartbeat").await {
                error!(
                    "Failed to send ping to player {:?} (session_id: {}): {:?}",
                    player_type_log, session_id_log, e
                );
                connection_addr.do_send(StopActorOnError { 
                    error: GameError::System(SystemError::Io(std::io::Error::new(std::io::ErrorKind::ConnectionAborted, e.to_string()))) 
                });
            } else {
                info!(
                    "Ping sent successfully to player {:?} (session_id: {})",
                    player_type_log, session_id_log
                );
            }
        }));
    }

    pub fn start_heartbeat_interval(&mut self, ctx: &mut Context<Self>) {
        if self.heartbeat_handle.is_some() {
            return;
        }

        let handle = ctx.run_interval(Duration::from_secs(HEARTBEAT_INTERVAL), |act, ctx_inner| {
            if Instant::now().duration_since(act.last_pong) > Duration::from_secs(CLIENT_TIMEOUT) {
                warn!(
                    "Heartbeat timeout for player {:?} (session_id: {}). Closing connection.",
                    act.player_type, act.player_id
                );
                ctx_inner.stop();
                return;
            }
            
            act.send_ping(ctx_inner);
        });

        self.heartbeat_handle = Some(handle);
    }


    fn start_cleanup_task(&mut self) {
        if self.cleanup_started {
            return;
        }
        self.cleanup_started = true;

        let player_clone = self.player_type;
        let sid_clone = self.player_id;
        let ws_session_clone = self.ws_session.clone();

        tokio::spawn(async move {
            ws_session_clone.close(None).await.unwrap_or_else(|e| {
                error!(
                    "Failed to close WebSocket session for player {:?} (session_id: {}): {:?}",
                    player_clone, sid_clone, e
                );
            });
            info!(
                "Session cleanup task completed: player={:?}, session_id={}",
                player_clone, sid_clone
            );
        });
    }
}

impl Actor for ConnectionActor {
    type Context = Context<Self>;

    fn started(&mut self, _ctx: &mut Context<Self>) {
        let player_type_log = self.player_type;
        info!(
            "ConnectionActor started for player {} {}",
            player_type_log, self.player_id
        );
    }

    fn stopping(&mut self, ctx: &mut Context<Self>) -> Running {
        info!(
            "ConnectionActor stopping for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );

        if let Some(handle) = self.heartbeat_handle.take() {
            ctx.cancel_future(handle);
            info!(
                "Heartbeat task cancelled for player {:?} (session_id: {})",
                self.player_type, self.player_id
            );
        } else {
            warn!(
                "No heartbeat task to cancel for player {:?} (session_id: {})",
                self.player_type, self.player_id
            );
        }

        self.game_addr.do_send(UnRegisterConnection {
            player_id: self.player_id,
        });

        self.start_cleanup_task();

        Running::Continue
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        info!(
            "ConnectionActor stopped for player {:?} (session_id: {})",
            self.player_type, self.player_id
        );
    }
}

impl StreamHandler<Result<Message, ProtocolError>> for ConnectionActor {
    fn handle(&mut self, msg: Result<Message, ProtocolError>, ctx: &mut Context<Self>) {
        debug!(
            "ConnectionActor received message from player {:?} (session_id: {}): {:?}",
            self.player_type, self.player_id, msg
        );
        match msg {
            Ok(Message::Ping(ping_msg)) => {
                info!(
                    "ConnectionActor for player {:?} (session_id: {}) received Ping from client.",
                    self.player_type, self.player_id
                );

                let player_type_log = self.player_type;
                let session_id_log = self.player_id;
                let mut session_clone = self.ws_session.clone();

                let send_future = async move {
                    if let Err(e) = session_clone.pong(&ping_msg).await {
                        error!(
                            "ConnectionActor for player {:?} (session_id: {}): Failed to send Pong to client: {:?}",
                            player_type_log, session_id_log, e
                        );
                    } else {
                        info!(
                            "ConnectionActor for player {:?} (session_id: {}): Sent Pong to client.",
                            player_type_log, session_id_log
                        );
                    }
                };
                ctx.spawn(wrap_future::<_, Self>(send_future));
            }
            Ok(Message::Pong(_)) => {
                let player_type = self.player_type;
                let player_id = self.player_id;
                let game_addr = self.game_addr.clone();
                let addr = ctx.address().clone();

                // 1. 활성 시간 갱신
                self.last_pong = Instant::now();
                info!(
                    "ConnectionActor for player {:?} (session_id: {}): Received Pong from client",
                    self.player_type, self.player_id
                );

                // 2. 초기 Pong 수신 여부 확인
                if !self.initial_pong_received {
                    self.initial_pong_received = true;
                    info!(
                        "ConnectionActor for player {:?} (session_id: {}): Initial Pong received. Registering with GameActor.",
                        self.player_type, self.player_id
                    );

                    let connection_addr = ctx.address().clone();
                    let ws_session = self.ws_session.clone(); // ws_session도 클론

                    ctx.spawn(wrap_future::<_, Self>(async move {
                        // 3. GameActor에 연결 등록 메시지를 전송하는 비동기 함수 생성
                        let operation = || {
                            let game_addr_clone = game_addr.clone();
                            let connection_addr_clone = connection_addr.clone();
                            async move {
                                let register_connection_future = game_addr_clone
                                    .send(RegisterConnection {
                                        player_id,
                                        recipient: connection_addr_clone.recipient(),
                                    }).await;

                                match register_connection_future {
                                    Ok(handler_result) => {
                                        match handler_result {
                                            Ok(_) => {
                                                return Ok(());
                                            }
                                            Err(game_error) => {
                                                error!(
                                                    "ConnectionActor for player {:?} (session_id: {}): Message sent to GameActor, but registration failed with GameError: {:?}",
                                                    player_type, player_id, game_error
                                                );
                                                return Err(game_error);
                                            }
                                        }
                                    }
                                    Err(mailbox_error) => {
                                        error!(
                                        "ConnectionActor for player {:?} (session_id: {}): Failed to send RegisterConnection message to GameActor (MailboxError): {:?}",
                                        player_type, player_id, mailbox_error
                                    );
                                        return Err(GameError::System(SystemError::Mailbox(mailbox_error)));
                                    }
                                }
                            }
                        };

                        // 4. 생성된 비동기 함수를 retry 함수에 넘겨서 재시도 로직 적용
                        let condition = |e: &GameError| {
                            if let GameError::Connection(ConnectionError::SessionExists(_)) = e {
                                return Condition::Stop;
                            }
                            Condition::Continue
                        };
                        
                        if let Err(e) = retry_with_condition(operation, RetryConfig::default(), condition,"RegisterConnection").await{
                            error!(
                                "ConnectionActor for player {:?} (session_id: {}): Failed to register with GameActor after retries: {:?}",
                                player_type, player_id, e
                            );

                            // 클라이언트에게 에러 메시지 전송
                            let server_error_message = ServerMessage::from(e);
                            
                            // 2. ServerMessage를 JSON 문자열로 변환합니다.
                            //    (to_json 헬퍼 함수가 이 새로운 variant를 처리하도록 수정 필요)
                            let error_payload = server_error_message.to_json();
                            
                            let mut session_clone = ws_session.clone();
                            if let Err(send_err) = session_clone.text(error_payload).await {
                                warn!("Failed to send error message to client: {:?}", send_err);
                            }
                            addr.do_send(StopActorOnError {
                                error: GameError::System(SystemError::Internal(
                                    "Failed to register with GameActor after retries".to_string(),
                                )),
                            });
                        } else {
                            info!(
                                "ConnectionActor for player {:?} (session_id: {}): Successfully registered with GameActor.",
                                player_type, player_id
                            );

                            connection_addr.do_send(PostRegistrationSetup);
                        }
                    }));
                }
            }
            Ok(Message::Close(reason)) => {
                info!(
                    "ConnectionActor for player {:?} (session_id: {}): Received Close from client. Reason: {:?}",
                    self.player_type, self.player_id, reason
                );
                ctx.stop();
            }
            Ok(Message::Text(text)) => {
                match serde_json::from_str::<UserAction>(&text.to_string()) {
                    Ok(user_action) => {
                        info!(
                            "ConnectionActor for player {:?} (session_id: {}): Forwarding action to GameActor: {:?}",
                            self.player_type, self.player_id, user_action
                        );
                        // self.game_addr.do_send(HandleUserAction {
                        //     player_id: self.player_id,
                        //     action: user_action,
                        // });
                    }
                    Err(e) => {
                        error!(
                            "ConnectionActor for player {:?} (session_id: {}): Failed to parse UserAction from text '{}'. Error: {}",
                            self.player_type, self.player_id, text, e
                        );
                        let error_msg = format!("{{\"error\": \"Invalid message format: {}\"}}", e);
                        let mut session_clone = self.ws_session.clone();
                        let player_id_log = self.player_id; // 로그용 ID 클론
                        ctx.spawn(wrap_future::<_, Self>(async move {
                            if let Err(send_err) = session_clone.text(error_msg).await {
                                error!(
                                    "ConnectionActor for player_id {}: Failed to send error text to client: {:?}",
                                    player_id_log, send_err
                                );
                            }
                        }));
                    }
                }
            }
            Ok(Message::Binary(_)) => {
                warn!(
                    "ConnectionActor for player {:?} (session_id: {}): Received unexpected Binary message.",
                    self.player_type, self.player_id
                );
            }
            Err(e) => {
                error!(
                    "ConnectionActor for player {:?} (session_id: {}): WebSocket error: {}",
                    self.player_type, self.player_id, e
                );
                ctx.stop();
            }
            _ => {
                // 예를 들어 Ok(Message::Continuation(_)) 등 명시적으로 처리하지 않은 메시지 타입
                warn!(
                    "ConnectionActor for player {:?} (session_id: {}): Received unhandled message type.",
                    self.player_type, self.player_id
                );
            }
        }
    }

    fn finished(&mut self, ctx: &mut Context<Self>) {
        info!(
            "ConnectionActor for player {:?} (session_id: {}): WebSocket stream finished. Stopping actor.",
            self.player_type, self.player_id
        );
        ctx.stop();
    }
}
</file>

<file path="simulator_dedicated_server/src/connection/messages.rs">
use std::io::Error;

use actix::{fut::wrap_future, prelude::*};
use tracing::{error, info, warn};

use simulator_core::{
    exception::{GameError, SystemError},
    game::msg::GameEvent,
};

use super::{connection::ConnectionActor, ServerMessage};

use actix::Message;

#[derive(Message)]
#[rtype(result = "()")]
pub struct StopActorOnError {
    pub error: GameError,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct CancelHeartbeat;

impl Handler<CancelHeartbeat> for ConnectionActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, _msg: CancelHeartbeat, ctx: &mut Context<Self>) -> Self::Result {
        info!("Cancelling heartbeat for player: {:?}", self.player_type);
        if let Some(handle) = self.heartbeat_handle {
            if ctx.cancel_future(handle) {
                info!(
                    "Heartbeat cancelled successfully for player: {:?}",
                    self.player_id
                );
                self.heartbeat_handle = None;
                return Ok(());
            } else {
                warn!(
                    "Failed to cancel heartbeat for player: {:?}, handle may not be valid.",
                    self.player_id
                );
                return Err(GameError::System(SystemError::Internal(
                    "Failed to cancel heartbeat, handle may not be valid.".to_string(),
                )));
            }
        }
        return Err(GameError::System(SystemError::Internal(
            "No heartbeat handle to cancel.".to_string(),
        )));
    }
}

impl Handler<StopActorOnError> for ConnectionActor {
    type Result = ();

    fn handle(&mut self, msg: StopActorOnError, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "Stopping ConnectionActor for player: {:?} due to error: {:?}",
            self.player_id, msg.error
        );
        // HeartBeat 등 리소스는 stopping 에서 처리함.
        ctx.stop();
    }
}

impl Handler<GameEvent> for ConnectionActor {
    type Result = ();
    fn handle(&mut self, msg: GameEvent, ctx: &mut Context<Self>) {
        match msg {
            GameEvent::SendMulliganDealCards { cards } => {
                info!("Received SendMulliganDealCards event, sending directly to client for player: {:?}", self.player_id);
                let data_to_send = ServerMessage::MulliganDealCards {
                    // ServerMessage는 클라이언트와 약속된 포맷
                    player: self.player_type.to_string(), // 또는 self.player_id.to_string()
                    cards: cards,                         // Uuid 리스트
                }
                .to_json(); // JSON 문자열로 변환하는 헬퍼

                let mut session_clone = self.ws_session.clone();
                let player_id_log = self.player_id;
                let actor_addr = ctx.address(); // 에러 시 중지를 위해

                let send_future = async move {
                    if let Err(e) = session_clone.text(data_to_send).await {
                        warn!(
                            "Failed to send Mulligan deal cards directly for player {}: {:?}",
                            player_id_log, e
                        );
                        actor_addr.do_send(StopActorOnError {
                            error: GameError::System(SystemError::Io(Error::new(
                                std::io::ErrorKind::ConnectionRefused,
                                format!("Failed to send Mulligan deal cards: {}", e),
                            ))),
                        });
                    } else {
                        info!(
                            "Successfully sent Mulligan deal cards directly to player: {}",
                            player_id_log
                        );
                    }
                };
                ctx.spawn(wrap_future::<_, Self>(send_future));
            }
            GameEvent::GameStopped => {
                info!(
                    "Game stopped event received, stopping ConnectionActor for player: {:?}",
                    self.player_id
                );
                ctx.stop(); // 게임이 중지되면 액터를 중지
            }
            GameEvent::SyncState { snapshot } => todo!(),
            GameEvent::StateUpdate(_) => todo!(),
        }
    }
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct PostRegistrationSetup;

impl Handler<PostRegistrationSetup> for ConnectionActor {
    type Result = ();

    fn handle(&mut self, _msg: PostRegistrationSetup, ctx: &mut Context<Self>) {
        info!("asd");
        // 1. Send the HeartbeatConnected message
        let success_msg = ServerMessage::HeartbeatConnected {
            player: self.player_type.to_string(),
            session_id: self.player_id,
        }
        .to_json();

        let mut session_clone = self.ws_session.clone();
        let actor_addr = ctx.address();
        ctx.spawn(wrap_future::<_, Self>(async move {
            if let Err(e) = session_clone.text(success_msg).await {
                error!(
                    "Failed to send HeartbeatConnected after successful registration: {:?}",
                    e
                );
                actor_addr.do_send(StopActorOnError {
                    error: GameError::System(SystemError::Io(std::io::Error::new(
                        std::io::ErrorKind::BrokenPipe,
                        e.to_string(),
                    ))),
                });
            }
        }));

        // 2. Send the first Ping immediately
        self.send_ping(ctx);

        // 3. Start the periodic heartbeat interval
        self.start_heartbeat_interval(ctx);
    }
}
</file>

<file path="simulator_dedicated_server/tests/test.rs">
pub mod mulligan {
    use std::{collections::HashSet, sync::Arc, time::Duration};

    use actix::Addr;
    use async_tungstenite::tungstenite::Message;
    use dedicated_server::{
        connection::{ServerErrorCode, ServerMessage},
        enums::HEARTBEAT_INTERVAL,
        test::{spawn_server, WebSocketTest},
    };
    use futures::StreamExt;
    use simulator_core::{
        card::types::PlayerKind,
        enums::{ZoneType, CLIENT_TIMEOUT, COUNT_OF_MULLIGAN_CARDS},
        game::{msg::zones::GetPlayerZoneCards, GameActor},
    };
    use tokio::{
        join,
        sync::Barrier,
        time::{sleep, timeout},
    };
    use tracing::info;
    use uuid::Uuid;

    // 플레이어별 테스트 로직을 위한 헬퍼 함수
    async fn connect_and_register_player(
        player_kind: PlayerKind,
        player_id: Uuid,
        addr: std::net::SocketAddr,
    ) -> WebSocketTest {
        let player_kind_str = player_kind.as_str();
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player_id);
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 1. 서버가 연결을 등록하도록 수동으로 첫 Pong을 보냅니다.
        ws.send(Message::Pong(vec![]))
            .await
            .expect("Failed to send initial Pong");
        info!(
            "[{}] Manually sent initial Pong to trigger registration.",
            player_kind_str
        );

        // 2. HeartbeatConnected 메시지를 수신하여 등록 완료를 확인합니다.
        //    이 함수는 한 명만 연결할 때도, 두 명이 동시에 연결할 때도 사용되므로,
        //    다른 메시지(MulliganDealCards)가 먼저 올 수도 있습니다.
        //    따라서 expect_message 루프가 HeartbeatConnected를 찾을 때까지 다른 메시지를 무시해야 합니다.
        ws.expect_message(|message: ServerMessage| {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert_eq!(session_id, player_id);
                    info!(
                        "[{}] Initial HeartbeatConnected received. Session ID: {}",
                        player_kind_str, session_id
                    );
                }
                // MulliganDealCards는 이 함수에서 처리하지 않으므로, 만약 먼저 온다면 패닉을 일으켜 로직 오류를 알립니다.
                // 혹은 테스트 시나리오에 따라 무시하고 계속 HeartbeatConnected를 기다릴 수도 있습니다.
                // 여기서는 일단 패닉 처리하여, 호출 순서가 잘못되었음을 명확히 합니다.
                _ => panic!(
                    "[{}] Expected HeartbeatConnected, but got {:?} instead.",
                    player_kind_str, message
                ),
            }
        })
        .await;

        ws
    }

    async fn connect_and_send_pong(
        player_kind: PlayerKind,
        player_id: Uuid,
        addr: std::net::SocketAddr,
    ) -> WebSocketTest {
        let player_kind_str = player_kind.as_str();
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player_id);
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 서버가 연결을 등록하도록 수동으로 첫 Pong을 보냅니다.
        ws.send(Message::Pong(vec![]))
            .await
            .expect("Failed to send initial Pong");
        info!("[{}] Connected and sent initial Pong.", player_kind_str);

        ws
    }

    /// WebSocketTest 인스턴스를 통해 MulliganDealCards 메시지를 기다리고 검증합니다.
    async fn expect_mulligan_cards(
        ws: &mut WebSocketTest,
        player_kind: PlayerKind,
        game_actor_addr: Addr<GameActor>,
    ) -> Vec<Uuid> {
        let player_kind_str = player_kind.as_str();
        info!(
            "[{}] Waiting for MulliganDealCards message...",
            player_kind_str
        );

        let dealt_cards = ws
            .expect_message(|message: ServerMessage| -> Vec<Uuid> {
                match message {
                    ServerMessage::MulliganDealCards { player, cards } => {
                        assert_eq!(
                            player, player_kind_str,
                            "[{}] Mulligan cards for wrong player",
                            player_kind_str
                        );
                        assert_eq!(
                            cards.len(),
                            COUNT_OF_MULLIGAN_CARDS,
                            "[{}] Incorrect number of mulligan cards",
                            player_kind_str
                        );
                        assert!(
                            cards.iter().all(|c| !c.is_nil()),
                            "[{}] Nil UUID in mulligan cards",
                            player_kind_str
                        );
                        info!(
                            "[{}] MulliganDealCards received with {} cards.",
                            player_kind_str,
                            cards.len()
                        );
                        cards
                    }
                    _ => panic!(
                        "[{}] Expected MulliganDealCards, but got {:?}",
                        player_kind_str, message
                    ),
                }
            })
            .await;

        // 받은 카드가 덱에 없는지 확인
        info!(
            "[{}] Verifying dealt cards are not in deck...",
            player_kind_str
        );
        let deck_cards_result = game_actor_addr
            .send(GetPlayerZoneCards {
                zone: ZoneType::Deck,
                player_type: player_kind,
            })
            .await
            .expect("Mailbox error getting deck cards");

        let deck_uuids: Vec<Uuid> = deck_cards_result
            .iter()
            .map(|card| card.get_uuid())
            .collect();
        for dealt_card_uuid in &dealt_cards {
            assert!(
                !deck_uuids.contains(dealt_card_uuid),
                "[{}] Deck should not contain card {} that was dealt in mulligan",
                player_kind_str,
                dealt_card_uuid
            );
        }
        info!(
            "[{}] Dealt cards correctly removed from deck.",
            player_kind_str
        );

        dealt_cards
    }

    #[actix_web::test]
    async fn test_mulligan_deal_cards_to_each_player_concurrently() {
        let (addr, state, _handle) = spawn_server().await;
        let game_actor_addr = state.game.clone();
        let player1_id = state.player1_id;
        let player2_id = state.player2_id;

        // 1. 두 플레이어를 병렬로 연결하고 등록합니다.
        let (p1_connect_result, p2_connect_result) = tokio::join!(
            connect_and_register_player(PlayerKind::Player1, player1_id, addr),
            connect_and_register_player(PlayerKind::Player2, player2_id, addr)
        );

        let mut ws1 = p1_connect_result;
        let mut ws2 = p2_connect_result;

        // 2. 두 플레이어가 모두 등록되었으므로, 이제 서버는 멀리건 카드를 보내야 합니다.
        let (p1_cards_result, p2_cards_result) = tokio::join!(
            expect_mulligan_cards(&mut ws1, PlayerKind::Player1, game_actor_addr.clone()),
            expect_mulligan_cards(&mut ws2, PlayerKind::Player2, game_actor_addr.clone())
        );

        // 3. 추가 검증
        let mut all_dealt_cards = p1_cards_result;
        all_dealt_cards.extend(p2_cards_result);
        let unique_cards_count = all_dealt_cards.iter().collect::<HashSet<_>>().len();
        assert_eq!(
            unique_cards_count,
            COUNT_OF_MULLIGAN_CARDS * 2,
            "Dealt cards between players are not unique."
        );
        println!("Test test_mulligan_deal_cards_to_each_player_concurrently completed.");
    }

    #[actix_web::test]
    async fn test_mulligan_deal_cards_one_player_delayed() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player2_id = state.player2_id;

        // --- Player 1's Task ---
        // P1은 즉시 연결하고, 서버가 타임아웃으로 자신을 끊을 때까지 기다립니다.
        let p1_task = tokio::spawn(async move {
            let mut ws1 = connect_and_register_player(PlayerKind::Player1, player1_id, addr).await;
            info!("[DELAYED_TEST] P1 connected and registered. Now waiting for server to close connection due to P2 timeout.");

            // 서버가 P2를 기다리다 타임아웃되어 연결을 끊을 때까지 대기
            // GameActor의 Abort -> ConnectionActor의 stop 흐름
            let close_future = async {
                loop {
                    if let Some(msg) = ws1.stream.next().await {
                        match msg {
                            Ok(Message::Close(_)) => {
                                info!("[DELAYED_TEST] P1 connection closed by server as expected.");
                                break;
                            }
                            Ok(Message::Ping(_)) => continue, // Ping은 무시
                            _ => {}                           // 다른 메시지도 무시
                        }
                    } else {
                        info!("[DELAYED_TEST] P1 stream ended, which is also expected.");
                        break;
                    }
                }
            };

            // CLIENT_TIMEOUT + 약간의 여유시간을 기다립니다.
            match timeout(Duration::from_secs(CLIENT_TIMEOUT + 5), close_future).await {
                Ok(_) => info!("[DELAYED_TEST] P1 task finished successfully."),
                Err(_) => panic!("[DELAYED_TEST] P1 connection was not closed by server within the timeout period."),
            }
        });

        // --- Player 2's Task ---
        // P2는 타임아웃이 발생한 *이후에* 연결을 시도합니다. 이 시도는 실패해야 합니다.
        let p2_task = tokio::spawn(async move {
            // P1이 타임아웃되기에 충분한 시간을 기다립니다.
            sleep(Duration::from_secs(CLIENT_TIMEOUT + 2)).await;
            info!("[DELAYED_TEST] P2 starting connection attempt after timeout.");

            let url = format!("ws://{}/game", addr);
            let cookie = format!("user_id={}", player2_id);
            let reconnect_result = WebSocketTest::connect(url, cookie).await;

            // GameActor가 이미 종료되었으므로 연결 시도는 실패해야 합니다.
            assert!(
                reconnect_result.is_err(),
                "[DELAYED_TEST] P2 connection should have failed, but it succeeded."
            );
            info!("[DELAYED_TEST] P2 connection attempt failed as expected.");
        });

        // 두 태스크의 결과를 기다립니다.
        let (p1_result, p2_result) = tokio::join!(p1_task, p2_task);

        // 태스크 자체가 패닉하지 않았는지 확인
        p1_result.expect("Player 1 task panicked");
        p2_result.expect("Player 2 task panicked");

        println!("[DELAYED_TEST] Test test_mulligan_deal_cards_one_player_delayed completed successfully.");
    }

    #[actix_web::test]
    async fn test_mulligan_deal_cards_on_simultaneous_connection_with_barrier() {
        let (addr, state, _handle) = spawn_server().await;
        let player1_id = state.player1_id;
        let player2_id = state.player2_id;
        let barrier = Arc::new(Barrier::new(2));

        // 1. Act (Phase 1): 동시에 연결 및 Pong 전송
        let p1_barrier = barrier.clone();
        let p1_task = tokio::spawn(async move {
            p1_barrier.wait().await;
            connect_and_send_pong(PlayerKind::Player1, player1_id, addr).await
        });

        let p2_barrier = barrier.clone();
        let p2_task = tokio::spawn(async move {
            p2_barrier.wait().await;
            connect_and_send_pong(PlayerKind::Player2, player2_id, addr).await
        });

        let (p1_result, p2_result) = join!(p1_task, p2_task);
        let mut ws1 = p1_result.unwrap();
        let mut ws2 = p2_result.unwrap();

        info!(
            "[BARRIER_TEST] Both players connected and sent Pong. Now expecting initial messages."
        );

        // 2. Act (Phase 2): 각 클라이언트가 초기 메시지 2개를 수신하고 검증합니다.
        let p1_message_handler = async {
            let mut received_messages = Vec::new();
            // 2개의 메시지를 받습니다.
            received_messages.push(ws1.expect_message_opt(|msg| Some(msg)).await);
            received_messages.push(ws1.expect_message_opt(|msg| Some(msg)).await);

            let mut seen_heartbeat = false;
            let mut dealt_cards: Option<Vec<Uuid>> = None;

            for msg in received_messages {
                match msg {
                    ServerMessage::HeartbeatConnected { player, session_id } => {
                        assert_eq!(player, "Player1");
                        assert_eq!(session_id, player1_id);
                        seen_heartbeat = true;
                    }
                    ServerMessage::MulliganDealCards { player, cards } => {
                        assert_eq!(player, "Player1");
                        assert_eq!(cards.len(), COUNT_OF_MULLIGAN_CARDS);
                        dealt_cards = Some(cards);
                    }
                    _ => panic!("[Player1] Received unexpected message: {:?}", msg),
                }
            }

            assert!(seen_heartbeat, "Player1 did not receive HeartbeatConnected");
            dealt_cards.expect("Player1 did not receive MulliganDealCards")
        };

        let p2_message_handler = async {
            let mut received_messages = Vec::new();
            received_messages.push(ws2.expect_message_opt(|msg| Some(msg)).await);
            received_messages.push(ws2.expect_message_opt(|msg| Some(msg)).await);

            let mut seen_heartbeat = false;
            let mut dealt_cards: Option<Vec<Uuid>> = None;

            for msg in received_messages {
                match msg {
                    ServerMessage::HeartbeatConnected { player, session_id } => {
                        assert_eq!(player, "Player2");
                        assert_eq!(session_id, player2_id);
                        seen_heartbeat = true;
                    }
                    ServerMessage::MulliganDealCards { player, cards } => {
                        assert_eq!(player, "Player2");
                        assert_eq!(cards.len(), COUNT_OF_MULLIGAN_CARDS);
                        dealt_cards = Some(cards);
                    }
                    _ => panic!("[Player2] Received unexpected message: {:?}", msg),
                }
            }

            assert!(seen_heartbeat, "Player2 did not receive HeartbeatConnected");
            dealt_cards.expect("Player2 did not receive MulliganDealCards")
        };

        let (p1_dealt_cards, p2_dealt_cards) = join!(p1_message_handler, p2_message_handler);

        // 3. Assert
        let mut all_dealt_cards = p1_dealt_cards;
        all_dealt_cards.extend(p2_dealt_cards);
        let unique_cards_count = all_dealt_cards.iter().collect::<HashSet<_>>().len();
        assert_eq!(unique_cards_count, COUNT_OF_MULLIGAN_CARDS * 2);

        println!("[BARRIER_TEST] Simultaneous connection test with Barrier PASSED.");
    }
    #[actix_web::test]
    async fn test_rejects_duplicate_connection_for_same_player() {
        // 1. Arrange: 테스트 서버를 시작하고 P1의 정보를 준비합니다.
        let (addr, state, _handle) = spawn_server().await;
        let player1_id = state.player1_id;
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        println!("[DUPLICATE_TEST] Starting duplicate connection test for Player 1.");

        // 2. Act (First Connection): 첫 번째 연결을 성공적으로 맺고, 등록 완료 메시지를 기다립니다.
        let mut ws1 = WebSocketTest::connect(url.clone(), cookie.clone())
            .await
            .expect("First connection should succeed");

        println!("[DUPLICATE_TEST] First connection established.");

        // tungstenite 클라이언트는 서버의 Ping에 자동으로 Pong으로 응답합니다.
        // Pong 응답 후 서버가 성공적으로 등록하고 보내주는 HeartbeatConnected 메시지를 기다립니다.
        ws1.expect_message(|msg: ServerMessage| match msg {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, "Player1");
                assert_eq!(session_id, player1_id);
            }
            _ => panic!("Expected HeartbeatConnected for the first connection"),
        })
        .await;
        println!("[DUPLICATE_TEST] First connection confirmed active.");

        // 3. Act (Second Connection): 동일한 플레이어로 두 번째 연결을 시도합니다.
        let mut ws2 = WebSocketTest::connect(url, cookie)
            .await
            .expect("Second connection handshake should also succeed initially");

        println!("[DUPLICATE_TEST] Second connection established. Now expecting an error message.");

        // 4. Assert (Second Connection receives error and is closed):
        // 두 번째 연결은 중복 세션 에러 메시지를 받고 즉시 종료되어야 합니다.
        ws2.expect_message(|msg: ServerMessage| {
            match msg {
                ServerMessage::Error(payload) => {
                    assert_eq!(payload.code, ServerErrorCode::ActiveSessionExists);
                    println!("[DUPLICATE_TEST] Second connection received correct ActiveSessionExists error.");
                }
                _ => panic!("[DUPLICATE_TEST] Expected an Error message for the second connection, but got {:?}", msg),
            }
        }).await;

        // 에러 메시지 전송 후, 서버는 연결을 닫아야 합니다. 스트림이 닫혔는지 확인합니다.
        let next_msg = timeout(Duration::from_secs(1), ws2.stream.next()).await;
        assert!(
            matches!(next_msg, Ok(None) | Ok(Some(Ok(Message::Close(_))))),
            "Second connection was not closed after sending the error message."
        );
        println!("[DUPLICATE_TEST] Second connection was closed as expected.");

        // 5. Assert (First Connection Intact): 첫 번째 연결이 여전히 살아있는지 확인합니다.
        // 서버로부터 오는 다음 heartbeat ping을 기다리는 것으로 확인할 수 있습니다.
        println!("[DUPLICATE_TEST] Verifying first connection is still alive.");
        let ping_check_result = timeout(Duration::from_secs(HEARTBEAT_INTERVAL + 2), async {
            loop {
                match ws1.stream.next().await {
                    Some(Ok(Message::Ping(_))) => {
                        println!("[DUPLICATE_TEST] First connection received a heartbeat ping. It's alive!");
                        return true;
                    }
                    Some(Ok(_)) => continue, // 다른 메시지는 무시
                    Some(Err(_)) | None => return false, // 스트림이 닫혔으면 실패
                }
            }
        }).await;

        assert!(
            ping_check_result.unwrap_or(false),
            "The first connection was unexpectedly closed after a duplicate attempt."
        );

        println!("[DUPLICATE_TEST] Duplicate connection test PASSED.");
    }

    #[actix_web::test]
    async fn test_game_aborts_if_first_player_disconnects() {
        // 1. Arrange
        let (addr, state, _handle) = spawn_server().await;
        let player1_id = state.player1_id;
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        info!("[ABORT_TEST] Starting test: P1 connects, then disconnects before P2 joins.");

        // 2. Act: P1 connects, confirms, and disconnects.
        let mut ws1 = WebSocketTest::connect(url.clone(), cookie.clone())
            .await
            .expect("P1 initial connection should succeed");

        ws1.send(Message::Pong(vec![]))
            .await
            .expect("Failed to send initial Pong");
        info!("[ABORT_TEST] P1 sent initial Pong.");

        ws1.expect_message(|msg: ServerMessage| {
            if !matches!(msg, ServerMessage::HeartbeatConnected { .. }) {
                panic!("Expected HeartbeatConnected, got {:?}", msg);
            }
        })
        .await;
        info!("[ABORT_TEST] P1 connection confirmed. Server is now waiting for P2.");

        ws1.close().await.expect("Failed to close P1's websocket");
        info!("[ABORT_TEST] P1 connection close command sent.");

        sleep(Duration::from_millis(500)).await;
        info!("[ABORT_TEST] P1 disconnected. Checking if the game session was aborted.");

        // 3. Assert: The game session should be terminated.
        let reconnect_result = WebSocketTest::connect(url, cookie).await;

        if let Ok(mut ws_reconnect) = reconnect_result {
            info!("[ABORT_TEST] Reconnection handshake succeeded. Now triggering registration attempt.");

            // *** KEY CHANGE: Trigger the registration process by sending a Pong ***
            // This will cause the new ConnectionActor to message the (now dead) GameActor.
            let send_pong_result = ws_reconnect.send(Message::Pong(vec![])).await;

            if send_pong_result.is_err() {
                // If sending the Pong fails, it means the connection was already closed. This is a pass.
                info!("[ABORT_TEST] PASSED: Could not send Pong on new connection, as it was already closing.");
            } else {
                // If Pong was sent, we expect the server to detect the dead GameActor and close the connection.
                let first_message =
                    timeout(Duration::from_secs(2), ws_reconnect.stream.next()).await;

                match first_message {
                    Ok(Some(Ok(Message::Close(_)))) | Ok(None) => {
                        info!("[ABORT_TEST] PASSED: Reconnection was closed by the server after registration attempt.");
                    }
                    Ok(Some(Err(e))) => {
                        info!("[ABORT_TEST] PASSED: Reconnection failed with an error, which is an acceptable outcome. Error: {:?}", e);
                    }
                    Ok(Some(Ok(msg))) => {
                        // It's possible to receive an error message before the close frame.
                        if let Ok(server_msg) =
                            serde_json::from_str::<ServerMessage>(&msg.to_string())
                        {
                            if matches!(server_msg, ServerMessage::Error(_)) {
                                info!("[ABORT_TEST] PASSED: Received an error message before closing.");
                                // Check for a subsequent close frame
                                let second_message =
                                    timeout(Duration::from_secs(1), ws_reconnect.stream.next())
                                        .await;
                                assert!(matches!(
                                    second_message,
                                    Ok(Some(Ok(Message::Close(_)))) | Ok(None)
                                ));
                                return;
                            }
                        }
                        panic!(
                            "[ABORT_TEST] FAILED: Reconnection was not closed. Instead, received message: {:?}",
                            msg
                        );
                    }
                    Err(_) => {
                        panic!("[ABORT_TEST] FAILED: Timed out waiting for the server to close the reconnection.");
                    }
                }
            }
        } else if let Err(e) = reconnect_result {
            info!(
                "[ABORT_TEST] PASSED: Reconnection attempt failed at the handshake level, as expected. Error: {}",
                e
            );
        }
    }
}

pub mod heartbeat {
    use std::time::Duration;

    use async_tungstenite::tungstenite::Message;
    use dedicated_server::{
        connection::ServerMessage,
        test::{spawn_server, WebSocketTest},
    };
    use futures::StreamExt;
    use simulator_core::{
        card::types::PlayerKind,
        enums::{CLIENT_TIMEOUT, HEARTBEAT_INTERVAL},
    };
    use tokio::time::{sleep, timeout};
    use tracing::info;
    use uuid::Uuid;

    #[actix_web::test]
    async fn test_heartbeat_initialize_msg() {
        let (addr, state, _handle) = spawn_server().await;

        let player_type = PlayerKind::Player1.as_str();

        // 하트비트 연결 URL 및 쿠키 설정
        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", state.player1_id);

        // 예시: 서버에 GET 요청 보내기
        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 2. 서버가 연결을 등록하도록 수동으로 첫 Pong을 보냅니다.
        ws.send(Message::Pong(vec![]))
            .await
            .expect("Failed to send initial Pong");
        info!("[TEST] Manually sent initial Pong to trigger registration.");

        let extractor = |message: ServerMessage| match message {
            ServerMessage::HeartbeatConnected { player, session_id } => {
                assert_eq!(player, player_type);
                assert!(!session_id.is_nil());
            }
            _ => panic!("Expected HeartbeatConnected message"),
        };
        ws.expect_message(extractor).await;
    }

    // TODO: 제대로된 사유로 성공하는지 확인해야함.
    #[actix_web::test]
    async fn test_heartbeat_timeout() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player_kind_str = PlayerKind::Player1.as_str();

        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 2. 서버가 연결을 등록하도록 수동으로 첫 Pong을 보냅니다.
        ws.send(Message::Pong(vec![]))
            .await
            .expect("Failed to send initial Pong");
        info!("[TEST] Manually sent initial Pong to trigger registration.");

        // 1. 초기 연결 메시지 수신
        info!("[TEST] Waiting for initial connection message...");
        let initial_extractor = |message: ServerMessage| -> Uuid {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert!(!session_id.is_nil());
                    info!(
                        "[TEST] Initial connection message received. Session ID: {}",
                        session_id
                    );
                    session_id
                }
                _ => panic!("Expected HeartbeatConnected message"),
            }
        };
        if timeout(
            Duration::from_secs(HEARTBEAT_INTERVAL),
            ws.expect_message(initial_extractor),
        )
        .await
        .is_err()
        {
            panic!("Timeout waiting for initial HeartbeatConnected message.");
        }

        // 2. 충분히 기다림 (CLIENT_TIMEOUT + 여유)
        let wait_duration = Duration::from_secs(CLIENT_TIMEOUT + 5);
        info!(
            "[TEST] Waiting for {} seconds to see if server closes connection (should NOT close due to auto Pong)...",
            wait_duration.as_secs()
        );

        sleep(wait_duration).await;

        // 3. 연결이 살아있는지 송수신 테스트 (예: Ping 보내고 Pong 받기)
        info!("[TEST] Sending Ping to check if connection is alive...");
        let ping_data = b"test_ping".to_vec();
        let send_result = ws.send(Message::Ping(ping_data.clone())).await;

        let pong_received = match send_result {
            Ok(_) => {
                // Pong 응답을 기다림
                timeout(Duration::from_secs(2), async {
                    loop {
                        match ws.stream.next().await {
                            Some(Ok(Message::Pong(data))) if data == ping_data => break true,
                            Some(Ok(_)) => continue,
                            Some(Err(_)) | None => break false,
                        }
                    }
                })
                .await
                .unwrap_or(false)
            }
            Err(_) => false, // 이미 연결이 끊겼다면
        };

        if pong_received {
            panic!("[TEST] Test Failed: Connection is still alive after client timeout (should be closed).");
        } else {
            info!("[TEST] Test Success: Connection is closed after client timeout (as expected).");
        }
    }

    #[actix_web::test]
    async fn test_heartbeat_ping_pong_once() {
        let (addr, state, _handle) = spawn_server().await;

        let player1_id = state.player1_id;
        let player_kind_str = PlayerKind::Player1.as_str();

        let url = format!("ws://{}/game", addr);
        let cookie = format!("user_id={}", player1_id);

        let mut ws = WebSocketTest::connect(url, cookie).await.unwrap();

        // 2. 서버가 연결을 등록하도록 수동으로 첫 Pong을 보냅니다.
        ws.send(Message::Pong(vec![]))
            .await
            .expect("Failed to send initial Pong");
        info!("[TEST] Manually sent initial Pong to trigger registration.");

        // 1. 초기 연결 메시지 수신 (선택 사항이지만, 이전 테스트에서 확인했으므로 여기서도 확인)
        info!("[TEST] Waiting for initial connection message...");
        let initial_extractor = |message: ServerMessage| -> Uuid {
            match message {
                ServerMessage::HeartbeatConnected { player, session_id } => {
                    assert_eq!(player, player_kind_str);
                    assert!(!session_id.is_nil());
                    info!(
                        "Initial connection message received. Session ID: {}",
                        session_id
                    );
                    session_id
                }
                _ => panic!("Expected HeartbeatConnected message first"),
            }
        };
        let _session_id = ws.expect_message(initial_extractor).await;

        // 2. 서버로부터 Ping 메시지 기다리기
        info!("[TEST] Waiting for Ping message...");
        let ping_received = timeout(Duration::from_secs(HEARTBEAT_INTERVAL * 2), async {
            loop {
                match ws.stream.next().await {
                    Some(Ok(Message::Ping(ping_data))) => {
                        info!("[TEST] Ping received!");
                        return Some(ping_data);
                    }
                    Some(Ok(Message::Text(text))) => {
                        info!(
                            "[TEST] Received unexpected Text while waiting for Ping: {}",
                            text
                        );
                        continue;
                    }
                    Some(Ok(Message::Pong(_))) => {
                        info!("[TEST] Received Pong while waiting for Ping, ignoring.");
                        continue;
                    }
                    Some(Ok(_)) => continue,
                    Some(Err(e)) => panic!("WebSocket error while waiting for Ping: {:?}", e),
                    None => panic!("WebSocket closed unexpectedly while waiting for Ping"),
                }
            }
        })
        .await;

        // 3. Ping 수신 및 Pong 전송 확인
        match ping_received {
            Ok(Some(ping_data)) => {
                // Ping을 받았으므로 Pong 전송
                info!("[TEST] Sending Pong response...");
                ws.send(Message::Pong(ping_data.clone()))
                    .await
                    .expect("Failed to send Pong");
                info!("[TEST] Pong sent.");

                // 잠시 대기하여 서버가 Pong을 처리하고 연결을 유지하는지 확인
                info!("[TEST] Waiting to see if connection is maintained...");
                sleep(Duration::from_secs(2)).await; // 짧은 시간 대기

                // 연결이 살아있는지 확인
                let test_msg = Message::Pong(ping_data);
                match ws.send(test_msg).await {
                    Ok(_) => info!("[TEST] Connection seems alive after Pong."),
                    Err(e) => panic!("Connection seems closed after Pong: {:?}", e),
                }
            }
            Ok(None) => {
                // 루프가 값을 반환하지 않고 종료된 경우
                panic!("Ping waiting loop exited unexpectedly without returning Ping data.");
            }
            Err(_) => {
                panic!(
                    "Timeout: Did not receive Ping within {} seconds.",
                    (HEARTBEAT_INTERVAL * 2)
                );
            }
        }

        // 테스트 종료 (정상적으로 연결 종료)
        info!("[TEST] Closing WebSocket connection.");
        ws.send(Message::Close(None)).await.ok(); // Close 메시지 전송 시도
    }
}
</file>

<file path="simulator_core/src/card/types.rs">
use std::fmt::{self, Display};
use std::hash::{Hash, Hasher};

use actix::Addr;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    exception::{GameError, GameplayError},
    game::GameActor,
    resource::CardSpecsResource,
    utils::json::CardJson,
};

use super::modifier::Modifier;

#[derive(Clone)]
/// `CardSpecs`는 카드의 공격력, 방어력, 비용과 같은 스펙을 나타내는 구조체입니다.
// TODO: `attack`, `defense` 필드의 타입을 CardSpecsResource가 아닌 구체적인 타입으로 변경할 필요가 있는지 검토
// TODO: 필드에 대한 상세 설명 추가 (공격력 범위, 방어력 계산 방식 등)
pub struct CardSpecs {
    attack: CardSpecsResource,
    defense: CardSpecsResource,
    cost: i32,
}

/// `CardSpecs`의 새로운 인스턴스를 생성합니다.
///
/// # Arguments
///
/// * `json` - `CardJson` 구조체의 참조. 카드 스펙 정보를 담고 있습니다.
///
/// # Returns
///
/// 새로운 `CardSpecs` 인스턴스.
// TODO: JSON 필드가 없을 경우의 예외 처리 추가
// TODO: `unwrap()` 호출 대신 `?` 연산자를 사용하여 오류를 전파하도록 변경
impl CardSpecs {
    pub fn new(json: &CardJson) -> Self {
        Self {
            attack: CardSpecsResource::new(json.attack.unwrap()),
            defense: CardSpecsResource::new(json.health.unwrap()),
            cost: json.cost.unwrap(),
        }
    }
}

// CardStatus 구조체 (카드의 현재 상태)
#[derive(Clone, Default)]
/// `CardStatus`는 카드의 현재 상태를 나타내는 구조체입니다.
///
/// 카드가 무효화되었는지, 비활성화되었는지, 그리고 적용된 수정자 목록을 저장합니다.
// TODO: `modifiers` 필드에 대한 상세 설명 추가 (수정자의 종류, 적용 방식 등)
pub struct CardStatus {
    is_negated: bool,
    is_disabled: bool,
    modifiers: Vec<Modifier>,
}

/// `CardStatus`의 새로운 기본 인스턴스를 생성합니다.
///
/// 초기 상태는 무효화되지 않고, 비활성화되지 않았으며, 수정자 목록은 비어 있습니다.
///
/// # Returns
///
/// 기본값을 가진 새로운 `CardStatus` 인스턴스.
impl CardStatus {
    pub fn new() -> Self {
        Self {
            is_negated: false,
            is_disabled: false,
            modifiers: vec![],
        }
    }

    pub fn is_negated(&self) -> bool {
        self.is_negated
    }

    pub fn is_disabled(&self) -> bool {
        self.is_disabled
    }
}

#[derive(Clone, PartialEq, Eq, Copy)]
/// `ModifierType`은 수정자의 유형을 나타내는 열거형입니다.
///
/// 공격력 증가, 방어력 증가, 비용 변경, 효과 무효화, 속성 변경 등의 유형을 정의합니다.
// TODO: 각 ModifierType에 대한 상세 설명 추가 (공격력 증가의 종류, 속성 변경의 범위 등)
pub enum ModifierType {
    AttackBoost,
    DefenseBoost,
    CostChange,
    EffectNegation,
    AttributeChange,
}

#[derive(Clone, Copy)]
/// `Duration`은 수정자의 지속 시간을 나타내는 열거형입니다.
///
/// 영구, 턴 종료까지, 페이즈 종료까지, 특정 턴 수 동안 등의 지속 시간을 정의합니다.
// TODO: 각 Duration에 대한 상세 설명 추가 (턴 종료, 페이즈 종료의 시점 정의)
pub enum Duration {
    Permanent,
    UntilEndOfTurn,
    UntilEndOfPhase,
    ForXTurns(usize),
}

impl CardStatus {
    // 수정자 추가
    pub fn add_modifier(&mut self, modifier: Modifier) {
        self.modifiers.push(modifier);
    }

    // 수정자 제거
    pub fn remove_modifier(&mut self, index: usize) {
        self.modifiers.remove(index);
    }

    // 특정 타입의 수정자 모두 제거
    pub fn remove_modifiers_of_type(&mut self, modifier_type: ModifierType) {
        self.modifiers
            .retain(|m| m.get_modifier_type() != modifier_type);
    }

    // 만료된 수정자 제거
    pub fn cleanup_expired_modifiers(&mut self, game: Addr<GameActor>) {
        todo!()
        // self.modifiers.retain(|modifier| {
        //     !modifier.is_expired(game.get_turn().get_turn_count(), game.get_phase())
        // });
    }

    // 특정 타입의 수정자 총합 계산
    pub fn get_total_modifier(&self, modifier_type: ModifierType) -> i32 {
        self.modifiers
            .iter()
            .filter(|m| m.get_modifier_type() == modifier_type)
            .map(|m| m.get_value())
            .sum()
    }
}

#[derive(Debug, PartialEq, Clone, Eq, Copy, Hash)]
/// `SpellType`은 마법 카드의 종류를 나타내는 열거형입니다.
///
/// SlowSpell, FastSpell 등의 유형을 정의합니다.
// TODO: 각 SpellType에 대한 상세 설명 추가 (발동 조건, 효과 발동 시점 등)
pub enum SpellType {
    SlowSpell,
    FastSpell,
}

#[derive(Eq, PartialEq, Hash, Clone, Copy)]
/// `CardType`은 카드의 종류를 나타내는 열거형입니다.
///
/// Dummy, Unit, Spell, Field, Ace, Trap, Game, Any 등의 유형을 정의합니다.
// TODO: 각 CardType에 대한 상세 설명 추가 (카드 사용 조건, 지속 효과 등)
pub enum CardType {
    Dummy,
    Unit,
    Spell,
    Field,
    Ace,
    Trap,
    Game,
    Any,
}

impl CardType {
    pub fn from_json(json: &CardJson) -> Result<Self, GameError> {
        match &json.r#type {
            Some(type_str) => match type_str.as_str() {
                "Dummy" => Ok(CardType::Dummy),
                "Unit" => Ok(CardType::Unit),
                "Spell" => Ok(CardType::Spell),
                "Field" => Ok(CardType::Field),
                "Ace" => Ok(CardType::Ace),
                "Trap" => Ok(CardType::Trap),
                "Game" => Ok(CardType::Game),
                _ => Err(GameError::Gameplay(GameplayError::InvalidAction {
                    reason: "Invalid card type".to_string(),
                })),
            },
            None => Err(GameError::Gameplay(GameplayError::InvalidAction {
                reason: "Invalid card type".to_string(),
            })),
        }
    }

    // 추가 유틸리티 메서드들
    pub fn to_string(&self) -> &'static str {
        match self {
            CardType::Dummy => "Dummy",
            CardType::Unit => "Unit",
            CardType::Spell => "Spell",
            CardType::Field => "Field",
            CardType::Ace => "Ace",
            CardType::Trap => "Trap",
            CardType::Game => "Game",
            CardType::Any => "Any",
        }
    }

    pub fn is_unit(&self) -> bool {
        matches!(self, CardType::Unit)
    }

    pub fn is_spell(&self) -> bool {
        matches!(self, CardType::Spell)
    }

    pub fn is_field(&self) -> bool {
        matches!(self, CardType::Field)
    }

    pub fn is_trap(&self) -> bool {
        matches!(self, CardType::Trap)
    }
    // 카드 타입별 특성 확인
    pub fn can_be_played_as_action(&self) -> bool {
        matches!(self, CardType::Spell | CardType::Trap)
    }

    pub fn stays_on_field(&self) -> bool {
        matches!(self, CardType::Unit | CardType::Field)
    }

    pub fn is_permanent(&self) -> bool {
        matches!(self, CardType::Field | CardType::Game)
    }

    // 카드 타입별 제한사항
    pub fn max_copies_allowed(&self) -> i32 {
        match self {
            CardType::Ace => 1,
            CardType::Game => 1,
            _ => 3,
        }
    }
}

impl fmt::Display for CardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let s = match self {
            CardType::Dummy => "Dummy",
            CardType::Unit => "Unit",
            CardType::Spell => "Spell",
            CardType::Field => "Field",
            CardType::Ace => "Ace",
            CardType::Trap => "Trap",
            CardType::Game => "Game",
            CardType::Any => "Any",
        };
        write!(f, "{}", s)
    }
}

impl fmt::Debug for CardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Debug 구현 시 Display 구현을 재사용합니다.
        write!(f, "{}", self)
    }
}

#[derive(Copy, Clone)]
/// `StatType`은 스탯의 종류를 나타내는 열거형입니다.
///
/// Attack, Defense 등의 유형을 정의합니다.
// TODO: 각 StatType에 대한 상세 설명 추가 (스탯 계산 방식, 적용 범위 등)
pub enum StatType {
    Attack,
    Defense,
}

///
/// 백엔드을 실행하는건 Host 역할을 부여 받은 플레이어쪽임.
/// 백엔드에서 Host 는 Player1 혹은 Self_ 로 취급되고
/// Client 는 Player2 혹은 Opponent 로 취급함.
///

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OwnerType {
    Self_,    // 자신 (현재 턴 플레이어)
    Opponent, // 상대방
    Any,      // 아무나 (자신 또는 상대)
    None,     // 소유자 없음
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
/// `PlayerKind`는 플레이어의 종류를 나타내는 열거형입니다.
///
/// Player1, Player2 등의 유형을 정의합니다.
pub enum PlayerKind {
    Player1,
    Player2,
}

impl Display for PlayerKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl PlayerKind {
    pub fn as_str(&self) -> &'static str {
        match self {
            PlayerKind::Player1 => "Player1",
            PlayerKind::Player2 => "Player2",
        }
    }

    pub fn to_string(&self) -> String {
        match self {
            PlayerKind::Player1 => "Player1".to_string(),
            PlayerKind::Player2 => "Player2".to_string(),
        }
    }

    pub fn reverse(&self) -> Self {
        match self {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }
}

impl From<String> for PlayerKind {
    fn from(s: String) -> Self {
        match s.as_str() {
            "Player1" => PlayerKind::Player1,
            "Player2" => PlayerKind::Player2,
            _ => panic!("Invalid PlayerKind string"),
        }
    }
}

impl From<PlayerKind> for String {
    fn from(player_kind: PlayerKind) -> Self {
        player_kind.to_string()
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
/// `PlayerIdentity`는 플레이어의 고유 식별 정보를 나타내는 구조체입니다.
///
/// `id`는 플레이어의 UUID이고, `kind`는 플레이어의 종류(`PlayerKind`)입니다.
pub struct PlayerIdentity {
    pub id: Uuid,
    pub kind: PlayerKind,
}

impl Hash for PlayerIdentity {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        self.kind.hash(state);
    }
}
</file>

<file path="simulator_core/src/enums/mod.rs">
use std::fmt::Display;

use serde::{Deserialize, Serialize};
use uuid::Uuid;

pub const CARD_ID_JSON_PATH: &str = "F:/work/simulator/simulator_core/Resource/cards_id.json";
pub const CARD_JSON_PATH: &str = "F:/work/simulator/simulator_core/Resource/cards.json";
pub const DECK_JSON_PATH_P1: &str = "F:/work/simulator/simulator_core/Datas/player1_test.json";
pub const DECK_JSON_PATH_P2: &str = "F:/work/simulator/simulator_core/Datas/player2_test.json";
pub const UUID_GENERATOR_PATH: &str = "F:/work/simulator/simulator_core/Resource/uuidgen";
pub const GAME_CONFIG_JSON_PATH: &str = "F:/work/simulator/simulator_core/Datas/config.json";

#[derive(Clone, Debug, PartialEq, Eq, Hash, Copy, Serialize, Deserialize)]
pub enum ZoneType {
    Hand,
    Deck,
    Graveyard,
    Effect,
    Field,
    None,
}

impl ZoneType {
    pub fn to_string(&self) -> String {
        match self {
            ZoneType::Hand => "Hand".to_string(),
            ZoneType::Deck => "Deck".to_string(),
            ZoneType::Graveyard => "Graveyard".to_string(),
            ZoneType::Effect => "Effect".to_string(),
            ZoneType::Field => "Field".to_string(),
            ZoneType::None => "None".to_string(),
        }
    }
}

impl Display for ZoneType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_string())
    }
}

pub const MAX_CARD_SIZE: usize = 30;

pub type CardsUuid = Vec<Uuid>;

pub const COUNT_OF_CARDS: usize = 30;
pub const COUNT_OF_MULLIGAN_CARDS: usize = 5;
pub const PLAYER_1: usize = 0;
pub const PLAYER_2: usize = 1;

pub const UNIT_ZONE_SIZE: usize = 12;
pub const DECK_ZONE_SIZE: usize = 30;
pub const HAND_ZONE_SIZE: usize = 10;

pub const HEARTBEAT_INTERVAL: u64 = 5;
pub const CLIENT_TIMEOUT: u64 = 30; // 30초 동안 응답 없으면 연결 끊김
</file>

<file path="simulator_core/src/game/phase.rs">
//! phase.rs
//!
//! 게임 시뮬레이터의 핵심 모듈
//! 이 모듈은 game와 관련된 기능을 제공합니다.

use std::collections::HashMap;

use crate::{
    card::types::PlayerKind,
    exception::{GameError, StateError},
};

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum PlayerPhaseProgress {
    NotStarted,         // 아직 해당 페이즈 시작 안 함
    Entered,            // 페이즈에 막 진입했거나 기본적인 작업 대기 중
    ActionTaken,        // 페이즈 내 주요 액션 수행 (예: 드로우 완료, 공격 선언 완료)
    WaitingForOpponent, // 자신의 액션은 끝났고 상대방 대기 중
    Completed,          // 해당 페이즈 완전히 종료 (양쪽 동의)
}

#[derive(Clone)]
pub struct PhaseState {
    current_phase: Phase,
    // 플레이어별 진행 상태 저장
    player_progress: HashMap<PlayerKind, PlayerPhaseProgress>,
}

impl PhaseState {
    pub fn new(phase: Phase) -> Self {
        let mut progress = HashMap::new();
        // 초기 상태는 NotStarted 또는 Entered
        progress.insert(PlayerKind::Player1, PlayerPhaseProgress::NotStarted);
        progress.insert(PlayerKind::Player2, PlayerPhaseProgress::NotStarted);
        Self {
            current_phase: phase,
            player_progress: progress,
        }
    }

    pub fn get_phase(&self) -> Phase {
        self.current_phase
    }

    pub fn set_phase(&mut self, phase: Phase) {
        self.current_phase = phase;
        // 페이즈 전환 시 플레이어 상태 초기화
        self.reset_progress();
    }

    // 플레이어 진행 상태 가져오기
    pub fn get_player_progress(&self, player: PlayerKind) -> PlayerPhaseProgress {
        self.player_progress
            .get(&player)
            .cloned()
            .unwrap_or(PlayerPhaseProgress::NotStarted)
    }

    // 플레이어 진행 상태 업데이트
    pub fn update_player_progress(&mut self, player: PlayerKind, progress: PlayerPhaseProgress) {
        println!("PhaseState Update: Player {:?} -> {:?}", player, progress); // 로그 추가
        self.player_progress.insert(player, progress);
    }

    // 페이즈 전환 시 상태 초기화
    pub fn reset_progress(&mut self) {
        for progress in self.player_progress.values_mut() {
            *progress = PlayerPhaseProgress::Entered; // 새 페이즈는 Entered 상태로 시작
        }
        println!(
            "PhaseState Reset: All players progress set to Entered for phase {:?}",
            self.current_phase
        );
    }

    // 특정 상태인 플레이어가 있는지 확인 (예: 둘 다 Completed 인지)
    pub fn both_players_in_progress(&self, progress: PlayerPhaseProgress) -> bool {
        self.player_progress.len() == 2 && self.player_progress.values().all(|p| *p == progress)
    }
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum PlayerActionStatus {
    NotYetActed,   // 아직 행동하지 않음
    ActedOrPassed, // 행동을 했거나 우선권을 넘김
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum MulliganStatus {
    NotStarted,                  // 시작 전
    DealingInitialHands,         // 초기 패 분배 중
    Player1Deciding(PlayerKind), // P1 멀리건 결정 대기 (현재 턴 플레이어 명시)
    Player2Deciding(PlayerKind), // P2 멀리건 결정 대기 (현재 턴 플레이어 명시)
    ApplyingMulligans,           // 멀리건 적용 중 (카드 교체 등)
    Completed,                   // 멀리건 완료
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum DrawPhaseStatus {
    TurnPlayerDraws, // 턴 플레이어가 드로우
    EffectsTrigger,  // 드로우 시 발동하는 효과 처리
    Completed,
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum StandbyPhaseStatus {
    EffectsTrigger, // 스탠바이 페이즈 시 발동하는 효과 처리
    Completed,
}

// 우선권 구현해야함.
// 우선권이란, 해당 턴에 어떤 플레이어가 먼저 행동할 수 있는지 권리를 나타내는 것.
// 턴 플레이어가 우선권을 가지며, 체인 발생 시 ( 효과 발동 ) / 우선권 포기 시 우선권이 이동함.
#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum MainPhaseStatus {
    OpenState, // 턴 플레이어가 자유롭게 행동 가능 (몬스터 소환, 마법/함정 발동/세트 등)
               // 체인 발생 시, 또는 우선권 이동 시 세부 상태가 더 필요할 수 있음
               // 예: WaitingForChainResponse, ResolvingChain
               // 유희왕은 메인 페이즈 1과 2가 동일한 행동을 할 수 있으므로,
               // MainPhaseStatus를 공유하고, Phase enum에서 MainPhase1, MainPhase2로 구분합니다.
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum BattlePhaseStep {
    StartStep(PlayerActionStatus), // 배틀 페이즈 개시 단계 (턴 플레이어 우선권)
    BattleStep(PlayerActionStatus), // 배틀 스텝 (몬스터 공격 선언 또는 종료)
    DamageStep(DamageStepSubPhase), // 데미지 스텝 (세부 단계로 진입)
    EndStep(PlayerActionStatus),   // 배틀 페이즈 종료 단계
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum DamageStepSubPhase {
    StartOfDamageStep,        // 데미지 스텝 개시시 (공격 대상이 앞면 표시가 됨 등)
    BeforeDamageCalculation,  // 데미지 계산 전 (공/수 증감 효과 발동)
    PerformDamageCalculation, // 데미지 계산 실행
    AfterDamageCalculation,   // 데미지 계산 후 (전투로 파괴된 몬스터 묘지로, 리버스 효과 발동 등)
    EndOfDamageStep,          // 데미지 스텝 종료시 (파괴 확정된 몬스터 묘지로 등)
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum EndPhaseStatus {
    EffectsTrigger, // 엔드 페이즈 시 발동하는 효과 처리
    TurnEnd,        // 실제 턴 종료
}

#[derive(Clone, PartialEq, Eq, Copy, Debug, PartialOrd, Ord)]
pub enum Phase {
    Mulligan(MulliganStatus),

    DrawPhase(DrawPhaseStatus),       // DP: 턴 플레이어가 1장 드로우
    StandbyPhase(StandbyPhaseStatus), // SP: 특정 효과 발동
    MainPhase1(MainPhaseStatus), // MP1: 몬스터 소환/반전소환/특수소환, 마법/함정 발동/세트, 효과 발동, 표시 형식 변경

    BattlePhase(BattlePhaseStep), // BP: 전투 수행
    // BattlePhaseStep enum이 세부 스텝(Start, Battle, Damage, End)을 관리
    MainPhase2(MainPhaseStatus), // MP2: MP1과 동일한 행동 가능 (공격한 몬스터는 표시 형식 변경 불가 등 일부 제약)
    EndPhase(EndPhaseStatus),    // EP: 특정 효과 발동, 턴 종료
}

impl Phase {
    /// 다음 페이즈로 진행합니다.
    /// 현재 턴 플레이어 정보가 필요할 수 있습니다.
    pub fn next(self, _current_turn_player: PlayerKind) -> Self {
        match self {
            Phase::Mulligan(status) => match status {
                MulliganStatus::Completed => Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws),
                _ => self, // 멀리건 내부 상태 진행은 별도 로직으로 처리
            },
            Phase::DrawPhase(status) => match status {
                DrawPhaseStatus::Completed => {
                    Phase::StandbyPhase(StandbyPhaseStatus::EffectsTrigger)
                }
                _ => self,
            },
            Phase::StandbyPhase(status) => match status {
                StandbyPhaseStatus::Completed => Phase::MainPhase1(MainPhaseStatus::OpenState),
                _ => self,
            },
            Phase::MainPhase1(_) => {
                Phase::BattlePhase(BattlePhaseStep::StartStep(PlayerActionStatus::NotYetActed))
            } // MP1에서 BP로 가는 것은 플레이어 선택
            Phase::BattlePhase(step) => match step {
                BattlePhaseStep::EndStep(PlayerActionStatus::ActedOrPassed) => {
                    Phase::MainPhase2(MainPhaseStatus::OpenState)
                }
                // 데미지 스텝의 각 하위 단계 진행은 BattlePhaseStep 내부 로직으로 처리
                _ => self,
            },
            Phase::MainPhase2(_) => Phase::EndPhase(EndPhaseStatus::EffectsTrigger), // MP2에서는 EP로 강제 진행
            Phase::EndPhase(status) => match status {
                EndPhaseStatus::TurnEnd => {
                    // 턴이 실제로 종료되면 다음 플레이어의 드로우 페이즈로 넘어감
                    // 이 때 current_turn_player가 변경되어야 함 (이 함수 외부에서 처리)
                    Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws)
                }
                _ => self,
            },
        }
    }

    // 메인 페이즈에서 엔드 페이즈로 바로 넘어갈 수 있는 경우 (플레이어가 배틀 페이즈 스킵 선택)
    pub fn skip_to_end_phase(self) -> Result<Self, GameError> {
        match self {
            Phase::MainPhase1(_) | Phase::MainPhase2(_) => {
                Ok(Phase::EndPhase(EndPhaseStatus::EffectsTrigger))
            }
            _ => Err(GameError::State(StateError::InvalidPhaseTransition)), // 다른 페이즈에서는 스킵 불가
        }
    }
}

// Display implementations for all Status enums
impl std::fmt::Display for PlayerActionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PlayerActionStatus::NotYetActed => write!(f, "NotYetActed"),
            PlayerActionStatus::ActedOrPassed => write!(f, "ActedOrPassed"),
        }
    }
}

impl std::fmt::Display for MulliganStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MulliganStatus::NotStarted => write!(f, "NotStarted"),
            MulliganStatus::DealingInitialHands => write!(f, "DealingInitialHands"),
            MulliganStatus::Player1Deciding(player) => write!(f, "Player1Deciding_{:?}", player),
            MulliganStatus::Player2Deciding(player) => write!(f, "Player2Deciding_{:?}", player),
            MulliganStatus::ApplyingMulligans => write!(f, "ApplyingMulligans"),
            MulliganStatus::Completed => write!(f, "Completed"),
        }
    }
}

impl std::fmt::Display for DrawPhaseStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DrawPhaseStatus::TurnPlayerDraws => write!(f, "TurnPlayerDraws"),
            DrawPhaseStatus::EffectsTrigger => write!(f, "EffectsTrigger"),
            DrawPhaseStatus::Completed => write!(f, "Completed"),
        }
    }
}

impl std::fmt::Display for StandbyPhaseStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StandbyPhaseStatus::EffectsTrigger => write!(f, "EffectsTrigger"),
            StandbyPhaseStatus::Completed => write!(f, "Completed"),
        }
    }
}

impl std::fmt::Display for MainPhaseStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MainPhaseStatus::OpenState => write!(f, "OpenState"),
        }
    }
}

impl std::fmt::Display for DamageStepSubPhase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DamageStepSubPhase::StartOfDamageStep => write!(f, "StartOfDamageStep"),
            DamageStepSubPhase::BeforeDamageCalculation => write!(f, "BeforeDamageCalculation"),
            DamageStepSubPhase::PerformDamageCalculation => write!(f, "PerformDamageCalculation"),
            DamageStepSubPhase::AfterDamageCalculation => write!(f, "AfterDamageCalculation"),
            DamageStepSubPhase::EndOfDamageStep => write!(f, "EndOfDamageStep"),
        }
    }
}

impl std::fmt::Display for BattlePhaseStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BattlePhaseStep::StartStep(status) => write!(f, "StartStep_{}", status),
            BattlePhaseStep::BattleStep(status) => write!(f, "BattleStep_{}", status),
            BattlePhaseStep::DamageStep(substep) => write!(f, "DamageStep_{}", substep),
            BattlePhaseStep::EndStep(status) => write!(f, "EndStep_{}", status),
        }
    }
}

impl std::fmt::Display for EndPhaseStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EndPhaseStatus::EffectsTrigger => write!(f, "EffectsTrigger"),
            EndPhaseStatus::TurnEnd => write!(f, "TurnEnd"),
        }
    }
}

// Main Phase Display implementation
impl std::fmt::Display for Phase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Phase::Mulligan(status) => write!(f, "Mulligan_{}", status),
            Phase::DrawPhase(status) => write!(f, "DrawPhase_{}", status),
            Phase::StandbyPhase(status) => write!(f, "StandbyPhase_{}", status),
            Phase::MainPhase1(status) => write!(f, "MainPhase1_{}", status),
            Phase::BattlePhase(step) => write!(f, "BattlePhase_{}", step),
            Phase::MainPhase2(status) => write!(f, "MainPhase2_{}", status),
            Phase::EndPhase(status) => write!(f, "EndPhase_{}", status),
        }
    }
}
</file>

<file path="simulator_core/src/game/state.rs">
//! state.rs
//!
//! 게임 시뮬레이터의 핵심 모듈
//! 이 모듈은 game와 관련된 기능을 제공합니다.

use std::collections::HashMap;

use tracing::{error, info, warn};

use crate::{
    card::types::PlayerKind,
    game::phase::{DrawPhaseStatus, Phase},
};

/// 게임의 현재 단계를 나타내는 열거형입니다.
///
/// 게임의 진행 상황을 추적하고, 각 단계에 맞는 로직을 실행하는 데 사용됩니다.
///
/// # 예시
///
/// ```
/// use simulator_core::game::state::GamePhase;
///
/// let current_phase = GamePhase::Mulligan;
///
/// match current_phase {
///     GamePhase::Mulligan => {
///         // 멀리건 단계 처리
///     }
///     _ => {}
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum GamePhase {
    /// 게임이 중단된 상태입니다.
    Aborted,
    /// 게임이 종료 중 입니다.
    Stopping,
    /// 게임이 종료 되었습니다.
    Stopped,
    /// 게임이 이미 취소된 상태입니다.
    AlreadyCancelled,
    /// 예상치 못한 게임 단계입니다.
    UnexpectedGamePhase,
    /// 게임이 초기 상태입니다.
    Initial,
    /// 플레이어들을 기다리는 상태입니다.
    WaitingForPlayers,
    /// 멀리건 단계입니다.
    Mulligan,
    /// 플레이어의 턴입니다. PlayerKind는 플레이어의 종류(Player1, Player2), Phase는 턴의 세부 단계를 나타냅니다.
    PlayerTurn(PlayerKind, Phase),
}

/// 플레이어의 연결 상태를 나타내는 열거형입니다.
///
/// 플레이어가 게임에 연결되었는지 여부를 추적하는 데 사용됩니다.
///
/// # 예시
///
/// ```
/// use simulator_core::game::state::PlayerConnectionStatus;
///
/// let connection_status = PlayerConnectionStatus::Connected;
///
/// if connection_status == PlayerConnectionStatus::Connected {
///     // 플레이어가 연결됨
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PlayerConnectionStatus {
    /// 플레이어가 연결 해제된 상태입니다.
    Disconnected,
    /// 플레이어가 연결된 상태입니다.
    Connected,
}

/// 플레이어의 멀리건 진행 상태를 나타내는 열거형입니다.
///
/// 플레이어가 멀리건을 얼마나 진행했는지 추적하는 데 사용됩니다.
///
/// # 예시
///
/// ```
/// use simulator_core::game::state::PlayerMulliganStatus;
///
/// let mulligan_status = PlayerMulliganStatus::CardsDealt;
///
/// match mulligan_status {
///     PlayerMulliganStatus::CardsDealt => {
///         // 카드 분배 처리
///     }
///     _ => {}
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PlayerMulliganStatus {
    /// 멀리건이 시작되지 않은 상태입니다.
    NotStarted,
    /// 카드 분배가 완료된 상태입니다.
    CardsDealt,
    /// 플레이어의 결정을 기다리는 상태입니다.
    WaitingForDecision,
    /// 멀리건이 완료된 상태입니다.
    Completed,
}

// PlayerState 구조체는 변경 없음
/// 각 플레이어의 상태 정보를 저장하는 구조체입니다.
///
/// 연결 상태, 멀리건 상태 등을 포함합니다.
///
/// # 예시
///
/// ```
/// use simulator_core::game::state::{PlayerState, PlayerConnectionStatus, PlayerMulliganStatus};
///
/// let player_state = PlayerState {
///     connection_status: PlayerConnectionStatus::Connected,
///     mulligan_status: PlayerMulliganStatus::Completed,
/// };
/// ```
#[derive(Debug, Clone)]
pub struct PlayerState {
    /// 플레이어의 연결 상태입니다.
    pub connection_status: PlayerConnectionStatus,
    /// 플레이어의 멀리건 상태입니다.
    pub mulligan_status: PlayerMulliganStatus,
}

impl PlayerState {
    /// 새로운 PlayerState 인스턴스를 생성합니다.
    ///
    /// 기본적으로 연결 해제 상태 및 멀리건 미시작 상태로 초기화됩니다.
    ///
    /// # Returns
    ///
    /// 새로운 PlayerState 인스턴스를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::PlayerState;
    ///
    /// let player_state = PlayerState::new();
    /// assert_eq!(player_state.connection_status, simulator_core::game::state::PlayerConnectionStatus::Disconnected);
    /// assert_eq!(player_state.mulligan_status, simulator_core::game::state::PlayerMulliganStatus::NotStarted);
    /// ```
    fn new() -> Self {
        PlayerState {
            connection_status: PlayerConnectionStatus::Disconnected,
            mulligan_status: PlayerMulliganStatus::NotStarted,
        }
    }
}

/// 게임 상태를 관리하는 구조체입니다.
/// 플레이어 정보, 게임 설정 등을 저장합니다.
///
/// # 예시
///
/// ```
/// use std::collections::HashMap;
/// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerConnectionStatus, PlayerMulliganStatus};
///
/// let mut game_state_manager = GameStateManager::new();
/// game_state_manager.initialize_players();
///
/// assert_eq!(game_state_manager.player_states.len(), 2);
/// ```
// TODO: 상태 관리 방식 개선
// TODO: 불변성 강화
#[derive(Clone)]
pub struct GameStateManager {
    current_phase: GamePhase,
    /// 플레이어 상태를 저장하는 HashMap입니다. PlayerKind를 키로 사용합니다.
    pub player_states: HashMap<PlayerKind, PlayerState>,
}

impl GameStateManager {
    /// 새로운 GameStateManager 인스턴스를 생성합니다.
    ///
    /// 초기 게임 단계를 Initial로 설정하고, 플레이어 상태를 저장할 HashMap을 초기화합니다.
    ///
    /// # Returns
    ///
    /// 새로운 GameStateManager 인스턴스를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, GamePhase};
    ///
    /// let game_state_manager = GameStateManager::new();
    /// assert_eq!(game_state_manager.current_phase(), GamePhase::Initial);
    /// ```
    pub fn new() -> Self {
        Self {
            current_phase: GamePhase::Initial,
            player_states: HashMap::new(),
        }
    }

    /// 플레이어들을 초기화합니다.
    ///
    /// Player1과 Player2에 대한 PlayerState를 생성하고, HashMap에 저장합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind};
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.initialize_players();
    /// assert_eq!(game_state_manager.player_states.len(), 2);
    /// ```
    pub fn initialize_players(&mut self) {
        self.player_states
            .insert(PlayerKind::Player1, PlayerState::new());
        self.player_states
            .insert(PlayerKind::Player2, PlayerState::new());
        info!(
            "GameStateManager initialized for players {:?} and {:?}",
            PlayerKind::Player1,
            PlayerKind::Player2
        );
    }

    /// 현재 게임 단계를 반환합니다.
    ///
    /// # Returns
    ///
    /// 현재 게임 단계를 나타내는 GamePhase 열거형 값을 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, GamePhase};
    ///
    /// let game_state_manager = GameStateManager::new();
    /// assert_eq!(game_state_manager.current_phase(), GamePhase::Initial);
    /// ```
    pub fn current_phase(&self) -> GamePhase {
        self.current_phase.clone()
    }

    /// 연결된 플레이어의 수를 반환합니다.
    ///
    /// # Returns
    ///
    /// 연결된 플레이어의 수를 usize 타입으로 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerConnectionStatus};
    /// use std::collections::HashMap;
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.player_states.insert(PlayerKind::Player1, PlayerState { connection_status: PlayerConnectionStatus::Connected, mulligan_status: simulator_core::game::state::PlayerMulliganStatus::NotStarted });
    /// game_state_manager.player_states.insert(PlayerKind::Player2, PlayerState { connection_status: PlayerConnectionStatus::Disconnected, mulligan_status: simulator_core::game::state::PlayerMulliganStatus::NotStarted });
    ///
    /// assert_eq!(game_state_manager.count_connected_players(), 1);
    /// ```
    pub fn count_connected_players(&self) -> usize {
        self.player_states
            .values()
            .filter(|s| s.connection_status == PlayerConnectionStatus::Connected)
            .count()
    }

    /// 특정 플레이어가 연결되었는지 여부를 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `player_kind` - 확인할 플레이어의 종류 (PlayerKind).
    ///
    /// # Returns
    ///
    /// 플레이어가 연결되어 있으면 true, 그렇지 않으면 false를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerConnectionStatus};
    /// use std::collections::HashMap;
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.player_states.insert(PlayerKind::Player1, PlayerState { connection_status: PlayerConnectionStatus::Connected, mulligan_status: simulator_core::game::state::PlayerMulliganStatus::NotStarted });
    ///
    /// assert_eq!(game_state_manager.is_player_connected(PlayerKind::Player1), true);
    /// assert_eq!(game_state_manager.is_player_connected(PlayerKind::Player2), false);
    /// ```
    pub fn is_player_connected(&self, player_kind: PlayerKind) -> bool {
        self.player_states.get(&player_kind).map_or(false, |s| {
            s.connection_status == PlayerConnectionStatus::Connected
        })
    }

    /// 게임이 아직 시작되지 않았는지(연결 대기 상태인지) 확인합니다.
    pub fn is_in_waiting_phase(&self) -> bool {
        matches!(
            self.current_phase,
            GamePhase::Initial | GamePhase::WaitingForPlayers
        )
    }

    /// 플레이어의 연결 상태를 업데이트합니다.
    ///
    /// # Arguments
    ///
    /// * `player` - 연결 상태를 업데이트할 플레이어의 종류 (PlayerKind).
    /// * `connected` - 연결 여부 (true: 연결됨, false: 연결 해제됨).
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerConnectionStatus};
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.initialize_players();
    /// game_state_manager.update_player_connection_status(PlayerKind::Player1, true);
    /// assert_eq!(game_state_manager.is_player_connected(PlayerKind::Player1), true);
    /// ```
    pub fn update_player_connection_status(&mut self, player: PlayerKind, connected: bool) {
        let new_status = if connected {
            PlayerConnectionStatus::Connected
        } else {
            PlayerConnectionStatus::Disconnected
        };

        if let Some(player_state) = self.player_states.get_mut(&player) {
            if player_state.connection_status != new_status {
                info!(
                    "Player {:?} connection status changed from {:?} to {:?}",
                    player, player_state.connection_status, new_status
                );
                player_state.connection_status = new_status;
            } else {
                warn!(
                    "Player {:?} connection status already {:?}. No change.",
                    player, new_status
                );
            }
        } else {
            error!(
                "Attempted to update connection status for an uninitialized player: {:?}",
                player
            );
            return;
        }

        if connected && self.current_phase == GamePhase::Initial && self.is_all_players_connected()
        {
            self.transition_to_phase(GamePhase::Mulligan);
        }
    }

    /// 모든 플레이어가 연결되었는지 확인합니다.
    ///
    /// # Returns
    ///
    /// 모든 플레이어가 연결되었으면 true, 그렇지 않으면 false를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerConnectionStatus};
    /// use std::collections::HashMap;
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.player_states.insert(PlayerKind::Player1, PlayerState { connection_status: PlayerConnectionStatus::Connected, mulligan_status: simulator_core::game::state::PlayerMulliganStatus::NotStarted });
    /// game_state_manager.player_states.insert(PlayerKind::Player2, PlayerState { connection_status: PlayerConnectionStatus::Connected, mulligan_status: simulator_core::game::state::PlayerMulliganStatus::NotStarted });
    ///
    /// assert_eq!(game_state_manager.is_all_players_connected(), true);
    /// ```
    pub fn is_all_players_connected(&self) -> bool {
        // player_states에 두 플레이어가 모두 있고, 둘 다 Connected 상태인지 확인
        self.player_states.len() == 2
            && self
                .player_states
                .values()
                .all(|s| s.connection_status == PlayerConnectionStatus::Connected)
    }

    /// 게임 단계를 변경합니다.
    ///
    /// # Arguments
    ///
    /// * `new_phase` - 변경할 새로운 게임 단계 (GamePhase).
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, GamePhase};
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.transition_to_phase(GamePhase::Mulligan);
    /// assert_eq!(game_state_manager.current_phase(), GamePhase::Mulligan);
    /// ```
    pub fn transition_to_phase(&mut self, new_phase: GamePhase) {
        info!(
            "Game phase transitioning from {:?} to {:?}",
            self.current_phase, new_phase
        );
        self.current_phase = new_phase.clone();

        // 새 페이즈에 따른 플레이어 상태 초기화 등 추가 로직
        match new_phase {
            GamePhase::Mulligan => {
                for state in self.player_states.values_mut() {
                    // 이미 멀리건을 완료한 플레이어의 상태는 초기화하지 않도록 방어 코드 추가 가능
                    if state.mulligan_status != PlayerMulliganStatus::Completed {
                        state.mulligan_status = PlayerMulliganStatus::NotStarted;
                    }
                }
            }
            // 다른 페이즈 전환 시 필요한 초기화 로직 추가
            _ => {}
        }
    }

    /// 플레이어의 멀리건 상태를 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `player` - 멀리건 상태를 확인할 플레이어의 종류 (PlayerKind).
    ///
    /// # Returns
    ///
    /// 플레이어의 멀리건 상태를 나타내는 PlayerMulliganStatus 열거형 값의 Option을 반환합니다.
    /// 플레이어가 존재하지 않으면 None을 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerMulliganStatus};
    /// use std::collections::HashMap;
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.player_states.insert(PlayerKind::Player1, PlayerState { connection_status: simulator_core::game::state::PlayerConnectionStatus::Disconnected, mulligan_status: PlayerMulliganStatus::Completed });
    ///
    /// assert_eq!(game_state_manager.get_player_mulligan_status(PlayerKind::Player1), Some(PlayerMulliganStatus::Completed));
    /// assert_eq!(game_state_manager.get_player_mulligan_status(PlayerKind::Player2), None);
    /// ```
    pub fn get_player_mulligan_status(&self, player: PlayerKind) -> Option<PlayerMulliganStatus> {
        self.player_states
            .get(&player)
            .map(|s| s.mulligan_status.clone())
    }

    /// 플레이어의 연결 상태를 반환합니다.
    ///
    /// # Arguments
    ///
    /// * `player` - 연결 상태를 확인할 플레이어의 종류 (PlayerKind).
    ///
    /// # Returns
    ///
    /// 플레이어의 연결 상태를 나타내는 PlayerConnectionStatus 열거형 값의 Option을 반환합니다.
    /// 플레이어가 존재하지 않으면 None을 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerConnectionStatus};
    /// use std::collections::HashMap;
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.player_states.insert(PlayerKind::Player1, PlayerState { connection_status: PlayerConnectionStatus::Connected, mulligan_status: simulator_core::game::state::PlayerMulliganStatus::NotStarted });
    ///
    /// assert_eq!(game_state_manager.get_player_connection_status(PlayerKind::Player1), Some(PlayerConnectionStatus::Connected));
    /// assert_eq!(game_state_manager.get_player_connection_status(PlayerKind::Player2), None);
    /// ```
    pub fn get_player_connection_status(
        &self,
        player: PlayerKind,
    ) -> Option<PlayerConnectionStatus> {
        self.player_states
            .get(&player)
            .map(|s| s.connection_status.clone())
    }

    /// 플레이어의 멀리건 상태를 업데이트합니다.
    ///
    /// # Arguments
    ///
    /// * `player` - 멀리건 상태를 업데이트할 플레이어의 종류 (PlayerKind).
    /// * `new_status` - 업데이트할 새로운 멀리건 상태 (PlayerMulliganStatus).
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerMulliganStatus};
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.initialize_players();
    /// game_state_manager.update_player_mulligan_status(PlayerKind::Player1, PlayerMulliganStatus::Completed);
    /// assert_eq!(game_state_manager.get_player_mulligan_status(PlayerKind::Player1), Some(PlayerMulliganStatus::Completed));
    /// ```
    pub fn update_player_mulligan_status(
        &mut self,
        player: PlayerKind,
        new_status: PlayerMulliganStatus,
    ) {
        if let Some(state) = self.player_states.get_mut(&player) {
            info!(
                "Player {:?} mulligan status updated from {:?} to {:?}",
                player, state.mulligan_status, new_status
            );
            state.mulligan_status = new_status;

            // 두 플레이어 모두 멀리건 완료 시 다음 단계로 전환
            if state.mulligan_status == PlayerMulliganStatus::Completed
                && self.all_players_mulligan_completed()
            {
                self.transition_to_phase(GamePhase::PlayerTurn(
                    PlayerKind::Player1, // 선공 플레이어 정보 필요
                    Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws),
                ));
            }
        }
    }

    /// 모든 플레이어가 멀리건을 완료했는지 확인합니다.
    ///
    /// # Returns
    ///
    /// 모든 플레이어가 멀리건을 완료했으면 true, 그렇지 않으면 false를 반환합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::state::{GameStateManager, PlayerKind, PlayerState, PlayerMulliganStatus};
    /// use std::collections::HashMap;
    ///
    /// let mut game_state_manager = GameStateManager::new();
    /// game_state_manager.player_states.insert(PlayerKind::Player1, PlayerState { connection_status: simulator_core::game::state::PlayerConnectionStatus::Disconnected, mulligan_status: PlayerMulliganStatus::Completed });
    /// game_state_manager.player_states.insert(PlayerKind::Player2, PlayerState { connection_status: simulator_core::game::state::PlayerConnectionStatus::Disconnected, mulligan_status: PlayerMulliganStatus::Completed });
    ///
    /// assert_eq!(game_state_manager.all_players_mulligan_completed(), true);
    /// ```
    fn all_players_mulligan_completed(&self) -> bool {
        self.player_states.len() == 2
            && self
                .player_states
                .values()
                .all(|s| s.mulligan_status == PlayerMulliganStatus::Completed)
    }
}
</file>

<file path="simulator_core/src/game/turn.rs">
//! turn.rs
//! 
//! 게임 시뮬레이터의 핵심 모듈
//! 이 모듈은 game와 관련된 기능을 제공합니다.

use crate::card::types::PlayerKind;

use super::phase::{DrawPhaseStatus, MulliganStatus, Phase, PlayerActionStatus};

/// `TurnState` 구조체는 게임 턴의 상태를 나타냅니다.
///
/// 이 구조체는 현재 턴 플레이어, 우선권 소유자, 턴 카운트, 현재 페이즈,
/// 각 플레이어의 행동 상태를 포함합니다. 게임 턴의 진행과 관련된 모든 정보를 관리합니다.
///
/// # Examples
///
/// ```
/// use simulator_core::game::turn::TurnState;
/// use simulator_core::card::types::PlayerKind;
/// use simulator_core::game::phase::{Phase, MulliganStatus, PlayerActionStatus};
///
/// let mut turn_state = TurnState::new(PlayerKind::Player1);
/// assert_eq!(turn_state.current_turn_plyaer, PlayerKind::Player1);
/// assert_eq!(turn_state.turn_count, 1);
/// assert_eq!(turn_state.current_phase, Phase::Mulligan(MulliganStatus::NotStarted));
/// ```
#[derive(Debug, PartialEq)]
pub struct TurnState {
    /// 현재 턴 플레이어
    pub current_turn_plyaer: PlayerKind,
    /// 현재 우선권 소유자
    pub priority_holder: PlayerKind,
    /// 턴 카운트
    pub turn_count: usize,
    /// 현재 페이즈
    pub current_phase: Phase,
    /// 턴 플레이어의 행동 상태
    pub turn_player_action_status: PlayerActionStatus,
    /// 턴이 아닌 플레이어의 행동 상태
    pub non_turn_player_action_status: PlayerActionStatus,
}

impl TurnState {
    /// 새로운 `TurnState` 인스턴스를 생성합니다.
    ///
    /// 초기 턴 플레이어, 턴 카운트, 초기 페이즈, 우선권 소유자를 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `starting_player` - 게임을 시작하는 플레이어 (`PlayerKind::Player1` 또는 `PlayerKind::Player2`)
    ///
    /// # Returns
    ///
    /// * `TurnState` - 새로운 `TurnState` 인스턴스
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let turn_state = TurnState::new(PlayerKind::Player1);
    /// assert_eq!(turn_state.current_turn_plyaer, PlayerKind::Player1);
    /// assert_eq!(turn_state.turn_count, 1);
    /// ```
    pub fn new(starting_player: PlayerKind) -> Self {
        // 초기 페이즈 (예: 멀리건 또는 드로우 페이즈) 설정
        let initial_phase = Phase::Mulligan(MulliganStatus::NotStarted); // 혹은 DrawPhase
        Self {
            current_turn_plyaer: starting_player,
            turn_count: 1, // 또는 0에서 시작
            current_phase: initial_phase,
            priority_holder: starting_player, // 턴 시작 시 턴 플레이어가 우선권을 가짐
            turn_player_action_status: PlayerActionStatus::NotYetActed,
            non_turn_player_action_status: PlayerActionStatus::NotYetActed,
        }
    }

    /// 우선권을 상대방에게 넘깁니다.
    ///
    /// 현재 우선권을 가진 플레이어의 상태를 `ActedOrPassed`로 변경하고,
    /// 우선권을 상대방에게 넘깁니다. 상대방의 행동 상태를 `NotYetActed`로 초기화합니다.
    /// 양쪽 모두 `ActedOrPassed` 상태면 `attempt_to_advance_phase_or_step` 함수를 호출합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    /// use simulator_core::game::phase::{Phase, MulliganStatus, PlayerActionStatus};
    ///
    /// let mut turn_state = TurnState::new(PlayerKind::Player1);
    /// turn_state.pass_priority();
    /// assert_eq!(turn_state.priority_holder, PlayerKind::Player2);
    /// ```
    pub fn pass_priority(&mut self) {
        // 현재 우선권 가진 플레이어의 상태를 ActedOrPassed로 변경
        if self.priority_holder == self.current_turn_plyaer {
            self.turn_player_action_status = PlayerActionStatus::ActedOrPassed;
        } else {
            self.non_turn_player_action_status = PlayerActionStatus::ActedOrPassed;
        }

        // 우선권을 상대방에게 넘김
        self.priority_holder = self.priority_holder.reverse();

        // 상대방의 행동 상태를 NotYetActed로 초기화 (새로 우선권을 받았으므로)
        if self.priority_holder == self.current_turn_plyaer {
            self.turn_player_action_status = PlayerActionStatus::NotYetActed;
        } else {
            self.non_turn_player_action_status = PlayerActionStatus::NotYetActed;
        }

        // 양쪽 모두 ActedOrPassed 상태면 페이즈/스텝 진행 로직 호출 가능
        if self.turn_player_action_status == PlayerActionStatus::ActedOrPassed
            && self.non_turn_player_action_status == PlayerActionStatus::ActedOrPassed
        {
            // 여기서 다음 페이즈/스텝으로 진행하거나,
            // 또는 이 함수를 호출한 곳에서 이 상태를 확인하고 진행 로직을 실행
            self.attempt_to_advance_phase_or_step();
        }
    }

    /// 플레이어가 행동을 했을 때 호출됩니다 (예: 카드 발동).
    ///
    /// TODO: 플레이어가 행동을 했을 때 필요한 로직을 구현해야 합니다.
    /// 현재는 `todo!()` 매크로로 표시되어 있습니다.
    ///
    /// # Arguments
    ///
    /// * `acting_player` - 행동을 한 플레이어 (`PlayerKind::Player1` 또는 `PlayerKind::Player2`)
    pub fn player_acted(&mut self, acting_player: PlayerKind) {
        todo!()
        // self.pass_priority();
    }

    /// 페이즈/스텝 자동 진행을 시도합니다 (양쪽 플레이어가 모두 행동을 마쳤을 때).
    ///
    /// TODO: 페이즈/스텝 자동 진행에 필요한 로직을 구현해야 합니다.
    /// 현재는 `todo!()` 매크로로 표시되어 있습니다.
    fn attempt_to_advance_phase_or_step(&mut self) {
        todo!()
    }

    /// 다음 턴으로 넘어갑니다.
    ///
    /// 현재 턴 플레이어를 변경하고, 턴 카운트를 증가시키고, 현재 페이즈를 드로우 페이즈로 변경하고,
    /// 우선권 소유자를 현재 턴 플레이어로 설정하고, 각 플레이어의 행동 상태를 초기화합니다.
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    /// use simulator_core::game::phase::{Phase, DrawPhaseStatus, MulliganStatus, PlayerActionStatus};
    ///
    /// let mut turn_state = TurnState::new(PlayerKind::Player1);
    /// turn_state.advance_turn();
    /// assert_eq!(turn_state.current_turn_plyaer, PlayerKind::Player2);
    /// assert_eq!(turn_state.turn_count, 2);
    /// assert_eq!(turn_state.current_phase, Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws));
    /// ```
    pub fn advance_turn(&mut self) {
        self.current_turn_plyaer = self.current_turn_plyaer.reverse();
        self.turn_count += 1;
        self.current_phase = Phase::DrawPhase(DrawPhaseStatus::TurnPlayerDraws);
        self.priority_holder = self.current_turn_plyaer;
        self.turn_player_action_status = PlayerActionStatus::NotYetActed;
        self.non_turn_player_action_status = PlayerActionStatus::NotYetActed;
    }
}

impl TurnState {
    /// 현재 턴 카운트를 반환합니다.
    ///
    /// # Returns
    ///
    /// * `usize` - 현재 턴 카운트
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let turn_state = TurnState::new(PlayerKind::Player1);
    /// assert_eq!(turn_state.get_turn_count(), 1);
    /// ```
    pub fn get_turn_count(&self) -> usize {
        self.turn_count
    }

    /// 턴 카운트를 1 증가시키고, 증가된 턴 카운트를 반환합니다.
    ///
    /// # Returns
    ///
    /// * `usize` - 증가된 턴 카운트
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let mut turn_state = TurnState::new(PlayerKind::Player1);
    /// let new_turn_count = turn_state.increase_turn_count();
    /// assert_eq!(new_turn_count, 2);
    /// assert_eq!(turn_state.get_turn_count(), 2);
    /// ```
    pub fn increase_turn_count(&mut self) -> usize {
        self.turn_count += 1;
        self.turn_count
    }

    /// 현재 턴 플레이어를 반환합니다.
    ///
    /// # Returns
    ///
    /// * `PlayerKind` - 현재 턴 플레이어 (`PlayerKind::Player1` 또는 `PlayerKind::Player2`)
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let turn_state = TurnState::new(PlayerKind::Player1);
    /// assert_eq!(turn_state.current_turn(), PlayerKind::Player1);
    /// ```
    pub fn current_turn(&self) -> PlayerKind {
        self.current_turn_plyaer
    }

    /// 현재 턴 플레이어를 변경하고, 변경된 턴 플레이어를 반환합니다.
    ///
    /// 현재 턴 플레이어가 `PlayerKind::Player1`이면 `PlayerKind::Player2`로,
    /// `PlayerKind::Player2`이면 `PlayerKind::Player1`로 변경합니다.
    ///
    /// # Returns
    ///
    /// * `PlayerKind` - 변경된 턴 플레이어 (`PlayerKind::Player1` 또는 `PlayerKind::Player2`)
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let mut turn_state = TurnState::new(PlayerKind::Player1);
    /// let new_turn_player = turn_state.change_turn();
    /// assert_eq!(new_turn_player, PlayerKind::Player2);
    /// assert_eq!(turn_state.current_turn(), PlayerKind::Player2);
    /// ```
    pub fn change_turn(&mut self) -> PlayerKind {
        self.current_turn_plyaer = match self.current_turn_plyaer {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        };
        self.current_turn_plyaer
    }

    /// 현재 턴이 플레이어 1의 턴인지 확인합니다.
    ///
    /// # Returns
    ///
    /// * `bool` - 현재 턴이 플레이어 1의 턴이면 `true`, 그렇지 않으면 `false`
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let turn_state = TurnState::new(PlayerKind::Player1);
    /// assert_eq!(turn_state.is_player_turn(), true);
    /// ```
    pub fn is_player_turn(&self) -> bool {
        self.current_turn_plyaer == PlayerKind::Player1
    }

    /// 현재 턴이 상대방의 턴인지 확인합니다.
    ///
    /// # Returns
    ///
    /// * `bool` - 현재 턴이 상대방의 턴이면 `true`, 그렇지 않으면 `false`
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let turn_state = TurnState::new(PlayerKind::Player1);
    /// assert_eq!(turn_state.is_opponent_turn(), false);
    /// ```
    pub fn is_opponent_turn(&self) -> bool {
        self.current_turn_plyaer == PlayerKind::Player2
    }

    /// 현재 턴 플레이어의 상대방을 반환합니다.
    ///
    /// # Returns
    ///
    /// * `PlayerKind` - 현재 턴 플레이어의 상대방 (`PlayerKind::Player1` 또는 `PlayerKind::Player2`)
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let turn_state = TurnState::new(PlayerKind::Player1);
    /// assert_eq!(turn_state.get_opponent_turn(), PlayerKind::Player2);
    /// ```
    pub fn get_opponent_turn(&self) -> PlayerKind {
        match self.current_turn_plyaer {
            PlayerKind::Player1 => PlayerKind::Player2,
            PlayerKind::Player2 => PlayerKind::Player1,
        }
    }

    /// 특정 플레이어의 턴으로 강제 설정합니다.
    ///
    /// # Arguments
    ///
    /// * `player` - 설정할 턴 플레이어 (`PlayerKind::Player1` 또는 `PlayerKind::Player2`)
    ///
    /// # Examples
    ///
    /// ```
    /// use simulator_core::game::turn::TurnState;
    /// use simulator_core::card::types::PlayerKind;
    ///
    /// let mut turn_state = TurnState::new(PlayerKind::Player1);
    /// turn_state.set_turn(PlayerKind::Player2);
    /// assert_eq!(turn_state.current_turn(), PlayerKind::Player2);
    /// ```
    pub fn set_turn(&mut self, player: PlayerKind) {
        self.current_turn_plyaer = player;
    }
}
</file>

<file path="simulator_core/src/player/mod.rs">
use actix::{Actor, Addr, Context};
use tracing::{debug, instrument};
use uuid::Uuid;

use crate::{
    card::{cards::Cards, take::TopTake, types::PlayerKind, Card},
    enums::ZoneType,
    exception::GameError,
    selector::{mulligan::MulliganState, TargetCount},
    utils::deckcode_to_cards_single,
    zone::{
        deck::Deck, effect::Effect, field::Field, graveyard::Graveyard, hand::Hand, zone::Zone,
    },
};

pub mod message;

/// 플레이어의 소모 가능한 자원 (마나, 코스트 등)을 관리하는 구조체
#[derive(Clone, Debug)]
pub struct Resoruce {
    current: i32,  // 현재 보유량
    max: i32,      // 최대 보유 가능량
    per_turn: i32, // 턴당 자동 충전량
}

impl Resoruce {
    /// 새로운 자원 생성
    /// current: 현재 보유량, max: 최대 보유량
    pub fn new(current: i32, max: i32) -> Self {
        Self {
            current,
            max,
            per_turn: 1, // 기본값: 턴당 1씩 충전
        }
    }

    /// 턴당 충전량을 설정한 자원 생성
    pub fn new_with_per_turn(current: i32, max: i32, per_turn: i32) -> Self {
        Self {
            current,
            max,
            per_turn,
        }
    }

    /// 현재 보유량 반환
    pub fn get_current(&self) -> i32 {
        self.current
    }

    /// 최대 보유량 반환
    pub fn get_max(&self) -> i32 {
        self.max
    }

    /// 턴당 충전량 반환
    pub fn get_per_turn(&self) -> i32 {
        self.per_turn
    }

    /// 자원 소모 (성공 여부 반환)
    pub fn spend(&mut self, amount: i32) -> bool {
        if self.current >= amount {
            self.current -= amount;
            true
        } else {
            false
        }
    }

    /// 자원 소모 가능 여부 확인
    pub fn can_spend(&self, amount: i32) -> bool {
        self.current >= amount
    }

    /// 자원 충전 (최대값 초과 불가)
    pub fn refill(&mut self, amount: i32) {
        self.current = (self.current + amount).min(self.max);
    }

    /// 턴 시작시 자동 충전
    pub fn turn_refill(&mut self) {
        self.refill(self.per_turn);
    }

    /// 최대값 증가 (마나 크리스탈 증가 등)
    pub fn increase_max(&mut self, amount: i32) {
        self.max += amount;
        // 최대값 증가시 현재값도 증가 (하스스톤 스타일)
        self.current += amount;
    }

    /// 자원 완전 충전
    pub fn full_refill(&mut self) {
        self.current = self.max;
    }

    /// 현재 자원이 비어있는지 확인
    pub fn is_empty(&self) -> bool {
        self.current <= 0
    }

    /// 현재 자원이 가득 찬지 확인
    pub fn is_full(&self) -> bool {
        self.current >= self.max
    }

    /// 현재 자원 직접 설정 (최대값 초과 불가)
    pub fn set_current(&mut self, amount: i32) {
        self.current = amount.clamp(0, self.max);
    }

    /// 최대값 직접 설정
    pub fn set_max(&mut self, max: i32) {
        self.max = max;
        // 현재값이 새로운 최대값을 초과하면 조정
        if self.current > self.max {
            self.current = self.max;
        }
    }

    /// 턴당 충전량 설정
    pub fn set_per_turn(&mut self, per_turn: i32) {
        self.per_turn = per_turn;
    }
}

pub struct PlayerActor {
    pub opponent: Option<Addr<PlayerActor>>,
    pub player_type: PlayerKind,
    pub mulligan_state: MulliganState,
    pub cards: Cards,
    pub cost: Resoruce,
    pub mana: Resoruce,
    pub health: i32,

    pub hand: Hand,
    pub deck: Deck,
    pub graveyard: Graveyard,
    pub effect: Effect,
    pub field: Field,
}

impl Actor for PlayerActor {
    type Context = Context<Self>;
}

impl PlayerActor {
    pub fn new(player_type: PlayerKind, deck_code: String) -> Self {
        let cards = deckcode_to_cards_single(deck_code).unwrap();
        Self {
            player_type,
            opponent: None,
            mulligan_state: MulliganState::new(),
            cards: cards.clone(),
            cost: Resoruce::new(0, 0), // 코스트는 보통 카드별로 다르므로 0으로 시작
            mana: Resoruce::new(1, 1), // 게임 시작시 마나 1/1으로 시작 (하스스톤 스타일)
            hand: Hand::new(),
            deck: Deck::new(cards),
            graveyard: Graveyard::new(),
            effect: Effect::new(),
            field: Field::new(),
            // TODO: Player Health 를 정확히 구현해야함.
            health: 20,
        }
    }

    pub fn restore_cards(&mut self, card: &[Card], target_zone: ZoneType) -> Result<(), GameError> {
        match target_zone {
            ZoneType::Hand => todo!(),
            ZoneType::Deck => todo!(),
            ZoneType::Graveyard => todo!(),
            ZoneType::Effect => todo!(),
            ZoneType::Field => todo!(),
            ZoneType::None => todo!(),
        }
    }

    pub fn get_cards_by_uuids(&self, uuids: &[Uuid]) -> Result<Vec<Card>, GameError> {
        todo!()
    }

    #[instrument(skip(self), fields(player_type = ?player_type.into()))]
    pub fn get_new_mulligan_cards<T: Into<PlayerKind> + Copy>(
        &mut self,
        player_type: T,
        count: usize,
    ) -> Result<Vec<Uuid>, GameError> {
        let player_type = player_type.into();
        debug!(
            "멀리건 카드 뽑기 시도: player={:?}, count={}",
            player_type, count
        );

        let take_result = self
            .deck
            .take_card(Box::new(TopTake(TargetCount::Exact(count))))?;

        let uuids = take_result
            .iter()
            .map(|card| card.get_uuid())
            .collect::<Vec<_>>();

        debug!(
            "멀리건 카드 뽑기 완료: player={:?}, card_count={}",
            player_type,
            uuids.len()
        );

        Ok(uuids)
    }

    pub fn get_cards_mut(&mut self) -> &mut Cards {
        &mut self.cards
    }

    pub fn get_cards(&self) -> &Cards {
        &self.cards
    }
}

//         #[instrument(skip(self), fields(player_type = ?player_type.into()))]
//         pub fn add_select_cards<T: Into<PlayerType> + Copy>(
//             &mut self,
//             cards: Vec<Uuid>,
//             player_type: T,
//         ) {
//             let player_type = player_type.into();
//             debug!(
//                 "멀리건 상태에 카드 추가 시작: player={:?}, cards={:?}",
//                 player_type, cards
//             );

//             let mut player = self.get_player_by_type(player_type).get();

//             player
//                 .get_mulligan_state_mut()
//                 .add_select_cards(cards.clone());
//             debug!("멀리건 상태에 카드 추가 완료: player={:?}", player_type);
//         }

//         pub fn add_reroll_cards<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//             payload_cards: Vec<Uuid>,
//             rerolled_cards: Vec<Uuid>,
//         ) {
//             let player_type = player_type.into();
//             debug!("선택 카드 제거: player={:?}", player_type);
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .remove_select_cards(payload_cards);

//             debug!("리롤된 카드 추가: player={:?}", player_type);
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .add_select_cards(rerolled_cards);
//         }

//         pub fn reroll_request<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//             cards: Vec<Uuid>,
//         ) -> Result<Vec<Uuid>, GameError> {
//             let player_type = player_type.into();
//             // 플레이어가 이미 준비 상태인 경우
//             if self
//                 .get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .is_ready()
//             {
//                 warn!("플레이어가 이미 준비 상태: player={:?}", player_type);
//                 return Err(GameError::AlreadyReady);
//                 // try_send_error!(session, GameError::AlreadyReady, retry 3);
//             }

//             // 플레이어가 선택한 카드가 유효한지 확인합니다.
//             debug!("선택한 카드 유효성 검사: player={:?}", player_type);
//             if let Err(e) = self.get_cards_by_uuids(cards.clone()) {
//                 error!("유효하지 않은 카드 선택: player={:?}", player_type);
//                 return Err(e);
//             }

//             // 기존 카드를 덱의 최하단에 위치 시킨 뒤, 새로운 카드를 뽑아서 player 의 mulligan cards 에 저장하고 json 으로 변환하여 전송합니다.
//             info!("카드 리롤 시작: player={:?}", player_type);
//             let rerolled_card = match self.restore_then_reroll_mulligan_cards(player_type, cards) {
//                 Ok(cards) => {
//                     debug!("카드 리롤 성공: card_count={}", cards.len());
//                     cards
//                 }
//                 Err(e) => {
//                     error!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
//                     panic!("카드 리롤 실패: player={:?}, error={:?}", player_type, e);
//                 }
//             };

//             Ok(rerolled_card)
//         }

//         /// 멀리건 완료 처리 함수
//         /// - 게임 객체를 받아서, 플레이어의 멀리건 상태를 완료로 변경하고, 선택한 카드들을 손으로 이동시킵니다.
//         /// - 선택한 카드들의 UUID를 반환합니다.
//         /// # Arguments
//         /// * `game` - 게임 객체
//         /// * `player_type` - 플레이어 타입
//         /// # Returns
//         /// * `Vec<Uuid>` - 선택한 카드들의 UUID

//         pub fn process_mulligan_completion<T: Into<PlayerType> + Copy>(
//             &mut self,
//             player_type: T,
//         ) -> Result<Vec<Uuid>, GameError> {
//             let player_type = player_type.into();

//             // 선택된 멀리건 카드들의 UUID 를 얻습니다.
//             let selected_cards = self
//                 .get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .get_select_cards();

//             // UUID -> Card 객체로 변환하는 과정입니다.
//             let cards = self.get_cards_by_uuids(selected_cards.clone())?;

//             // add_card 함수를 통해 선택된 카드들을 손으로 이동시킵니다.
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_hand_mut()
//                 .add_card(cards, Box::new(TopInsert))
//                 .map_err(|_| GameError::InternalServerError)?;

//             // 멀리건 상태를 "완료" 상태로 변경합니다.
//             self.get_player_by_type(player_type)
//                 .get()
//                 .get_mulligan_state_mut()
//                 .confirm_selection();

//             // 그런 뒤, 선택한 카드들을 반환합니다.
//             Ok(selected_cards)
//         }

//         pub fn check_player_ready_state<T: Into<PlayerType> + Copy>(&self, player_type: T) -> bool {
//             let player_type = player_type.into();
//             self.get_player_by_type(player_type.reverse())
//                 .get()
//                 .get_mulligan_state_mut()
//                 .is_ready()
//         }
//     }
// }
</file>

<file path="simulator_core/src/exception/mod.rs">
// In: simulator_core/src/exception/mod.rs

use crate::card::types::PlayerKind;
use actix::MailboxError;
use actix_web::{http::StatusCode, HttpResponse, ResponseError};
use std::fmt;
use uuid::Uuid;

// ===================================================================
// 1. 세분화된 에러 타입을 정의합니다.
// ===================================================================

/// 시스템 레벨의 에러 (네트워크, I/O, 내부 로직 등)
#[derive(Debug)]
pub enum SystemError {
    Io(std::io::Error),
    Json(serde_json::Error),
    Mailbox(MailboxError),
    LockFailed(String),
    TaskFailed(String),
    Internal(String), // 예기치 못한 내부 로직 에러
}

/// 게임 상태와 관련된 에러
#[derive(Debug, PartialEq, Clone)]
pub enum StateError {
    InvalidPhaseTransition,
    InvalidActionForPhase {
        current_phase: String,
        action: String,
    },
    GameAlreadyOver,
    GameAborted,
    PlayerNotReady(PlayerKind),
}

/// 클라이언트 연결 및 인증과 관련된 에러
#[derive(Debug, PartialEq, Clone)]
pub enum ConnectionError {
    AuthenticationFailed(String),
    SessionExists(Uuid), // 이미 세션이 존재하는 플레이어 ID
    InvalidPayload(String),
}

/// 게임 플레이 규칙과 관련된 에러
#[derive(Debug, PartialEq, Clone)]
pub enum GameplayError {
    ResourceNotFound {
        kind: &'static str,
        id: String,
    },
    DeckError(DeckError),
    InvalidTarget {
        reason: String,
    },
    InvalidAction {
        reason: String,
    },
    ChainError {
        reason: String,
    },
    NotEnoughResources {
        resource: &'static str,
        needed: i32,
        available: i32,
    },
}

/// 덱 구성 및 처리 관련 에러
#[derive(Debug, PartialEq, Clone)]
pub enum DeckError {
    ParseFailed(String),
    CodeMissingFor(PlayerKind),
    ExceededCardLimit(String),
    NoCardsLeftToDraw,
}

// ===================================================================
// 2. 최상위 GameError Enum을 새롭게 정의합니다.
// ===================================================================

#[derive(Debug)]
pub enum GameError {
    System(SystemError),
    Connection(ConnectionError),
    State(StateError),
    Gameplay(GameplayError),
}

// ===================================================================
// 3. Display 트레이트를 구현하여 명확한 로그 메시지를 생성합니다.
// ===================================================================

// 각 하위 에러 타입에 대한 Display 구현
impl fmt::Display for SystemError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SystemError::Io(e) => write!(f, "System I/O error: {}", e),
            SystemError::Json(e) => write!(f, "System JSON processing error: {}", e),
            SystemError::Mailbox(e) => write!(f, "Actor mailbox error: {}", e),
            SystemError::LockFailed(name) => write!(f, "Failed to acquire lock on '{}'", name),
            SystemError::TaskFailed(name) => write!(f, "Async task '{}' failed to complete", name),
            SystemError::Internal(msg) => write!(f, "Internal server error: {}", msg),
        }
    }
}

impl fmt::Display for StateError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            StateError::InvalidPhaseTransition => {
                write!(f, "Invalid game phase transition attempted")
            }
            StateError::InvalidActionForPhase {
                current_phase,
                action,
            } => write!(
                f,
                "Action '{}' is not allowed during phase '{}'",
                action, current_phase
            ),
            StateError::GameAlreadyOver => {
                write!(f, "Action attempted but the game is already over")
            }
            StateError::GameAborted => write!(f, "Action attempted but the game was aborted"),
            StateError::PlayerNotReady(pk) => {
                write!(f, "Player {:?} is not ready for the action", pk)
            }
        }
    }
}

impl fmt::Display for ConnectionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConnectionError::AuthenticationFailed(reason) => {
                write!(f, "Authentication failed: {}", reason)
            }
            ConnectionError::SessionExists(player_id) => write!(
                f,
                "An active session already exists for player {}",
                player_id
            ),
            ConnectionError::InvalidPayload(reason) => {
                write!(f, "Received invalid payload from client: {}", reason)
            }
        }
    }
}

impl fmt::Display for GameplayError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GameplayError::ResourceNotFound { kind, id } => {
                write!(f, "Resource not found: kind={}, id={}", kind, id)
            }
            GameplayError::DeckError(e) => write!(f, "Deck error: {}", e),
            GameplayError::InvalidTarget { reason } => write!(f, "Invalid target: {}", reason),
            GameplayError::InvalidAction { reason } => write!(f, "Invalid action: {}", reason),
            GameplayError::ChainError { reason } => write!(f, "Chain error: {}", reason),
            GameplayError::NotEnoughResources {
                resource,
                needed,
                available,
            } => write!(
                f,
                "Not enough {}: needed {}, available {}",
                resource, needed, available
            ),
        }
    }
}

impl fmt::Display for DeckError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DeckError::ParseFailed(s) => write!(f, "Failed to parse deck: {}", s),
            DeckError::CodeMissingFor(pk) => write!(f, "Deck code is missing for player {:?}", pk),
            DeckError::ExceededCardLimit(s) => write!(f, "Deck limit exceeded: {}", s),
            DeckError::NoCardsLeftToDraw => write!(f, "No cards left in the deck to draw"),
        }
    }
}

// 최상위 GameError에 대한 Display 구현
impl fmt::Display for GameError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GameError::System(e) => e.fmt(f),
            GameError::Connection(e) => e.fmt(f),
            GameError::State(e) => e.fmt(f),
            GameError::Gameplay(e) => e.fmt(f),
        }
    }
}

// ===================================================================
// 4. ResponseError를 구현하여 HTTP 응답으로 변환합니다.
// ===================================================================

impl ResponseError for GameError {
    fn status_code(&self) -> StatusCode {
        match self {
            // 시스템 에러는 모두 500번대
            GameError::System(_) => StatusCode::INTERNAL_SERVER_ERROR,
            // 상태 에러는 주로 동시성 문제나 순서 문제이므로 409 Conflict
            GameError::State(StateError::InvalidPhaseTransition) => StatusCode::CONFLICT,
            GameError::State(StateError::InvalidActionForPhase { .. }) => StatusCode::CONFLICT,
            GameError::State(_) => StatusCode::CONFLICT,
            // 연결 에러는 클라이언트의 잘못일 가능성이 높으므로 400번대
            GameError::Connection(ConnectionError::AuthenticationFailed(_)) => {
                StatusCode::UNAUTHORIZED
            }
            GameError::Connection(ConnectionError::SessionExists(_)) => StatusCode::CONFLICT,
            GameError::Connection(ConnectionError::InvalidPayload(_)) => StatusCode::BAD_REQUEST,
            // 게임플레이 에러는 규칙 위반이므로 400 Bad Request
            GameError::Gameplay(_) => StatusCode::BAD_REQUEST,
        }
    }

    fn error_response(&self) -> HttpResponse {
        let status = self.status_code();
        let error_message = self.to_string(); // Display 구현을 사용

        // 프로덕션에서는 내부 에러를 클라이언트에 노출하지 않는 것이 좋습니다.
        let client_message = if status.is_server_error() {
            "An internal server error occurred.".to_string()
        } else {
            error_message.clone()
        };

        // 서버 로그에는 상세한 에러를 남깁니다.
        tracing::error!("Request failed: {}", error_message);

        HttpResponse::build(status).json(serde_json::json!({ "error": client_message }))
    }
}

// ===================================================================
// 5. From 트레이트를 구현하여 에러 변환을 쉽게 합니다.
// ===================================================================

impl From<MailboxError> for GameError {
    fn from(e: MailboxError) -> Self {
        GameError::System(SystemError::Mailbox(e))
    }
}

impl From<serde_json::Error> for GameError {
    fn from(e: serde_json::Error) -> Self {
        GameError::System(SystemError::Json(e))
    }
}

impl From<std::io::Error> for GameError {
    fn from(e: std::io::Error) -> Self {
        GameError::System(SystemError::Io(e))
    }
}

// 기존에 정의된 GameError enum과 const 문자열들은 모두 삭제하시면 됩니다.
</file>

<file path="simulator_core/src/lib.rs">
// #![allow(unused_variables, unused_labels, dead_code)]

use std::{collections::HashMap, future::Future, time::Duration};

use card::types::{PlayerIdentity, PlayerKind};
use exception::{GameError, SystemError};
use tracing::{debug, error, warn};
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};
use uuid::Uuid;

pub mod card;
pub mod card_gen;
pub mod effect;
pub mod enums;
pub mod exception;
pub mod game;
pub mod player;
pub mod resource;
pub mod selector;
pub mod sync;
pub mod utils;
pub mod zone;

use std::sync::Once;
static INIT: Once = Once::new();
static mut GUARD: Option<tracing_appender::non_blocking::WorkerGuard> = None;
pub fn setup_logger() {
    INIT.call_once(|| {
        // 1. 파일 로거 설정
        let file_appender = RollingFileAppender::new(Rotation::DAILY, "logs", "app.log");
        let (non_blocking_file_writer, _guard) = tracing_appender::non_blocking(file_appender);

        // 2. 로그 레벨 필터 설정 (환경 변수 또는 기본값 INFO)
        let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")); // 기본 INFO 레벨

        // 3. 콘솔 출력 레이어 설정
        // let console_layer = fmt::layer()
        //     .with_writer(io::stdout) // 표준 출력으로 설정
        //     .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
        //     .with_thread_ids(true) // 스레드 ID 포함
        //     .with_thread_names(true) // 스레드 이름 포함
        //     .with_file(true) // 파일 경로 포함
        //     .with_line_number(true) // 라인 번호 포함
        //     .with_target(false) // target 정보 제외 (선택 사항)
        //     .pretty(); // 사람이 읽기 좋은 포맷

        // 4. 파일 출력 레이어 설정
        let file_layer = fmt::layer()
            .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
            .with_ansi(false) // 파일에는 ANSI 코드 제외
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .pretty();

        // 5. 레지스트리(Registry)에 필터와 레이어 결합
        tracing_subscriber::registry()
            .with(filter) // 필터를 먼저 적용
            // .with(console_layer) // 콘솔 레이어 추가
            .with(file_layer) // 파일 레이어 추가
            .init(); // 전역 Subscriber로 설정

        unsafe {
            GUARD = Some(_guard);
        }

        tracing::info!("로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.");
    });
}

pub trait StringUuidExt {
    fn to_uuid(&self) -> Result<Uuid, GameError>;
}

impl StringUuidExt for String {
    fn to_uuid(&self) -> Result<Uuid, GameError> {
        Uuid::parse_str(self)
            .map_err(|_| GameError::System(SystemError::Internal("UUID parse failed".to_string())))
    }
}

pub trait VecUuidExt {
    fn to_vec_string(&self) -> Vec<String>;
}

impl VecUuidExt for Vec<Uuid> {
    fn to_vec_string(&self) -> Vec<String> {
        self.iter()
            .map(|uuid| uuid.to_string())
            .collect::<Vec<String>>()
    }
}

pub trait VecStringExt {
    fn to_vec_uuid(&self) -> Result<Vec<Uuid>, GameError>;
}

impl VecStringExt for Vec<String> {
    fn to_vec_uuid(&self) -> Result<Vec<Uuid>, GameError> {
        self.iter()
            .map(|uuid| {
                Uuid::parse_str(uuid).map_err(|_| {
                    GameError::System(SystemError::Internal("UUID parse failed".to_string()))
                })
            })
            .collect::<Result<Vec<Uuid>, GameError>>()
    }
}

pub trait LogExt<T, E> {
    fn log_ok(self, f: impl FnOnce()) -> Self;
    fn log_err(self, f: impl FnOnce(&E)) -> Self;
}

impl<T, E> LogExt<T, E> for Result<T, E> {
    fn log_ok(self, f: impl FnOnce()) -> Self {
        if self.is_ok() {
            f()
        }
        self
    }

    fn log_err(self, f: impl FnOnce(&E)) -> Self {
        if let Err(ref e) = self {
            f(e);
        }
        self
    }
}
pub trait PlayerHashMapExt<V> {
    fn get_by_uuid(&self, uuid_key: &Uuid) -> Option<&V>;
    fn get_by_kind(&self, kind_key: PlayerKind) -> Option<&V>;
}

impl<V> PlayerHashMapExt<V> for HashMap<PlayerIdentity, V> {
    fn get_by_uuid(&self, uuid_key: &Uuid) -> Option<&V> {
        self.iter()
            .find(|(player_identity_key, _value)| player_identity_key.id == *uuid_key)
            .map(|(_player_identity_key, value)| value)
    }

    fn get_by_kind(&self, kind_key: PlayerKind) -> Option<&V> {
        self.iter()
            .find(|(player_identity_key, _value)| player_identity_key.kind == kind_key)
            .map(|(_player_identity_key, value)| value)
    }
}

pub struct RetryConfig {
    pub max_attempts: usize,
    pub base_delay_ms: u64,
    pub backoff_multiplier: f64,
    pub max_delay_ms: u64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_attempts: 3,
            base_delay_ms: 100,
            backoff_multiplier: 2.0,
            max_delay_ms: 5000,
        }
    }
}

#[derive(PartialEq, Eq)]
pub enum Condition {
    Continue,
    Stop,
}

pub async fn retry_with_condition<F, Fut, T, E>(
    operation: F,
    config: RetryConfig,
    should_retry: impl Fn(&E) -> Condition,
    operation_name: &str,
) -> Result<T, E>
where
    F: Fn() -> Fut,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Debug,
{
    for attempt in 1..=config.max_attempts {
        match operation().await {
            Ok(result) => {
                if attempt > 1 {
                    debug!(
                        "{} succeeded on attempt {}/{}",
                        operation_name, attempt, config.max_attempts
                    );
                }
                return Ok(result);
            }
            Err(e) => {
                if should_retry(&e) == Condition::Stop {
                    warn!(
                        "{} failed with non-retryable error: {:?}",
                        operation_name, e
                    );
                    return Err(e);
                }
                if attempt == config.max_attempts {
                    error!(
                        "{} failed after {} attempts. Final error: {:?}",
                        operation_name, config.max_attempts, e
                    );
                    return Err(e);
                }

                warn!(
                    "{} failed on attempt {}/{}. Error: {:?}. Retrying...",
                    operation_name, attempt, config.max_attempts, e
                );

                let delay_ms = (config.base_delay_ms as f64
                    * config.backoff_multiplier.powi(attempt as i32 - 1))
                .min(config.max_delay_ms as f64) as u64;

                tokio::time::sleep(Duration::from_millis(delay_ms)).await;
            }
        }
    }

    // 이 부분은 실제로 도달하지 않아야 함
    unreachable!()
}

pub async fn retry<F, Fut, T, E>(
    operation: F,
    config: RetryConfig,
    operation_name: &str,
) -> Result<T, E>
where
    F: Fn() -> Fut,
    Fut: Future<Output = Result<T, E>>,
    E: std::fmt::Debug,
{
    for attempt in 1..=config.max_attempts {
        match operation().await {
            Ok(result) => {
                if attempt > 1 {
                    debug!(
                        "{} succeeded on attempt {}/{}",
                        operation_name, attempt, config.max_attempts
                    );
                }
                return Ok(result);
            }
            Err(e) => {
                if attempt == config.max_attempts {
                    error!(
                        "{} failed after {} attempts. Final error: {:?}",
                        operation_name, config.max_attempts, e
                    );
                    return Err(e);
                }

                warn!(
                    "{} failed on attempt {}/{}. Error: {:?}. Retrying...",
                    operation_name, attempt, config.max_attempts, e
                );

                let delay_ms = (config.base_delay_ms as f64
                    * config.backoff_multiplier.powi(attempt as i32 - 1))
                .min(config.max_delay_ms as f64) as u64;

                tokio::time::sleep(Duration::from_millis(delay_ms)).await;
            }
        }
    }

    // 이 부분은 실제로 도달하지 않아야 함
    unreachable!()
}
</file>

<file path="simulator_core/src/player/message.rs">
use crate::{
    card::{
        cards::CardVecExt,
        insert::Insert,
        take::{RandomTake, Take},
        Card,
    },
    enums::{ZoneType, COUNT_OF_MULLIGAN_CARDS},
    exception::{GameError, SystemError},
    selector::TargetCount,
    zone::zone::Zone,
};
use actix::{ActorContext, Addr, Context, Handler, Message};
use tracing::info;
use uuid::Uuid;

use super::PlayerActor;

#[derive(Message)]
#[rtype(result = "()")]
pub struct Terminate;

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct GameOver;

#[derive(Message)]
#[rtype(result = "Result<Vec<Uuid>, GameError>")]
pub struct RequestMulliganReroll {
    pub cards_to_restore: Vec<Uuid>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct SetOpponent {
    pub opponent: Addr<PlayerActor>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetCardsByUuid {
    pub uuid: Vec<Uuid>,
}

#[derive(Message)]
#[rtype(result = "Result<(), GameError>")]
pub struct AddCardsToDeck {
    pub cards: Vec<Card>,
    pub insert: Box<dyn Insert>,
}

#[derive(Message)]
#[rtype(result = "Result<Vec<Card>, GameError>")]
pub struct GetCardFromDeck {
    pub take: Box<dyn Take>,
}

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetDeckCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetHandCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetFieldCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetGraveyardCards;

#[derive(Message)]
#[rtype(result = "Vec<Card>")]
pub struct GetMulliganDealCards;

impl Handler<Terminate> for PlayerActor {
    type Result = ();

    fn handle(&mut self, _: Terminate, ctx: &mut Context<Self>) -> Self::Result {
        info!("PLAYER ACTOR [{:?}]: Handling Terminate", self.player_type);
        ctx.stop();
    }
}

impl Handler<GameOver> for PlayerActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, _: GameOver, ctx: &mut Context<Self>) -> Self::Result {
        info!("PLAYER ACTOR [{:?}]: Handling GameOver", self.player_type);

        // 필요시 리소스 해제

        ctx.stop();
        Ok(())
    }
}

impl Handler<GetMulliganDealCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetMulliganDealCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetMulliganDealCards",
            self.player_type
        );

        self.deck
            .take_card(Box::new(RandomTake(TargetCount::Exact(
                COUNT_OF_MULLIGAN_CARDS,
            ))))
            .unwrap()
            .into_iter()
            .map(|card| card.clone())
            .collect::<Vec<_>>()
    }
}

impl Handler<RequestMulliganReroll> for PlayerActor {
    type Result = Result<Vec<Uuid>, GameError>;

    fn handle(&mut self, msg: RequestMulliganReroll, ctx: &mut Context<Self>) -> Self::Result {
        println!(
            "PLAYER ACTOR [{:?}]: Handling RequestMulliganReroll",
            self.player_type
        );

        // 카드를 복원
        let cards_to_restore = self.get_cards_by_uuids(&msg.cards_to_restore)?;
        self.restore_cards(&cards_to_restore, ZoneType::Deck)?;

        // 복원 시킨 카드 갯수 만큼 카드를 뽑음.
        let new_cards = self.get_new_mulligan_cards(
            self.player_type,
            cards_to_restore.len(), // 뽑을 카드 갯수
        )?;

        // 뽑은 카드의 갯수를 확인
        if new_cards.len() != cards_to_restore.len() {
            return Err(GameError::System(SystemError::Internal(
                "Card count mismatch after mulligan".to_string(),
            )));
        }

        // 뽑은 카드를 mulligan state 에 넣음.
        self.mulligan_state.add_select_cards(new_cards.clone());

        // 뽑은 카드 목록을 반환
        Ok(new_cards)
    }
}

impl Handler<SetOpponent> for PlayerActor {
    type Result = ();

    fn handle(&mut self, msg: SetOpponent, ctx: &mut Context<Self>) -> Self::Result {
        println!(
            "PLAYER ACTOR [{:?}]: Handling SetOpponent",
            self.player_type
        );

        // 상대방 플레이어를 설정
        self.opponent = Some(msg.opponent);
    }
}

impl Handler<GetCardsByUuid> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, msg: GetCardsByUuid, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetCardsByUuid",
            self.player_type
        );

        // UUID에 해당하는 카드 목록을 반환
        let mut result = vec![];
        for uuid in msg.uuid {
            if let Some(card) = self.get_cards().find_by_uuid(uuid) {
                result.push(card.clone());
            } else {
                return vec![]; // 카드가 없으면 빈 벡터 반환
            }
        }
        result
    }
}

impl Handler<AddCardsToDeck> for PlayerActor {
    type Result = Result<(), GameError>;

    fn handle(&mut self, msg: AddCardsToDeck, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling AddCardsToDeck",
            self.player_type
        );

        self.deck.add_card(msg.cards, msg.insert)
    }
}

impl Handler<GetCardFromDeck> for PlayerActor {
    type Result = Result<Vec<Card>, GameError>;

    fn handle(&mut self, msg: GetCardFromDeck, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetCardFromDeck",
            self.player_type
        );

        // 덱에서 카드를 가져옴
        let cards = self.deck.take_card(msg.take)?;
        Ok(cards)
    }
}

impl Handler<GetDeckCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetDeckCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetDeckCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.deck.get_cards().clone()
    }
}

impl Handler<GetHandCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetHandCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetHandCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.hand.get_cards().clone()
    }
}

impl Handler<GetFieldCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetFieldCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetFieldCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.field.get_cards().clone()
    }
}

impl Handler<GetGraveyardCards> for PlayerActor {
    type Result = Vec<Card>;

    fn handle(&mut self, _: GetGraveyardCards, ctx: &mut Context<Self>) -> Self::Result {
        info!(
            "PLAYER ACTOR [{:?}]: Handling GetGraveyardCards",
            self.player_type
        );

        // 덱의 카드 목록을 반환
        self.graveyard.get_cards().clone()
    }
}
</file>

<file path="simulator_core/src/game/mod.rs">
use std::{collections::HashMap, sync::Arc, time::Duration};

use actix::{
    fut, Actor, ActorFutureExt, Addr, AsyncContext, Context, Handler, Message, Recipient, ResponseFuture, Running, SpawnHandle
};
use futures::{future::join_all, FutureExt};
use msg::GameEvent;
use state::GameStateManager;
use tokio::sync::Mutex;
use tracing::{error, info, warn};
use turn::TurnState;
use uuid::Uuid;

use crate::{card::{types::{PlayerIdentity, PlayerKind}, Card}, exception::{GameError, SystemError}, game::{msg::{system::GetPlayerStateSnapshot}, state::GamePhase}, player::{message::{GameOver, Terminate}, PlayerActor}, sync::{snapshots::{GameStateSnapshot, OpponentStateSnapshot}, SyncActor}};

pub mod choice;
pub mod phase;
pub mod state;
pub mod turn;
pub mod msg;

/// 게임 설정을 위한 빈 구조체입니다. 현재는 필드를 포함하지 않습니다.
pub struct GameConfig {}

/// 게임 액터는 게임 로직의 핵심을 담당합니다.
/// 플레이어 연결 관리, 게임 상태 관리, 턴 진행 등을 처리합니다.
// TODO: 상태 관리 개선
// TODO: 락 사용 최소화
pub struct GameActor {
    /// 플레이어 액터들의 주소를 저장합니다.
    pub players: HashMap<PlayerIdentity, Addr<PlayerActor>>,
    /// 플레이어의 ConnectionActor 주소를 저장합니다.
    pub connections: Arc<Mutex<HashMap<Uuid, Recipient<GameEvent>>>>,
    /// 각 플레이어 초기화 완료 여부를 나타냅니다.
    pub player_connection_ready: HashMap<PlayerKind, bool>,

    /// 상대방 플레이어의 연결 대기 타이머 핸들입니다.
    pub opponent_wait_timer_handle: Option<SpawnHandle>,
    /// 연결을 기다리는 상대방 플레이어의 종류입니다.
    pub opponent_player_kind: Option<PlayerKind>,

    /// 재접속 타이머 핸들입니다.
    pub reconnection_timer: HashMap<PlayerKind, SpawnHandle>,

    /// 게임의 현재 턴 상태를 관리합니다.
    pub turn: TurnState,

    /// 모든 카드 정보를 저장합니다. 플레이어 종류별로 카드를 관리합니다.
    pub all_cards: HashMap<PlayerKind, Vec<Card>>,
    /// 게임 상태를 관리하는 객체입니다.
    pub game_state: Arc<Mutex<GameStateManager>>,
    /// 게임의 고유 ID입니다.
    pub game_id: Uuid,

    /// gsm lock 에 실패한 경우 등에 사용되는 플래그입니다.
    pub unexpected_stop: bool,

    /// 동기화 액터의 주소를 저장합니다.
    pub sync_actor: Option<Addr<SyncActor>>,
}

impl Actor for GameActor {
    type Context = Context<Self>;

    /// 액터가 시작될 때 호출되는 메서드입니다.
    ///
    /// # Arguments
    ///
    /// * `ctx` - 액터 컨텍스트.
    fn started(&mut self, ctx: &mut Context<Self>) {
        info!("GameActor [{}] has started. Initializing SyncActor.", self.game_id);
        
        let game_addr = ctx.address();

        let sync_actor_addr = SyncActor::create(|_| {
            SyncActor::new(game_addr)
        });

        // 3. 생성된 SyncActor의 주소를 GameActor의 필드에 저장합니다.
        self.sync_actor = Some(sync_actor_addr);

        let mut gsm = self.game_state.lock().now_or_never().unwrap(); // started는 동기적으로 실행되므로 now_or_never 가능
        gsm.initialize_players();
    }

    /// 액터가 정지될 때 호출되는 메서드입니다.
    ///
    /// # Arguments
    ///
    /// * `ctx` - 액터 컨텍스트.
    fn stopping(&mut self, ctx: &mut Context<Self>) -> Running {
        {
            // Start gsm Lock
            let mut gsm = self.game_state.try_lock().unwrap();
            let current_phase = gsm.current_phase();
            let connection_len = self.connections.try_lock().unwrap().len();
            if current_phase == GamePhase::Stopping && connection_len == 0 {
                info!(
                    "GameActor [{}]: Entering Stopped.",
                    self.game_id
                );
                gsm.transition_to_phase(GamePhase::Stopped);
                return Running::Stop;
            }else if current_phase == GamePhase::Stopping{
                info!(
                    "GameActor [{}]: stopping() called again, but cleanup is already in progress. Ignoring.",
                    self.game_id
                );
                // 이미 정리 작업이 진행 중이므로, 해당 작업이 끝날 때까지 액터를 살려둬야 합니다.
                return Running::Continue; 
            }
            
            gsm.transition_to_phase(GamePhase::Stopping);
        } // Drop gsm
            
        info!(
            "GameActor [{}] is stopping. Initiating comprehensive cleanup.",
            self.game_id
        );

        // 1. GameStateManager 정리
        let game_state = self.game_state.clone();
        let connections = self.connections.clone();
        let player_addrs: Vec<Addr<PlayerActor>> = self.players.values().cloned().collect();
        let game_id_clone = self.game_id;

        let cleanup_future = async move {
            info!(
                "GameActor [{}]: Starting comprehensive cleanup task.",
                game_id_clone
            );

            // 1. PlayerActor들에게 GameOver 전송
            let mut send_futures = Vec::new();
            for player_addr in player_addrs {
                info!(
                    "GameActor [{}]: Preparing to send GameOver to PlayerActor ({:?}).",
                    game_id_clone, player_addr
                );
                let fut = player_addr.send(GameOver);
                send_futures.push(async move { 
                    match fut.await {
                        Ok(_) => {
                            info!("GameActor [{}]: Successfully sent GameOver to PlayerActor ({:?})", game_id_clone, player_addr);
                        },
                        Err(e) => {
                            warn!(
                                "GameActor [{}]: Failed to send GameOver to PlayerActor ({:?}): {:?}. Attempting Terminate.",
                                game_id_clone, player_addr, e
                            );
                            player_addr.do_send(Terminate);
                        }
                    }
                });
            }

            // 2. GameStateManager에서 모든 연결된 플레이어 제거
            {
                let mut gsm = game_state.lock().await;
                let connected_players: Vec<_> = gsm.player_states.keys().cloned().collect();
                for player_kind in connected_players {
                    gsm.update_player_connection_status(player_kind, false);
                }
                info!(
                    "GameActor [{}]: All players removed from GameStateManager.",
                    game_id_clone
                );
            }

            // 3. 모든 연결 정리
            {
                let mut connections_guard = connections.lock().await;
                connections_guard.clear();
                info!(
                    "GameActor [{}]: All connections cleared.",
                    game_id_clone
                );
            }

            join_all(send_futures).await;

            info!(
                "GameActor [{}]: Comprehensive cleanup task completed.",
                game_id_clone
            );
        };

       let stop_self_after_cleanup = fut::wrap_future(cleanup_future).then(
            move |_, _act: &mut GameActor, ctx_then: &mut Context<GameActor>| {
                info!(
                    "GameActor [{}]: All cleanup completed. Now stopping context.",
                    _act.game_id
                );
                ctx_then.address().do_send(msg::system::Terminate);
                
                fut::ready(())
            },
        );

        ctx.spawn(stop_self_after_cleanup);

        info!("GameActor [{}]: stopping() method finished, comprehensive cleanup scheduled.", self.game_id);
        Running::Continue
    }

    /// 액터가 완전히 정지된 후 호출되는 메서드입니다.
    ///
    /// # Arguments
    ///
    /// * `ctx` - 액터 컨텍스트.
    fn stopped(&mut self, _ctx: &mut Self::Context) {
        info!("GameActor [{}] has stopped.", self.game_id);
    }
}

impl GameActor {
    /// 새로운 게임 세션을 위한 GameActor를 생성합니다.
    ///
    /// # Arguments
    ///
    /// * `game_id` - 이 게임 세션의 고유 ID.
    /// * `player1_id` - 플레이어 1의 ID.
    /// * `player2_id` - 플레이어 2의 ID.
    /// * `player1_deck_code` - 플레이어 1의 덱 코드.
    /// * `player2_deck_code` - 플레이어 2의 덱 코드.
    /// * `attacker_player_type` - 선공 플레이어의 타입.
    ///
    /// # Returns
    ///
    /// 새로운 GameActor 인스턴스.
    ///
    /// # Examples
    ///
    /// ```
    /// use uuid::Uuid;
    /// use crate::game::GameActor;
    /// use crate::card::types::PlayerKind;
    ///
    /// let game_id = Uuid::new_v4();
    /// let player1_id = Uuid::new_v4();
    /// let player2_id = Uuid::new_v4();
    /// let player1_deck_code = "test_deck_1".to_string();
    /// let player2_deck_code = "test_deck_2".to_string();
    /// let attacker_player_type = PlayerKind::Player1;
    ///
    /// let game_actor = GameActor::new(
    ///     game_id,
    ///     player1_id,
    ///     player2_id,
    ///     player1_deck_code,
    ///     player2_deck_code,
    ///     attacker_player_type,
    /// );
    ///
    /// assert_eq!(game_actor.game_id, game_id);
    /// ```
    pub fn new(
        game_id: Uuid,
        player1_id: Uuid,
        player2_id: Uuid,
        player1_deck_code: String,
        player2_deck_code: String,
        attacker_player_type: PlayerKind,
    ) -> Self {
        let p1_identity = PlayerIdentity {
            id: player1_id,
            kind: PlayerKind::Player1,
        };
        let p2_identity = PlayerIdentity {
            id: player2_id,
            kind: PlayerKind::Player2,
        };

        let mut player_actors_map = HashMap::new();

        // PlayerActor 생성 및 맵에 추가
        let p1_addr =
            PlayerActor::create(|_ctx| PlayerActor::new(p1_identity.kind, player1_deck_code));
        let p2_addr =
            PlayerActor::create(|_ctx| PlayerActor::new(p2_identity.kind, player2_deck_code));
        player_actors_map.insert(p1_identity, p1_addr.clone());
        player_actors_map.insert(p2_identity, p2_addr.clone());

        actix::spawn(async move {
            while !p1_addr.connected() {
                tokio::time::sleep(Duration::from_millis(5)).await;
            }
            info!(
                "PlayerActor 1 connected ( not session connection! ), P1 can now receive messages."
            );

            while !p2_addr.connected() {
                tokio::time::sleep(Duration::from_millis(5)).await;
            }
            info!(
                "PlayerActor 2 connected ( not session connection! ), P2 can now receive messages."
            );

            info!("Both players actor connected. ( not session connection! ) Sending SetOpponent messages");
        });

        let game_state_manager = GameStateManager::new();

        Self {
            players: player_actors_map,
            connections: Arc::new(Mutex::new(HashMap::new())),
            player_connection_ready: HashMap::from([
                (PlayerKind::Player1, false),
                (PlayerKind::Player2, false),
            ]),
            opponent_wait_timer_handle: None,
            opponent_player_kind: None,
            reconnection_timer: HashMap::new(),
            turn: TurnState::new(attacker_player_type),
            all_cards: HashMap::new(),
            game_state: Arc::new(Mutex::new(game_state_manager)),
            game_id,
            unexpected_stop: false,
            sync_actor: None,
        }
    }

    
    pub fn all_players_ready(&self) -> bool {
        self.player_connection_ready.len() == 2
            && self
                .player_connection_ready
                .get(&PlayerKind::Player1)
                .is_some()
            && self
                .player_connection_ready
                .get(&PlayerKind::Player2)
                .is_some()
    }

    pub async fn create_snapshot_for(
        &self,
        perspective_of: PlayerKind,
    ) -> Result<GameStateSnapshot, GameError> {
        let my_player_addr = self.get_player_addr_by_kind(perspective_of);
        let opponent_player_addr = self.get_player_addr_by_kind(perspective_of.reverse());

        // 두 플레이어의 상태를 병렬로 가져옵니다.
        let (my_state_res, opponent_state_res) = tokio::join!(
            my_player_addr.send(GetPlayerStateSnapshot),
            opponent_player_addr.send(GetPlayerStateSnapshot)
        );

        let my_state = my_state_res??;
        let opponent_state = opponent_state_res??;

        // 상대방 정보는 공개된 정보로 변환합니다.
        let opponent_info_for_me = OpponentStateSnapshot {
            player_kind: opponent_state.player_kind,
            health: opponent_state.health,
            mana: opponent_state.mana,
            mana_max: opponent_state.mana_max,
            deck_count: opponent_state.deck_count,
            hand_count: opponent_state.hand.len(), // 손패는 개수만
            field: opponent_state.field,
            graveyard: opponent_state.graveyard,
        };

        // TODO: 현재 시퀀스 번호와 해시를 SyncActor로부터 가져오거나 GameActor가 직접 관리
        let current_seq = 0; // self.sync_actor.send(GetCurrentSeq).await?
        let current_hash = None; // self.calculate_hash()

        let snapshot = GameStateSnapshot {
            seq: current_seq,
            state_hash: current_hash,
            current_phase: self.turn.current_phase.to_string(), // Phase를 문자열로
            turn_player: self.turn.current_turn_plyaer,
            turn_count: self.turn.turn_count,
            my_info: my_state,
            opponent_info: opponent_info_for_me,
        };
        
        Ok(snapshot)
    }

    fn get_player_info_by_kind(&self, target_kind: PlayerKind) -> Option<(Uuid, &PlayerIdentity)> {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return Some((identity.id, identity));
            }
        }
        None
    }

    fn get_player_identity_by_kind(&self, target_kind: PlayerKind) -> Option<&PlayerIdentity> {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return Some(identity);
            }
        }
        None
    }

    fn get_player_identity_by_uuid(&self, player_id: Uuid) -> Option<&PlayerIdentity> {
        for (identity, _) in &self.players {
            if identity.id == player_id {
                return Some(identity);
            }
        }
        None
    }

    /// PlayerKind를 기반으로 PlayerActor의 주소(Addr)를 가져옵니다.
    pub fn get_player_addr_by_kind(&self, target_kind: PlayerKind) -> Addr<PlayerActor> {
        for (identity, addr) in &self.players {
            if identity.kind == target_kind {
                return addr.clone();
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with kind {:?} not found", target_kind)
    }

    pub fn get_player_type_by_uuid(&self, player_id: Uuid) -> PlayerKind {
        for (identity, _) in &self.players {
            if identity.id == player_id {
                return identity.kind;
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with ID {} not found", player_id)
    }
    pub fn get_player_uuid_by_kind(&self, target_kind: PlayerKind) -> Uuid {
        for (identity, _) in &self.players {
            if identity.kind == target_kind {
                return identity.id;
            }
        }
        // TODO : 나중에 수정해야함.
        panic!("Player with kind {:?} not found", target_kind)
    }

    /// PlayerKind를 기반으로 ConnectionActor의 주소(Addr)를 가져옵니다.
    pub fn get_connection_addr_by_kind(
        &self,
        target_kind: PlayerKind,
    ) -> Option<Recipient<GameEvent>> {
        todo!()
    }

    /// PlayerKind를 기반으로 해당 PlayerActor에게 메시지를 보내고 결과를 기다립니다. (send 버전)
    ///
    /// # Arguments
    /// * `target_kind` - 메시지를 보낼 대상 플레이어의 PlayerKind.
    /// * `msg` - 보낼 메시지.
    ///
    /// # Returns
    /// * `ResponseFuture<Result<M::Result, GameActorError>>` -
    ///   비동기적으로 PlayerActor 핸들러의 결과 또는 에러를 반환합니다.
    ///   `GameActorError`는 플레이어를 찾지 못했거나 Mailbox 에러를 포함할 수 있습니다.
    pub fn send_to_player_actor<M>(
        &self,
        target_kind: PlayerKind,
        msg: M,
    ) -> ResponseFuture<Result<M::Result, GameError>>
    where
        M: Message + Send + 'static, // 메시지 제약 조건
        M::Result: Send,             // 결과 제약 조건
        PlayerActor: Handler<M>,     // PlayerActor가 이 메시지를 처리할 수 있어야 함
    {
        // 1. target_kind에 해당하는 PlayerActor의 주소(Addr)를 찾습니다.
        let addr = self.get_player_addr_by_kind(target_kind);
        // 2. 주소를 찾았으면, send 메서드를 호출하고 결과를 await합니다.
        //    send의 결과는 Result<M::Result, MailboxError> 입니다.
        //    이를 GameError로 매핑하여 반환합니다.

        let game_id = self.game_id;
        Box::pin(async move {
            info!(
                "GAME ACTOR [{}]: Sending message to PlayerActor ({:?}) and awaiting response.",
                // self.game_id, // self 직접 접근 불가, 필요시 game_id를 클론해서 전달
                game_id,
                target_kind
            );
            match addr.send(msg).await {
                Ok(handler_result) => {
                    // PlayerActor 핸들러가 반환한 M::Result
                    // 이 M::Result 자체가 Result<T, E>일 수 있음 (핸들러가 오류를 반환하는 경우)
                    // 여기서는 M::Result를 그대로 반환 (필요시 내부 Result 처리)
                    Ok(handler_result)
                }
                Err(mailbox_error) => {
                    error!(
                        "GAME ACTOR: Mailbox error sending message to PlayerActor ({:?}): {:?}",
                        target_kind, mailbox_error
                    );
                    Err(GameError::System(SystemError::Mailbox(mailbox_error)))
                }
            }
        })
    }

    /// PlayerKind를 기반으로 해당 PlayerActor에게 메시지를 보냅니다. (do_send 버전)
    pub fn do_send_to_player_actor<M>(&self, target_kind: PlayerKind, msg: M)
    where
        M: Message + Send + 'static,
        M::Result: Send,
        // PlayerActor: Handler<M>, // Handler 제약은 받는 쪽에서 필요, 보내는 쪽에서는 불필요
    {
        todo!()
    }

    /// PlayerKind를 기반으로 해당 ConnectionActor에게 메시지를 보냅니다. (do_send 버전)
    /// (GameEvent 등을 보낼 때 사용)
    pub fn send_to_connection<M>(&self, target_kind: PlayerKind, msg: M)
    where
        M: Message + Send + 'static,
        M::Result: Send,
        // ConnectionActor: Handler<M>, // 받는 쪽에서 필요
    {
        todo!()
    }

    /// 게임 내 모든 플레이어의 ConnectionActor에게 메시지를 브로드캐스트합니다.
    pub fn broadcast_to_connections<M>(&self, msg: M)
    where
        M: Message + Send + Clone + 'static, // Clone 필요
        M::Result: Send,
        // ConnectionActor: Handler<M>, // 받는 쪽에서 필요
    {
        todo!()
    }
}
</file>

<file path="Cargo.toml">
[workspace.package]
version = "0.1.0"
edition = "2021"
description = "card backend"

[workspace]
members = [ 
    "simulator_auth_server",
    "simulator_core",
    "simulator_dedicated_server",
    "simulator_match_server",
    "simulator_client/src-tauri",
]

resolver = "2"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
</file>

</files>
