This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.sqlx/query-10c463dca64ab573b22438e02cd9e1fa5bc9cb27ad42219f806aa18107b5a98e.json
Cargo.toml
migrations/001_create_extensions_and_functions.sql
migrations/002_create_enum_types.sql
migrations/003_create_players_table.sql
migrations/004_create_tiers_table.sql
migrations/005_create_player_profiles_table.sql
migrations/006_create_game_modes_table.sql
migrations/007_create_match_history_table.sql
migrations/008_create_match_participants_table.sql
migrations/009_create_cards_table.sql
migrations/010_create_player_card_collection_table.sql
migrations/011_create_player_decks_table.sql
migrations/012_create_deck_cards_table.sql
migrations/init.sql
reset_and_migrate.bat
src/auth_server/db_operation.rs
src/auth_server/end_point.rs
src/auth_server/errors.rs
src/auth_server/mod.rs
src/auth_server/model.rs
src/auth_server/types.rs
src/lib.rs
src/main.rs
steam_appid.txt
tests/test.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".sqlx/query-10c463dca64ab573b22438e02cd9e1fa5bc9cb27ad42219f806aa18107b5a98e.json">
{
  "db_name": "PostgreSQL",
  "query": "SELECT id, username, hashed_password, email, email_verified_at, status, created_at, updated_at, last_login_at FROM players WHERE username = $1",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id",
        "type_info": "Uuid"
      },
      {
        "ordinal": 1,
        "name": "username",
        "type_info": "Varchar"
      },
      {
        "ordinal": 2,
        "name": "hashed_password",
        "type_info": "Text"
      },
      {
        "ordinal": 3,
        "name": "email",
        "type_info": "Varchar"
      },
      {
        "ordinal": 4,
        "name": "email_verified_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 5,
        "name": "status",
        "type_info": "Varchar"
      },
      {
        "ordinal": 6,
        "name": "created_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 7,
        "name": "updated_at",
        "type_info": "Timestamptz"
      },
      {
        "ordinal": 8,
        "name": "last_login_at",
        "type_info": "Timestamptz"
      }
    ],
    "parameters": {
      "Left": [
        "Text"
      ]
    },
    "nullable": [
      false,
      false,
      false,
      true,
      true,
      false,
      false,
      false,
      true
    ]
  },
  "hash": "10c463dca64ab573b22438e02cd9e1fa5bc9cb27ad42219f806aa18107b5a98e"
}
</file>

<file path="Cargo.toml">
[package]
name = "simulator_auth_server"
version.workspace = true
edition.workspace = true
description.workspace = true

[dependencies]
sqlx = { version = "0.8", features = [ "runtime-tokio", "postgres", "tls-rustls-ring-native-roots", "uuid", "chrono", "json" ] }
# sqlx-cli = {version = "0.8.6", features = ["native-tls", "postgres"] } 
actix-web = "4.9.0"
ctor = "0.4.1"
actix = "=0.13.5"
hex = "0.4.3"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.140"
tokio = { version = "1.15", features = ["full", "tracing"] }
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
dotenvy = "0.15.7"
uuid = { version = "1.14.0", features = ["v4", "serde"] }
reqwest = { version = "0.12.12", features = ["json"] }
anyhow = "1.0.98"
chrono = { version = "0.4.41", features = ["serde"] }
steamworks = "0.12.0"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
once_cell = "1.21.3"
crossbeam-utils = "0.8.21"

[env]
url = "postgres://postgres:root@localhost:5432/auth"
</file>

<file path="migrations/001_create_extensions_and_functions.sql">
-- 데이터베이스에 uuid-ossp 확장 기능 활성화 (여전히 다른 테이블에서 UUID를 사용할 수 있으므로 유지)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- updated_at 컬럼 자동 갱신을 위한 트리거 함수
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';
</file>

<file path="migrations/002_create_enum_types.sql">
-- Custom ENUM types
DO $$ BEGIN
    CREATE TYPE player_status AS ENUM ('active', 'suspended', 'banned');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE card_rarity AS ENUM ('common', 'rare', 'epic', 'legendary');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;
</file>

<file path="migrations/003_create_players_table.sql">
-- Players table for Steam Player Account Mapping
CREATE TABLE IF NOT EXISTS players (
    id BIGINT PRIMARY KEY, -- SteamID64 as primary key
    last_known_username VARCHAR(64), -- Steam nickname snapshot
    status player_status NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);
COMMENT ON TABLE players IS 'Core table linking Steam player accounts with game data';
COMMENT ON COLUMN players.id IS 'Unique player ID (SteamID64)';
COMMENT ON COLUMN players.last_known_username IS 'Last known player Steam nickname';
COMMENT ON COLUMN players.status IS 'Account status (ENUM: active, suspended, banned)';
CREATE TRIGGER trigger_players_updated_at
BEFORE UPDATE ON players
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
</file>

<file path="migrations/004_create_tiers_table.sql">
-- Tiers master data table
CREATE TABLE IF NOT EXISTS tiers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    order_key INT UNIQUE NOT NULL,
    icon_url TEXT
);
COMMENT ON TABLE tiers IS 'Game tier/rank definition master table';
-- Insert sample tier data
INSERT INTO tiers (id, name, order_key, icon_url) VALUES
(1, 'Bronze', 1, '/icons/tiers/bronze.png'),
(2, 'Silver', 2, '/icons/tiers/silver.png'),
(3, 'Gold', 3, '/icons/tiers/gold.png'),
(4, 'Platinum', 4, '/icons/tiers/platinum.png'),
(5, 'Diamond', 5, '/icons/tiers/diamond.png')
ON CONFLICT (id) DO NOTHING;
</file>

<file path="migrations/005_create_player_profiles_table.sql">
-- Player profiles table for game-specific profile and stats
CREATE TABLE IF NOT EXISTS player_profiles (
    player_id BIGINT PRIMARY KEY REFERENCES players(id) ON DELETE CASCADE,
    mmr DOUBLE PRECISION NOT NULL DEFAULT 1500.0,
    rd DOUBLE PRECISION NOT NULL DEFAULT 350.0,
    volatility DOUBLE PRECISION NOT NULL DEFAULT 0.06,
    last_rating_update_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    tier_id INT NOT NULL REFERENCES tiers(id),
    rank_points INT NOT NULL DEFAULT 0,
    experience_points BIGINT NOT NULL DEFAULT 0,
    level INT NOT NULL DEFAULT 1,
    -- Game-specific profile customization items
    -- custom_profile_icon_id VARCHAR(100),
    -- custom_profile_banner_id VARCHAR(100),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE player_profiles IS 'In-game player profiles, rank, and stats information';
COMMENT ON COLUMN player_profiles.player_id IS 'Player SteamID64';
CREATE INDEX IF NOT EXISTS idx_player_profiles_mmr ON player_profiles(mmr);
CREATE TRIGGER trigger_player_profiles_updated_at
BEFORE UPDATE ON player_profiles
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
</file>

<file path="migrations/006_create_game_modes_table.sql">
-- Game modes master data table
CREATE TABLE IF NOT EXISTS game_modes (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_ranked BOOLEAN NOT NULL DEFAULT FALSE,
    player_count_per_team INT NOT NULL DEFAULT 1,
    team_count INT NOT NULL DEFAULT 2,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE game_modes IS 'Game mode definition master table';
INSERT INTO game_modes (id, internal_name, display_name, is_ranked, player_count_per_team, team_count) VALUES
(1, 'ranked_1v1', '1v1 Ranked Game', TRUE, 1, 2),
(2, 'unranked_1v1', '1v1 Casual Game', FALSE, 1, 2)
ON CONFLICT (id) DO NOTHING;
</file>

<file path="migrations/007_create_match_history_table.sql">
-- Match history table for completed games
CREATE TABLE IF NOT EXISTS match_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    game_mode_id INT NOT NULL REFERENCES game_modes(id),
    started_at TIMESTAMPTZ NOT NULL,
    ended_at TIMESTAMPTZ NOT NULL,
    duration_seconds INT GENERATED ALWAYS AS (EXTRACT(EPOCH FROM (ended_at - started_at))::INT) STORED,
    winning_team_id INT,
    additional_data JSONB
);
COMMENT ON TABLE match_history IS 'Records of all completed games';
CREATE INDEX IF NOT EXISTS idx_match_history_started_at ON match_history(started_at DESC);
</file>

<file path="migrations/008_create_match_participants_table.sql">
-- Match participants table for player performance in matches
CREATE TABLE IF NOT EXISTS match_participants (
    match_id UUID NOT NULL REFERENCES match_history(id) ON DELETE CASCADE,
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE SET NULL,
    team_id INT NOT NULL,
    is_winner BOOLEAN NOT NULL,
    initial_mmr DOUBLE PRECISION NOT NULL,
    final_mmr DOUBLE PRECISION NOT NULL,
    mmr_change DOUBLE PRECISION GENERATED ALWAYS AS (final_mmr - initial_mmr) STORED,
    score INT,
    stats JSONB,
    disconnected BOOLEAN NOT NULL DEFAULT FALSE,
    PRIMARY KEY (match_id, player_id)
);
COMMENT ON TABLE match_participants IS 'Match participant and performance information';
CREATE INDEX IF NOT EXISTS idx_match_participants_player_id ON match_participants(player_id);
</file>

<file path="migrations/009_create_cards_table.sql">
-- Cards master data table
CREATE TABLE IF NOT EXISTS cards (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    rarity card_rarity,
    mana_cost INT NOT NULL DEFAULT 0,
    attack INT,
    health INT,
    card_type VARCHAR(50),
    image_url TEXT,
    attributes JSONB,
    is_collectible BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE cards IS 'Master table for all card information in the game';
-- Insert sample card data
INSERT INTO cards (id, internal_name, display_name, rarity, mana_cost, attack, health, card_type, is_collectible) VALUES
(1, 'fireball', 'Fireball', 'common', 4, 6, 0, 'spell', TRUE),
(2, 'frost_golem', 'Frost Golem', 'rare', 5, 4, 5, 'minion', TRUE)
ON CONFLICT (id) DO NOTHING;
</file>

<file path="migrations/010_create_player_card_collection_table.sql">
-- Player card collection table
CREATE TABLE IF NOT EXISTS player_card_collection (
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
    is_new BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (player_id, card_id)
);
COMMENT ON TABLE player_card_collection IS 'List of cards owned by players';
</file>

<file path="migrations/011_create_player_decks_table.sql">
-- Player decks table
CREATE TABLE IF NOT EXISTS player_decks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    deck_name VARCHAR(100) NOT NULL,
    cover_card_id INT REFERENCES cards(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (player_id, deck_name)
);
COMMENT ON TABLE player_decks IS 'List of decks created by players';
CREATE TRIGGER trigger_player_decks_updated_at
BEFORE UPDATE ON player_decks
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();
</file>

<file path="migrations/012_create_deck_cards_table.sql">
-- Deck cards table for deck composition
CREATE TABLE IF NOT EXISTS deck_cards (
    deck_id UUID NOT NULL REFERENCES player_decks(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL CHECK (quantity > 0 AND quantity <= 2),
    PRIMARY KEY (deck_id, card_id)
);
COMMENT ON TABLE deck_cards IS 'Information about cards included in each deck';
</file>

<file path="migrations/init.sql">
-- 데이터베이스에 uuid-ossp 확장 기능 활성화 (여전히 다른 테이블에서 UUID를 사용할 수 있으므로 유지)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- updated_at 컬럼 자동 갱신을 위한 트리거 함수
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- =================================================================
-- 0. 커스텀 ENUM 타입 정의 (Custom ENUM Types)
-- =================================================================
DO $$ BEGIN
    CREATE TYPE player_status AS ENUM ('active', 'suspended', 'banned'); -- [수정됨] pending_verification 제거
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE card_rarity AS ENUM ('common', 'rare', 'epic', 'legendary');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;


-- =================================================================
-- 1. 플레이어 계정 (Steam Player Account Mapping)
-- [수정됨] 스팀 연동에 맞게 테이블 구조 대폭 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS players (
    id BIGINT PRIMARY KEY, -- SteamID64를 기본 키로 사용
    last_known_username VARCHAR(64), -- 스팀 닉네임 스냅샷 (선택 사항)
    status player_status NOT NULL DEFAULT 'active',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_login_at TIMESTAMPTZ
);
COMMENT ON TABLE players IS '스팀 플레이어 계정과 게임 데이터를 연결하는 핵심 테이블';
COMMENT ON COLUMN players.id IS '고유 플레이어 ID (SteamID64)';
COMMENT ON COLUMN players.last_known_username IS '마지막으로 알려진 플레이어의 스팀 닉네임';
COMMENT ON COLUMN players.status IS '계정 상태 (ENUM: active, suspended, banned)';
CREATE TRIGGER trigger_players_updated_at
BEFORE UPDATE ON players
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();


-- =================================================================
-- 2. 티어 정보 (Master Data - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS tiers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    order_key INT UNIQUE NOT NULL,
    icon_url TEXT
);
COMMENT ON TABLE tiers IS '게임의 티어(등급) 정의 마스터 테이블';
-- 예시 티어 데이터 삽입
INSERT INTO tiers (id, name, order_key, icon_url) VALUES
(1, 'Bronze', 1, '/icons/tiers/bronze.png'),
(2, 'Silver', 2, '/icons/tiers/silver.png'),
(3, 'Gold', 3, '/icons/tiers/gold.png'),
(4, 'Platinum', 4, '/icons/tiers/platinum.png'),
(5, 'Diamond', 5, '/icons/tiers/diamond.png')
ON CONFLICT (id) DO NOTHING;


-- =================================================================
-- 3. 플레이어 프로필 (Game-specific Profile & Stats)
-- [수정됨] 스팀 연동에 맞게 컬럼 축소 및 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS player_profiles (
    player_id BIGINT PRIMARY KEY REFERENCES players(id) ON DELETE CASCADE,
    mmr DOUBLE PRECISION NOT NULL DEFAULT 1500.0,
    rd DOUBLE PRECISION NOT NULL DEFAULT 350.0,
    volatility DOUBLE PRECISION NOT NULL DEFAULT 0.06,
    last_rating_update_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    tier_id INT NOT NULL REFERENCES tiers(id),
    rank_points INT NOT NULL DEFAULT 0,
    experience_points BIGINT NOT NULL DEFAULT 0,
    level INT NOT NULL DEFAULT 1,
    -- 게임 고유의 프로필 꾸미기 아이템이 있다면 아래 컬럼들을 사용
    -- custom_profile_icon_id VARCHAR(100),
    -- custom_profile_banner_id VARCHAR(100),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE player_profiles IS '게임 내 플레이어 프로필, 랭크, 스탯 정보';
COMMENT ON COLUMN player_profiles.player_id IS '플레이어의 SteamID64';
CREATE INDEX IF NOT EXISTS idx_player_profiles_mmr ON player_profiles(mmr);
CREATE TRIGGER trigger_player_profiles_updated_at
BEFORE UPDATE ON player_profiles
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();


-- =================================================================
-- 4. 게임 모드 (Master Data - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS game_modes (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_ranked BOOLEAN NOT NULL DEFAULT FALSE,
    player_count_per_team INT NOT NULL DEFAULT 1,
    team_count INT NOT NULL DEFAULT 2,
    is_active BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE game_modes IS '게임 모드 정의 마스터 테이블';
INSERT INTO game_modes (id, internal_name, display_name, is_ranked, player_count_per_team, team_count) VALUES
(1, 'ranked_1v1', '1v1 랭크 게임', TRUE, 1, 2),
(2, 'unranked_1v1', '1v1 일반 게임', FALSE, 1, 2)
ON CONFLICT (id) DO NOTHING;


-- =================================================================
-- 5. 게임 기록 (Match History - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS match_history (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    game_mode_id INT NOT NULL REFERENCES game_modes(id),
    started_at TIMESTAMPTZ NOT NULL,
    ended_at TIMESTAMPTZ NOT NULL,
    duration_seconds INT GENERATED ALWAYS AS (EXTRACT(EPOCH FROM (ended_at - started_at))::INT) STORED,
    winning_team_id INT,
    additional_data JSONB
);
COMMENT ON TABLE match_history IS '완료된 모든 게임의 기록';
CREATE INDEX IF NOT EXISTS idx_match_history_started_at ON match_history(started_at DESC);


-- =================================================================
-- 6. 매치 참여자 정보 (Match Participants)
-- [수정됨] player_id의 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS match_participants (
    match_id UUID NOT NULL REFERENCES match_history(id) ON DELETE CASCADE,
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE SET NULL,
    team_id INT NOT NULL,
    is_winner BOOLEAN NOT NULL,
    initial_mmr DOUBLE PRECISION NOT NULL,
    final_mmr DOUBLE PRECISION NOT NULL,
    mmr_change DOUBLE PRECISION GENERATED ALWAYS AS (final_mmr - initial_mmr) STORED,
    score INT,
    stats JSONB,
    disconnected BOOLEAN NOT NULL DEFAULT FALSE,
    PRIMARY KEY (match_id, player_id)
);
COMMENT ON TABLE match_participants IS '각 매치의 참여자 및 성과 정보';
CREATE INDEX IF NOT EXISTS idx_match_participants_player_id ON match_participants(player_id);


-- =================================================================
-- 7. 친구 관계 (Friendships)
-- [제거됨] 스팀 친구 시스템을 사용하므로 테이블 전체를 제거합니다.
-- =================================================================


-- =================================================================
-- 8. 카드 마스터 테이블 (Card Master Data - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS cards (
    id SERIAL PRIMARY KEY,
    internal_name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    rarity card_rarity,
    mana_cost INT NOT NULL DEFAULT 0,
    attack INT,
    health INT,
    card_type VARCHAR(50),
    image_url TEXT,
    attributes JSONB,
    is_collectible BOOLEAN NOT NULL DEFAULT TRUE
);
COMMENT ON TABLE cards IS '게임 내 모든 카드 정보 마스터 테이블';
-- 예시 카드 데이터 삽입
INSERT INTO cards (id, internal_name, display_name, rarity, mana_cost, attack, health, card_type, is_collectible) VALUES
(1, 'fireball', 'Fireball', 'common', 4, 6, 0, 'spell', TRUE),
(2, 'frost_golem', 'Frost Golem', 'rare', 5, 4, 5, 'minion', TRUE)
ON CONFLICT (id) DO NOTHING;


-- =================================================================
-- 9. 플레이어 소유 카드 (Player Card Collection)
-- [수정됨] player_id의 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS player_card_collection (
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
    is_new BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (player_id, card_id)
);
COMMENT ON TABLE player_card_collection IS '플레이어가 소유한 카드 목록';


-- =================================================================
-- 10. 플레이어 덱 (Player Decks)
-- [수정됨] player_id의 FK 변경
-- =================================================================
CREATE TABLE IF NOT EXISTS player_decks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    player_id BIGINT NOT NULL REFERENCES players(id) ON DELETE CASCADE,
    deck_name VARCHAR(100) NOT NULL,
    cover_card_id INT REFERENCES cards(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE (player_id, deck_name)
);
COMMENT ON TABLE player_decks IS '플레이어가 생성한 덱 목록';
CREATE TRIGGER trigger_player_decks_updated_at
BEFORE UPDATE ON player_decks
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();


-- =================================================================
-- 11. 덱 구성 카드 (Deck Card Entries - 변경 없음)
-- =================================================================
CREATE TABLE IF NOT EXISTS deck_cards (
    deck_id UUID NOT NULL REFERENCES player_decks(id) ON DELETE CASCADE,
    card_id INT NOT NULL REFERENCES cards(id) ON DELETE RESTRICT,
    quantity INT NOT NULL CHECK (quantity > 0 AND quantity <= 2),
    PRIMARY KEY (deck_id, card_id)
);
COMMENT ON TABLE deck_cards IS '각 덱에 포함된 카드 정보';


-- =================================================================
-- 스크립트 실행 완료
-- =================================================================
SELECT 'Database schema setup for Steam integration finished successfully.';
</file>

<file path="reset_and_migrate.bat">
@echo off
chcp 65001 >nul
echo ========================================
echo PostgreSQL Database Reset and Migration
echo ========================================

set PGPASSWORD=root
set DB_USER=postgres
set DB_HOST=localhost
set DB_PORT=5432
set DB_NAME=auth
set DEFAULT_DB=postgres
set PGCLIENTENCODING=UTF8

echo Dropping database '%DB_NAME%'...
psql -h %DB_HOST% -p %DB_PORT% -U %DB_USER% -d %DEFAULT_DB% -c "DROP DATABASE IF EXISTS %DB_NAME%;"

if %errorlevel% neq 0 (
    echo Error: Failed to drop database
    pause
    exit /b 1
)

echo Creating database '%DB_NAME%'...
psql -h %DB_HOST% -p %DB_PORT% -U %DB_USER% -d %DEFAULT_DB% -c "CREATE DATABASE %DB_NAME%;"

if %errorlevel% neq 0 (
    echo Error: Failed to create database
    pause
    exit /b 1
)

echo Running migrations...
for %%f in (migrations\0*.sql) do (
    echo Applying migration: %%f
    psql -h %DB_HOST% -p %DB_PORT% -U %DB_USER% -d %DB_NAME% -f "%%f"
    if %errorlevel% neq 0 (
        echo Error: Failed to apply migration %%f
        pause
        exit /b 1
    )
)

echo ========================================
echo Database reset and migration completed successfully!
echo ========================================
pause
</file>

<file path="src/auth_server/db_operation.rs">
// src/auth/db_operation.rs

use crate::auth_server::model::*;
use anyhow::Result;
use sqlx::PgPool;
use uuid::Uuid;

// =================================================================
// 1. 플레이어 계정 (Players) - 스팀 연동 버전
// =================================================================

/// 신규 플레이어를 생성하거나, 기존 플레이어의 로그인 정보를 업데이트합니다.
/// 스팀 인증 성공 후 호출되며, 플레이어 프로필이 없으면 함께 생성합니다.
pub async fn upsert_player_on_login(
    pool: &PgPool,
    steam_id: i64,
    username: &str,
) -> Result<Player> {
    // 트랜잭션 시작
    let mut tx = pool.begin().await?;

    // 플레이어 정보 INSERT 또는 UPDATE
    let player = sqlx::query_as!(
        Player,
        r#"
        INSERT INTO players (id, last_known_username, last_login_at)
        VALUES ($1, $2, NOW())
        ON CONFLICT (id) DO UPDATE
        SET last_known_username = EXCLUDED.last_known_username,
            last_login_at = NOW(),
            updated_at = NOW()
        RETURNING id, last_known_username, status AS "status: _", created_at, updated_at, last_login_at
        "#,
        steam_id,
        username,
    )
    .fetch_one(&mut *tx) // 트랜잭션 내에서 실행
    .await?;

    // 플레이어 프로필이 없는 경우에만 생성
    sqlx::query!(
        "INSERT INTO player_profiles (player_id) VALUES ($1) ON CONFLICT (player_id) DO NOTHING",
        steam_id
    )
    .execute(&mut *tx)
    .await?;

    // 트랜잭션 커밋
    tx.commit().await?;

    Ok(player)
}

pub async fn get_player_by_id(pool: &PgPool, player_id: i64) -> Result<Option<Player>> {
    sqlx::query_as!(
        Player,
        r#"SELECT id, last_known_username, status AS "status: _", created_at, updated_at, last_login_at FROM players WHERE id = $1"#,
        player_id
    )
    .fetch_optional(pool)
    .await
    .map_err(Into::into)
}

pub async fn update_player_status(
    pool: &PgPool,
    player_id: i64,
    new_status: PlayerStatus,
) -> Result<Player> {
    sqlx::query_as!(
        Player,
        r#"
        UPDATE players SET status = $1 WHERE id = $2
        RETURNING id, last_known_username, status AS "status: _", created_at, updated_at, last_login_at
        "#,
        new_status as _,
        player_id
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 2. 플레이어 프로필 (Player Profiles)
// =================================================================

pub async fn get_player_profile(pool: &PgPool, player_id: i64) -> Result<Option<PlayerProfile>> {
    sqlx::query_as!(
        PlayerProfile,
        "SELECT * FROM player_profiles WHERE player_id = $1",
        player_id
    )
    .fetch_optional(pool)
    .await
    .map_err(Into::into)
}

pub async fn update_player_mmr(
    pool: &PgPool,
    player_id: i64,
    new_mmr: f64,
    new_rd: f64,
    new_volatility: f64,
) -> Result<PlayerProfile> {
    sqlx::query_as!(
        PlayerProfile,
        r#"
        UPDATE player_profiles
        SET mmr = $1, rd = $2, volatility = $3, last_rating_update_at = NOW()
        WHERE player_id = $4
        RETURNING *
        "#,
        new_mmr,
        new_rd,
        new_volatility,
        player_id
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 3. 티어 정보 (Tiers) - 변경 없음
// =================================================================
pub async fn get_all_tiers(pool: &PgPool) -> Result<Vec<Tier>> {
    sqlx::query_as!(Tier, "SELECT * FROM tiers ORDER BY order_key")
        .fetch_all(pool)
        .await
        .map_err(Into::into)
}

// =================================================================
// 5 & 6. 게임 기록 (Match History & Participants)
// =================================================================
pub struct MatchResult<'a> {
    pub player_id: i64, // Uuid -> i64
    pub team_id: i32,
    pub is_winner: bool,
    pub initial_mmr: f64,
    pub final_mmr: f64,
    pub score: Option<i32>,
    pub stats: Option<&'a serde_json::Value>,
}

pub async fn record_match_result(
    pool: &PgPool,
    game_mode_id: i32,
    winning_team_id: Option<i32>,
    participants: &[MatchResult<'_>],
) -> Result<MatchHistory> {
    let mut tx = pool.begin().await?;

    let now = chrono::Utc::now();
    let match_history = sqlx::query_as!(
        MatchHistory,
        r#"
        INSERT INTO match_history (game_mode_id, started_at, ended_at, winning_team_id)
        VALUES ($1, $2, $3, $4) RETURNING *
        "#,
        game_mode_id,
        now,
        now,
        winning_team_id
    )
    .fetch_one(&mut *tx)
    .await?;

    for p in participants {
        sqlx::query!(
            r#"
            INSERT INTO match_participants (match_id, player_id, team_id, is_winner, initial_mmr, final_mmr, score, stats)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            "#,
            match_history.id,
            p.player_id,
            p.team_id,
            p.is_winner,
            p.initial_mmr,
            p.final_mmr,
            p.score,
            p.stats
        )
        .execute(&mut *tx)
        .await?;

        // MMR 업데이트
        sqlx::query!(
            "UPDATE player_profiles SET mmr = $1 WHERE player_id = $2",
            p.final_mmr,
            p.player_id
        )
        .execute(&mut *tx)
        .await?;
    }

    tx.commit().await?;
    Ok(match_history)
}

pub async fn get_player_match_history(
    pool: &PgPool,
    player_id: i64, // Uuid -> i64
    limit: i64,
) -> Result<Vec<MatchHistory>> {
    sqlx::query_as!(
        MatchHistory,
        r#"
        SELECT mh.*
        FROM match_history mh
        JOIN match_participants mp ON mh.id = mp.match_id
        WHERE mp.player_id = $1
        ORDER BY mh.started_at DESC
        LIMIT $2
        "#,
        player_id,
        limit
    )
    .fetch_all(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 9. 플레이어 카드 컬렉션 (Player Card Collection)
// =================================================================

pub async fn add_card_to_collection(
    pool: &PgPool,
    player_id: i64, // Uuid -> i64
    card_id: i32,
    quantity: i32,
) -> Result<PlayerCardCollection> {
    sqlx::query_as!(
        PlayerCardCollection,
        r#"
        INSERT INTO player_card_collection (player_id, card_id, quantity)
        VALUES ($1, $2, $3)
        ON CONFLICT (player_id, card_id)
        DO UPDATE SET quantity = player_card_collection.quantity + EXCLUDED.quantity
        RETURNING *
        "#,
        player_id,
        card_id,
        quantity
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

pub async fn get_player_card_collection(
    pool: &PgPool,
    player_id: i64,
) -> Result<Vec<PlayerCardCollection>> {
    sqlx::query_as!(
        PlayerCardCollection,
        "SELECT * FROM player_card_collection WHERE player_id = $1",
        player_id
    )
    .fetch_all(pool)
    .await
    .map_err(Into::into)
}

// =================================================================
// 10 & 11. 덱 및 덱 카드 (Player Decks & Deck Cards)
// =================================================================

pub async fn create_deck(pool: &PgPool, player_id: i64, deck_name: &str) -> Result<PlayerDeck> {
    sqlx::query_as!(
        PlayerDeck,
        "INSERT INTO player_decks (player_id, deck_name) VALUES ($1, $2) RETURNING *",
        player_id,
        deck_name
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

pub async fn add_card_to_deck(
    pool: &PgPool,
    deck_id: Uuid,
    card_id: i32,
    quantity: i32,
) -> Result<DeckCard> {
    sqlx::query_as!(
        DeckCard,
        r#"
        INSERT INTO deck_cards (deck_id, card_id, quantity)
        VALUES ($1, $2, $3)
        ON CONFLICT (deck_id, card_id) DO UPDATE SET quantity = EXCLUDED.quantity
        RETURNING *
        "#,
        deck_id,
        card_id,
        quantity
    )
    .fetch_one(pool)
    .await
    .map_err(Into::into)
}

// 덱 정보와 카드 목록을 함께 가져오는 함수
#[derive(Debug)]
pub struct DeckWithCards {
    pub deck_info: PlayerDeck,
    pub cards: Vec<DeckCard>,
}

pub async fn get_deck_with_cards(pool: &PgPool, deck_id: Uuid) -> Result<Option<DeckWithCards>> {
    let deck_info = match sqlx::query_as!(
        PlayerDeck,
        "SELECT * FROM player_decks WHERE id = $1",
        deck_id
    )
    .fetch_optional(pool)
    .await?
    {
        Some(deck) => deck,
        None => return Ok(None),
    };

    let cards = sqlx::query_as!(
        DeckCard,
        "SELECT * FROM deck_cards WHERE deck_id = $1",
        deck_id
    )
    .fetch_all(pool)
    .await?;

    Ok(Some(DeckWithCards { deck_info, cards }))
}

pub async fn get_player_decks(pool: &PgPool, player_id: i64) -> Result<Vec<PlayerDeck>> {
    sqlx::query_as!(
        PlayerDeck,
        "SELECT * FROM player_decks WHERE player_id = $1",
        player_id
    )
    .fetch_all(pool)
    .await
    .map_err(Into::into)
}
</file>

<file path="src/auth_server/end_point.rs">
use actix_web::{web, HttpResponse};
use serde::{Deserialize, Serialize};

use crate::auth_server::{
    db_operation,
    errors::AuthError,
    types::{AppState, SteamApiResponse},
};

// --- HTTP 요청 본문 구조체 ---
#[derive(Deserialize)]
struct SteamAuthRequest {
    ticket: String,
}

#[derive(Deserialize, Serialize)]
struct AuthSuccessResponse {
    message: String,
    steam_id: String,
}

// --- 엔드포인트 핸들러 ---
/// POST /auth/steam
/// 클라이언트로부터 스팀 티켓을 받아 인증을 처리합니다.

// --- 핸들러 수정: 스팀 웹 API로 직접 요청 ---
#[actix_web::post("/steam")] // POST 메소드로 변경, 경로는 /auth/steam
pub async fn steam_authentication_handler(
    state: web::Data<AppState>,
    req_body: web::Json<SteamAuthRequest>,
) -> Result<HttpResponse, AuthError> {
    let api_url = "https://api.steampowered.com/ISteamUserAuth/AuthenticateUserTicket/v1/";

    // 1. 스팀 웹 API에 GET 요청을 보냅니다.
    let res = state
        .http_client
        .get(api_url)
        .query(&[
            ("key", &state.steam_web_api_key),
            ("appid", &state.app_id.to_string()),
            ("ticket", &req_body.ticket),
            ("identity", &state.expected_identity),
        ])
        .send()
        .await
        .map_err(|e| AuthError::InternalServerError(anyhow::anyhow!(e)))?;

    // 2. 응답 상태 코드 확인
    if !res.status().is_success() {
        return Err(AuthError::GatewayTimeout(format!(
            "Steam API returned non-success status: {}",
            res.status()
        )));
    }

    // 3. JSON 응답 파싱
    let steam_response = res
        .json::<SteamApiResponse>()
        .await
        .map_err(|e| AuthError::InternalServerError(anyhow::anyhow!(e)))?;

    // 4. 스팀 응답의 유효성 검사
    if let Some(params) = steam_response.response.params {
        if params.result == "OK" {
            // 성공!
            let steam_id_u64 = params.steamid.parse::<u64>().map_err(|_| {
                AuthError::InternalServerError(anyhow::anyhow!("Steam returned invalid SteamID"))
            })?;

            tracing::info!(
                "Steam Web API authentication successful for SteamID: {}",
                steam_id_u64
            );

            // 5. DB 작업 수행
            // let temp_username = format!("user_{}", steam_id_u64);
            // db_operation::upsert_player_on_login(
            //     &state.db_pool,
            //     steam_id_u64 as i64,
            //     &temp_username,
            // )
            // .await?;

            Ok(HttpResponse::Ok().json(AuthSuccessResponse {
                message: "Steam Web API authentication successful.".to_string(),
                steam_id: steam_id_u64.to_string(),
            }))
        } else {
            // 결과가 "OK"가 아닌 경우
            Err(AuthError::Unauthorized(format!(
                "Steam validation failed with result: {}",
                params.result
            )))
        }
    } else if let Some(error) = steam_response.response.error {
        // 스팀 API가 에러를 반환한 경우
        Err(AuthError::Unauthorized(format!(
            "Steam API Error {}: {}",
            error.errorcode, error.errordesc
        )))
    } else {
        Err(AuthError::InternalServerError(anyhow::anyhow!(
            "Invalid response structure from Steam API"
        )))
    }
}
</file>

<file path="src/auth_server/errors.rs">
// src/auth/error.rs

use actix_web::{http::StatusCode, HttpResponse, ResponseError};
use serde_json::json;
use std::fmt;

// 애플리케이션의 모든 에러를 통합 관리하는 Enum
#[derive(Debug)]
pub enum AuthError {
    BadRequest(String),
    Unauthorized(String),
    GatewayTimeout(String),
    InternalServerError(anyhow::Error), // 내부 에러는 anyhow로 감싸서 상세 정보 유지
}

// 에러 메시지를 예쁘게 출력하기 위한 Display 구현
impl fmt::Display for AuthError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AuthError::BadRequest(reason) => write!(f, "Bad Request: {}", reason),
            AuthError::Unauthorized(reason) => write!(f, "Unauthorized: {}", reason),
            AuthError::GatewayTimeout(reason) => write!(f, "Gateway Timeout: {}", reason),
            // anyhow::Error는 상세한 에러 체인을 포함하므로, 로그에 매우 유용합니다.
            AuthError::InternalServerError(e) => write!(f, "Internal Server Error: {:?}", e),
        }
    }
}

// Actix-web이 에러를 HTTP 응답으로 변환할 수 있도록 ResponseError 구현
impl ResponseError for AuthError {
    // 각 에러 타입에 맞는 HTTP 상태 코드를 반환합니다.
    fn status_code(&self) -> StatusCode {
        match self {
            AuthError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AuthError::Unauthorized(_) => StatusCode::UNAUTHORIZED,
            AuthError::GatewayTimeout(_) => StatusCode::GATEWAY_TIMEOUT,
            AuthError::InternalServerError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    // 실제 HTTP 응답 본문을 생성합니다.
    fn error_response(&self) -> HttpResponse {
        // 모든 에러를 서버 로그에 기록합니다 (중요!)
        tracing::error!("{}", self);

        let status = self.status_code();
        let message = match self {
            // 5xx 서버 에러는 클라이언트에게 상세 내용을 노출하지 않는 것이 보안상 좋습니다.
            AuthError::InternalServerError(_) => "An internal server error occurred.".to_string(),
            // 4xx 클라이언트 에러는 원인을 알려주는 것이 좋습니다.
            _ => self.to_string(),
        };

        HttpResponse::build(status).json(json!({ "error": message }))
    }
}

// 다른 라이브러리의 에러를 우리 AuthError로 쉽게 변환하기 위한 `From` 구현
impl From<actix::MailboxError> for AuthError {
    fn from(e: actix::MailboxError) -> Self {
        AuthError::InternalServerError(anyhow::anyhow!(e))
    }
}

impl From<anyhow::Error> for AuthError {
    fn from(e: anyhow::Error) -> Self {
        AuthError::InternalServerError(e)
    }
}

impl From<sqlx::Error> for AuthError {
    fn from(e: sqlx::Error) -> Self {
        AuthError::InternalServerError(anyhow::anyhow!(e))
    }
}
</file>

<file path="src/auth_server/mod.rs">
pub mod db_operation;
pub mod end_point;
pub mod errors;
pub mod model;
pub mod types;
</file>

<file path="src/auth_server/model.rs">
// src/auth/model.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::prelude::FromRow;
use uuid::Uuid;

// =================================================================
// ENUM 타입 정의 (Type-safe Enums)
// =================================================================

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "player_status", rename_all = "snake_case")]
pub enum PlayerStatus {
    Active,
    Suspended,
    Banned,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "card_rarity", rename_all = "snake_case")]
pub enum CardRarity {
    Common,
    Rare,
    Epic,
    Legendary,
}

// =================================================================
// 테이블 매핑 구조체 (Table Mapping Structs)
// =================================================================

// 1. 플레이어 계정 (Steam Player Account)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct Player {
    pub id: i64, // [수정됨] SteamID64 (BIGINT)
    pub last_known_username: Option<String>,
    pub status: PlayerStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub last_login_at: Option<DateTime<Utc>>,
}

// 2. 플레이어 프로필 (Game-specific Profile)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct PlayerProfile {
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub mmr: f64,
    pub rd: f64,
    pub volatility: f64,
    pub last_rating_update_at: DateTime<Utc>,
    pub tier_id: i32,
    pub rank_points: i32,
    pub experience_points: i64,
    pub level: i32,
    pub updated_at: DateTime<Utc>,
}

// 3. 티어 정보 (Master Data - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct Tier {
    pub id: i32,
    pub name: String,
    pub order_key: i32,
    pub icon_url: Option<String>,
}

// 4. 게임 모드 (Master Data - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct GameMode {
    pub id: i32,
    pub internal_name: String,
    pub display_name: String,
    pub description: Option<String>,
    pub is_ranked: bool,
    pub player_count_per_team: i32,
    pub team_count: i32,
    pub is_active: bool,
}

// 5. 게임 기록 (Match History)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct MatchHistory {
    pub id: Uuid,
    pub game_mode_id: i32,
    pub started_at: DateTime<Utc>,
    pub ended_at: DateTime<Utc>,
    pub duration_seconds: Option<i32>, // DB에서는 GENERATED 이지만, Rust에서는 읽기 전용이므로 Option<i32>
    pub winning_team_id: Option<i32>,
    pub additional_data: Option<serde_json::Value>,
}

// 6. 매치 참여자 (Match Participants)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct MatchParticipant {
    pub match_id: Uuid,
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub team_id: i32,
    pub is_winner: bool,
    pub initial_mmr: f64,
    pub final_mmr: f64,
    pub mmr_change: f64, // DB에서는 GENERATED 이지만, Rust에서는 읽기 전용
    pub score: Option<i32>,
    pub stats: Option<serde_json::Value>,
    pub disconnected: bool,
}

// 7. 친구 관계 (Friendships) - [제거됨]

// 8. 카드 마스터 (Card Master Data - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct Card {
    pub id: i32,
    pub internal_name: String,
    pub display_name: String,
    pub description: Option<String>,
    pub rarity: Option<CardRarity>,
    pub mana_cost: i32,
    pub attack: Option<i32>,
    pub health: Option<i32>,
    pub card_type: Option<String>,
    pub image_url: Option<String>,
    pub attributes: Option<serde_json::Value>,
    pub is_collectible: bool,
}

// 9. 플레이어 소유 카드 (Player Card Collection)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct PlayerCardCollection {
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub card_id: i32,
    pub quantity: i32,
    pub is_new: bool,
}

// 10. 플레이어 덱 (Player Decks)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct PlayerDeck {
    pub id: Uuid,
    pub player_id: i64, // [수정됨] SteamID64 (BIGINT), 외래 키
    pub deck_name: String,
    pub cover_card_id: Option<i32>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

// 11. 덱 구성 카드 (Deck Card Entries - 변경 없음)
#[derive(Debug, FromRow, Serialize, Deserialize)]
pub struct DeckCard {
    pub deck_id: Uuid,
    pub card_id: i32,
    pub quantity: i32,
}
</file>

<file path="src/auth_server/types.rs">
use sqlx::PgPool;

// --- AppState: 서버 전체에서 공유될 상태 ---
// 액터 주소와 DB 커넥션 풀을 포함합니다.
#[derive(Clone)]
pub struct AppState {
    pub http_client: reqwest::Client,
    pub db_pool: PgPool,
    pub steam_web_api_key: String,
    pub app_id: u32,
    pub expected_identity: String,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiResponse {
    pub response: SteamApiResponseDetails,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiResponseDetails {
    pub params: Option<SteamApiResponseParams>,
    pub error: Option<SteamApiError>,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiResponseParams {
    pub result: String,
    pub steamid: String,
    pub ownersteamid: String,
    pub vacbanned: bool,
    pub publisherbanned: bool,
}

#[derive(serde::Deserialize, Debug)]
pub struct SteamApiError {
    pub errorcode: i32,
    pub errordesc: String,
}
</file>

<file path="src/lib.rs">
pub mod auth_server;

use std::sync::Once;

use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

static INIT: Once = Once::new();
static mut GUARD: Option<tracing_appender::non_blocking::WorkerGuard> = None;
pub fn setup_logger() {
    INIT.call_once(|| {
        // 1. 파일 로거 설정
        let file_appender = RollingFileAppender::new(Rotation::DAILY, "logs", "app.log");
        let (non_blocking_file_writer, _guard) = tracing_appender::non_blocking(file_appender);

        // 2. 로그 레벨 필터 설정 (환경 변수 또는 기본값 INFO)
        let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")); // 기본 INFO 레벨

        // 3. 콘솔 출력 레이어 설정
        // let console_layer = fmt::layer()
        //     .with_writer(io::stdout) // 표준 출력으로 설정
        //     .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
        //     .with_thread_ids(true) // 스레드 ID 포함
        //     .with_thread_names(true) // 스레드 이름 포함
        //     .with_file(true) // 파일 경로 포함
        //     .with_line_number(true) // 라인 번호 포함
        //     .with_target(false) // target 정보 제외 (선택 사항)
        //     .pretty(); // 사람이 읽기 좋은 포맷

        // 4. 파일 출력 레이어 설정
        let file_layer = fmt::layer()
            .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
            .with_ansi(false) // 파일에는 ANSI 코드 제외
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .pretty();

        // 5. 레지스트리(Registry)에 필터와 레이어 결합
        tracing_subscriber::registry()
            .with(filter) // 필터를 먼저 적용
            // .with(console_layer) // 콘솔 레이어 추가
            .with(file_layer) // 파일 레이어 추가
            .init(); // 전역 Subscriber로 설정

        unsafe {
            GUARD = Some(_guard);
        }

        tracing::info!("로거 초기화 완료: 콘솔 및 파일(logs/app.log) 출력 활성화.");
    });
}
</file>

<file path="src/main.rs">
use actix_web::{web, App, HttpServer};
use simulator_auth_server::auth_server::{
    end_point::steam_authentication_handler, types::AppState,
};
use sqlx::postgres::PgPoolOptions;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // --- 1. 환경 설정 및 로깅 초기화 ---
    dotenvy::dotenv().ok(); // .env 파일 로드
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    std::fs::write("steam_appid.txt", "480")?;

    tracing::info!("Steamworks SDK Initialized.");

    let database_url =
        std::env::var("DATABASE_URL").expect("DATABASE_URL must be set in .env file");
    let steam_web_api_key =
        std::env::var("STEAM_WEB_API_KEY").expect("STEAM_WEB_API_KEY must be set in .env file");
    let db_pool = PgPoolOptions::new()
        .max_connections(10)
        .connect(&database_url)
        .await
        .expect("Failed to create database connection pool");
    tracing::info!("Database connection pool created.");

    let app_state = AppState {
        http_client: reqwest::Client::new(),
        db_pool,
        steam_web_api_key: steam_web_api_key.clone(),
        app_id: 480,
        expected_identity: std::env::var("EXPECTED_IDENTITY")
            .expect("EXPECTED_IDENTITY must be set in .env file"),
    };
    let bind_address = "127.0.0.1:8080";
    tracing::info!("Starting Actix-Web server on {}", bind_address);

    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .service(steam_authentication_handler)
    })
    .bind(bind_address)?
    .run()
    .await
}
</file>

<file path="steam_appid.txt">
480
</file>

<file path="tests/test.rs">
use actix_web::{test, web, App};
use serde_json::json;
use simulator_auth_server::auth_server::{
    db_operation, end_point::steam_authentication_handler, types::AppState,
};
use sqlx::PgPool;
use std::sync::Once;
use steamworks::{Client, TicketForWebApiResponse};

// ... (setup_test_environment 함수는 그대로 유지) ...
static INIT: Once = Once::new();

fn setup_test_environment() {
    INIT.call_once(|| {
        dotenvy::dotenv().ok();
        let _ = tracing_subscriber::fmt().with_env_filter("info").try_init();
        std::fs::write("steam_appid.txt", "480").expect("Failed to write steam_appid.txt for test");
    });
}

/// 웹 API용 티켓을 발급받는 헬퍼 함수
fn get_web_api_ticket() -> (u64, String) {
    let client = Client::init().unwrap();
    let steam_id = client.user().steam_id().raw();

    let (tx, rx) = std::sync::mpsc::channel();

    let _cb = client.register_callback(move |resp: TicketForWebApiResponse| {
        if resp.result.is_ok() {
            let ticket_hex = hex::encode(resp.ticket);
            tx.send(Some(ticket_hex)).unwrap();
        } else {
            tx.send(None).unwrap();
        }
    });

    // 웹 API용 티켓을 요청합니다.
    client
        .user()
        .authentication_session_ticket_for_webapi("test_identity");

    for _ in 0..100 {
        client.run_callbacks();
        if let Ok(Some(ticket)) = rx.try_recv() {
            return (steam_id, ticket);
        }
        std::thread::sleep(std::time::Duration::from_millis(50));
    }
    panic!("Failed to get web api ticket");
}

#[actix_web::test]
async fn test_web_api_auth_endpoint() {
    setup_test_environment();

    // 1. 클라이언트 역할: 웹 API용 스팀 티켓 발급
    let (my_steam_id, steam_ticket_hex) = tokio::task::spawn_blocking(get_web_api_ticket)
        .await
        .unwrap();

    // 2. 서버 역할: 테스트 환경 구성
    let db_pool = PgPool::connect(&std::env::var("DATABASE_URL").unwrap())
        .await
        .unwrap();
    let http_client = reqwest::Client::new();
    let steam_web_api_key = std::env::var("STEAM_WEB_API_KEY").unwrap();

    let app_state = AppState {
        http_client,
        db_pool: db_pool.clone(),
        steam_web_api_key,
        app_id: 480,
        expected_identity: std::env::var("EXPECTED_IDENTITY")
            .unwrap_or("test_identity".to_string()),
    };

    let app = test::init_service(
        App::new()
            .app_data(web::Data::new(app_state))
            .service(web::scope("/auth").service(steam_authentication_handler)),
    )
    .await;

    // 3. 엔드포인트에 HTTP 요청 보내기
    let req_body = json!({ "ticket": steam_ticket_hex });
    let req = test::TestRequest::post()
        .uri("/auth/steam")
        .insert_header(("Content-Type", "application/json"))
        .set_json(&req_body)
        .to_request();

    let resp = test::call_service(&app, req).await;

    // 4. 응답 검증
    assert!(
        resp.status().is_success(),
        "Request failed with status: {}",
        resp.status()
    );
    let body: serde_json::Value = test::read_body_json(resp).await;
    assert_eq!(body["steam_id"], my_steam_id.to_string());

    // 5. DB 검증
    // let player = db_operation::get_player_by_id(&db_pool, my_steam_id as i64)
    //     .await
    //     .unwrap()
    //     .unwrap();
    // assert_eq!(player.id, my_steam_id as i64);

    tracing::info!("✅ Web API auth endpoint test PASSED!");
}
</file>

</files>
