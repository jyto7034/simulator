# 경쟁 상태(Race Condition) 버그 분석 및 해결 계획

**발생일:** 2025-07-06

---

## 1. 문제 상황 분석

`match_server`의 로그를 분석한 결과, `HandleLoadingComplete` 메시지 핸들러에서 경쟁 상태가 발생하는 것을 확인했다.

1.  두 클라이언트가 거의 동시에 `LoadingComplete` 메시지를 `Matchmaker`에게 보낸다.
2.  `Matchmaker` 액터는 각 메시지를 순차적으로 처리하지만, 핸들러의 로직이 원자적(atomic)이지 않아 문제가 발생한다.
3.  첫 번째 메시지 처리 시, 해당 플레이어의 상태만 "ready"로 변경되고 `all_ready` 조건은 `false`가 된다.
4.  두 번째 메시지 처리 시, 두 번째 플레이어의 상태가 "ready"로 변경되고, `all_ready` 조건이 `true`가 된다.
5.  **문제:** 현재 로직의 결함으로 인해, 두 메시지 처리 시 모두 `all_ready` 조건이 `true`로 인식되어 게임 세션 생성 로직이 **두 번 호출**된다.
6.  **결과:** `dedicated_server`에 동일한 플레이어 그룹에 대한 세션이 2개 생성되고, 각 클라이언트는 서로 다른 `match_found` 메시지를 받게 되어 시스템 전체가 비정상 상태에 빠진다.

## 2. 근본 원인

`HandleLoadingComplete` 핸들러 내의 "플레이어 상태 변경"과 "모든 플레이어 상태 확인" 과정이 분리되어 있어 원자성을 보장하지 못한다.

## 3. 해결 방안: Redis Lua 스크립트를 이용한 원자적 연산

이러한 경쟁 상태를 해결하기 위한 가장 확실한 방법은 관련 Redis 연산을 하나의 원자적 단위로 묶는 것이다.

-   **3.1. 새로운 Lua 스크립트 도입:**
    -   `HandleLoadingComplete` 핸들러에서 사용할 새로운 Lua 스크립트를 작성한다.
    -   이 스크립트는 아래의 작업을 **원자적으로** 수행한다.
        1.  입력으로 받은 플레이어의 상태를 `HSET`을 이용해 "ready"로 변경한다.
        2.  `HGETALL`로 해당 로딩 세션의 모든 플레이어 상태를 가져온다.
        3.  모든 플레이어의 상태가 "ready"인지 스크립트 내부에서 검사한다.
        4.  **만약 모두 "ready"라면:**
            -   `DEL` 명령어로 해당 로딩 세션 키를 즉시 삭제하여 다른 중복 호출을 원천 차단한다.
            -   매칭된 플레이어 ID 목록을 반환한다.
        5.  **아직 준비되지 않은 플레이어가 있다면:**
            -   빈(empty) 목록을 반환한다.

-   **3.2. `HandleLoadingComplete` 핸들러 로직 수정:**
    -   기존의 `HSET`, `HGETALL` 로직을 제거한다.
    -   대신 위에서 작성한 Lua 스크립트를 호출한다.
    -   스크립트의 반환 값이 **비어있지 않은 경우에만 (즉, 내가 처음으로 '모두 준비' 상태를 만족시킨 유일한 호출인 경우에만)** 게임 세션 생성 로직(`FindAvailableServer` 호출 등)을 단 한 번 실행한다.

---
이 계획에 따라 코드를 수정하여 경쟁 상태 문제를 해결한다.
