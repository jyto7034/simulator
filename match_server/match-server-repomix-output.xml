This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/workflows/main.yml
.gitignore
Cargo.toml
config/development.toml
config/production.toml
SAFETY_IMPROVEMENTS.md
scripts/DEQUEUE_PLAYER.lua
scripts/ENQUEUE_PLAYER.lua
scripts/TRY_MATCH_POP.lua
src/env.rs
src/lib.rs
src/main.rs
src/matchmaker/common.rs
src/matchmaker/messages.rs
src/matchmaker/mod.rs
src/matchmaker/normal/handlers.rs
src/matchmaker/normal/mod.rs
src/matchmaker/operations/dequeue.rs
src/matchmaker/operations/enqueue.rs
src/matchmaker/operations/mod.rs
src/matchmaker/operations/notify.rs
src/matchmaker/operations/try_match.rs
src/matchmaker/patry/mod.rs
src/matchmaker/rank/handlers.rs
src/matchmaker/rank/mod.rs
src/matchmaker/scripts.rs
src/metrics.rs
src/protocol.rs
src/session/handlers.rs
src/session/helper.rs
src/session/mod.rs
src/subscript/handlers.rs
src/subscript/messages.rs
src/subscript/mod.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path=".gitignore">
/target
</file>

<file path="Cargo.toml">
[package]
name = "match_server"
version = "0.1.0"
edition = "2021"
description = "card backend"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html


[dependencies]
async-trait = "0.1.89"
tokio = { version = "1.15", features = ["full", "tracing"] }
tokio-util = "0.7"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
actix-web = "4.9.0"
actix = "=0.13.5"
actix-web-actors = "4.3.0"
reqwest = { version = "0.12.12", features = ["json"] }
uuid = { version = "1.14.0", features = ["v4", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
redis = { version = "0.22.3", features = ["tokio-comp", "connection-manager"] }
dotenv = "0.15.0"
config = {version = "0.15.11", features = ["toml"]}
jsonwebtoken = "9.3.1"
chrono = { version = "0.4.41", features = ["serde"] }
thiserror = "1.0"
backoff = { version = "0.4.0", features = ["tokio"] }
lazy_static = "1.5.0"

metrics = { path = "../metrics" }
prometheus = { version = "0.14", features = ["process"] }

[dev-dependencies]
tokio-test = "0.4"
</file>

<file path="config/development.toml">
# 서버 설정
[server]
bind_address = "0.0.0.0"
port = 8080
log_level = "info" # 로그 레벨
# metrics_auth_token = "secret-token-here"  # Optional: enable for metrics endpoint auth

# 로깅 설정
[logging]
directory = "logs"
filename = "app.log"

# Redis 설정
[redis]
url = "redis://127.0.0.1:6379"
max_reconnect_attempts = 10
initial_reconnect_delay_ms = 1000
max_reconnect_delay_ms = 60000

[jwt]
secret = "your-super-secret-and-long-key-that-no-one-knows"

# 재시도 설정
[retry]
message_max_elapsed_time_ms = 500
message_initial_interval_ms = 10
message_max_interval_ms = 100

# 매치메이킹 설정
[matchmaking]
try_match_tick_interval_seconds = 1
queue_key_prefix = "queue"
queue_order_key_prefix = "queue_order"
match_fetch_request_channel_prefix = "match_fetch_req"
match_fetch_ack_channel_prefix = "match_fetch_ack"
battle_request_channel = "battle:request"
battle_result_channel_prefix = "pod"
heartbeat_interval_seconds = 30
heartbeat_timeout = 120
max_dedicated_server_retries = 5
dedicated_request_timeout_seconds = 3
allocation_token_ttl_seconds = 20
slow_loading_threshold_seconds = 15

# 게임 서버 상태 문자열
[server_status]
idle = "idle"

# 게임 모드 목록 (테이블 배열)
# 각 [[matchmaking.game_modes]] 항목이 하나의 게임 모드를 정의합니다.
[[matchmaking.game_modes]]
game_mode = "Normal"        # 게임 모드
required_players = 2        # 매칭에 필요한 인원
use_mmr_matching = false    # MMR 기반 매칭 사용 여부 (일반 모드)

[[matchmaking.game_modes]]
game_mode = "Ranked"
required_players = 2
use_mmr_matching = true     # 랭크 모드에서는 이 값을 true로 설정
</file>

<file path="config/production.toml">
# 서버 설정
[server]
bind_address = "0.0.0.0"
port = 8080
log_level = "warn" # 로그 레벨
# metrics_auth_token = "CHANGE-ME-IN-PRODUCTION"  # Set via env: APP_SERVER__METRICS_AUTH_TOKEN

# 로깅 설정
[logging]
directory = "logs"
filename = "app.log"

# Redis 설정
[redis]
url = "redis://your-production-redis-endpoint:6379"
max_reconnect_attempts = 10
initial_reconnect_delay_ms = 1000
max_reconnect_delay_ms = 60000

[jwt]
secret = "a-very-secure-secret-that-should-be-injected-via-env-vars"

# 재시도 설정
[retry]
message_max_elapsed_time_ms = 500
message_initial_interval_ms = 10
message_max_interval_ms = 100

# 매치메이킹 설정
[matchmaking]
try_match_tick_interval_seconds = 5
queue_key_prefix = "queue"
queue_order_key_prefix = "queue_order"
match_fetch_request_channel_prefix = "match_fetch_req"
match_fetch_ack_channel_prefix = "match_fetch_ack"
battle_request_channel = "battle:request"
battle_result_channel_prefix = "pod"
heartbeat_interval_seconds = 30
heartbeat_timeout = 120
max_dedicated_server_retries = 5
dedicated_request_timeout_seconds = 5
allocation_token_ttl_seconds = 20
slow_loading_threshold_seconds = 20

# 블랙리스트 설정
[blacklist]
timeout_threshold = 3
timeout_window_hours = 1
block_duration_minutes = 10
check_ip_change = true
ip_change_strategy = "ReduceByPercent"
ip_change_reduction_percent = 50
ip_change_min_violations_to_keep = 1

# 게임 서버 상태 문자열
[server_status]
idle = "idle"

# 게임 모드 목록 (테이블 배열)
[[matchmaking.game_modes]]
game_mode = "Normal"
required_players = 2
use_mmr_matching = false

[[matchmaking.game_modes]]
game_mode = "Ranked"
required_players = 2
use_mmr_matching = true
</file>

<file path="SAFETY_IMPROVEMENTS.md">
# Match Server 안전 장치 개선 사항

현재 `CancellationToken`으로 좀비 Future 방지는 구현되었으나, 추가로 필요한 안전 장치들을 정리합니다.

---

## 우선순위 요약

| 우선순위 | 안전장치 | 구현 난이도 | 영향도 | 상태 |
|---------|---------|------------|--------|------|
| **P0** | **Redis Timeout 보호** | 쉬움 | 치명적 (무한 대기) | ❌ 미구현 |
| **P0** | **Max In-Flight Limit** | 쉬움 | 높음 (과부하 방지) | ❌ 미구현 |
| **P1** | **Poison Message 처리** | 중간 | 중간 (가용성) | ⚠️ TODO 있음 |
| **P1** | **Game Server Monitor** | 쉬움 | 중간 (운영 가시성) | ⚠️ TODO 있음 |
| **P2** | **Circuit Breaker** | 중간 | 낮음 (장애 시간 단축) | ❌ 미구현 |
| ✅ | **Re-enqueue on Failure** | - | - | ✅ 구현됨 |

---

## P0: Redis Timeout 보호 (치명적)

### 문제

Redis 작업이 무한 대기할 수 있습니다.

```rust
// 현재 코드 (rank/handlers.rs:123)
match pop_candidates(queue_suffix, required_players as usize * 2, &deps).await {
    Ok(candidates) => break candidates,
    Err(err) => { /* retry */ }
}

// try_match.rs:94
let subscriber_count = redis.publish(channel, json).await?;
```

**시나리오**: Redis 네트워크 장애 → `.await`가 영원히 리턴 안 함 → Actor 멈춤

### 해결책

#### 1. Settings에 timeout 설정 추가

```rust
// env.rs
#[derive(Debug, Deserialize, Clone)]
pub struct MatchmakingSettings {
    pub redis_operation_timeout_seconds: u64,  // 추가 (권장: 10)
    // ...
}
```

```toml
# config/production.toml
[matchmaking]
redis_operation_timeout_seconds = 10
```

#### 2. Timeout wrapper 함수 작성

```rust
// matchmaker/operations/mod.rs
use tokio::time::{timeout, Duration};

pub async fn with_timeout<F, T>(
    operation_name: &str,
    timeout_secs: u64,
    future: F,
) -> Result<T, String>
where
    F: Future<Output = Result<T, String>>,
{
    match timeout(Duration::from_secs(timeout_secs), future).await {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(err)) => Err(err),
        Err(_) => {
            error!("{} timeout after {}s", operation_name, timeout_secs);
            Err(format!("{} timeout", operation_name))
        }
    }
}
```

#### 3. 모든 Redis 작업에 적용

```rust
// rank/handlers.rs:123
let timeout_secs = deps.settings.redis_operation_timeout_seconds;

match with_timeout(
    "pop_candidates",
    timeout_secs,
    async {
        pop_candidates(queue_suffix, required_players * 2, &deps)
            .await
            .map_err(|e| e.to_string())
    }
).await {
    Ok(candidates) => break candidates,
    Err(err) => {
        // timeout 또는 Redis 에러
        if let Some(delay) = backoff.next_backoff() { /* retry */ }
    }
}

// publish도 동일하게
with_timeout(
    "publish_battle_request",
    timeout_secs,
    async {
        publish_battle_request(&mut redis, channel, &request).await
    }
).await?;
```

### 효과

- Redis 장애 시 10초 후 자동 복구 시도
- Actor가 무한 대기 상태에 빠지지 않음
- 명확한 에러 로그 (timeout vs network error)

---

## P0: Max In-Flight Limit (과부하 방지)

### 문제

동시에 너무 많은 TryMatch가 실행될 수 있습니다.

```rust
// rank/mod.rs:62
ctx.run_interval(Duration::from_secs(5), move |_actor, ctx| {
    ctx.notify(TryMatch { ... });  // 무조건 실행!
});
```

**시나리오**:
```
시간 0초:  TryMatch #1 시작 (Redis 느림, 20초 소요)
시간 5초:  TryMatch #2 시작 (interval 트리거)
시간 10초: TryMatch #3 시작
시간 15초: TryMatch #4 시작
→ 동시에 4개 실행 중! Redis/Game Server 폭주 😱
```

### 해결책

#### 1. MatchmakerInner에 플래그 추가

```rust
// matchmaker/common.rs
use std::sync::atomic::{AtomicBool, Ordering};

pub struct MatchmakerInner {
    pub is_try_match_running: Arc<AtomicBool>,
    // ...
}

impl MatchmakerInner {
    pub fn new(...) -> Self {
        Self {
            is_try_match_running: Arc::new(AtomicBool::new(false)),
            // ...
        }
    }
}
```

#### 2. Handler에서 중복 실행 방지

```rust
// rank/handlers.rs:92
impl Handler<TryMatch> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: TryMatch, ctx: &mut Self::Context) -> Self::Result {
        // 이미 실행 중이면 스킵
        if self.is_try_match_running.swap(true, Ordering::Relaxed) {
            warn!("TryMatch already running, skipping this tick");
            return;
        }

        let deps: MatchmakerDeps = (&self.inner).into();
        let is_running = self.is_try_match_running.clone();
        let shutdown_token = self.shutdown_token.clone();
        // ...

        async move {
            // ... 기존 로직 ...

            // 완료 후 플래그 해제
            is_running.store(false, Ordering::Relaxed);
        }
        .into_actor(self)
        .wait(ctx);
    }
}
```

#### 3. 메트릭 추가 (선택)

```rust
// 스킵 횟수 기록
if self.is_try_match_running.swap(true, Ordering::Relaxed) {
    warn!("TryMatch already running, skipping this tick");
    deps.metrics.try_match_skipped.inc();
    return;
}
```

### 효과

- 동시 실행 = 최대 1개로 제한
- Redis/Game Server 부하 예측 가능
- 느린 작업이 쌓이지 않음

---

## P1: Poison Message 처리

### 문제

`pod_id` 없는 플레이어 1명 때문에 전체 매칭 실패합니다.

```rust
// try_match.rs:64-71
let pod_id = metadata
    .get("pod_id")
    .and_then(|p| p.as_str())
    .map(String::from)
    .ok_or_else(|| {
        RedisError::from((ErrorKind::TypeError, "pod_id not found in metadata"))
    })?;  // ❌ 여기서 에러 → 전체 candidates 버림!

// TODO: pod_id 가 없을 경우, 오염된 플레이어로 간주하고 로그 처리 해당 match 는 실패로 처리.
```

**시나리오**:
```
Queue: [Player1(정상), Player2(pod_id 없음), Player3(정상), Player4(정상)]
→ pop_candidates() 호출
→ Player2에서 에러 발생
→ 전체 Err 반환
→ Player1, 3, 4도 매칭 실패 😱
```

### 해결책

#### 1. PoisonedCandidate 타입 추가

```rust
// try_match.rs:102 아래
#[derive(Debug, Clone)]
pub struct PoisonedCandidate {
    pub player_id: String,
    pub reason: String,
}
```

#### 2. pop_candidates 반환 타입 변경

```rust
// try_match.rs:20
pub async fn pop_candidates(
    queue_suffix: &str,
    batch_size: usize,
    deps: &MatchmakerDeps,
) -> RedisResult<(Vec<PlayerCandidate>, Vec<PoisonedCandidate>)> {
    if batch_size == 0 {
        return Ok((Vec::new(), Vec::new()));
    }

    let mut redis = deps.redis.clone();
    let hash_tag = format!("{{{}}}", queue_suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let raw: Vec<String> = invoke_try_match_script(&mut redis, queue_key, batch_size).await?;

    if raw.len() % 3 != 0 {
        return Err(RedisError::from((
            ErrorKind::TypeError,
            "unexpected response length",
        )));
    }

    let mut candidates = Vec::with_capacity(raw.len() / 3);
    let mut poisoned = Vec::new();

    for chunk in raw.chunks_exact(3) {
        let player_id = chunk[0].clone();
        let score = chunk[1].parse::<i64>().unwrap_or(0);
        let metadata_json = chunk[2].clone();

        // 파싱 시도
        match parse_candidate(&player_id, score, &metadata_json) {
            Ok(candidate) => candidates.push(candidate),
            Err(reason) => {
                warn!("Poisoned candidate {}: {}", player_id, reason);
                poisoned.push(PoisonedCandidate { player_id, reason });
                // ✅ 계속 진행! (전체 실패 X)
            }
        }
    }

    // 메트릭 기록
    if !poisoned.is_empty() {
        error!("Found {} poisoned candidates in queue {}", poisoned.len(), queue_suffix);
        deps.metrics.poisoned_candidates.inc_by(poisoned.len() as u64);
    }

    Ok((candidates, poisoned))
}

fn parse_candidate(
    player_id: &str,
    score: i64,
    metadata_json: &str,
) -> Result<PlayerCandidate, String> {
    let metadata = serde_json::from_str::<serde_json::Value>(metadata_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let pod_id = metadata
        .get("pod_id")
        .and_then(|p| p.as_str())
        .ok_or_else(|| "pod_id not found".to_string())?;

    Ok(PlayerCandidate {
        player_id: player_id.to_string(),
        score,
        pod_id: pod_id.to_string(),
        metadata,
    })
}
```

#### 3. Handler 업데이트

```rust
// rank/handlers.rs:123
match pop_candidates(queue_suffix, required_players * 2, &deps).await {
    Ok((candidates, poisoned)) => {
        // Poisoned는 로깅만 (이미 큐에서 제거됨)
        for p in poisoned {
            error!("Dropped poisoned candidate {}: {}", p.player_id, p.reason);
        }
        break candidates;
    }
    Err(err) => { /* retry */ }
}
```

### 효과

- 오염된 플레이어 1명이 전체 매칭을 막지 못함
- 정상 플레이어는 계속 매칭됨
- 오염된 데이터 추적 가능 (메트릭)

---

## P1: Game Server 모니터링 & Alert

### 문제

Game Server가 죽어있어도 감지하지 못합니다.

```rust
// try_match.rs:93
// TODO: subscriber_count 를 활용하여 Game Server 생존 여부 확인, 오류 전파 등 구현해야함.

// rank/handlers.rs:182-185
if subscriber_count == 0 {
    // TODO: Game Server 가 구독중이지 않음.
    warn!("No Game Server is subscribed to battle:request channel");
    // ✅ re-enqueue는 이미 구현됨
}
```

**문제**: 로그만 찍고 끝. 10분간 Game Server 다운되어도 모름.

### 해결책

#### 1. 모니터링 구조체 추가

```rust
// matchmaker/common.rs
use std::sync::atomic::{AtomicU64, Ordering};

pub struct GameServerHealthMonitor {
    no_subscriber_count: AtomicU64,
    last_alert_timestamp: AtomicU64,
}

impl GameServerHealthMonitor {
    pub fn new() -> Self {
        Self {
            no_subscriber_count: AtomicU64::new(0),
            last_alert_timestamp: AtomicU64::new(0),
        }
    }

    pub fn record_no_subscriber(&self) {
        use chrono::Utc;

        let count = self.no_subscriber_count.fetch_add(1, Ordering::Relaxed) + 1;
        let now = Utc::now().timestamp() as u64;
        let last_alert = self.last_alert_timestamp.load(Ordering::Relaxed);

        // 연속 10번 실패 + 5분마다 알림
        if count >= 10 && now - last_alert > 300 {
            error!(
                "CRITICAL: Game Server unavailable for {} consecutive attempts! \
                 No subscribers on battle:request channel.",
                count
            );
            // TODO: Slack/PagerDuty/Email 알림
            self.last_alert_timestamp.store(now, Ordering::Relaxed);
        } else if count % 5 == 0 {
            warn!("Game Server unavailable count: {}", count);
        }
    }

    pub fn record_has_subscriber(&self, count: usize) {
        let previous = self.no_subscriber_count.swap(0, Ordering::Relaxed);

        if previous > 0 {
            info!(
                "Game Server recovered! {} subscriber(s) available. \
                 (Was down for {} attempts)",
                count, previous
            );
        }
    }
}

pub struct MatchmakerInner {
    pub game_server_monitor: Arc<GameServerHealthMonitor>,
    // ...
}
```

#### 2. Handler에서 사용

```rust
// rank/handlers.rs:181
match publish_battle_request(&mut redis, channel, &request).await {
    Ok(subscriber_count) => {
        if subscriber_count == 0 {
            deps.game_server_monitor.record_no_subscriber();
            warn!("No Game Server subscribed");
            re_enqueue_candidates(...).await;
        } else {
            deps.game_server_monitor.record_has_subscriber(subscriber_count);
            info!("Battle request sent to {} server(s)", subscriber_count);
        }
    }
    Err(err) => {
        error!("Failed to publish: {}", err);
        re_enqueue_candidates(...).await;
    }
}
```

#### 3. 메트릭 추가 (선택)

```rust
// metrics/src/lib.rs
pub struct MetricsCtx {
    pub game_server_unavailable_total: Counter,
    pub game_server_available: Gauge,
    // ...
}
```

### 효과

- Game Server 장애 즉시 감지 (10번 연속 실패)
- 5분마다 CRITICAL 알림 (중복 방지)
- 복구 시 자동 감지 및 로깅
- 운영팀이 즉시 대응 가능

---

## P2: Circuit Breaker Pattern

### 문제

Redis가 죽어도 계속 재시도합니다.

```rust
// rank/handlers.rs:116-148
let candidates = loop {
    match pop_candidates(...).await {
        Ok(candidates) => break candidates,
        Err(err) => {
            if let Some(delay) = backoff.next_backoff() {
                sleep(delay).await;
                continue;  // 무한 재시도 (Redis 복구될 때까지)
            }
        }
    }
};
```

**시나리오**: Redis 죽음 → 모든 TryMatch가 재시도 → CPU/로그 폭증

### 해결책

#### 1. Circuit Breaker 구현

```rust
// matchmaker/circuit_breaker.rs (신규)
use std::sync::atomic::{AtomicU64, Ordering};
use chrono::Utc;

pub struct CircuitBreaker {
    consecutive_failures: AtomicU64,
    threshold: u64,           // 예: 5번 연속 실패 시 차단
    open_until: AtomicU64,    // timestamp (열린 시각)
    cooldown_seconds: u64,    // 예: 60초
}

impl CircuitBreaker {
    pub fn new(threshold: u64, cooldown_seconds: u64) -> Self {
        Self {
            consecutive_failures: AtomicU64::new(0),
            threshold,
            open_until: AtomicU64::new(0),
            cooldown_seconds,
        }
    }

    pub fn check(&self) -> Result<(), String> {
        let now = Utc::now().timestamp() as u64;
        let open_until = self.open_until.load(Ordering::Relaxed);

        if open_until > now {
            let remaining = open_until - now;
            return Err(format!("Circuit open for {}s", remaining));
        }

        Ok(())
    }

    pub fn record_success(&self) {
        let previous = self.consecutive_failures.swap(0, Ordering::Relaxed);
        let was_open = self.open_until.swap(0, Ordering::Relaxed);

        if was_open > 0 {
            info!("Circuit breaker CLOSED (recovered after {} failures)", previous);
        }
    }

    pub fn record_failure(&self) {
        let failures = self.consecutive_failures.fetch_add(1, Ordering::Relaxed) + 1;

        if failures >= self.threshold {
            let now = Utc::now().timestamp() as u64;
            let open_until = now + self.cooldown_seconds;
            self.open_until.store(open_until, Ordering::Relaxed);

            error!(
                "Circuit breaker OPEN! {} consecutive failures. \
                 Blocking operations for {}s",
                failures, self.cooldown_seconds
            );
        }
    }
}
```

#### 2. MatchmakerInner에 추가

```rust
// matchmaker/common.rs
pub struct MatchmakerInner {
    pub redis_circuit: Arc<CircuitBreaker>,
    // ...
}

impl MatchmakerInner {
    pub fn new(...) -> Self {
        Self {
            redis_circuit: Arc::new(CircuitBreaker::new(5, 60)),
            // threshold=5, cooldown=60초
            // ...
        }
    }
}
```

#### 3. Handler에서 사용

```rust
// rank/handlers.rs:103
async move {
    if shutdown_token.is_cancelled() { return; }

    // Circuit breaker 체크
    if let Err(e) = deps.redis_circuit.check() {
        warn!("Redis circuit open, skipping TryMatch: {}", e);
        return;
    }

    let candidates = loop {
        match pop_candidates(...).await {
            Ok(candidates) => {
                deps.redis_circuit.record_success();
                break candidates;
            }
            Err(err) => {
                deps.redis_circuit.record_failure();

                if let Some(delay) = backoff.next_backoff() {
                    // ...
                } else {
                    return;
                }
            }
        }
    };
    // ...
}
```

### 효과

- 5번 연속 실패 시 60초간 자동 중단
- 불필요한 재시도 방지 (CPU/로그 절약)
- 60초 후 자동 복구 시도
- Redis 복구 시 즉시 정상화

---

## ✅ 이미 구현된 항목

### Re-enqueue on Failure

다음 경우들에서 자동 재enqueue가 구현되어 있습니다:

1. **Game Server 없음** (rank/handlers.rs:182-194)
```rust
if subscriber_count == 0 {
    re_enqueue_candidates(...).await;
}
```

2. **Publish 실패** (rank/handlers.rs:202-213)
```rust
Err(err) => {
    error!("Failed to publish: {}", err);
    re_enqueue_candidates(...).await;
}
```

3. **홀수 플레이어** (rank/handlers.rs:216-220)
```rust
[single] => {
    re_enqueue_candidates(...).await;
}
```

4. **Shutdown 중** (rank/handlers.rs:160-164)
```rust
if shutdown_token.is_cancelled() {
    re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps).await;
    continue;
}
```

---

## 구현 순서 권장

### Phase 1: 프로덕션 필수 (P0)
1. ✅ **Redis Timeout 보호** - 1~2시간
2. ✅ **Max In-Flight Limit** - 30분

### Phase 2: 운영 안정화 (P1)
3. ✅ **Poison Message 처리** - 2~3시간
4. ✅ **Game Server Monitor** - 1시간

### Phase 3: 고급 최적화 (P2)
5. **Circuit Breaker** - 2시간 (선택)

---

## 테스트 시나리오

### Timeout 테스트
```bash
# Redis 중단
docker stop redis

# 로그 확인: 10초 후 timeout 에러 발생하는지
tail -f logs/match_server.log | grep timeout
```

### In-Flight 테스트
```bash
# Redis에 sleep 추가 (느린 응답 시뮬레이션)
# 로그에서 "TryMatch already running, skipping" 확인
```

### Poison Message 테스트
```bash
# 수동으로 잘못된 metadata 추가
redis-cli ZADD "queue:{normal}" $(date +%s) "bad_player"
redis-cli SET "metadata:bad_player" '{"invalid": "no_pod_id"}'

# 로그 확인: poisoned candidate 로그, 다른 플레이어는 정상 매칭
```

### Game Server 모니터링 테스트
```bash
# Game Server 중단
# 10번 연속 매칭 시도 후 CRITICAL 로그 확인
```

---

## 참고 자료

- [tokio::select! 문서](https://docs.rs/tokio/latest/tokio/macro.select.html)
- [tokio::time::timeout 문서](https://docs.rs/tokio/latest/tokio/time/fn.timeout.html)
- [Circuit Breaker Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker)
- [Poison Message Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/InvalidMessageChannel.html)
</file>

<file path="scripts/DEQUEUE_PLAYER.lua">
-- KEYS[1] = queue:{mode} (Sorted Set)
-- ARGV[1] = player_id

local queue_key = KEYS[1]
local player_id = ARGV[1]

-- queue에서 제거
local removed = redis.call('ZREM', queue_key, player_id)

-- metadata 삭제
if removed == 1 then
    local metadata_key = 'metadata:' .. player_id
    redis.call('DEL', metadata_key)
end

-- 현재 큐 크기 반환
local size = redis.call('ZCARD', queue_key)
return {removed, size}
</file>

<file path="scripts/ENQUEUE_PLAYER.lua">
-- KEYS[1] = queue:{mode} (Sorted Set)
-- ARGV[1] = player_id
-- ARGV[2] = timestamp (score)
-- ARGV[3] = metadata JSON string

local queue_key = KEYS[1]
local player_id = ARGV[1]
local timestamp = tonumber(ARGV[2])
local metadata_json = ARGV[3]

-- 유효성 검사
if timestamp == nil or metadata_json == nil or metadata_json == "" then
    local size = redis.call('ZCARD', queue_key)
    return {0, size}
end

-- 이미 큐에 있는지 확인
local exists = redis.call('ZSCORE', queue_key, player_id)
if exists then
    local size = redis.call('ZCARD', queue_key)
    return {0, size}
end

-- queue에 추가 (Sorted Set)
redis.call('ZADD', queue_key, timestamp, player_id)

-- metadata 저장 (JSON 문자열 그대로 저장)
local metadata_key = 'metadata:' .. player_id
redis.call('SET', metadata_key, metadata_json)

-- 현재 큐 크기 반환
local size = redis.call('ZCARD', queue_key)
return {1, size}
</file>

<file path="scripts/TRY_MATCH_POP.lua">
-- KEYS[1] = queue:{mode} (Sorted Set)
-- ARGV[1] = batch_size (integer)

local queue_key = KEYS[1]
local batch_size = tonumber(ARGV[1])

-- 유효성 검사
if batch_size == nil or batch_size <= 0 then
    return {}
end

-- ZPOPMIN으로 원자적으로 pop (FIFO 보장)
local popped = redis.call('ZPOPMIN', queue_key, batch_size)

if #popped == 0 then
    return {}
end

local result = {}

-- popped format: [player_id, score, player_id, score, ...]
for idx = 1, #popped, 2 do
    local player_id = popped[idx]
    local score = popped[idx + 1]

    -- metadata 가져오기 (JSON 문자열 그대로)
    local metadata_key = 'metadata:' .. player_id
    local metadata_json = redis.call('GET', metadata_key)

    -- metadata가 없으면 빈 객체
    if not metadata_json then
        metadata_json = "{}"
    end

    -- 결과에 추가: [player_id, score, metadata_json, ...]
    table.insert(result, player_id)
    table.insert(result, score)
    table.insert(result, metadata_json)

    -- metadata 삭제 (이미 pop했으므로)
    redis.call('DEL', metadata_key)
end

return result
</file>

<file path="src/env.rs">
use config::{Config, ConfigError, Environment, File, FileFormat};
use serde::Deserialize;

use crate::GameMode;

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub logging: LoggingSettings,
    pub server: ServerSettings,
    pub matchmaking: MatchmakingSettings,
    pub redis: RedisSettings,
    pub retry: RetrySettings,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let run_mode = std::env::var("RUN_MODE").unwrap_or_else(|_| "development".into());
        println!("Loading configuration for RUN_MODE: {}", &run_mode);

        let s = Config::builder()
            // Load environment-specific file (e.g., development.toml, production.toml)
            .add_source(
                File::with_name(&format!("match_server/config/{}", run_mode))
                    .format(FileFormat::Toml)
                    .required(true),
            )
            // Add environment variables (e.g., APP_SERVER__PORT=8000)
            .add_source(Environment::with_prefix("APP").separator("__"))
            .build()?;

        s.try_deserialize()
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct MatchmakingSettings {
    pub try_match_tick_interval_seconds: u64,
    pub queue_key_prefix: String,
    pub queue_order_key_prefix: String,
    pub match_fetch_request_channel_prefix: String,
    pub match_fetch_ack_channel_prefix: String,
    pub battle_request_channel: String,
    pub battle_result_channel_prefix: String,
    pub game_modes: Vec<MatchModeSettings>,
    pub heartbeat_interval_seconds: u64,
    pub heartbeat_timeout: u64,
    pub max_dedicated_server_retries: Option<u32>,
    pub dedicated_request_timeout_seconds: u64,
    pub allocation_token_ttl_seconds: u64,
    pub slow_loading_threshold_seconds: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RedisSettings {
    pub max_reconnect_attempts: u32,
    pub max_reconnect_delay_ms: u64,
    pub initial_reconnect_delay_ms: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct ServerSettings {
    pub bind_address: String,
    pub port: u16,
    pub log_level: String,
    pub metrics_auth_token: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct LoggingSettings {
    pub directory: String,
    pub filename: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct MatchModeSettings {
    pub game_mode: GameMode,
    pub required_players: u32,
    pub use_mmr_matching: bool,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RetrySettings {
    pub message_max_elapsed_time_ms: u64,
    pub message_initial_interval_ms: u64,
    pub message_max_interval_ms: u64,
}
</file>

<file path="src/lib.rs">
use ::redis::aio::ConnectionManager;
use actix::{Addr, Message};
use actix_web::HttpRequest;
use backoff::ExponentialBackoff;
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::io;
use std::net::IpAddr;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};
use tracing::{debug, error, warn};
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

use crate::env::RetrySettings;
use crate::subscript::SubScriptionManager;
use crate::{env::Settings, matchmaker::MatchmakerAddr, metrics::MetricsCtx};

lazy_static! {
    static ref RETRY_CONFIG: RwLock<Option<ExponentialBackoff>> = RwLock::new(None);
}

pub mod env;
pub mod matchmaker;
pub mod metrics;
pub mod protocol;
pub mod session;
pub mod subscript;

pub struct LoggerManager {
    _guard: tracing_appender::non_blocking::WorkerGuard,
}

#[derive(Debug)]
pub enum StopReason {
    ClientDisconnected,
    GracefulShutdown,
    Error(String),
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct Stop {
    pub reason: StopReason,
}

impl LoggerManager {
    pub fn setup(settings: &Settings) -> Self {
        // 1. 파일 로거 설정
        let file_appender = RollingFileAppender::new(
            Rotation::DAILY,
            &settings.logging.directory,
            &settings.logging.filename,
        );
        let (non_blocking_file_writer, guard) = tracing_appender::non_blocking(file_appender);

        // 2. 로그 레벨 필터 설정 (환경 변수 또는 설정 파일 값)
        let filter = EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| EnvFilter::new(&settings.server.log_level));

        // 3. 콘솔 출력 레이어 설정
        let console_layer = fmt::layer()
            .with_writer(io::stdout) // 표준 출력으로 설정
            .with_ansi(true) // ANSI 색상 코드 사용 (터미널 지원 시)
            .with_thread_ids(true) // 스레드 ID 포함
            .with_thread_names(true) // 스레드 이름 포함
            .with_file(true) // 파일 경로 포함
            .with_line_number(true) // 라인 번호 포함
            .with_target(false) // target 정보 제외 (선택 사항)
            .pretty(); // 사람이 읽기 좋은 포맷

        // 4. 파일 출력 레이어 설정
        let file_layer = fmt::layer()
            .with_writer(non_blocking_file_writer) // Non-blocking 파일 로거 사용
            .with_ansi(false) // 파일에는 ANSI 코드 제외
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .pretty();

        // 5. 레지스트리(Registry)에 필터와 레이어 결합
        tracing_subscriber::registry()
            .with(filter) // 필터를 먼저 적용
            .with(console_layer) // 콘솔 레이어 추가
            .with(file_layer) // 파일 레이어 추가
            .init(); // 전역 Subscriber로 설정

        tracing::info!(
            "Logger initialization complete: console and file ({}/{}) output enabled",
            settings.logging.directory,
            settings.logging.filename
        );

        Self { _guard: guard }
    }
}

pub fn init_retry_config(settings: &RetrySettings) {
    let backoff = ExponentialBackoff {
        max_elapsed_time: Some(Duration::from_millis(settings.message_max_elapsed_time_ms)),
        initial_interval: Duration::from_millis(settings.message_initial_interval_ms),
        max_interval: Duration::from_millis(settings.message_max_interval_ms),
        ..Default::default()
    };

    *RETRY_CONFIG.write().unwrap() = Some(backoff);
}

#[derive(Clone)]
pub struct AppState {
    pub settings: Settings,
    pub matchmakers: HashMap<GameMode, MatchmakerAddr>,
    pub sub_manager_addr: Addr<SubScriptionManager>,
    pub redis: ConnectionManager,
    pub logger_manager: Arc<LoggerManager>,
    pub current_run_id: Arc<RwLock<Option<String>>>,
    pub metrics: Arc<MetricsCtx>,
    pub metrics_registry: prometheus::Registry,
    pub rate_limiter: Arc<RateLimiter>,
}

pub fn extract_client_ip(req: &HttpRequest) -> Option<IpAddr> {
    // 1. X-Forwarded-For 검증 강화
    if let Some(forwarded) = req.headers().get("x-forwarded-for") {
        if let Ok(forwarded_str) = forwarded.to_str() {
            for ip_str in forwarded_str.split(',') {
                let ip_str = ip_str.trim();
                if let Ok(ip) = ip_str.parse::<IpAddr>() {
                    // Private IP 및 localhost 필터링
                    if !is_private_or_loopback_ip(&ip) {
                        debug!("Extracted public client IP from X-Forwarded-For: {}", ip);
                        return Some(ip);
                    }
                }
            }
        }
    }

    // 2-3. 기존 X-Real-IP, CF-Connecting-IP 처리...

    // 4. Direct connection (개발 환경에서만 허용)
    if cfg!(debug_assertions) {
        // 디버그 빌드에서만
        if let Some(peer_addr) = req.connection_info().peer_addr() {
            if let Some(ip_str) = peer_addr.split(':').next() {
                if let Ok(ip) = ip_str.parse::<IpAddr>() {
                    warn!("Using direct connection IP in development: {}", ip);
                    return Some(ip);
                }
            }
        }
    }

    error!(
        "Could not extract valid client IP from request headers: {:?}",
        req.headers()
    );
    None
}

fn is_private_or_loopback_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => ipv4.is_private() || ipv4.is_loopback() || ipv4.is_link_local(),
        IpAddr::V6(ipv6) => ipv6.is_loopback() || ipv6.is_unspecified(),
    }
}

#[derive(Serialize, Deserialize, Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum GameMode {
    None,
    #[serde(rename = "Normal")]
    Normal,
    #[serde(rename = "Ranked")]
    Ranked,
}

/// Simple rate limiter using token bucket algorithm
pub struct RateLimiter {
    buckets: Arc<RwLock<HashMap<IpAddr, TokenBucket>>>,
    max_requests_per_second: u32,
    #[allow(dead_code)]
    cleanup_interval: Duration,
}

struct TokenBucket {
    tokens: f64,
    last_refill: Instant,
    max_tokens: f64,
    refill_rate: f64, // tokens per second
}

impl RateLimiter {
    pub fn new(max_requests_per_second: u32) -> Self {
        Self {
            buckets: Arc::new(RwLock::new(HashMap::new())),
            max_requests_per_second,
            cleanup_interval: Duration::from_secs(300), // cleanup every 5 minutes
        }
    }

    pub fn check(&self, ip: &IpAddr) -> bool {
        let mut buckets = self.buckets.write().unwrap();
        let bucket = buckets.entry(*ip).or_insert_with(|| TokenBucket {
            tokens: self.max_requests_per_second as f64,
            last_refill: Instant::now(),
            max_tokens: self.max_requests_per_second as f64,
            refill_rate: self.max_requests_per_second as f64,
        });

        // Refill tokens based on elapsed time
        let now = Instant::now();
        let elapsed = now.duration_since(bucket.last_refill).as_secs_f64();
        bucket.tokens = (bucket.tokens + elapsed * bucket.refill_rate).min(bucket.max_tokens);
        bucket.last_refill = now;

        // Check if we have tokens
        if bucket.tokens >= 1.0 {
            bucket.tokens -= 1.0;
            true
        } else {
            false
        }
    }

    /// Cleanup old entries (call periodically)
    pub fn cleanup(&self) {
        let mut buckets = self.buckets.write().unwrap();
        let now = Instant::now();
        buckets.retain(|_, bucket| {
            now.duration_since(bucket.last_refill) < Duration::from_secs(600) // 10 minutes
        });
    }
}
</file>

<file path="src/main.rs">
use actix::{Actor, System};
use actix_web::{get, web, App, Error, HttpRequest, HttpResponse, HttpServer};
use actix_web_actors::ws;
use match_server::{
    env::Settings,
    extract_client_ip, init_retry_config,
    matchmaker::{spawn_matchmakers, MatchmakerDeps},
    metrics::MetricsCtx,
    session::Session,
    subscript::SubScriptionManager,
    AppState, GameMode, LoggerManager,
};
use prometheus::{Encoder, TextEncoder};
use std::{
    sync::{Arc, RwLock},
    time::Duration,
};
use tokio_util::sync::CancellationToken;
use tracing::{error, info};

#[get("/ws/")]
async fn matchmaking_ws_route(
    req: HttpRequest,
    stream: web::Payload,
    state: web::Data<AppState>,
) -> Result<HttpResponse, Error> {
    let client_ip = extract_client_ip(&req).ok_or_else(|| {
        error!("Failed to extract client IP - rejecting connection");
        actix_web::error::ErrorBadRequest("Unable to determine client IP")
    })?;

    let session = Session::new(
        state.sub_manager_addr.clone(),
        Duration::from_secs(state.settings.matchmaking.heartbeat_interval_seconds),
        Duration::from_secs(state.settings.matchmaking.heartbeat_timeout),
        state.clone(),
        client_ip,
    );

    // WebSocket with default size limits (64KB max frame size by default)
    // Note: actix-web-actors uses default max_frame_size of 64KB
    ws::start(session, &req, stream)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // 1. 환경변수 로드
    dotenv::dotenv().ok();

    // 2. 설정 파일 로드
    let settings = Settings::new().expect("Failed to load settings");

    // 3. 로거 초기화
    let logger_manager = Arc::new(LoggerManager::setup(&settings));
    info!("Logger initialized");

    // 4. Retry config 초기화
    init_retry_config(&settings.retry);
    info!("Retry config initialized");

    // 5. Redis 클라이언트 생성
    let redis_url =
        std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://127.0.0.1:6379".to_string());
    let redis_client =
        redis::Client::open(redis_url.clone()).expect("Failed to create Redis client");

    let redis_conn_manager = redis::aio::ConnectionManager::new(redis_client.clone())
        .await
        .expect("Failed to create Redis connection manager");
    info!("Redis connection established: {}", redis_url);

    // 6. 전역 Shutdown Token 생성
    let shutdown_token = CancellationToken::new();

    // 7. SubScriptionManager 시작
    let sub_manager_addr = SubScriptionManager::new().start();
    info!("SubScriptionManager actor started");

    // 8. Metrics 초기화
    let metrics = Arc::new(MetricsCtx::new());
    let metrics_registry = prometheus::Registry::new();
    metrics::register_custom_metrics(&metrics_registry)
        .expect("Failed to register custom metrics");
    info!("Metrics initialized and registered");

    // 9. Matchmaker Dependencies 준비
    let matchmaker_deps = MatchmakerDeps {
        redis: redis_conn_manager.clone(),
        settings: settings.matchmaking.clone(),
        subscription_addr: sub_manager_addr.clone(),
        metrics: metrics.clone(),
        shutdown_token: shutdown_token.clone(),
    };

    // 10. Matchmaker들 시작 (Normal, Ranked)
    let game_modes = vec![GameMode::Normal, GameMode::Ranked];
    let matchmakers = spawn_matchmakers(&matchmaker_deps, game_modes)
        .expect("Failed to spawn matchmakers");
    info!("Matchmakers started: Normal, Ranked");

    // 11. Rate Limiter 초기화 (10 requests/second per IP)
    let rate_limiter = Arc::new(match_server::RateLimiter::new(10));
    info!("Rate limiter initialized: 10 req/sec per IP");

    // 12. AppState 구성
    let current_run_id = Arc::new(RwLock::new(None));
    let app_state = AppState {
        settings: settings.clone(),
        matchmakers,
        sub_manager_addr,
        redis: redis_conn_manager.clone(),
        logger_manager,
        current_run_id,
        metrics,
        metrics_registry: metrics_registry.clone(),
        rate_limiter,
    };

    // 13. HTTP 서버 시작
    let bind_address = format!("{}:{}", settings.server.bind_address, settings.server.port);
    info!("Starting HTTP server on {}", bind_address);

    let mut server = HttpServer::new(move || {
        // /metrics 엔드포인트 (optional auth)
        let metrics_route = |req: HttpRequest, state: web::Data<AppState>| async move {
            // Check auth token if configured
            if let Some(expected_token) = &state.settings.server.metrics_auth_token {
                let auth_header = req.headers().get("Authorization");
                let provided_token = auth_header
                    .and_then(|h| h.to_str().ok())
                    .and_then(|s| s.strip_prefix("Bearer "));

                if provided_token != Some(expected_token.as_str()) {
                    return HttpResponse::Unauthorized()
                        .body("Unauthorized: Invalid or missing token");
                }
            }

            let metric_families = state.metrics_registry.gather();
            let mut buffer = Vec::new();
            let encoder = TextEncoder::new();

            if let Err(e) = encoder.encode(&metric_families, &mut buffer) {
                return HttpResponse::InternalServerError()
                    .body(format!("Metrics encode error: {}", e));
            }

            HttpResponse::Ok()
                .content_type(encoder.format_type())
                .body(buffer)
        };

        // Healthcheck endpoints
        let health_route = || async { HttpResponse::Ok().body("OK") };
        let ready_route = || async { HttpResponse::Ok().body("READY") };

        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .service(matchmaking_ws_route)
            .route("/metrics", web::get().to(metrics_route))
            .route("/health", web::get().to(health_route))
            .route("/ready", web::get().to(ready_route))
    })
    .bind(&bind_address)?
    .run();

    info!("Match Server is running on {}", bind_address);

    // 14. 종료 신호 대기
    tokio::select! {
        // 서버 자체 종료 (드문 경우)
        res = &mut server => {
            error!("Server exited unexpectedly");
            return res;
        },

        // Ctrl+C 종료 (정상 종료)
        _ = tokio::signal::ctrl_c() => {
            info!("Ctrl+C received. Initiating graceful shutdown...");
            shutdown_token.cancel();  // 모든 Actor에 종료 신호
            System::current().stop();
        },
    }

    // 15. 모든 Actor와 연결 정리 대기
    info!("Waiting for all actors to shutdown...");
    server.await?;
    info!("System has shut down gracefully");

    Ok(())
}
</file>

<file path="src/matchmaker/common.rs">
use std::sync::Arc;

use actix::Addr;
use redis::aio::ConnectionManager;
use tokio_util::sync::CancellationToken;

use crate::{
    env::{MatchModeSettings, MatchmakingSettings},
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
    GameMode,
};

pub struct MatchmakerInner {
    pub redis: ConnectionManager,
    pub settings: MatchmakingSettings,
    pub mode_settings: MatchModeSettings,
    pub sub_manager_addr: Addr<SubScriptionManager>,
    pub metrics: Arc<MetricsCtx>,
    pub shutdown_token: CancellationToken,
}

impl MatchmakerInner {
    pub fn new(
        redis: ConnectionManager,
        settings: MatchmakingSettings,
        mode_settings: MatchModeSettings,
        sub_manager_addr: Addr<SubScriptionManager>,
        metrics: Arc<MetricsCtx>,
        shutdown_token: CancellationToken,
    ) -> Self {
        Self {
            redis,
            settings,
            mode_settings,
            sub_manager_addr,
            metrics,
            shutdown_token,
        }
    }

    pub fn queue_suffix(&self, mode: GameMode) -> &'static str {
        match mode {
            GameMode::Ranked => "ranked",
            GameMode::Normal => "normal",
            GameMode::None => "none",
        }
    }
}
</file>

<file path="src/matchmaker/messages.rs">
use actix::Message;
use uuid::Uuid;

use crate::{env::MatchModeSettings, GameMode};

#[derive(Message)]
#[rtype(result = "()")]
pub struct Enqueue {
    pub player_id: Uuid,
    pub game_mode: GameMode,
    pub metadata: String,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct Dequeue {
    pub player_id: Uuid,
    pub game_mode: GameMode,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct TryMatch {
    pub match_mode_settings: MatchModeSettings,
}
</file>

<file path="src/matchmaker/mod.rs">
use actix::{Actor, Addr, MailboxError};
use redis::aio::ConnectionManager;
use std::collections::HashMap;
use tokio_util::sync::CancellationToken;

use crate::{
    env::MatchmakingSettings,
    matchmaker::{
        messages::{Dequeue, Enqueue},
        normal::NormalMatchmaker,
        rank::RankedMatchmaker,
    },
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
    GameMode,
};

pub mod common;
pub mod messages;
pub mod normal;
pub mod operations;
pub mod patry;
pub mod rank;
pub mod scripts;

#[derive(Clone)]
pub enum MatchmakerAddr {
    Normal(Addr<NormalMatchmaker>),
    Ranked(Addr<RankedMatchmaker>),
}

impl MatchmakerAddr {
    pub fn do_send_enqueue(&self, msg: Enqueue) {
        match self {
            Self::Normal(addr) => addr.do_send(msg),
            Self::Ranked(addr) => addr.do_send(msg),
        }
    }

    pub fn do_send_dequeue(&self, msg: Dequeue) {
        match self {
            Self::Normal(addr) => addr.do_send(msg),
            Self::Ranked(addr) => addr.do_send(msg),
        }
    }

    pub async fn dequeue(&self, msg: Dequeue) -> Result<(), MailboxError> {
        match self {
            Self::Normal(addr) => addr.send(msg).await,
            Self::Ranked(addr) => addr.send(msg).await,
        }
    }
}

#[derive(Clone)]
pub struct MatchmakerDeps {
    pub redis: ConnectionManager,
    pub settings: MatchmakingSettings,
    pub subscription_addr: Addr<SubScriptionManager>,
    pub metrics: std::sync::Arc<MetricsCtx>,
    pub shutdown_token: CancellationToken,
}

impl From<&common::MatchmakerInner> for MatchmakerDeps {
    fn from(source: &common::MatchmakerInner) -> Self {
        Self {
            redis: source.redis.clone(),
            settings: source.settings.clone(),
            subscription_addr: source.sub_manager_addr.clone(),
            metrics: source.metrics.clone(),
            shutdown_token: source.shutdown_token.clone(),
        }
    }
}

pub fn spawn_matchmaker_for_mode(
    game_mode: GameMode,
    deps: &MatchmakerDeps,
) -> Result<MatchmakerAddr, String> {
    // settings에서 해당 game_mode의 MatchModeSettings 찾기
    let mode_settings = deps
        .settings
        .game_modes
        .iter()
        .find(|m| m.game_mode == game_mode)
        .cloned()
        .ok_or_else(|| format!("MatchModeSettings not found for mode {:?}", game_mode))?;

    match game_mode {
        GameMode::None => {
            Err("Unsupported game mode: None".to_string())
        }
        GameMode::Normal => Ok(MatchmakerAddr::Normal(
            NormalMatchmaker::new(
                deps.redis.clone(),
                deps.settings.clone(),
                mode_settings,
                deps.subscription_addr.clone(),
                deps.metrics.clone(),
                deps.shutdown_token.clone(),
            )
            .start(),
        )),
        GameMode::Ranked => Ok(MatchmakerAddr::Ranked(
            RankedMatchmaker::new(
                deps.redis.clone(),
                deps.settings.clone(),
                mode_settings,
                deps.subscription_addr.clone(),
                deps.metrics.clone(),
                deps.shutdown_token.clone(),
            )
            .start(),
        )),
    }
}

pub fn spawn_matchmakers<I>(
    deps: &MatchmakerDeps,
    modes: I,
) -> Result<HashMap<GameMode, MatchmakerAddr>, String>
where
    I: IntoIterator<Item = GameMode>,
{
    let mut map = HashMap::new();
    for mode in modes {
        let handle = spawn_matchmaker_for_mode(mode, deps)?;
        map.insert(mode, handle);
    }
    Ok(map)
}
</file>

<file path="src/matchmaker/normal/handlers.rs">
use actix::{dev::ContextFutureSpawner, ActorContext, Handler, WrapFuture};
use backoff::backoff::Backoff;
use tokio::time::sleep;
use tracing::{error, info, warn};

use crate::{
    matchmaker::{
        messages::{Dequeue, Enqueue, TryMatch},
        normal::NormalMatchmaker,
        operations::{
            dequeue::dequeue,
            enqueue::{enqueue, re_enqueue_candidates},
            notify,
            try_match::{pop_candidates, publish_battle_request},
        },
        MatchmakerDeps,
    },
    protocol::{BattleRequest, ErrorCode, ServerMessage},
    GameMode, Stop, RETRY_CONFIG,
};

impl Handler<Enqueue> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Enqueue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Normal {
                warn!(
                    "Player {} tried to enqueue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            enqueue(queue_prefix, msg.game_mode, player_id, msg.metadata, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Dequeue> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Dequeue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Normal {
                warn!(
                    "Player {} tried to dequeue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            dequeue(queue_prefix, msg.game_mode, player_id, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<TryMatch> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: TryMatch, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let settings = msg.match_mode_settings;
        let queue_suffix = self.queue_suffix(settings.game_mode);
        let required_players = settings.required_players;
        let mut redis = deps.redis.clone();
        let shutdown_token = self.shutdown_token.clone();

        async move {
            // 종료 신호 체크
            if shutdown_token.is_cancelled() {
                info!("TryMatch cancelled due to shutdown");
                return;
            }
            let mut backoff = RETRY_CONFIG
                .read()
                .unwrap()
                .as_ref()
                .expect("Retry config not initialized")
                .clone();

            let candidates = loop {
                // 종료 신호 체크
                if shutdown_token.is_cancelled() {
                    info!("TryMatch cancelled during candidate pop");
                    return;
                }

                match pop_candidates(queue_suffix, required_players as usize * 2, &deps).await {
                    Ok(candidates) => break candidates,
                    Err(err) => {
                        if let Some(delay) = backoff.next_backoff() {
                            warn!(
                                "Failed to pop candidates from queue {}: {} (retrying in {:?})",
                                queue_suffix, err, delay
                            );
                            // 종료 신호와 함께 대기
                            tokio::select! {
                                _ = sleep(delay) => continue,
                                _ = shutdown_token.cancelled() => {
                                    info!("TryMatch cancelled during backoff");
                                    return;
                                }
                            }
                        } else {
                            error!(
                                "Failed to pop candidates after all retries from queue {}: {}",
                                queue_suffix, err
                            );
                            return; // async move 블록 종료
                        }
                    }
                }
            };
            
            if candidates.is_empty() {
                warn!("No candidates available");
                return;
            }
                
            // try_match 에 의해 4명이 수집되는데, 모종의 이유로 0~3명이 수집될 수 있음.
            // candidates 에서 2명씩 꺼내어 매칭을 시도하고, 남은 인원은 Re enqueue
            // 2명씩 묶어서 처리
            for chunk in candidates.chunks(2) {
                // 종료 신호 체크 - 이미 pop한 candidates는 re-enqueue
                if shutdown_token.is_cancelled() {
                    warn!("Shutdown requested, re-enqueueing remaining candidates");
                    re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps).await;
                    continue;
                }

                match chunk {
                    [player1, player2] => {
                        // 2명 매칭
                        let request = BattleRequest {
                            player1: player1.clone(),
                            player2: player2.clone(),
                        };

                        match publish_battle_request(
                            &mut redis,
                            &deps.settings.battle_request_channel,
                            &request,
                        )
                        .await
                        {
                            Ok(subscriber_count) => {
                                if subscriber_count == 0 {
                                    // TODO: Game Server 가 구독중이지 않음. -> Game Server 가 죽어있을 가능성이 존재함.
                                    // 자세하게 오류 파악하고 관리 시스템에게 보고 해야함 ( Orchestrator )
                                    warn!("No Game Server is subscribed to battle:request channel");
                                    // 매칭 실패: player1, player2 re enqueue
                                    let failed_match = [player1.clone(), player2.clone()];
                                    re_enqueue_candidates(
                                        queue_suffix,
                                        settings.game_mode,
                                        &failed_match,
                                        &deps,
                                    )
                                    .await;
                                } else {
                                    // Metrics: 매칭 성공
                                    metrics::MATCHES_CREATED_TOTAL.inc();
                                    metrics::MATCHED_PLAYERS_TOTAL_BY_MODE
                                        .with_label_values(&[&format!("{:?}", settings.game_mode)])
                                        .inc_by(2);

                                    info!(
                                        "Battle request sent to {} Game Server(s) for players {} and {}",
                                        subscriber_count, player1.player_id, player2.player_id
                                    );
                                }
                            }
                            Err(err) => {
                                error!("Failed to publish battle request: {}", err);
                                // 매칭 실패: player1, player2 re enqueue
                                let failed_match = [player1.clone(), player2.clone()];
                                re_enqueue_candidates(
                                    queue_suffix,
                                    settings.game_mode,
                                    &failed_match,
                                    &deps,
                                )
                                .await;
                            }
                        }
                    }
                    [single] => {
                        // 1명 남음, re enqueue
                        info!("Single player left, re-enqueueing: {}", single.player_id);
                        re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps)
                            .await;
                    }
                    _ => unreachable!("chunks(2) only returns 1 or 2 elements"),
                }
            }
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Stop> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "NormalMatchmaker for mode {:?} stopping: {:?}",
            self.mode_settings.game_mode, msg.reason
        );
        ctx.stop();
    }
}
</file>

<file path="src/matchmaker/normal/mod.rs">
use std::{
    ops::{Deref, DerefMut},
    time::Duration,
};

use actix::{Actor, Addr, AsyncContext};
use redis::aio::ConnectionManager;
use tokio_util::sync::CancellationToken;
use tracing::{info, warn};

pub mod handlers;

use crate::{
    env::{MatchModeSettings, MatchmakingSettings},
    matchmaker::{common::MatchmakerInner, messages::TryMatch},
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
};

pub struct NormalMatchmaker {
    inner: MatchmakerInner,
}

impl Deref for NormalMatchmaker {
    type Target = MatchmakerInner;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl DerefMut for NormalMatchmaker {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl NormalMatchmaker {
    pub fn new(
        redis: ConnectionManager,
        settings: MatchmakingSettings,
        mode_settings: MatchModeSettings,
        sub_manager_addr: Addr<SubScriptionManager>,
        metrics: std::sync::Arc<MetricsCtx>,
        shutdown_token: CancellationToken,
    ) -> Self {
        Self {
            inner: MatchmakerInner::new(redis, settings, mode_settings, sub_manager_addr, metrics, shutdown_token),
        }
    }
}

impl Actor for NormalMatchmaker {
    type Context = actix::Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!(
            "NormalMatchmaker actor started for mode {:?}",
            self.mode_settings.game_mode
        );
        let interval = self.settings.try_match_tick_interval_seconds;
        let mode_settings = self.mode_settings.clone();

        ctx.run_interval(Duration::from_secs(interval), move |_actor, ctx| {
            ctx.notify(TryMatch {
                match_mode_settings: mode_settings.clone(),
            });
        });
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> actix::Running {
        info!(
            "NormalMatchmaker for mode {:?} stopping, cancelling futures",
            self.mode_settings.game_mode
        );

        // 모든 실행 중인 future에게 종료 신호
        self.shutdown_token.cancel();

        // 완료 대기 (타임아웃 25초)
        if ctx.waiting() {
            info!("Waiting for pending futures to complete");
            ctx.run_later(Duration::from_secs(25), |_act, _ctx| {
                warn!("Graceful shutdown timeout, force stopping");
            });
            actix::Running::Continue
        } else {
            info!("No pending futures, stopping immediately");
            actix::Running::Stop
        }
    }
}
</file>

<file path="src/matchmaker/operations/dequeue.rs">
use backoff::backoff::Backoff;
use redis::{aio::ConnectionManager, RedisResult, Script};
use tokio::time::sleep;
use tracing::{error, info, warn};
use uuid::Uuid;

use crate::{
    matchmaker::{
        operations::notify,
        scripts::{self},
        MatchmakerDeps,
    },
    protocol::{ErrorCode, ServerMessage},
    GameMode, RETRY_CONFIG,
};

async fn invoke_dequeue_script(
    redis: &mut ConnectionManager,
    queue_key: String,
    player_id: Uuid,
) -> RedisResult<Vec<i64>> {
    Script::new(scripts::dequeue_player_script())
        .key(queue_key)
        .arg(player_id.to_string())
        .invoke_async(redis)
        .await
}

pub async fn dequeue(
    queue_suffix: &str,
    game_mode: GameMode,
    player_id: Uuid,
    deps: &MatchmakerDeps,
) {
    let subscription_addr = deps.subscription_addr.clone();
    let mut redis = deps.redis.clone();
    let settings = deps.settings.clone();

    let is_known_mode = settings
        .game_modes
        .iter()
        .any(|mode| mode.game_mode == game_mode);

    if !is_known_mode {
        warn!(
            "Player {} tried to dequeue for unsupported mode {:?}",
            player_id, game_mode
        );
        notify::send_message_to_player(
            subscription_addr,
            &mut redis,
            player_id,
            ServerMessage::Error {
                code: ErrorCode::InvalidGameMode,
                message: "Unsupported game mode".to_string(),
            },
        )
        .await;
        return;
    }

    let suffix = queue_suffix;
    let hash_tag = format!("{{{}}}", suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let mut backoff_state = backoff;
    let dequeue_result = loop {
        let mut redis_clone = redis.clone();

        match invoke_dequeue_script(
            &mut redis_clone,
            queue_key.clone(),
            player_id,
        )
        .await
        {
            Ok(res) => break Ok(res),
            Err(err) => {
                if let Some(delay) = backoff_state.next_backoff() {
                    warn!(
                        "Temporary dequeue failure for player {}: {} (retrying in {:?})",
                        player_id, err, delay
                    );
                    sleep(delay).await;
                    continue;
                } else {
                    break Err(err);
                }
            }
        }
    };

    let result = match dequeue_result {
        Ok(res) => res,
        Err(err) => {
            error!(
                "Failed to dequeue player {} into {}: {}",
                player_id, queue_key, err
            );
            notify::send_message_to_player(
                subscription_addr,
                &mut redis,
                player_id,
                ServerMessage::Error {
                    code: ErrorCode::InternalError,
                    message: "Failed to dequeue".to_string(),
                },
            )
            .await;
            return;
        }
    };

    let removed_flag = result.get(0).copied().unwrap_or_default();
    let current_size = result.get(1).copied().unwrap_or_default();

    let response = if removed_flag == 1 {
        info!(
            "Player {} dequeued for {:?}. queue size = {}",
            player_id, game_mode, current_size
        );
        ServerMessage::DeQueued
    } else {
        warn!("Player {} not found in queue {:?}", player_id, game_mode);
        ServerMessage::Error {
            code: ErrorCode::NotInQueue,
            message: "Not found in queue".to_string(),
        }
    };

    notify::send_message_to_player(subscription_addr, &mut redis, player_id, response).await;
}
</file>

<file path="src/matchmaker/operations/enqueue.rs">
use backoff::backoff::Backoff;
use chrono::Utc;
use redis::{aio::ConnectionManager, RedisResult, Script};
use tokio::time::sleep;
use tracing::{error, info, warn};
use uuid::Uuid;

use crate::{
    matchmaker::{
        operations::{notify, try_match::PlayerCandidate},
        scripts, MatchmakerDeps,
    },
    protocol::{ErrorCode, ServerMessage},
    GameMode, RETRY_CONFIG,
};

async fn invoke_enqueue_script(
    redis: &mut ConnectionManager,
    queue_key: String,
    player_id: Uuid,
    timestamp: String,
    metadata: String,
) -> RedisResult<Vec<i64>> {
    Script::new(scripts::enqueue_player_script())
        .key(queue_key)
        .arg(player_id.to_string())
        .arg(timestamp)
        .arg(metadata)
        .invoke_async(redis)
        .await
}

pub async fn enqueue(
    queue_suffix: &str,
    game_mode: GameMode,
    player_id: Uuid,
    metadata: String,
    deps: &MatchmakerDeps,
) {
    let subscription_addr = deps.subscription_addr.clone();
    let mut redis = deps.redis.clone();
    let settings = deps.settings.clone();

    let is_known_mode = settings
        .game_modes
        .iter()
        .any(|mode| mode.game_mode == game_mode);

    if !is_known_mode {
        warn!(
            "Player {} tried to enqueue for unsupported mode {:?}",
            player_id, game_mode
        );
        notify::send_message_to_player(
            subscription_addr,
            &mut redis,
            player_id,
            ServerMessage::Error {
                code: ErrorCode::InvalidGameMode,
                message: "Unsupported game mode".to_string(),
            },
        )
        .await;
        return;
    }

    let suffix = queue_suffix;
    let hash_tag = format!("{{{}}}", suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let timestamp = Utc::now().timestamp().to_string();

    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let mut backoff_state = backoff;
    let enqueue_result = loop {
        let mut redis_clone = redis.clone();

        match invoke_enqueue_script(
            &mut redis_clone,
            queue_key.clone(),
            player_id,
            timestamp.clone(),
            metadata.clone(),
        )
        .await
        {
            Ok(res) => break Ok(res),
            Err(err) => {
                if let Some(delay) = backoff_state.next_backoff() {
                    warn!(
                        "Temporary enqueue failure for player {}: {} (retrying in {:?})",
                        player_id, err, delay
                    );
                    sleep(delay).await;
                    continue;
                } else {
                    break Err(err);
                }
            }
        }
    };

    let result = match enqueue_result {
        Ok(res) => res,
        Err(err) => {
            error!(
                "Failed to enqueue player {} into {}: {}",
                player_id, queue_key, err
            );
            notify::send_message_to_player(
                subscription_addr,
                &mut redis,
                player_id,
                ServerMessage::Error {
                    code: ErrorCode::InternalError,
                    message: "Failed to enqueue".to_string(),
                },
            )
            .await;
            return;
        }
    };

    let added_flag = result.get(0).copied().unwrap_or_default();
    let current_size = result.get(1).copied().unwrap_or_default();

    let response = if added_flag == 1 {
        info!(
            "Player {} enqueued for {:?}. queue size = {}",
            player_id, game_mode, current_size
        );

        // Metrics: 신규 Enqueue 카운트
        metrics::PLAYERS_ENQUEUED_NEW_TOTAL.inc();
        metrics::ENQUEUED_TOTAL_BY_MODE
            .with_label_values(&[&format!("{:?}", game_mode)])
            .inc();

        ServerMessage::EnQueued
    } else {
        warn!("Player {} already in queue {:?}", player_id, game_mode);

        // Metrics: 중복 Enqueue 시도
        metrics::ABNORMAL_DUPLICATE_ENQUEUE_TOTAL.inc();

        ServerMessage::Error {
            code: ErrorCode::AlreadyInQueue,
            message: "Already in queue".to_string(),
        }
    };

    notify::send_message_to_player(subscription_addr, &mut redis, player_id, response).await;
}

pub async fn re_enqueue_candidates(
    queue_suffix: &str,
    game_mode: GameMode,
    candidates: &[PlayerCandidate],
    deps: &MatchmakerDeps,
) {
    // Metrics: Re-enqueue 카운트
    if !candidates.is_empty() {
        metrics::PLAYERS_REQUEUED_TOTAL.inc_by(candidates.len() as u64);
    }

    for candidate in candidates {
        let player_id = match Uuid::parse_str(&candidate.player_id) {
            Ok(id) => id,
            Err(e) => {
                error!("Invalid player_id during re-enqueue: {}", e);
                continue;
            }
        };

        let metadata_json = match serde_json::to_string(&candidate.metadata) {
            Ok(json) => json,
            Err(e) => {
                error!("Failed to serialize metadata: {}", e);
                continue;
            }
        };

        enqueue(queue_suffix, game_mode, player_id, metadata_json, deps).await;
    }
}
</file>

<file path="src/matchmaker/operations/mod.rs">
pub mod dequeue;
pub mod enqueue;
pub mod notify;
pub mod try_match;
</file>

<file path="src/matchmaker/operations/notify.rs">
use actix::Addr;
use redis::{aio::ConnectionManager, AsyncCommands};
use tracing::warn;
use uuid::Uuid;

use crate::{
    protocol::ServerMessage,
    subscript::{messages::ForwardServerMessage, SubScriptionManager},
    RETRY_CONFIG,
};

/// 플레이어에게 직접 전달 + Redis 발행으로 메시지를 보냅니다.
/// Redis 발행은 외부 관측성을 위함입니다.
pub async fn send_message_to_player(
    subscription_addr: Addr<SubScriptionManager>,
    redis: &mut ConnectionManager,
    player_id: Uuid,
    message: ServerMessage,
) {
    // 직접 전달
    send_direct_message(&subscription_addr, player_id, &message).await;

    // Redis로 발행 (관측성용)
    publish_to_redis_with_retry(redis, player_id, message).await;
}

/// 플레이어에게 직접 메시지 전달 (WebSocket)
async fn send_direct_message(
    subscription_addr: &Addr<SubScriptionManager>,
    player_id: Uuid,
    message: &ServerMessage,
) {
    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let subscription_addr = subscription_addr.clone();
    let message = message.clone();

    let result = backoff::future::retry(backoff, move || {
        let subscription_addr = subscription_addr.clone();
        let message = message.clone();

        async move {
            subscription_addr
                .send(ForwardServerMessage { player_id, message })
                .await
                .map_err(|e| {
                    warn!(
                        "Direct message attempt failed for player {}: {:?}",
                        player_id, e
                    );
                    backoff::Error::Transient {
                        err: "Transient",
                        retry_after: None,
                    }
                })
        }
    })
    .await;

    if let Err(e) = result {
        warn!(
            "Direct message delivery permanently failed for player {}: {:?}",
            player_id, e
        );
    }
}

/// Redis로 메시지 발행 (재시도 포함)
async fn publish_to_redis_with_retry(
    redis: &mut ConnectionManager,
    player_id: Uuid,
    message: ServerMessage,
) {
    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let redis_conn = redis.clone();
    let result = backoff::future::retry(backoff, move || {
        let mut redis_conn = redis_conn.clone();
        let message = message.clone();

        async move {
            let channel = format!("notification:{}", player_id);
            let payload = serde_json::to_string(&message).map_err(|e| {
                warn!(
                    "Failed to serialize message for player {}: {}",
                    player_id, e
                );
                backoff::Error::Permanent("Permanent")
            })?;

            redis_conn
                .publish::<_, _, ()>(&channel, &payload)
                .await
                .map_err(|e| {
                    warn!("Failed to publish to Redis for player {}: {}", player_id, e);
                    backoff::Error::Transient {
                        err: "Transient",
                        retry_after: None,
                    }
                })
        }
    })
    .await;

    if let Err(e) = result {
        warn!(
            "Redis publish permanently failed for player {}: {:?}",
            player_id, e
        );
    }
}
</file>

<file path="src/matchmaker/operations/try_match.rs">
use redis::{aio::ConnectionManager, AsyncCommands, ErrorKind, RedisError, RedisResult, Script};

use crate::{
    matchmaker::{scripts, MatchmakerDeps},
    protocol::BattleRequest,
};

async fn invoke_try_match_script(
    redis: &mut ConnectionManager,
    queue_key: String,
    batch_size: usize,
) -> RedisResult<Vec<String>> {
    Script::new(scripts::try_match_pop_script())
        .key(queue_key)
        .arg(batch_size)
        .invoke_async(redis)
        .await
}

pub async fn pop_candidates(
    queue_suffix: &str,
    batch_size: usize,
    deps: &MatchmakerDeps,
) -> RedisResult<Vec<PlayerCandidate>> {
    if batch_size == 0 {
        return Ok(Vec::new());
    }

    let mut redis = deps.redis.clone();
    let hash_tag = format!("{{{}}}", queue_suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let raw: Vec<String> = invoke_try_match_script(&mut redis, queue_key, batch_size).await?;

    if raw.len() % 3 != 0 {
        return Err(RedisError::from((
            ErrorKind::TypeError,
            "unexpected response length in try_match pop script - expected triplets",
        )));
    }

    let mut candidates = Vec::with_capacity(raw.len() / 3);
    let mut iter = raw.chunks_exact(3);
    while let Some(chunk) = iter.next() {
        let player_id = chunk[0].clone();
        let score = chunk[1].parse::<i64>().map_err(|_| {
            RedisError::from((
                ErrorKind::TypeError,
                "invalid score returned from try_match pop script",
            ))
        })?;
        let metadata_json = chunk[2].clone();

        // metadata 파싱
        let metadata = serde_json::from_str::<serde_json::Value>(&metadata_json).map_err(|e| {
            RedisError::from((
                ErrorKind::TypeError,
                "failed to parse metadata JSON",
                e.to_string(),
            ))
        })?;

        // metadata에서 pod_id 추출
        let pod_id = metadata
            .get("pod_id")
            .and_then(|p| p.as_str())
            .map(String::from)
            .ok_or_else(|| {
                RedisError::from((ErrorKind::TypeError, "pod_id not found in metadata"))
            })?;
        // TODO: pod_id 가 없을 경우, 오염된 플레이어로 간주하고 로그 처리 해당 match 는 실패로 처리.

        candidates.push(PlayerCandidate {
            player_id,
            score,
            pod_id,
            metadata,
        });
    }

    Ok(candidates)
}

/// Battle request를 Redis에 publish하는 헬퍼 함수
pub async fn publish_battle_request(
    redis: &mut ConnectionManager,
    channel: &str,
    request: &BattleRequest,
) -> Result<usize, String> {
    let json = serde_json::to_string(request)
        .map_err(|e| format!("Failed to serialize BattleRequest: {}", e))?;

    // TODO: subscriber_count 를 활용하여 Game Server 생존 여부 확인, 오류 전파 등 구현해야함.
    let subscriber_count = redis
        .publish(channel, json)
        .await
        .map_err(|e| format!("Failed to publish battle request: {}", e))?;

    Ok(subscriber_count)
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PlayerCandidate {
    pub player_id: String,
    pub score: i64,
    pub pod_id: String,
    pub metadata: serde_json::Value,
}
</file>

<file path="src/matchmaker/patry/mod.rs">

</file>

<file path="src/matchmaker/rank/handlers.rs">
use actix::{dev::ContextFutureSpawner, ActorContext, Handler, WrapFuture};
use backoff::backoff::Backoff;
use tokio::time::sleep;
use tracing::{error, info, warn};

use crate::{
    matchmaker::{
        messages::{Dequeue, Enqueue, TryMatch},
        operations::{
            dequeue::dequeue,
            enqueue::{enqueue, re_enqueue_candidates},
            notify,
            try_match::{pop_candidates, publish_battle_request},
        },
        rank::RankedMatchmaker,
        MatchmakerDeps,
    },
    protocol::{BattleRequest, ErrorCode, ServerMessage},
    GameMode, Stop, RETRY_CONFIG,
};

impl Handler<Enqueue> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Enqueue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Ranked {
                warn!(
                    "Player {} tried to enqueue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            enqueue(queue_prefix, msg.game_mode, player_id, msg.metadata, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Dequeue> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Dequeue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Ranked {
                warn!(
                    "Player {} tried to dequeue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            dequeue(queue_prefix, msg.game_mode, player_id, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<TryMatch> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: TryMatch, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let settings = msg.match_mode_settings;
        let queue_suffix = self.queue_suffix(settings.game_mode);
        let required_players = settings.required_players;
        let mut redis = deps.redis.clone();
        let shutdown_token = self.shutdown_token.clone();

        async move {
            // 종료 신호 체크
            if shutdown_token.is_cancelled() {
                info!("TryMatch cancelled due to shutdown");
                return;
            }
            let mut backoff = RETRY_CONFIG
                .read()
                .unwrap()
                .as_ref()
                .expect("Retry config not initialized")
                .clone();

            let candidates = loop {
                // 종료 신호 체크
                if shutdown_token.is_cancelled() {
                    info!("TryMatch cancelled during candidate pop");
                    return;
                }

                match pop_candidates(queue_suffix, required_players as usize * 2, &deps).await {
                    Ok(candidates) => break candidates,
                    Err(err) => {
                        if let Some(delay) = backoff.next_backoff() {
                            warn!(
                                "Failed to pop candidates from queue {}: {} (retrying in {:?})",
                                queue_suffix, err, delay
                            );
                            // 종료 신호와 함께 대기
                            tokio::select! {
                                _ = sleep(delay) => continue,
                                _ = shutdown_token.cancelled() => {
                                    info!("TryMatch cancelled during backoff");
                                    return;
                                }
                            }
                        } else {
                            error!(
                                "Failed to pop candidates after all retries from queue {}: {}",
                                queue_suffix, err
                            );
                            return; // async move 블록 종료
                        }
                    }
                }
            };

            if candidates.is_empty() {
                warn!("No candidates available");
                return;
            }

            // try_match 에 의해 4명이 수집되는데, 모종의 이유로 0~3명이 수집될 수 있음.
            // candidates 에서 2명씩 꺼내어 매칭을 시도하고, 남은 인원은 Re enqueue
            // 2명씩 묶어서 처리
            for chunk in candidates.chunks(2) {
                // 종료 신호 체크 - 이미 pop한 candidates는 re-enqueue
                if shutdown_token.is_cancelled() {
                    warn!("Shutdown requested, re-enqueueing remaining candidates");
                    re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps).await;
                    continue;
                }

                match chunk {
                    [player1, player2] => {
                        // 2명 매칭
                        let request = BattleRequest {
                            player1: player1.clone(),
                            player2: player2.clone(),
                        };

                        match publish_battle_request(
                            &mut redis,
                            &deps.settings.battle_request_channel,
                            &request,
                        )
                        .await
                        {
                            Ok(subscriber_count) => {
                                if subscriber_count == 0 {
                                    // TODO: Game Server 가 구독중이지 않음. -> Game Server 가 죽어있을 가능성이 존재함.
                                    // 자세하게 오류 파악하고 관리 시스템에게 보고 해야함 ( Orchestrator )
                                    warn!("No Game Server is subscribed to battle:request channel");
                                    // 매칭 실패: player1, player2 re enqueue
                                    let failed_match = [player1.clone(), player2.clone()];
                                    re_enqueue_candidates(
                                        queue_suffix,
                                        settings.game_mode,
                                        &failed_match,
                                        &deps,
                                    )
                                    .await;
                                } else {
                                    // Metrics: 매칭 성공
                                    metrics::MATCHES_CREATED_TOTAL.inc();
                                    metrics::MATCHED_PLAYERS_TOTAL_BY_MODE
                                        .with_label_values(&[&format!("{:?}", settings.game_mode)])
                                        .inc_by(2);

                                    info!(
                                        "Battle request sent to {} Game Server(s) for players {} and {}",
                                        subscriber_count, player1.player_id, player2.player_id
                                    );
                                }
                            }
                            Err(err) => {
                                error!("Failed to publish battle request: {}", err);
                                // 매칭 실패: player1, player2 re enqueue
                                let failed_match = [player1.clone(), player2.clone()];
                                re_enqueue_candidates(
                                    queue_suffix,
                                    settings.game_mode,
                                    &failed_match,
                                    &deps,
                                )
                                .await;
                            }
                        }
                    }
                    [single] => {
                        // 1명 남음, re enqueue
                        info!("Single player left, re-enqueueing: {}", single.player_id);
                        re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps)
                            .await;
                    }
                    _ => unreachable!("chunks(2) only returns 1 or 2 elements"),
                }
            }
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Stop> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "RankedMatchmaker for mode {:?} stopping: {:?}",
            self.mode_settings.game_mode, msg.reason
        );
        ctx.stop();
    }
}
</file>

<file path="src/matchmaker/rank/mod.rs">
use std::{
    ops::{Deref, DerefMut},
    time::Duration,
};

use actix::{Actor, Addr, AsyncContext};
use redis::aio::ConnectionManager;
use tokio_util::sync::CancellationToken;
use tracing::{info, warn};

pub mod handlers;

use crate::{
    env::{MatchModeSettings, MatchmakingSettings},
    matchmaker::{common::MatchmakerInner, messages::TryMatch},
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
};

pub struct RankedMatchmaker {
    inner: MatchmakerInner,
}

impl Deref for RankedMatchmaker {
    type Target = MatchmakerInner;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl DerefMut for RankedMatchmaker {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl RankedMatchmaker {
    pub fn new(
        redis: ConnectionManager,
        settings: MatchmakingSettings,
        mode_settings: MatchModeSettings,
        sub_manager_addr: Addr<SubScriptionManager>,
        metrics: std::sync::Arc<MetricsCtx>,
        shutdown_token: CancellationToken,
    ) -> Self {
        Self {
            inner: MatchmakerInner::new(redis, settings, mode_settings, sub_manager_addr, metrics, shutdown_token),
        }
    }
}

impl Actor for RankedMatchmaker {
    type Context = actix::Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!(
            "RankedMatchmaker actor started for mode {:?}",
            self.mode_settings.game_mode
        );
        let interval = self.settings.try_match_tick_interval_seconds;
        let mode_settings = self.mode_settings.clone();

        ctx.run_interval(Duration::from_secs(interval), move |_actor, ctx| {
            ctx.notify(TryMatch {
                match_mode_settings: mode_settings.clone(),
            });
        });
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> actix::Running {
        info!(
            "RankedMatchmaker for mode {:?} stopping, cancelling futures",
            self.mode_settings.game_mode
        );

        // 모든 실행 중인 future에게 종료 신호
        self.shutdown_token.cancel();

        // 완료 대기 (타임아웃 25초)
        if ctx.waiting() {
            info!("Waiting for pending futures to complete");
            ctx.run_later(Duration::from_secs(25), |_act, _ctx| {
                warn!("Graceful shutdown timeout, force stopping");
            });
            actix::Running::Continue
        } else {
            info!("No pending futures, stopping immediately");
            actix::Running::Stop
        }
    }
}
</file>

<file path="src/matchmaker/scripts.rs">
const ENQUEUE_PLAYER_SCRIPT: &str = include_str!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/scripts/ENQUEUE_PLAYER.lua"
));
const DEQUEUE_PLAYER_SCRIPT: &str = include_str!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/scripts/DEQUEUE_PLAYER.lua"
));
const TRY_MATCH_POP_SCRIPT: &str = include_str!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/scripts/TRY_MATCH_POP.lua"
));

pub fn enqueue_player_script() -> &'static str {
    ENQUEUE_PLAYER_SCRIPT
}

pub fn dequeue_player_script() -> &'static str {
    DEQUEUE_PLAYER_SCRIPT
}

pub fn try_match_pop_script() -> &'static str {
    TRY_MATCH_POP_SCRIPT
}
</file>

<file path="src/metrics.rs">
pub struct MetricsCtx;

impl MetricsCtx {
    pub fn new() -> Self {
        Self
    }
    pub fn inc_redis_connection_failure(&self) {
        metrics::REDIS_CONNECTION_FAILURES_TOTAL.inc();
    }
}
</file>

<file path="src/protocol.rs">
use actix::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{matchmaker::operations::try_match::PlayerCandidate, GameMode};

// --- Client to Server Messages ---

#[derive(Deserialize, Message)]
#[rtype(result = "()")]
#[serde(tag = "type")]
pub enum ClientMessage {
    /// 플레이어가 매칭 대기열에 들어가기를 요청합니다.
    #[serde(rename = "enqueue")]
    Enqueue {
        player_id: Uuid,
        game_mode: GameMode,
        metadata: String,
    },

    /// 플레이어가 매칭 대기열에서 나가기를 요청합니다.
    #[serde(rename = "dequeue")]
    Dequeue {
        player_id: Uuid,
        game_mode: GameMode,
    },
}

// --- Server to Client Messages ---
#[derive(Serialize, Deserialize, Message, Clone)]
#[rtype(result = "()")]
#[serde(tag = "type")]
pub enum ServerMessage {
    /// 대기열에 성공적으로 등록되었음을 알립니다.
    #[serde(rename = "enqueued")]
    EnQueued,

    /// 대기열에서 성공적으로 제거되었음을 알립니다.
    #[serde(rename = "dequeued")]
    DeQueued,

    /// 최종적으로 매칭이 성사되었고, 게임 서버 접속 정보를 전달합니다.
    #[serde(rename = "match_found")]
    MatchFound {
        session_id: Uuid, // dedicated_server의 게임 세션 ID
        server_address: String,
    },

    /// 에러가 발생했음을 알립니다.
    /// code는 선택적이며, 구 클라이언트와의 호환을 위해 없을 수 있습니다.
    #[serde(rename = "error")]
    Error { code: ErrorCode, message: String },
}

#[derive(Serialize, Deserialize, Message, Clone, Debug)]
#[rtype(result = "()")]
#[serde(rename_all = "snake_case")]
pub enum ErrorCode {
    InvalidGameMode,
    AlreadyInQueue,
    InternalError,
    NotInQueue,
    InvalidMessageFormat,
    WrongSessionId,
    TemporaryAllocationError,
    DedicatedServerTimeout,
    DedicatedServerErrorResponse,
    MaxRetriesExceeded,
    MatchmakingTimeout,
    PlayerTemporarilyBlocked,
    RateLimitExceeded,
}

// --- Battle Request Messages ---

/// Match Server가 Game Server로 전송하는 전투 요청
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BattleRequest {
    pub player1: PlayerCandidate,
    pub player2: PlayerCandidate,
}

/*
  ---
  📋 전체 요약표

  | 위치                     | Metric                                 | 타입         | 중요도 |
  |------------------------|----------------------------------------|------------|-----|
  | session/mod.rs:113     | ACTIVE_WS_CONNECTIONS.inc()            | Gauge      | ⭐⭐⭐ |
  | session/mod.rs:120     | ACTIVE_WS_CONNECTIONS.dec()            | Gauge      | ⭐⭐⭐ |
  | enqueue.rs:133         | PLAYERS_ENQUEUED_NEW_TOTAL.inc()       | Counter    | ⭐⭐⭐ |
  | enqueue.rs:133         | ENQUEUED_TOTAL_BY_MODE                 | CounterVec | ⭐⭐⭐ |
  | enqueue.rs:140         | ABNORMAL_DUPLICATE_ENQUEUE_TOTAL.inc() | Counter    | ⭐⭐  |
  | enqueue.rs:150         | PLAYERS_REQUEUED_TOTAL.inc_by(n)       | Counter    | ⭐⭐  |
  | rank/handlers.rs:196   | MATCHES_CREATED_TOTAL.inc()            | Counter    | ⭐⭐⭐ |
  | rank/handlers.rs:196   | MATCHED_PLAYERS_TOTAL_BY_MODE          | CounterVec | ⭐⭐⭐ |
  | normal/handlers.rs:196 | (동일)                                   | -          | ⭐⭐⭐ |
  | session/mod.rs:61      | STATE_VIOLATIONS_TOTAL.inc()           | Counter    | ⭐⭐  |
  | session/helper.rs:12   | MATCHMAKING_ERRORS_TOTAL.inc()         | Counter    | ⭐   |

  ---
  🎯 우선순위별 추가 순서

  Phase 1: 필수 (5분)

  1. ✅ ACTIVE_WS_CONNECTIONS (Session 생명주기)
  2. ✅ PLAYERS_ENQUEUED_NEW_TOTAL (Enqueue)
  3. ✅ MATCHES_CREATED_TOTAL (매칭 성공)

  Phase 2: 중요 (10분)

  4. ✅ ENQUEUED_TOTAL_BY_MODE (모드별 분석)
  5. ✅ MATCHED_PLAYERS_TOTAL_BY_MODE (모드별 매칭)
  6. ✅ PLAYERS_REQUEUED_TOTAL (재시도 추적)

  Phase 3: 부가 (5분)

  7. ✅ ABNORMAL_DUPLICATE_ENQUEUE_TOTAL (이상 행동)
  8. ✅ STATE_VIOLATIONS_TOTAL (프로토콜 위반)
  9. ✅ MATCHMAKING_ERRORS_TOTAL (에러 추적)

  ---
  💡 사용하지 않을 Metrics (Game Server용)

  다음 metrics는 Match Server가 아닌 Game Server에서 사용:
  - ❌ LOADING_COMPLETED_TOTAL_BY_MODE
  - ❌ DEDICATED_ALLOCATION_SUCCESS_TOTAL_BY_MODE
  - ❌ LOADING_DURATION_SECONDS
  - ❌ PLAYERS_ALLOCATED_TOTAL
  - ❌ LOADING_SESSION_TIMEOUT_PLAYERS_TOTAL

  ---
  전부 추가해드릴까요? 아니면 Phase 1만 먼저 구현할까요?

*/
</file>

<file path="src/session/handlers.rs">
use crate::{
    protocol::{ClientMessage, ErrorCode, ServerMessage},
    session::{
        helper::{send_err, SessionState},
        Session,
    },
    Stop,
};
use actix::{ActorContext, Handler, StreamHandler};
use actix_web_actors::ws::{self, Message, ProtocolError};
use tracing::{info, warn};

impl Handler<Stop> for Session {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "Stop message received in Session actor. Stopping actor. {:?}",
            msg.reason
        );
        ctx.stop();
    }
}

// SubScription, Matchmaker ( 하위 액터 ) 는 Session 을 거쳐서 Client 와 통신함.
impl Handler<ServerMessage> for Session {
    type Result = ();

    fn handle(&mut self, msg: ServerMessage, ctx: &mut Self::Context) -> Self::Result {
        match &msg {
            ServerMessage::EnQueued => {
                // 하위 액터에서 Client 에게 메시지를 보낸다는 것은, Queue 에 성공적으로 등록되었음을 의미함.
                self.transition_to(SessionState::InQueue, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::EnQueued");
                }
            }
            ServerMessage::DeQueued => {
                self.transition_to(SessionState::Dequeued, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::DeQueued");
                }
            }
            ServerMessage::MatchFound {
                session_id: _,
                server_address: _,
            } => {
                self.transition_to(SessionState::Completed, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::MatchFound");
                }
                ctx.close(Some(ws::CloseCode::Normal.into()));
                ctx.stop();
            }
            ServerMessage::Error {
                code: _,
                message: _,
            } => {
                self.transition_to(SessionState::Error, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::Error");
                }
                ctx.stop();
            }
        }
    }
}

impl StreamHandler<Result<Message, ProtocolError>> for Session {
    fn handle(&mut self, msg: Result<Message, ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {}
            Ok(ws::Message::Text(text)) => match serde_json::from_str::<ClientMessage>(&text) {
                Ok(ClientMessage::Enqueue {
                    player_id,
                    game_mode,
                    metadata,
                }) => {
                    self.handle_enqueue(ctx, player_id, game_mode, metadata);
                }
                Ok(ClientMessage::Dequeue {
                    player_id,
                    game_mode,
                }) => {
                    self.handle_dequeue(ctx, player_id, game_mode);
                }
                Err(e) => {
                    warn!("Failed to parse client message: {}", e);
                    send_err(
                        ctx,
                        ErrorCode::InvalidMessageFormat,
                        "Invalid message format",
                    );
                }
            },
            Ok(ws::Message::Close(reason)) => {
                ctx.close(reason);
                ctx.stop();
            }
            _ => ctx.stop(),
        }
    }
}
</file>

<file path="src/session/helper.rs">
use crate::{
    protocol::{ErrorCode, ServerMessage},
    session::Ctx,
};

pub enum TransitionViolation {
    Minor,
    Major,
    Critical,
}

pub fn send_err(ctx: &mut Ctx, code: ErrorCode, message: &str) {
    // Metrics: 에러 메시지 카운트
    metrics::MATCHMAKING_ERRORS_TOTAL.inc();

    if let Ok(text) = serde_json::to_string(&ServerMessage::Error {
        code: code,
        message: message.to_string(),
    }) {
        ctx.text(text);
    }
}

pub fn classify_violation(from: SessionState, to: SessionState) -> TransitionViolation {
    use SessionState::*;
    match (from, to) {
        // 클라이언트 타이밍 이슈 (경미함)
        (InQueue, Enqueuing) => TransitionViolation::Minor,
        (InQueue, Dequeuing) if from == to => TransitionViolation::Minor,

        // 논리적 모순 (심각함)
        (Completed, Enqueuing) => TransitionViolation::Major,
        (Completed, Dequeuing) => TransitionViolation::Major,

        // 명백한 프로토콜 위반 (치명적)
        (Error, InQueue) => TransitionViolation::Critical,
        (Error, Enqueuing) => TransitionViolation::Critical,

        _ => TransitionViolation::Major,
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum SessionState {
    Idle,          // 초기 상태. 세션 생성 직후.
    Enqueuing,     // Enqueue 요청을 받고 대기열에 등록 중.
    InQueue,       // 큐에 성공적으로 등록됨.
    Dequeuing,     // Dequeue 요청을 받고 대기열에서 제거 중.
    Dequeued,      // 큐에서 성공적으로 제거됨.
    Completed,     // 정상적으로 매칭이 성사됨.
    Disconnecting, // 정상적으로 종료됨.
    Error,         // 오류 발생으로 인한 세션 종료 상태.
}

impl SessionState {
    pub fn can_transition_to(&self, new_state: SessionState) -> bool {
        use SessionState::*;
        match (self, new_state) {
            // From Idle
            (Idle, Enqueuing) => true,
            (Idle, Error) => true,

            // From Enqueuing
            (Enqueuing, InQueue) => true,
            (Enqueuing, Error) => true,
            (Enqueuing, Disconnecting) => true,

            // From InQueue
            (InQueue, Dequeuing) => true,
            (InQueue, Completed) => true,
            (InQueue, Error) => true,
            (InQueue, Disconnecting) => true,

            // From Dequeuing
            (Dequeuing, Dequeued) => true,
            (Dequeuing, Error) => true,
            (Dequeuing, Disconnecting) => true,

            // From Dequeued
            (Dequeued, Enqueuing) => true,
            (Dequeued, Error) => true,
            (Dequeued, Disconnecting) => true,

            // From Completed
            (Completed, Disconnecting) => true,
            (Completed, Error) => true,

            // Disconnecting, Error 에서 State 전환 불가.
            _ => false,
        }
    }

    /// Get human-readable description of the state
    pub fn description(&self) -> &'static str {
        match self {
            SessionState::Idle => "Waiting for player input",
            SessionState::Enqueuing => "Processing enqueue request",
            SessionState::InQueue => "Waiting for match",
            SessionState::Dequeuing => "Processing dequeue request",
            SessionState::Dequeued => "Dequeued from queue",
            SessionState::Completed => "Match completed successfully",
            SessionState::Disconnecting => "Cleaning up connection",
            SessionState::Error => "Error occurred, cleaning up",
        }
    }
}
</file>

<file path="src/session/mod.rs">
use crate::matchmaker::messages::{Dequeue, Enqueue};
use crate::protocol::ErrorCode;
use crate::session::helper::{classify_violation, send_err, SessionState, TransitionViolation};
use crate::subscript::messages::{Deregister, Register};
use crate::{matchmaker::MatchmakerAddr, subscript::SubScriptionManager, AppState, GameMode};
use crate::{Stop, StopReason};
use actix::dev::ContextFutureSpawner;
use actix::ActorContext;
use actix::{Actor, Addr, WrapFuture};
use actix::{AsyncContext, Running};
use actix_web::web;
use actix_web_actors::ws::{self};
use std::cell::OnceCell;
use std::time::Instant;
use std::{net::IpAddr, time::Duration};
use tracing::{info, warn};
use uuid::Uuid;

pub mod handlers;
pub mod helper;

type Ctx = ws::WebsocketContext<Session>;

pub struct Session {
    state: SessionState,
    matchmaker_addr: OnceCell<MatchmakerAddr>,
    subscript_addr: Addr<SubScriptionManager>,
    app_state: web::Data<AppState>,
    player_id: Uuid,
    game_mode: GameMode,
    heartbeat_interval: Duration,
    heartbeat_timeout: Duration,
    last_heartbeat: Instant,
    cleanup_started: bool,
    client_ip: IpAddr,
}

impl Session {
    pub fn new(
        subscript_addr: Addr<SubScriptionManager>,
        heartbeat_interval: Duration,
        heartbeat_timeout: Duration,
        app_state: web::Data<AppState>,
        client_ip: IpAddr,
    ) -> Self {
        Self {
            state: SessionState::Idle,
            matchmaker_addr: OnceCell::new(),
            subscript_addr,
            app_state,
            player_id: Uuid::new_v4(),
            game_mode: GameMode::None,
            heartbeat_interval,
            heartbeat_timeout,
            last_heartbeat: Instant::now(),
            cleanup_started: false,
            client_ip,
        }
    }

    fn transition_to(&mut self, new_state: SessionState, ctx: &mut ws::WebsocketContext<Self>) {
        // 유효한 상태 전환인지 확인. 만약 유효하지 않다면 Error 상태로 전환 후 error 메시지 전송.
        if !self.state.can_transition_to(new_state) {
            let violation = classify_violation(self.state, new_state);

            // Metrics: 상태 전환 위반
            metrics::STATE_VIOLATIONS_TOTAL.inc();

            match violation {
                TransitionViolation::Minor => {
                    warn!("Minor state violation, ignoring transition");
                    return; // 현재 상태 유지
                }

                TransitionViolation::Major => {
                    self.state = SessionState::Error;
                    send_err(ctx, ErrorCode::InternalError, "Invalid state transition");
                    return;
                }

                TransitionViolation::Critical => {
                    send_err(ctx, ErrorCode::InternalError, "Critical protocol violation");
                    // 메시지 전송 후 약간 대기 후 우아하게 종료
                    ctx.run_later(Duration::from_millis(100), |_act, ctx| {
                        ctx.close(Some(ws::CloseCode::Protocol.into()));
                        ctx.stop();
                    });
                    return;
                }
            }
        }
        let old_state = self.state;
        self.state = new_state;

        info!(
            "Player {:?} transitioned: {} -> {}",
            self.player_id,
            old_state.description(),
            new_state.description()
        );
    }

    fn hb(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_interval(self.heartbeat_interval, |act, ctx| {
            if act.last_heartbeat.elapsed() > act.heartbeat_timeout {
                info!("Websocket Client heartbeat failed, disconnecting!");
                ctx.stop();
                return;
            }
            ctx.ping(b"");
        });
    }
}

impl Actor for Session {
    type Context = Ctx;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!("Session started for player {:?}", self.player_id);

        // Metrics: WebSocket 연결 증가
        metrics::ACTIVE_WS_CONNECTIONS.inc();

        self.transition_to(SessionState::Idle, ctx);

        self.hb(ctx);
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> Running {
        info!("Session stopping for player {:#?}", self.player_id);

        // Metrics: WebSocket 연결 감소
        metrics::ACTIVE_WS_CONNECTIONS.dec();

        if self.cleanup_started {
            return Running::Stop;
        }

        self.cleanup_started = true;

        ctx.run_later(Duration::from_secs(10), |_act, ctx| {
            warn!("Cleanup wachdog triggered - forcing shutdown");
            ctx.stop();
        });

        let matchmaker_addr = self.matchmaker_addr.get().cloned();
        let subscription_addr = self.subscript_addr.clone();
        let ctx_clone = ctx.address();
        let player_id = self.player_id.clone();
        let game_mode = self.game_mode.clone();

        async move {
            let res_match = if let Some(addr) = matchmaker_addr {
                addr.dequeue(Dequeue {
                    player_id,
                    game_mode,
                })
                .await
            } else {
                Ok(())
            };
            let res_sub = subscription_addr.send(Deregister { player_id }).await;

            match (res_match, res_sub) {
                (Ok(()), Ok(())) => {
                    info!("Successfully sent message to matchmaker and subscription manager.")
                }
                (Ok(()), Err(e)) => {
                    warn!("Failed to send Dequeue to matchmaker manager. : {:?}", e)
                }
                (Err(e), Ok(())) => warn!(
                    "Failed to send Deregister to subscription manager. : {:?}",
                    e
                ),
                (Err(e), Err(_e)) => warn!(
                    "Failed to send message to matchmaker and subscription manager. {:?}, {:?}",
                    e, _e
                ),
            }

            ctx_clone.do_send(Stop {
                reason: StopReason::GracefulShutdown,
            });
        }
        .into_actor(self)
        .wait(ctx);

        Running::Continue
    }
}

impl Session {
    fn handle_enqueue(
        &mut self,
        ctx: &mut Ctx,
        player_id: Uuid,
        game_mode: GameMode,
        metadata: String,
    ) {
        // Rate limiting check
        if !self.app_state.rate_limiter.check(&self.client_ip) {
            warn!("Rate limit exceeded for IP: {}", self.client_ip);
            send_err(
                ctx,
                ErrorCode::RateLimitExceeded,
                "Too many requests. Please slow down.",
            );
            return;
        }

        // Session 객체 상태가 Idle 에서만 Enqueue 허용
        if self.state != SessionState::Idle && self.state != SessionState::Error {
            warn!(
                "Player {:?} sent Enqueue request in invalid state: {:?}. Ignoring.",
                self.player_id, self.state
            );
            return;
        }

        let matchmaker = match self.resolve_matchmaker(game_mode) {
            Ok(handle) => handle,
            Err(code) => {
                send_err(ctx, code, "Unsupported game mode");
                return;
            }
        };

        self.transition_to(SessionState::Enqueuing, ctx);

        self.player_id = player_id;
        self.game_mode = game_mode;
        matchmaker.do_send_enqueue(Enqueue {
            player_id: self.player_id,
            game_mode: self.game_mode,
            metadata,
        });

        self.subscript_addr.do_send(Register {
            player_id,
            addr: ctx.address(),
        });
    }

    fn handle_dequeue(&mut self, ctx: &mut Ctx, player_id: Uuid, game_mode: GameMode) {
        // InQueue 상태에서만 Dequeue 허용
        if self.state != SessionState::InQueue {
            warn!(
                "Player {:?} sent Dequeue request in invalid state: {:?}. Ignoring.",
                self.player_id, self.state
            );
            return;
        }

        // player_id 검증
        if self.player_id != player_id {
            send_err(ctx, ErrorCode::WrongSessionId, "Player ID mismatch");
            return;
        }

        let matchmaker = match self.resolve_matchmaker(game_mode) {
            Ok(handle) => handle,
            Err(code) => {
                send_err(ctx, code, "Unsupported game mode");
                return;
            }
        };

        self.transition_to(SessionState::Dequeuing, ctx);

        matchmaker.do_send_dequeue(Dequeue {
            player_id: self.player_id,
            game_mode: self.game_mode,
        });
    }
}

impl Session {
    fn resolve_matchmaker(&mut self, game_mode: GameMode) -> Result<MatchmakerAddr, ErrorCode> {
        if let Some(existing) = self.matchmaker_addr.get() {
            return Ok(existing.clone());
        }

        let handle = self
            .app_state
            .matchmakers
            .get(&game_mode)
            .cloned()
            .ok_or(ErrorCode::InvalidGameMode)?;

        let _ = self.matchmaker_addr.set(handle.clone());

        Ok(handle)
    }
}
</file>

<file path="src/subscript/handlers.rs">
use actix::{ActorContext, Context, Handler};
use tracing::{info, warn};

use crate::{
    subscript::{
        messages::{Deregister, ForwardServerMessage, Register},
        SubScriptionManager,
    },
    Stop,
};

impl Handler<ForwardServerMessage> for SubScriptionManager {
    type Result = ();
    fn handle(&mut self, msg: ForwardServerMessage, _ctx: &mut Context<Self>) -> Self::Result {
        if let Some(session_addr) = self.sessions.get(&msg.player_id) {
            session_addr.do_send(msg.message);
        } else {
            warn!(
                "Could not find session for player {} to forward message.",
                msg.player_id
            );
        }
    }
}

impl Handler<Register> for SubScriptionManager {
    type Result = ();
    fn handle(&mut self, msg: Register, _ctx: &mut Context<Self>) -> Self::Result {
        info!("Player {} registered for notifications.", msg.player_id);
        self.sessions.insert(msg.player_id, msg.addr);
    }
}

impl Handler<Deregister> for SubScriptionManager {
    type Result = ();
    fn handle(&mut self, msg: Deregister, _ctx: &mut Context<Self>) -> Self::Result {
        info!("Player {} deregistered.", msg.player_id);
        let _ = self.sessions.remove(&msg.player_id);
    }
}

impl Handler<Stop> for SubScriptionManager {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "Stop message received in SubScriptionManager actor. Stopping actor. {:?}",
            msg.reason
        );
        self.sessions.clear();
        ctx.stop();
    }
}
</file>

<file path="src/subscript/messages.rs">
use actix::{Addr, Message};
use uuid::Uuid;

use crate::{protocol::ServerMessage, session::Session};

#[derive(Message)]
#[rtype(result = "()")]
pub struct Register {
    pub player_id: Uuid,
    pub addr: Addr<Session>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct Deregister {
    pub player_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct ForwardServerMessage {
    pub player_id: Uuid,
    pub message: ServerMessage,
}
</file>

<file path="src/subscript/mod.rs">
use std::collections::HashMap;

use actix::{Actor, Addr, Context};
use uuid::Uuid;

use crate::session::Session;

pub mod handlers;
pub mod messages;

pub struct SubScriptionManager {
    pub sessions: HashMap<Uuid, Addr<Session>>,
}

impl Actor for SubScriptionManager {
    type Context = Context<Self>;
}

impl SubScriptionManager {
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
        }
    }
}
</file>

</files>
