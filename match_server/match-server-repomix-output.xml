This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/workflows/main.yml
.gitignore
Cargo.toml
config/development.toml
config/production.toml
SAFETY_IMPROVEMENTS.md
scripts/DEQUEUE_PLAYER.lua
scripts/ENQUEUE_PLAYER.lua
scripts/TRY_MATCH_POP.lua
src/env.rs
src/lib.rs
src/main.rs
src/matchmaker/common.rs
src/matchmaker/messages.rs
src/matchmaker/mod.rs
src/matchmaker/normal/handlers.rs
src/matchmaker/normal/mod.rs
src/matchmaker/operations/dequeue.rs
src/matchmaker/operations/enqueue.rs
src/matchmaker/operations/mod.rs
src/matchmaker/operations/notify.rs
src/matchmaker/operations/try_match.rs
src/matchmaker/patry/mod.rs
src/matchmaker/rank/handlers.rs
src/matchmaker/rank/mod.rs
src/matchmaker/scripts.rs
src/metrics.rs
src/protocol.rs
src/session/handlers.rs
src/session/helper.rs
src/session/mod.rs
src/subscript/handlers.rs
src/subscript/messages.rs
src/subscript/mod.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/main.yml">
name: Code Coverage

on:
  pull_request:
    branches: [ main, master ]

jobs:
  codecov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true
          components: llvm-tools-preview
      
      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      
      - name: Generate code coverage
        run: cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: lcov.info
</file>

<file path=".gitignore">
/target
</file>

<file path="Cargo.toml">
[package]
name = "match_server"
version = "0.1.0"
edition = "2021"
description = "card backend"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html


[dependencies]
async-trait = "0.1.89"
tokio = { version = "1.15", features = ["full", "tracing"] }
tokio-util = "0.7"
tracing = "0.1.41"
tracing-appender = "0.2.3"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
actix-web = "4.9.0"
actix = "=0.13.5"
actix-web-actors = "4.3.0"
reqwest = { version = "0.12.12", features = ["json"] }
uuid = { version = "1.14.0", features = ["v4", "serde"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
futures-util = {version = "0.3", features = ["sink"]}
futures = "0.3.31"
redis = { version = "0.22.3", features = ["tokio-comp", "connection-manager"] }
dotenv = "0.15.0"
config = {version = "0.15.11", features = ["toml"]}
jsonwebtoken = "9.3.1"
chrono = { version = "0.4.41", features = ["serde"] }
thiserror = "1.0"
backoff = { version = "0.4.0", features = ["tokio"] }
lazy_static = "1.5.0"

metrics = { path = "../metrics" }
prometheus = { version = "0.14", features = ["process"] }

[dev-dependencies]
tokio-test = "0.4"
</file>

<file path="config/development.toml">
# ì„œë²„ ì„¤ì •
[server]
bind_address = "0.0.0.0"
port = 8080
log_level = "info" # ë¡œê·¸ ë ˆë²¨
# metrics_auth_token = "secret-token-here"  # Optional: enable for metrics endpoint auth

# ë¡œê¹… ì„¤ì •
[logging]
directory = "logs"
filename = "app.log"

# Redis ì„¤ì •
[redis]
url = "redis://127.0.0.1:6379"
max_reconnect_attempts = 10
initial_reconnect_delay_ms = 1000
max_reconnect_delay_ms = 60000

[jwt]
secret = "your-super-secret-and-long-key-that-no-one-knows"

# ì¬ì‹œë„ ì„¤ì •
[retry]
message_max_elapsed_time_ms = 500
message_initial_interval_ms = 10
message_max_interval_ms = 100

# ë§¤ì¹˜ë©”ì´í‚¹ ì„¤ì •
[matchmaking]
try_match_tick_interval_seconds = 1
queue_key_prefix = "queue"
queue_order_key_prefix = "queue_order"
match_fetch_request_channel_prefix = "match_fetch_req"
match_fetch_ack_channel_prefix = "match_fetch_ack"
battle_request_channel = "battle:request"
battle_result_channel_prefix = "pod"
heartbeat_interval_seconds = 30
heartbeat_timeout = 120
max_dedicated_server_retries = 5
dedicated_request_timeout_seconds = 3
allocation_token_ttl_seconds = 20
slow_loading_threshold_seconds = 15

# ê²Œì„ ì„œë²„ ìƒíƒœ ë¬¸ìì—´
[server_status]
idle = "idle"

# ê²Œì„ ëª¨ë“œ ëª©ë¡ (í…Œì´ë¸” ë°°ì—´)
# ê° [[matchmaking.game_modes]] í•­ëª©ì´ í•˜ë‚˜ì˜ ê²Œì„ ëª¨ë“œë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
[[matchmaking.game_modes]]
game_mode = "Normal"        # ê²Œì„ ëª¨ë“œ
required_players = 2        # ë§¤ì¹­ì— í•„ìš”í•œ ì¸ì›
use_mmr_matching = false    # MMR ê¸°ë°˜ ë§¤ì¹­ ì‚¬ìš© ì—¬ë¶€ (ì¼ë°˜ ëª¨ë“œ)

[[matchmaking.game_modes]]
game_mode = "Ranked"
required_players = 2
use_mmr_matching = true     # ë­í¬ ëª¨ë“œì—ì„œëŠ” ì´ ê°’ì„ trueë¡œ ì„¤ì •
</file>

<file path="config/production.toml">
# ì„œë²„ ì„¤ì •
[server]
bind_address = "0.0.0.0"
port = 8080
log_level = "warn" # ë¡œê·¸ ë ˆë²¨
# metrics_auth_token = "CHANGE-ME-IN-PRODUCTION"  # Set via env: APP_SERVER__METRICS_AUTH_TOKEN

# ë¡œê¹… ì„¤ì •
[logging]
directory = "logs"
filename = "app.log"

# Redis ì„¤ì •
[redis]
url = "redis://your-production-redis-endpoint:6379"
max_reconnect_attempts = 10
initial_reconnect_delay_ms = 1000
max_reconnect_delay_ms = 60000

[jwt]
secret = "a-very-secure-secret-that-should-be-injected-via-env-vars"

# ì¬ì‹œë„ ì„¤ì •
[retry]
message_max_elapsed_time_ms = 500
message_initial_interval_ms = 10
message_max_interval_ms = 100

# ë§¤ì¹˜ë©”ì´í‚¹ ì„¤ì •
[matchmaking]
try_match_tick_interval_seconds = 5
queue_key_prefix = "queue"
queue_order_key_prefix = "queue_order"
match_fetch_request_channel_prefix = "match_fetch_req"
match_fetch_ack_channel_prefix = "match_fetch_ack"
battle_request_channel = "battle:request"
battle_result_channel_prefix = "pod"
heartbeat_interval_seconds = 30
heartbeat_timeout = 120
max_dedicated_server_retries = 5
dedicated_request_timeout_seconds = 5
allocation_token_ttl_seconds = 20
slow_loading_threshold_seconds = 20

# ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì„¤ì •
[blacklist]
timeout_threshold = 3
timeout_window_hours = 1
block_duration_minutes = 10
check_ip_change = true
ip_change_strategy = "ReduceByPercent"
ip_change_reduction_percent = 50
ip_change_min_violations_to_keep = 1

# ê²Œì„ ì„œë²„ ìƒíƒœ ë¬¸ìì—´
[server_status]
idle = "idle"

# ê²Œì„ ëª¨ë“œ ëª©ë¡ (í…Œì´ë¸” ë°°ì—´)
[[matchmaking.game_modes]]
game_mode = "Normal"
required_players = 2
use_mmr_matching = false

[[matchmaking.game_modes]]
game_mode = "Ranked"
required_players = 2
use_mmr_matching = true
</file>

<file path="SAFETY_IMPROVEMENTS.md">
# Match Server ì•ˆì „ ì¥ì¹˜ ê°œì„  ì‚¬í•­

í˜„ì¬ `CancellationToken`ìœ¼ë¡œ ì¢€ë¹„ Future ë°©ì§€ëŠ” êµ¬í˜„ë˜ì—ˆìœ¼ë‚˜, ì¶”ê°€ë¡œ í•„ìš”í•œ ì•ˆì „ ì¥ì¹˜ë“¤ì„ ì •ë¦¬í•©ë‹ˆë‹¤.

---

## ìš°ì„ ìˆœìœ„ ìš”ì•½

| ìš°ì„ ìˆœìœ„ | ì•ˆì „ì¥ì¹˜ | êµ¬í˜„ ë‚œì´ë„ | ì˜í–¥ë„ | ìƒíƒœ |
|---------|---------|------------|--------|------|
| **P0** | **Redis Timeout ë³´í˜¸** | ì‰¬ì›€ | ì¹˜ëª…ì  (ë¬´í•œ ëŒ€ê¸°) | âŒ ë¯¸êµ¬í˜„ |
| **P0** | **Max In-Flight Limit** | ì‰¬ì›€ | ë†’ìŒ (ê³¼ë¶€í•˜ ë°©ì§€) | âŒ ë¯¸êµ¬í˜„ |
| **P1** | **Poison Message ì²˜ë¦¬** | ì¤‘ê°„ | ì¤‘ê°„ (ê°€ìš©ì„±) | âš ï¸ TODO ìˆìŒ |
| **P1** | **Game Server Monitor** | ì‰¬ì›€ | ì¤‘ê°„ (ìš´ì˜ ê°€ì‹œì„±) | âš ï¸ TODO ìˆìŒ |
| **P2** | **Circuit Breaker** | ì¤‘ê°„ | ë‚®ìŒ (ì¥ì•  ì‹œê°„ ë‹¨ì¶•) | âŒ ë¯¸êµ¬í˜„ |
| âœ… | **Re-enqueue on Failure** | - | - | âœ… êµ¬í˜„ë¨ |

---

## P0: Redis Timeout ë³´í˜¸ (ì¹˜ëª…ì )

### ë¬¸ì œ

Redis ì‘ì—…ì´ ë¬´í•œ ëŒ€ê¸°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
// í˜„ì¬ ì½”ë“œ (rank/handlers.rs:123)
match pop_candidates(queue_suffix, required_players as usize * 2, &deps).await {
    Ok(candidates) => break candidates,
    Err(err) => { /* retry */ }
}

// try_match.rs:94
let subscriber_count = redis.publish(channel, json).await?;
```

**ì‹œë‚˜ë¦¬ì˜¤**: Redis ë„¤íŠ¸ì›Œí¬ ì¥ì•  â†’ `.await`ê°€ ì˜ì›íˆ ë¦¬í„´ ì•ˆ í•¨ â†’ Actor ë©ˆì¶¤

### í•´ê²°ì±…

#### 1. Settingsì— timeout ì„¤ì • ì¶”ê°€

```rust
// env.rs
#[derive(Debug, Deserialize, Clone)]
pub struct MatchmakingSettings {
    pub redis_operation_timeout_seconds: u64,  // ì¶”ê°€ (ê¶Œì¥: 10)
    // ...
}
```

```toml
# config/production.toml
[matchmaking]
redis_operation_timeout_seconds = 10
```

#### 2. Timeout wrapper í•¨ìˆ˜ ì‘ì„±

```rust
// matchmaker/operations/mod.rs
use tokio::time::{timeout, Duration};

pub async fn with_timeout<F, T>(
    operation_name: &str,
    timeout_secs: u64,
    future: F,
) -> Result<T, String>
where
    F: Future<Output = Result<T, String>>,
{
    match timeout(Duration::from_secs(timeout_secs), future).await {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(err)) => Err(err),
        Err(_) => {
            error!("{} timeout after {}s", operation_name, timeout_secs);
            Err(format!("{} timeout", operation_name))
        }
    }
}
```

#### 3. ëª¨ë“  Redis ì‘ì—…ì— ì ìš©

```rust
// rank/handlers.rs:123
let timeout_secs = deps.settings.redis_operation_timeout_seconds;

match with_timeout(
    "pop_candidates",
    timeout_secs,
    async {
        pop_candidates(queue_suffix, required_players * 2, &deps)
            .await
            .map_err(|e| e.to_string())
    }
).await {
    Ok(candidates) => break candidates,
    Err(err) => {
        // timeout ë˜ëŠ” Redis ì—ëŸ¬
        if let Some(delay) = backoff.next_backoff() { /* retry */ }
    }
}

// publishë„ ë™ì¼í•˜ê²Œ
with_timeout(
    "publish_battle_request",
    timeout_secs,
    async {
        publish_battle_request(&mut redis, channel, &request).await
    }
).await?;
```

### íš¨ê³¼

- Redis ì¥ì•  ì‹œ 10ì´ˆ í›„ ìë™ ë³µêµ¬ ì‹œë„
- Actorê°€ ë¬´í•œ ëŒ€ê¸° ìƒíƒœì— ë¹ ì§€ì§€ ì•ŠìŒ
- ëª…í™•í•œ ì—ëŸ¬ ë¡œê·¸ (timeout vs network error)

---

## P0: Max In-Flight Limit (ê³¼ë¶€í•˜ ë°©ì§€)

### ë¬¸ì œ

ë™ì‹œì— ë„ˆë¬´ ë§ì€ TryMatchê°€ ì‹¤í–‰ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
// rank/mod.rs:62
ctx.run_interval(Duration::from_secs(5), move |_actor, ctx| {
    ctx.notify(TryMatch { ... });  // ë¬´ì¡°ê±´ ì‹¤í–‰!
});
```

**ì‹œë‚˜ë¦¬ì˜¤**:
```
ì‹œê°„ 0ì´ˆ:  TryMatch #1 ì‹œì‘ (Redis ëŠë¦¼, 20ì´ˆ ì†Œìš”)
ì‹œê°„ 5ì´ˆ:  TryMatch #2 ì‹œì‘ (interval íŠ¸ë¦¬ê±°)
ì‹œê°„ 10ì´ˆ: TryMatch #3 ì‹œì‘
ì‹œê°„ 15ì´ˆ: TryMatch #4 ì‹œì‘
â†’ ë™ì‹œì— 4ê°œ ì‹¤í–‰ ì¤‘! Redis/Game Server í­ì£¼ ğŸ˜±
```

### í•´ê²°ì±…

#### 1. MatchmakerInnerì— í”Œë˜ê·¸ ì¶”ê°€

```rust
// matchmaker/common.rs
use std::sync::atomic::{AtomicBool, Ordering};

pub struct MatchmakerInner {
    pub is_try_match_running: Arc<AtomicBool>,
    // ...
}

impl MatchmakerInner {
    pub fn new(...) -> Self {
        Self {
            is_try_match_running: Arc::new(AtomicBool::new(false)),
            // ...
        }
    }
}
```

#### 2. Handlerì—ì„œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€

```rust
// rank/handlers.rs:92
impl Handler<TryMatch> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: TryMatch, ctx: &mut Self::Context) -> Self::Result {
        // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´ ìŠ¤í‚µ
        if self.is_try_match_running.swap(true, Ordering::Relaxed) {
            warn!("TryMatch already running, skipping this tick");
            return;
        }

        let deps: MatchmakerDeps = (&self.inner).into();
        let is_running = self.is_try_match_running.clone();
        let shutdown_token = self.shutdown_token.clone();
        // ...

        async move {
            // ... ê¸°ì¡´ ë¡œì§ ...

            // ì™„ë£Œ í›„ í”Œë˜ê·¸ í•´ì œ
            is_running.store(false, Ordering::Relaxed);
        }
        .into_actor(self)
        .wait(ctx);
    }
}
```

#### 3. ë©”íŠ¸ë¦­ ì¶”ê°€ (ì„ íƒ)

```rust
// ìŠ¤í‚µ íšŸìˆ˜ ê¸°ë¡
if self.is_try_match_running.swap(true, Ordering::Relaxed) {
    warn!("TryMatch already running, skipping this tick");
    deps.metrics.try_match_skipped.inc();
    return;
}
```

### íš¨ê³¼

- ë™ì‹œ ì‹¤í–‰ = ìµœëŒ€ 1ê°œë¡œ ì œí•œ
- Redis/Game Server ë¶€í•˜ ì˜ˆì¸¡ ê°€ëŠ¥
- ëŠë¦° ì‘ì—…ì´ ìŒ“ì´ì§€ ì•ŠìŒ

---

## P1: Poison Message ì²˜ë¦¬

### ë¬¸ì œ

`pod_id` ì—†ëŠ” í”Œë ˆì´ì–´ 1ëª… ë•Œë¬¸ì— ì „ì²´ ë§¤ì¹­ ì‹¤íŒ¨í•©ë‹ˆë‹¤.

```rust
// try_match.rs:64-71
let pod_id = metadata
    .get("pod_id")
    .and_then(|p| p.as_str())
    .map(String::from)
    .ok_or_else(|| {
        RedisError::from((ErrorKind::TypeError, "pod_id not found in metadata"))
    })?;  // âŒ ì—¬ê¸°ì„œ ì—ëŸ¬ â†’ ì „ì²´ candidates ë²„ë¦¼!

// TODO: pod_id ê°€ ì—†ì„ ê²½ìš°, ì˜¤ì—¼ëœ í”Œë ˆì´ì–´ë¡œ ê°„ì£¼í•˜ê³  ë¡œê·¸ ì²˜ë¦¬ í•´ë‹¹ match ëŠ” ì‹¤íŒ¨ë¡œ ì²˜ë¦¬.
```

**ì‹œë‚˜ë¦¬ì˜¤**:
```
Queue: [Player1(ì •ìƒ), Player2(pod_id ì—†ìŒ), Player3(ì •ìƒ), Player4(ì •ìƒ)]
â†’ pop_candidates() í˜¸ì¶œ
â†’ Player2ì—ì„œ ì—ëŸ¬ ë°œìƒ
â†’ ì „ì²´ Err ë°˜í™˜
â†’ Player1, 3, 4ë„ ë§¤ì¹­ ì‹¤íŒ¨ ğŸ˜±
```

### í•´ê²°ì±…

#### 1. PoisonedCandidate íƒ€ì… ì¶”ê°€

```rust
// try_match.rs:102 ì•„ë˜
#[derive(Debug, Clone)]
pub struct PoisonedCandidate {
    pub player_id: String,
    pub reason: String,
}
```

#### 2. pop_candidates ë°˜í™˜ íƒ€ì… ë³€ê²½

```rust
// try_match.rs:20
pub async fn pop_candidates(
    queue_suffix: &str,
    batch_size: usize,
    deps: &MatchmakerDeps,
) -> RedisResult<(Vec<PlayerCandidate>, Vec<PoisonedCandidate>)> {
    if batch_size == 0 {
        return Ok((Vec::new(), Vec::new()));
    }

    let mut redis = deps.redis.clone();
    let hash_tag = format!("{{{}}}", queue_suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let raw: Vec<String> = invoke_try_match_script(&mut redis, queue_key, batch_size).await?;

    if raw.len() % 3 != 0 {
        return Err(RedisError::from((
            ErrorKind::TypeError,
            "unexpected response length",
        )));
    }

    let mut candidates = Vec::with_capacity(raw.len() / 3);
    let mut poisoned = Vec::new();

    for chunk in raw.chunks_exact(3) {
        let player_id = chunk[0].clone();
        let score = chunk[1].parse::<i64>().unwrap_or(0);
        let metadata_json = chunk[2].clone();

        // íŒŒì‹± ì‹œë„
        match parse_candidate(&player_id, score, &metadata_json) {
            Ok(candidate) => candidates.push(candidate),
            Err(reason) => {
                warn!("Poisoned candidate {}: {}", player_id, reason);
                poisoned.push(PoisonedCandidate { player_id, reason });
                // âœ… ê³„ì† ì§„í–‰! (ì „ì²´ ì‹¤íŒ¨ X)
            }
        }
    }

    // ë©”íŠ¸ë¦­ ê¸°ë¡
    if !poisoned.is_empty() {
        error!("Found {} poisoned candidates in queue {}", poisoned.len(), queue_suffix);
        deps.metrics.poisoned_candidates.inc_by(poisoned.len() as u64);
    }

    Ok((candidates, poisoned))
}

fn parse_candidate(
    player_id: &str,
    score: i64,
    metadata_json: &str,
) -> Result<PlayerCandidate, String> {
    let metadata = serde_json::from_str::<serde_json::Value>(metadata_json)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let pod_id = metadata
        .get("pod_id")
        .and_then(|p| p.as_str())
        .ok_or_else(|| "pod_id not found".to_string())?;

    Ok(PlayerCandidate {
        player_id: player_id.to_string(),
        score,
        pod_id: pod_id.to_string(),
        metadata,
    })
}
```

#### 3. Handler ì—…ë°ì´íŠ¸

```rust
// rank/handlers.rs:123
match pop_candidates(queue_suffix, required_players * 2, &deps).await {
    Ok((candidates, poisoned)) => {
        // PoisonedëŠ” ë¡œê¹…ë§Œ (ì´ë¯¸ íì—ì„œ ì œê±°ë¨)
        for p in poisoned {
            error!("Dropped poisoned candidate {}: {}", p.player_id, p.reason);
        }
        break candidates;
    }
    Err(err) => { /* retry */ }
}
```

### íš¨ê³¼

- ì˜¤ì—¼ëœ í”Œë ˆì´ì–´ 1ëª…ì´ ì „ì²´ ë§¤ì¹­ì„ ë§‰ì§€ ëª»í•¨
- ì •ìƒ í”Œë ˆì´ì–´ëŠ” ê³„ì† ë§¤ì¹­ë¨
- ì˜¤ì—¼ëœ ë°ì´í„° ì¶”ì  ê°€ëŠ¥ (ë©”íŠ¸ë¦­)

---

## P1: Game Server ëª¨ë‹ˆí„°ë§ & Alert

### ë¬¸ì œ

Game Serverê°€ ì£½ì–´ìˆì–´ë„ ê°ì§€í•˜ì§€ ëª»í•©ë‹ˆë‹¤.

```rust
// try_match.rs:93
// TODO: subscriber_count ë¥¼ í™œìš©í•˜ì—¬ Game Server ìƒì¡´ ì—¬ë¶€ í™•ì¸, ì˜¤ë¥˜ ì „íŒŒ ë“± êµ¬í˜„í•´ì•¼í•¨.

// rank/handlers.rs:182-185
if subscriber_count == 0 {
    // TODO: Game Server ê°€ êµ¬ë…ì¤‘ì´ì§€ ì•ŠìŒ.
    warn!("No Game Server is subscribed to battle:request channel");
    // âœ… re-enqueueëŠ” ì´ë¯¸ êµ¬í˜„ë¨
}
```

**ë¬¸ì œ**: ë¡œê·¸ë§Œ ì°ê³  ë. 10ë¶„ê°„ Game Server ë‹¤ìš´ë˜ì–´ë„ ëª¨ë¦„.

### í•´ê²°ì±…

#### 1. ëª¨ë‹ˆí„°ë§ êµ¬ì¡°ì²´ ì¶”ê°€

```rust
// matchmaker/common.rs
use std::sync::atomic::{AtomicU64, Ordering};

pub struct GameServerHealthMonitor {
    no_subscriber_count: AtomicU64,
    last_alert_timestamp: AtomicU64,
}

impl GameServerHealthMonitor {
    pub fn new() -> Self {
        Self {
            no_subscriber_count: AtomicU64::new(0),
            last_alert_timestamp: AtomicU64::new(0),
        }
    }

    pub fn record_no_subscriber(&self) {
        use chrono::Utc;

        let count = self.no_subscriber_count.fetch_add(1, Ordering::Relaxed) + 1;
        let now = Utc::now().timestamp() as u64;
        let last_alert = self.last_alert_timestamp.load(Ordering::Relaxed);

        // ì—°ì† 10ë²ˆ ì‹¤íŒ¨ + 5ë¶„ë§ˆë‹¤ ì•Œë¦¼
        if count >= 10 && now - last_alert > 300 {
            error!(
                "CRITICAL: Game Server unavailable for {} consecutive attempts! \
                 No subscribers on battle:request channel.",
                count
            );
            // TODO: Slack/PagerDuty/Email ì•Œë¦¼
            self.last_alert_timestamp.store(now, Ordering::Relaxed);
        } else if count % 5 == 0 {
            warn!("Game Server unavailable count: {}", count);
        }
    }

    pub fn record_has_subscriber(&self, count: usize) {
        let previous = self.no_subscriber_count.swap(0, Ordering::Relaxed);

        if previous > 0 {
            info!(
                "Game Server recovered! {} subscriber(s) available. \
                 (Was down for {} attempts)",
                count, previous
            );
        }
    }
}

pub struct MatchmakerInner {
    pub game_server_monitor: Arc<GameServerHealthMonitor>,
    // ...
}
```

#### 2. Handlerì—ì„œ ì‚¬ìš©

```rust
// rank/handlers.rs:181
match publish_battle_request(&mut redis, channel, &request).await {
    Ok(subscriber_count) => {
        if subscriber_count == 0 {
            deps.game_server_monitor.record_no_subscriber();
            warn!("No Game Server subscribed");
            re_enqueue_candidates(...).await;
        } else {
            deps.game_server_monitor.record_has_subscriber(subscriber_count);
            info!("Battle request sent to {} server(s)", subscriber_count);
        }
    }
    Err(err) => {
        error!("Failed to publish: {}", err);
        re_enqueue_candidates(...).await;
    }
}
```

#### 3. ë©”íŠ¸ë¦­ ì¶”ê°€ (ì„ íƒ)

```rust
// metrics/src/lib.rs
pub struct MetricsCtx {
    pub game_server_unavailable_total: Counter,
    pub game_server_available: Gauge,
    // ...
}
```

### íš¨ê³¼

- Game Server ì¥ì•  ì¦‰ì‹œ ê°ì§€ (10ë²ˆ ì—°ì† ì‹¤íŒ¨)
- 5ë¶„ë§ˆë‹¤ CRITICAL ì•Œë¦¼ (ì¤‘ë³µ ë°©ì§€)
- ë³µêµ¬ ì‹œ ìë™ ê°ì§€ ë° ë¡œê¹…
- ìš´ì˜íŒ€ì´ ì¦‰ì‹œ ëŒ€ì‘ ê°€ëŠ¥

---

## P2: Circuit Breaker Pattern

### ë¬¸ì œ

Redisê°€ ì£½ì–´ë„ ê³„ì† ì¬ì‹œë„í•©ë‹ˆë‹¤.

```rust
// rank/handlers.rs:116-148
let candidates = loop {
    match pop_candidates(...).await {
        Ok(candidates) => break candidates,
        Err(err) => {
            if let Some(delay) = backoff.next_backoff() {
                sleep(delay).await;
                continue;  // ë¬´í•œ ì¬ì‹œë„ (Redis ë³µêµ¬ë  ë•Œê¹Œì§€)
            }
        }
    }
};
```

**ì‹œë‚˜ë¦¬ì˜¤**: Redis ì£½ìŒ â†’ ëª¨ë“  TryMatchê°€ ì¬ì‹œë„ â†’ CPU/ë¡œê·¸ í­ì¦

### í•´ê²°ì±…

#### 1. Circuit Breaker êµ¬í˜„

```rust
// matchmaker/circuit_breaker.rs (ì‹ ê·œ)
use std::sync::atomic::{AtomicU64, Ordering};
use chrono::Utc;

pub struct CircuitBreaker {
    consecutive_failures: AtomicU64,
    threshold: u64,           // ì˜ˆ: 5ë²ˆ ì—°ì† ì‹¤íŒ¨ ì‹œ ì°¨ë‹¨
    open_until: AtomicU64,    // timestamp (ì—´ë¦° ì‹œê°)
    cooldown_seconds: u64,    // ì˜ˆ: 60ì´ˆ
}

impl CircuitBreaker {
    pub fn new(threshold: u64, cooldown_seconds: u64) -> Self {
        Self {
            consecutive_failures: AtomicU64::new(0),
            threshold,
            open_until: AtomicU64::new(0),
            cooldown_seconds,
        }
    }

    pub fn check(&self) -> Result<(), String> {
        let now = Utc::now().timestamp() as u64;
        let open_until = self.open_until.load(Ordering::Relaxed);

        if open_until > now {
            let remaining = open_until - now;
            return Err(format!("Circuit open for {}s", remaining));
        }

        Ok(())
    }

    pub fn record_success(&self) {
        let previous = self.consecutive_failures.swap(0, Ordering::Relaxed);
        let was_open = self.open_until.swap(0, Ordering::Relaxed);

        if was_open > 0 {
            info!("Circuit breaker CLOSED (recovered after {} failures)", previous);
        }
    }

    pub fn record_failure(&self) {
        let failures = self.consecutive_failures.fetch_add(1, Ordering::Relaxed) + 1;

        if failures >= self.threshold {
            let now = Utc::now().timestamp() as u64;
            let open_until = now + self.cooldown_seconds;
            self.open_until.store(open_until, Ordering::Relaxed);

            error!(
                "Circuit breaker OPEN! {} consecutive failures. \
                 Blocking operations for {}s",
                failures, self.cooldown_seconds
            );
        }
    }
}
```

#### 2. MatchmakerInnerì— ì¶”ê°€

```rust
// matchmaker/common.rs
pub struct MatchmakerInner {
    pub redis_circuit: Arc<CircuitBreaker>,
    // ...
}

impl MatchmakerInner {
    pub fn new(...) -> Self {
        Self {
            redis_circuit: Arc::new(CircuitBreaker::new(5, 60)),
            // threshold=5, cooldown=60ì´ˆ
            // ...
        }
    }
}
```

#### 3. Handlerì—ì„œ ì‚¬ìš©

```rust
// rank/handlers.rs:103
async move {
    if shutdown_token.is_cancelled() { return; }

    // Circuit breaker ì²´í¬
    if let Err(e) = deps.redis_circuit.check() {
        warn!("Redis circuit open, skipping TryMatch: {}", e);
        return;
    }

    let candidates = loop {
        match pop_candidates(...).await {
            Ok(candidates) => {
                deps.redis_circuit.record_success();
                break candidates;
            }
            Err(err) => {
                deps.redis_circuit.record_failure();

                if let Some(delay) = backoff.next_backoff() {
                    // ...
                } else {
                    return;
                }
            }
        }
    };
    // ...
}
```

### íš¨ê³¼

- 5ë²ˆ ì—°ì† ì‹¤íŒ¨ ì‹œ 60ì´ˆê°„ ìë™ ì¤‘ë‹¨
- ë¶ˆí•„ìš”í•œ ì¬ì‹œë„ ë°©ì§€ (CPU/ë¡œê·¸ ì ˆì•½)
- 60ì´ˆ í›„ ìë™ ë³µêµ¬ ì‹œë„
- Redis ë³µêµ¬ ì‹œ ì¦‰ì‹œ ì •ìƒí™”

---

## âœ… ì´ë¯¸ êµ¬í˜„ëœ í•­ëª©

### Re-enqueue on Failure

ë‹¤ìŒ ê²½ìš°ë“¤ì—ì„œ ìë™ ì¬enqueueê°€ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤:

1. **Game Server ì—†ìŒ** (rank/handlers.rs:182-194)
```rust
if subscriber_count == 0 {
    re_enqueue_candidates(...).await;
}
```

2. **Publish ì‹¤íŒ¨** (rank/handlers.rs:202-213)
```rust
Err(err) => {
    error!("Failed to publish: {}", err);
    re_enqueue_candidates(...).await;
}
```

3. **í™€ìˆ˜ í”Œë ˆì´ì–´** (rank/handlers.rs:216-220)
```rust
[single] => {
    re_enqueue_candidates(...).await;
}
```

4. **Shutdown ì¤‘** (rank/handlers.rs:160-164)
```rust
if shutdown_token.is_cancelled() {
    re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps).await;
    continue;
}
```

---

## êµ¬í˜„ ìˆœì„œ ê¶Œì¥

### Phase 1: í”„ë¡œë•ì…˜ í•„ìˆ˜ (P0)
1. âœ… **Redis Timeout ë³´í˜¸** - 1~2ì‹œê°„
2. âœ… **Max In-Flight Limit** - 30ë¶„

### Phase 2: ìš´ì˜ ì•ˆì •í™” (P1)
3. âœ… **Poison Message ì²˜ë¦¬** - 2~3ì‹œê°„
4. âœ… **Game Server Monitor** - 1ì‹œê°„

### Phase 3: ê³ ê¸‰ ìµœì í™” (P2)
5. **Circuit Breaker** - 2ì‹œê°„ (ì„ íƒ)

---

## í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### Timeout í…ŒìŠ¤íŠ¸
```bash
# Redis ì¤‘ë‹¨
docker stop redis

# ë¡œê·¸ í™•ì¸: 10ì´ˆ í›„ timeout ì—ëŸ¬ ë°œìƒí•˜ëŠ”ì§€
tail -f logs/match_server.log | grep timeout
```

### In-Flight í…ŒìŠ¤íŠ¸
```bash
# Redisì— sleep ì¶”ê°€ (ëŠë¦° ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜)
# ë¡œê·¸ì—ì„œ "TryMatch already running, skipping" í™•ì¸
```

### Poison Message í…ŒìŠ¤íŠ¸
```bash
# ìˆ˜ë™ìœ¼ë¡œ ì˜ëª»ëœ metadata ì¶”ê°€
redis-cli ZADD "queue:{normal}" $(date +%s) "bad_player"
redis-cli SET "metadata:bad_player" '{"invalid": "no_pod_id"}'

# ë¡œê·¸ í™•ì¸: poisoned candidate ë¡œê·¸, ë‹¤ë¥¸ í”Œë ˆì´ì–´ëŠ” ì •ìƒ ë§¤ì¹­
```

### Game Server ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸
```bash
# Game Server ì¤‘ë‹¨
# 10ë²ˆ ì—°ì† ë§¤ì¹­ ì‹œë„ í›„ CRITICAL ë¡œê·¸ í™•ì¸
```

---

## ì°¸ê³  ìë£Œ

- [tokio::select! ë¬¸ì„œ](https://docs.rs/tokio/latest/tokio/macro.select.html)
- [tokio::time::timeout ë¬¸ì„œ](https://docs.rs/tokio/latest/tokio/time/fn.timeout.html)
- [Circuit Breaker Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker)
- [Poison Message Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/InvalidMessageChannel.html)
</file>

<file path="scripts/DEQUEUE_PLAYER.lua">
-- KEYS[1] = queue:{mode} (Sorted Set)
-- ARGV[1] = player_id

local queue_key = KEYS[1]
local player_id = ARGV[1]

-- queueì—ì„œ ì œê±°
local removed = redis.call('ZREM', queue_key, player_id)

-- metadata ì‚­ì œ
if removed == 1 then
    local metadata_key = 'metadata:' .. player_id
    redis.call('DEL', metadata_key)
end

-- í˜„ì¬ í í¬ê¸° ë°˜í™˜
local size = redis.call('ZCARD', queue_key)
return {removed, size}
</file>

<file path="scripts/ENQUEUE_PLAYER.lua">
-- KEYS[1] = queue:{mode} (Sorted Set)
-- ARGV[1] = player_id
-- ARGV[2] = timestamp (score)
-- ARGV[3] = metadata JSON string

local queue_key = KEYS[1]
local player_id = ARGV[1]
local timestamp = tonumber(ARGV[2])
local metadata_json = ARGV[3]

-- ìœ íš¨ì„± ê²€ì‚¬
if timestamp == nil or metadata_json == nil or metadata_json == "" then
    local size = redis.call('ZCARD', queue_key)
    return {0, size}
end

-- ì´ë¯¸ íì— ìˆëŠ”ì§€ í™•ì¸
local exists = redis.call('ZSCORE', queue_key, player_id)
if exists then
    local size = redis.call('ZCARD', queue_key)
    return {0, size}
end

-- queueì— ì¶”ê°€ (Sorted Set)
redis.call('ZADD', queue_key, timestamp, player_id)

-- metadata ì €ì¥ (JSON ë¬¸ìì—´ ê·¸ëŒ€ë¡œ ì €ì¥)
local metadata_key = 'metadata:' .. player_id
redis.call('SET', metadata_key, metadata_json)

-- í˜„ì¬ í í¬ê¸° ë°˜í™˜
local size = redis.call('ZCARD', queue_key)
return {1, size}
</file>

<file path="scripts/TRY_MATCH_POP.lua">
-- KEYS[1] = queue:{mode} (Sorted Set)
-- ARGV[1] = batch_size (integer)

local queue_key = KEYS[1]
local batch_size = tonumber(ARGV[1])

-- ìœ íš¨ì„± ê²€ì‚¬
if batch_size == nil or batch_size <= 0 then
    return {}
end

-- ZPOPMINìœ¼ë¡œ ì›ìì ìœ¼ë¡œ pop (FIFO ë³´ì¥)
local popped = redis.call('ZPOPMIN', queue_key, batch_size)

if #popped == 0 then
    return {}
end

local result = {}

-- popped format: [player_id, score, player_id, score, ...]
for idx = 1, #popped, 2 do
    local player_id = popped[idx]
    local score = popped[idx + 1]

    -- metadata ê°€ì ¸ì˜¤ê¸° (JSON ë¬¸ìì—´ ê·¸ëŒ€ë¡œ)
    local metadata_key = 'metadata:' .. player_id
    local metadata_json = redis.call('GET', metadata_key)

    -- metadataê°€ ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´
    if not metadata_json then
        metadata_json = "{}"
    end

    -- ê²°ê³¼ì— ì¶”ê°€: [player_id, score, metadata_json, ...]
    table.insert(result, player_id)
    table.insert(result, score)
    table.insert(result, metadata_json)

    -- metadata ì‚­ì œ (ì´ë¯¸ popí–ˆìœ¼ë¯€ë¡œ)
    redis.call('DEL', metadata_key)
end

return result
</file>

<file path="src/env.rs">
use config::{Config, ConfigError, Environment, File, FileFormat};
use serde::Deserialize;

use crate::GameMode;

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub logging: LoggingSettings,
    pub server: ServerSettings,
    pub matchmaking: MatchmakingSettings,
    pub redis: RedisSettings,
    pub retry: RetrySettings,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let run_mode = std::env::var("RUN_MODE").unwrap_or_else(|_| "development".into());
        println!("Loading configuration for RUN_MODE: {}", &run_mode);

        let s = Config::builder()
            // Load environment-specific file (e.g., development.toml, production.toml)
            .add_source(
                File::with_name(&format!("match_server/config/{}", run_mode))
                    .format(FileFormat::Toml)
                    .required(true),
            )
            // Add environment variables (e.g., APP_SERVER__PORT=8000)
            .add_source(Environment::with_prefix("APP").separator("__"))
            .build()?;

        s.try_deserialize()
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct MatchmakingSettings {
    pub try_match_tick_interval_seconds: u64,
    pub queue_key_prefix: String,
    pub queue_order_key_prefix: String,
    pub match_fetch_request_channel_prefix: String,
    pub match_fetch_ack_channel_prefix: String,
    pub battle_request_channel: String,
    pub battle_result_channel_prefix: String,
    pub game_modes: Vec<MatchModeSettings>,
    pub heartbeat_interval_seconds: u64,
    pub heartbeat_timeout: u64,
    pub max_dedicated_server_retries: Option<u32>,
    pub dedicated_request_timeout_seconds: u64,
    pub allocation_token_ttl_seconds: u64,
    pub slow_loading_threshold_seconds: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RedisSettings {
    pub max_reconnect_attempts: u32,
    pub max_reconnect_delay_ms: u64,
    pub initial_reconnect_delay_ms: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct ServerSettings {
    pub bind_address: String,
    pub port: u16,
    pub log_level: String,
    pub metrics_auth_token: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct LoggingSettings {
    pub directory: String,
    pub filename: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct MatchModeSettings {
    pub game_mode: GameMode,
    pub required_players: u32,
    pub use_mmr_matching: bool,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RetrySettings {
    pub message_max_elapsed_time_ms: u64,
    pub message_initial_interval_ms: u64,
    pub message_max_interval_ms: u64,
}
</file>

<file path="src/lib.rs">
use ::redis::aio::ConnectionManager;
use actix::{Addr, Message};
use actix_web::HttpRequest;
use backoff::ExponentialBackoff;
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::io;
use std::net::IpAddr;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};
use tracing::{debug, error, warn};
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};

use crate::env::RetrySettings;
use crate::subscript::SubScriptionManager;
use crate::{env::Settings, matchmaker::MatchmakerAddr, metrics::MetricsCtx};

lazy_static! {
    static ref RETRY_CONFIG: RwLock<Option<ExponentialBackoff>> = RwLock::new(None);
}

pub mod env;
pub mod matchmaker;
pub mod metrics;
pub mod protocol;
pub mod session;
pub mod subscript;

pub struct LoggerManager {
    _guard: tracing_appender::non_blocking::WorkerGuard,
}

#[derive(Debug)]
pub enum StopReason {
    ClientDisconnected,
    GracefulShutdown,
    Error(String),
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct Stop {
    pub reason: StopReason,
}

impl LoggerManager {
    pub fn setup(settings: &Settings) -> Self {
        // 1. íŒŒì¼ ë¡œê±° ì„¤ì •
        let file_appender = RollingFileAppender::new(
            Rotation::DAILY,
            &settings.logging.directory,
            &settings.logging.filename,
        );
        let (non_blocking_file_writer, guard) = tracing_appender::non_blocking(file_appender);

        // 2. ë¡œê·¸ ë ˆë²¨ í•„í„° ì„¤ì • (í™˜ê²½ ë³€ìˆ˜ ë˜ëŠ” ì„¤ì • íŒŒì¼ ê°’)
        let filter = EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| EnvFilter::new(&settings.server.log_level));

        // 3. ì½˜ì†” ì¶œë ¥ ë ˆì´ì–´ ì„¤ì •
        let console_layer = fmt::layer()
            .with_writer(io::stdout) // í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ì„¤ì •
            .with_ansi(true) // ANSI ìƒ‰ìƒ ì½”ë“œ ì‚¬ìš© (í„°ë¯¸ë„ ì§€ì› ì‹œ)
            .with_thread_ids(true) // ìŠ¤ë ˆë“œ ID í¬í•¨
            .with_thread_names(true) // ìŠ¤ë ˆë“œ ì´ë¦„ í¬í•¨
            .with_file(true) // íŒŒì¼ ê²½ë¡œ í¬í•¨
            .with_line_number(true) // ë¼ì¸ ë²ˆí˜¸ í¬í•¨
            .with_target(false) // target ì •ë³´ ì œì™¸ (ì„ íƒ ì‚¬í•­)
            .pretty(); // ì‚¬ëŒì´ ì½ê¸° ì¢‹ì€ í¬ë§·

        // 4. íŒŒì¼ ì¶œë ¥ ë ˆì´ì–´ ì„¤ì •
        let file_layer = fmt::layer()
            .with_writer(non_blocking_file_writer) // Non-blocking íŒŒì¼ ë¡œê±° ì‚¬ìš©
            .with_ansi(false) // íŒŒì¼ì—ëŠ” ANSI ì½”ë“œ ì œì™¸
            .with_thread_ids(true)
            .with_thread_names(true)
            .with_file(true)
            .with_line_number(true)
            .with_target(false)
            .pretty();

        // 5. ë ˆì§€ìŠ¤íŠ¸ë¦¬(Registry)ì— í•„í„°ì™€ ë ˆì´ì–´ ê²°í•©
        tracing_subscriber::registry()
            .with(filter) // í•„í„°ë¥¼ ë¨¼ì € ì ìš©
            .with(console_layer) // ì½˜ì†” ë ˆì´ì–´ ì¶”ê°€
            .with(file_layer) // íŒŒì¼ ë ˆì´ì–´ ì¶”ê°€
            .init(); // ì „ì—­ Subscriberë¡œ ì„¤ì •

        tracing::info!(
            "Logger initialization complete: console and file ({}/{}) output enabled",
            settings.logging.directory,
            settings.logging.filename
        );

        Self { _guard: guard }
    }
}

pub fn init_retry_config(settings: &RetrySettings) {
    let backoff = ExponentialBackoff {
        max_elapsed_time: Some(Duration::from_millis(settings.message_max_elapsed_time_ms)),
        initial_interval: Duration::from_millis(settings.message_initial_interval_ms),
        max_interval: Duration::from_millis(settings.message_max_interval_ms),
        ..Default::default()
    };

    *RETRY_CONFIG.write().unwrap() = Some(backoff);
}

#[derive(Clone)]
pub struct AppState {
    pub settings: Settings,
    pub matchmakers: HashMap<GameMode, MatchmakerAddr>,
    pub sub_manager_addr: Addr<SubScriptionManager>,
    pub redis: ConnectionManager,
    pub logger_manager: Arc<LoggerManager>,
    pub current_run_id: Arc<RwLock<Option<String>>>,
    pub metrics: Arc<MetricsCtx>,
    pub metrics_registry: prometheus::Registry,
    pub rate_limiter: Arc<RateLimiter>,
}

pub fn extract_client_ip(req: &HttpRequest) -> Option<IpAddr> {
    // 1. X-Forwarded-For ê²€ì¦ ê°•í™”
    if let Some(forwarded) = req.headers().get("x-forwarded-for") {
        if let Ok(forwarded_str) = forwarded.to_str() {
            for ip_str in forwarded_str.split(',') {
                let ip_str = ip_str.trim();
                if let Ok(ip) = ip_str.parse::<IpAddr>() {
                    // Private IP ë° localhost í•„í„°ë§
                    if !is_private_or_loopback_ip(&ip) {
                        debug!("Extracted public client IP from X-Forwarded-For: {}", ip);
                        return Some(ip);
                    }
                }
            }
        }
    }

    // 2-3. ê¸°ì¡´ X-Real-IP, CF-Connecting-IP ì²˜ë¦¬...

    // 4. Direct connection (ê°œë°œ í™˜ê²½ì—ì„œë§Œ í—ˆìš©)
    if cfg!(debug_assertions) {
        // ë””ë²„ê·¸ ë¹Œë“œì—ì„œë§Œ
        if let Some(peer_addr) = req.connection_info().peer_addr() {
            if let Some(ip_str) = peer_addr.split(':').next() {
                if let Ok(ip) = ip_str.parse::<IpAddr>() {
                    warn!("Using direct connection IP in development: {}", ip);
                    return Some(ip);
                }
            }
        }
    }

    error!(
        "Could not extract valid client IP from request headers: {:?}",
        req.headers()
    );
    None
}

fn is_private_or_loopback_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => ipv4.is_private() || ipv4.is_loopback() || ipv4.is_link_local(),
        IpAddr::V6(ipv6) => ipv6.is_loopback() || ipv6.is_unspecified(),
    }
}

#[derive(Serialize, Deserialize, Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum GameMode {
    None,
    #[serde(rename = "Normal")]
    Normal,
    #[serde(rename = "Ranked")]
    Ranked,
}

/// Simple rate limiter using token bucket algorithm
pub struct RateLimiter {
    buckets: Arc<RwLock<HashMap<IpAddr, TokenBucket>>>,
    max_requests_per_second: u32,
    #[allow(dead_code)]
    cleanup_interval: Duration,
}

struct TokenBucket {
    tokens: f64,
    last_refill: Instant,
    max_tokens: f64,
    refill_rate: f64, // tokens per second
}

impl RateLimiter {
    pub fn new(max_requests_per_second: u32) -> Self {
        Self {
            buckets: Arc::new(RwLock::new(HashMap::new())),
            max_requests_per_second,
            cleanup_interval: Duration::from_secs(300), // cleanup every 5 minutes
        }
    }

    pub fn check(&self, ip: &IpAddr) -> bool {
        let mut buckets = self.buckets.write().unwrap();
        let bucket = buckets.entry(*ip).or_insert_with(|| TokenBucket {
            tokens: self.max_requests_per_second as f64,
            last_refill: Instant::now(),
            max_tokens: self.max_requests_per_second as f64,
            refill_rate: self.max_requests_per_second as f64,
        });

        // Refill tokens based on elapsed time
        let now = Instant::now();
        let elapsed = now.duration_since(bucket.last_refill).as_secs_f64();
        bucket.tokens = (bucket.tokens + elapsed * bucket.refill_rate).min(bucket.max_tokens);
        bucket.last_refill = now;

        // Check if we have tokens
        if bucket.tokens >= 1.0 {
            bucket.tokens -= 1.0;
            true
        } else {
            false
        }
    }

    /// Cleanup old entries (call periodically)
    pub fn cleanup(&self) {
        let mut buckets = self.buckets.write().unwrap();
        let now = Instant::now();
        buckets.retain(|_, bucket| {
            now.duration_since(bucket.last_refill) < Duration::from_secs(600) // 10 minutes
        });
    }
}
</file>

<file path="src/main.rs">
use actix::{Actor, System};
use actix_web::{get, web, App, Error, HttpRequest, HttpResponse, HttpServer};
use actix_web_actors::ws;
use match_server::{
    env::Settings,
    extract_client_ip, init_retry_config,
    matchmaker::{spawn_matchmakers, MatchmakerDeps},
    metrics::MetricsCtx,
    session::Session,
    subscript::SubScriptionManager,
    AppState, GameMode, LoggerManager,
};
use prometheus::{Encoder, TextEncoder};
use std::{
    sync::{Arc, RwLock},
    time::Duration,
};
use tokio_util::sync::CancellationToken;
use tracing::{error, info};

#[get("/ws/")]
async fn matchmaking_ws_route(
    req: HttpRequest,
    stream: web::Payload,
    state: web::Data<AppState>,
) -> Result<HttpResponse, Error> {
    let client_ip = extract_client_ip(&req).ok_or_else(|| {
        error!("Failed to extract client IP - rejecting connection");
        actix_web::error::ErrorBadRequest("Unable to determine client IP")
    })?;

    let session = Session::new(
        state.sub_manager_addr.clone(),
        Duration::from_secs(state.settings.matchmaking.heartbeat_interval_seconds),
        Duration::from_secs(state.settings.matchmaking.heartbeat_timeout),
        state.clone(),
        client_ip,
    );

    // WebSocket with default size limits (64KB max frame size by default)
    // Note: actix-web-actors uses default max_frame_size of 64KB
    ws::start(session, &req, stream)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // 1. í™˜ê²½ë³€ìˆ˜ ë¡œë“œ
    dotenv::dotenv().ok();

    // 2. ì„¤ì • íŒŒì¼ ë¡œë“œ
    let settings = Settings::new().expect("Failed to load settings");

    // 3. ë¡œê±° ì´ˆê¸°í™”
    let logger_manager = Arc::new(LoggerManager::setup(&settings));
    info!("Logger initialized");

    // 4. Retry config ì´ˆê¸°í™”
    init_retry_config(&settings.retry);
    info!("Retry config initialized");

    // 5. Redis í´ë¼ì´ì–¸íŠ¸ ìƒì„±
    let redis_url =
        std::env::var("REDIS_URL").unwrap_or_else(|_| "redis://127.0.0.1:6379".to_string());
    let redis_client =
        redis::Client::open(redis_url.clone()).expect("Failed to create Redis client");

    let redis_conn_manager = redis::aio::ConnectionManager::new(redis_client.clone())
        .await
        .expect("Failed to create Redis connection manager");
    info!("Redis connection established: {}", redis_url);

    // 6. ì „ì—­ Shutdown Token ìƒì„±
    let shutdown_token = CancellationToken::new();

    // 7. SubScriptionManager ì‹œì‘
    let sub_manager_addr = SubScriptionManager::new().start();
    info!("SubScriptionManager actor started");

    // 8. Metrics ì´ˆê¸°í™”
    let metrics = Arc::new(MetricsCtx::new());
    let metrics_registry = prometheus::Registry::new();
    metrics::register_custom_metrics(&metrics_registry)
        .expect("Failed to register custom metrics");
    info!("Metrics initialized and registered");

    // 9. Matchmaker Dependencies ì¤€ë¹„
    let matchmaker_deps = MatchmakerDeps {
        redis: redis_conn_manager.clone(),
        settings: settings.matchmaking.clone(),
        subscription_addr: sub_manager_addr.clone(),
        metrics: metrics.clone(),
        shutdown_token: shutdown_token.clone(),
    };

    // 10. Matchmakerë“¤ ì‹œì‘ (Normal, Ranked)
    let game_modes = vec![GameMode::Normal, GameMode::Ranked];
    let matchmakers = spawn_matchmakers(&matchmaker_deps, game_modes)
        .expect("Failed to spawn matchmakers");
    info!("Matchmakers started: Normal, Ranked");

    // 11. Rate Limiter ì´ˆê¸°í™” (10 requests/second per IP)
    let rate_limiter = Arc::new(match_server::RateLimiter::new(10));
    info!("Rate limiter initialized: 10 req/sec per IP");

    // 12. AppState êµ¬ì„±
    let current_run_id = Arc::new(RwLock::new(None));
    let app_state = AppState {
        settings: settings.clone(),
        matchmakers,
        sub_manager_addr,
        redis: redis_conn_manager.clone(),
        logger_manager,
        current_run_id,
        metrics,
        metrics_registry: metrics_registry.clone(),
        rate_limiter,
    };

    // 13. HTTP ì„œë²„ ì‹œì‘
    let bind_address = format!("{}:{}", settings.server.bind_address, settings.server.port);
    info!("Starting HTTP server on {}", bind_address);

    let mut server = HttpServer::new(move || {
        // /metrics ì—”ë“œí¬ì¸íŠ¸ (optional auth)
        let metrics_route = |req: HttpRequest, state: web::Data<AppState>| async move {
            // Check auth token if configured
            if let Some(expected_token) = &state.settings.server.metrics_auth_token {
                let auth_header = req.headers().get("Authorization");
                let provided_token = auth_header
                    .and_then(|h| h.to_str().ok())
                    .and_then(|s| s.strip_prefix("Bearer "));

                if provided_token != Some(expected_token.as_str()) {
                    return HttpResponse::Unauthorized()
                        .body("Unauthorized: Invalid or missing token");
                }
            }

            let metric_families = state.metrics_registry.gather();
            let mut buffer = Vec::new();
            let encoder = TextEncoder::new();

            if let Err(e) = encoder.encode(&metric_families, &mut buffer) {
                return HttpResponse::InternalServerError()
                    .body(format!("Metrics encode error: {}", e));
            }

            HttpResponse::Ok()
                .content_type(encoder.format_type())
                .body(buffer)
        };

        // Healthcheck endpoints
        let health_route = || async { HttpResponse::Ok().body("OK") };
        let ready_route = || async { HttpResponse::Ok().body("READY") };

        App::new()
            .app_data(web::Data::new(app_state.clone()))
            .service(matchmaking_ws_route)
            .route("/metrics", web::get().to(metrics_route))
            .route("/health", web::get().to(health_route))
            .route("/ready", web::get().to(ready_route))
    })
    .bind(&bind_address)?
    .run();

    info!("Match Server is running on {}", bind_address);

    // 14. ì¢…ë£Œ ì‹ í˜¸ ëŒ€ê¸°
    tokio::select! {
        // ì„œë²„ ìì²´ ì¢…ë£Œ (ë“œë¬¸ ê²½ìš°)
        res = &mut server => {
            error!("Server exited unexpectedly");
            return res;
        },

        // Ctrl+C ì¢…ë£Œ (ì •ìƒ ì¢…ë£Œ)
        _ = tokio::signal::ctrl_c() => {
            info!("Ctrl+C received. Initiating graceful shutdown...");
            shutdown_token.cancel();  // ëª¨ë“  Actorì— ì¢…ë£Œ ì‹ í˜¸
            System::current().stop();
        },
    }

    // 15. ëª¨ë“  Actorì™€ ì—°ê²° ì •ë¦¬ ëŒ€ê¸°
    info!("Waiting for all actors to shutdown...");
    server.await?;
    info!("System has shut down gracefully");

    Ok(())
}
</file>

<file path="src/matchmaker/common.rs">
use std::sync::Arc;

use actix::Addr;
use redis::aio::ConnectionManager;
use tokio_util::sync::CancellationToken;

use crate::{
    env::{MatchModeSettings, MatchmakingSettings},
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
    GameMode,
};

pub struct MatchmakerInner {
    pub redis: ConnectionManager,
    pub settings: MatchmakingSettings,
    pub mode_settings: MatchModeSettings,
    pub sub_manager_addr: Addr<SubScriptionManager>,
    pub metrics: Arc<MetricsCtx>,
    pub shutdown_token: CancellationToken,
}

impl MatchmakerInner {
    pub fn new(
        redis: ConnectionManager,
        settings: MatchmakingSettings,
        mode_settings: MatchModeSettings,
        sub_manager_addr: Addr<SubScriptionManager>,
        metrics: Arc<MetricsCtx>,
        shutdown_token: CancellationToken,
    ) -> Self {
        Self {
            redis,
            settings,
            mode_settings,
            sub_manager_addr,
            metrics,
            shutdown_token,
        }
    }

    pub fn queue_suffix(&self, mode: GameMode) -> &'static str {
        match mode {
            GameMode::Ranked => "ranked",
            GameMode::Normal => "normal",
            GameMode::None => "none",
        }
    }
}
</file>

<file path="src/matchmaker/messages.rs">
use actix::Message;
use uuid::Uuid;

use crate::{env::MatchModeSettings, GameMode};

#[derive(Message)]
#[rtype(result = "()")]
pub struct Enqueue {
    pub player_id: Uuid,
    pub game_mode: GameMode,
    pub metadata: String,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct Dequeue {
    pub player_id: Uuid,
    pub game_mode: GameMode,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct TryMatch {
    pub match_mode_settings: MatchModeSettings,
}
</file>

<file path="src/matchmaker/mod.rs">
use actix::{Actor, Addr, MailboxError};
use redis::aio::ConnectionManager;
use std::collections::HashMap;
use tokio_util::sync::CancellationToken;

use crate::{
    env::MatchmakingSettings,
    matchmaker::{
        messages::{Dequeue, Enqueue},
        normal::NormalMatchmaker,
        rank::RankedMatchmaker,
    },
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
    GameMode,
};

pub mod common;
pub mod messages;
pub mod normal;
pub mod operations;
pub mod patry;
pub mod rank;
pub mod scripts;

#[derive(Clone)]
pub enum MatchmakerAddr {
    Normal(Addr<NormalMatchmaker>),
    Ranked(Addr<RankedMatchmaker>),
}

impl MatchmakerAddr {
    pub fn do_send_enqueue(&self, msg: Enqueue) {
        match self {
            Self::Normal(addr) => addr.do_send(msg),
            Self::Ranked(addr) => addr.do_send(msg),
        }
    }

    pub fn do_send_dequeue(&self, msg: Dequeue) {
        match self {
            Self::Normal(addr) => addr.do_send(msg),
            Self::Ranked(addr) => addr.do_send(msg),
        }
    }

    pub async fn dequeue(&self, msg: Dequeue) -> Result<(), MailboxError> {
        match self {
            Self::Normal(addr) => addr.send(msg).await,
            Self::Ranked(addr) => addr.send(msg).await,
        }
    }
}

#[derive(Clone)]
pub struct MatchmakerDeps {
    pub redis: ConnectionManager,
    pub settings: MatchmakingSettings,
    pub subscription_addr: Addr<SubScriptionManager>,
    pub metrics: std::sync::Arc<MetricsCtx>,
    pub shutdown_token: CancellationToken,
}

impl From<&common::MatchmakerInner> for MatchmakerDeps {
    fn from(source: &common::MatchmakerInner) -> Self {
        Self {
            redis: source.redis.clone(),
            settings: source.settings.clone(),
            subscription_addr: source.sub_manager_addr.clone(),
            metrics: source.metrics.clone(),
            shutdown_token: source.shutdown_token.clone(),
        }
    }
}

pub fn spawn_matchmaker_for_mode(
    game_mode: GameMode,
    deps: &MatchmakerDeps,
) -> Result<MatchmakerAddr, String> {
    // settingsì—ì„œ í•´ë‹¹ game_modeì˜ MatchModeSettings ì°¾ê¸°
    let mode_settings = deps
        .settings
        .game_modes
        .iter()
        .find(|m| m.game_mode == game_mode)
        .cloned()
        .ok_or_else(|| format!("MatchModeSettings not found for mode {:?}", game_mode))?;

    match game_mode {
        GameMode::None => {
            Err("Unsupported game mode: None".to_string())
        }
        GameMode::Normal => Ok(MatchmakerAddr::Normal(
            NormalMatchmaker::new(
                deps.redis.clone(),
                deps.settings.clone(),
                mode_settings,
                deps.subscription_addr.clone(),
                deps.metrics.clone(),
                deps.shutdown_token.clone(),
            )
            .start(),
        )),
        GameMode::Ranked => Ok(MatchmakerAddr::Ranked(
            RankedMatchmaker::new(
                deps.redis.clone(),
                deps.settings.clone(),
                mode_settings,
                deps.subscription_addr.clone(),
                deps.metrics.clone(),
                deps.shutdown_token.clone(),
            )
            .start(),
        )),
    }
}

pub fn spawn_matchmakers<I>(
    deps: &MatchmakerDeps,
    modes: I,
) -> Result<HashMap<GameMode, MatchmakerAddr>, String>
where
    I: IntoIterator<Item = GameMode>,
{
    let mut map = HashMap::new();
    for mode in modes {
        let handle = spawn_matchmaker_for_mode(mode, deps)?;
        map.insert(mode, handle);
    }
    Ok(map)
}
</file>

<file path="src/matchmaker/normal/handlers.rs">
use actix::{dev::ContextFutureSpawner, ActorContext, Handler, WrapFuture};
use backoff::backoff::Backoff;
use tokio::time::sleep;
use tracing::{error, info, warn};

use crate::{
    matchmaker::{
        messages::{Dequeue, Enqueue, TryMatch},
        normal::NormalMatchmaker,
        operations::{
            dequeue::dequeue,
            enqueue::{enqueue, re_enqueue_candidates},
            notify,
            try_match::{pop_candidates, publish_battle_request},
        },
        MatchmakerDeps,
    },
    protocol::{BattleRequest, ErrorCode, ServerMessage},
    GameMode, Stop, RETRY_CONFIG,
};

impl Handler<Enqueue> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Enqueue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Normal {
                warn!(
                    "Player {} tried to enqueue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            enqueue(queue_prefix, msg.game_mode, player_id, msg.metadata, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Dequeue> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Dequeue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Normal {
                warn!(
                    "Player {} tried to dequeue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            dequeue(queue_prefix, msg.game_mode, player_id, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<TryMatch> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: TryMatch, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let settings = msg.match_mode_settings;
        let queue_suffix = self.queue_suffix(settings.game_mode);
        let required_players = settings.required_players;
        let mut redis = deps.redis.clone();
        let shutdown_token = self.shutdown_token.clone();

        async move {
            // ì¢…ë£Œ ì‹ í˜¸ ì²´í¬
            if shutdown_token.is_cancelled() {
                info!("TryMatch cancelled due to shutdown");
                return;
            }
            let mut backoff = RETRY_CONFIG
                .read()
                .unwrap()
                .as_ref()
                .expect("Retry config not initialized")
                .clone();

            let candidates = loop {
                // ì¢…ë£Œ ì‹ í˜¸ ì²´í¬
                if shutdown_token.is_cancelled() {
                    info!("TryMatch cancelled during candidate pop");
                    return;
                }

                match pop_candidates(queue_suffix, required_players as usize * 2, &deps).await {
                    Ok(candidates) => break candidates,
                    Err(err) => {
                        if let Some(delay) = backoff.next_backoff() {
                            warn!(
                                "Failed to pop candidates from queue {}: {} (retrying in {:?})",
                                queue_suffix, err, delay
                            );
                            // ì¢…ë£Œ ì‹ í˜¸ì™€ í•¨ê»˜ ëŒ€ê¸°
                            tokio::select! {
                                _ = sleep(delay) => continue,
                                _ = shutdown_token.cancelled() => {
                                    info!("TryMatch cancelled during backoff");
                                    return;
                                }
                            }
                        } else {
                            error!(
                                "Failed to pop candidates after all retries from queue {}: {}",
                                queue_suffix, err
                            );
                            return; // async move ë¸”ë¡ ì¢…ë£Œ
                        }
                    }
                }
            };
            
            if candidates.is_empty() {
                warn!("No candidates available");
                return;
            }
                
            // try_match ì— ì˜í•´ 4ëª…ì´ ìˆ˜ì§‘ë˜ëŠ”ë°, ëª¨ì¢…ì˜ ì´ìœ ë¡œ 0~3ëª…ì´ ìˆ˜ì§‘ë  ìˆ˜ ìˆìŒ.
            // candidates ì—ì„œ 2ëª…ì”© êº¼ë‚´ì–´ ë§¤ì¹­ì„ ì‹œë„í•˜ê³ , ë‚¨ì€ ì¸ì›ì€ Re enqueue
            // 2ëª…ì”© ë¬¶ì–´ì„œ ì²˜ë¦¬
            for chunk in candidates.chunks(2) {
                // ì¢…ë£Œ ì‹ í˜¸ ì²´í¬ - ì´ë¯¸ popí•œ candidatesëŠ” re-enqueue
                if shutdown_token.is_cancelled() {
                    warn!("Shutdown requested, re-enqueueing remaining candidates");
                    re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps).await;
                    continue;
                }

                match chunk {
                    [player1, player2] => {
                        // 2ëª… ë§¤ì¹­
                        let request = BattleRequest {
                            player1: player1.clone(),
                            player2: player2.clone(),
                        };

                        match publish_battle_request(
                            &mut redis,
                            &deps.settings.battle_request_channel,
                            &request,
                        )
                        .await
                        {
                            Ok(subscriber_count) => {
                                if subscriber_count == 0 {
                                    // TODO: Game Server ê°€ êµ¬ë…ì¤‘ì´ì§€ ì•ŠìŒ. -> Game Server ê°€ ì£½ì–´ìˆì„ ê°€ëŠ¥ì„±ì´ ì¡´ì¬í•¨.
                                    // ìì„¸í•˜ê²Œ ì˜¤ë¥˜ íŒŒì•…í•˜ê³  ê´€ë¦¬ ì‹œìŠ¤í…œì—ê²Œ ë³´ê³  í•´ì•¼í•¨ ( Orchestrator )
                                    warn!("No Game Server is subscribed to battle:request channel");
                                    // ë§¤ì¹­ ì‹¤íŒ¨: player1, player2 re enqueue
                                    let failed_match = [player1.clone(), player2.clone()];
                                    re_enqueue_candidates(
                                        queue_suffix,
                                        settings.game_mode,
                                        &failed_match,
                                        &deps,
                                    )
                                    .await;
                                } else {
                                    // Metrics: ë§¤ì¹­ ì„±ê³µ
                                    metrics::MATCHES_CREATED_TOTAL.inc();
                                    metrics::MATCHED_PLAYERS_TOTAL_BY_MODE
                                        .with_label_values(&[&format!("{:?}", settings.game_mode)])
                                        .inc_by(2);

                                    info!(
                                        "Battle request sent to {} Game Server(s) for players {} and {}",
                                        subscriber_count, player1.player_id, player2.player_id
                                    );
                                }
                            }
                            Err(err) => {
                                error!("Failed to publish battle request: {}", err);
                                // ë§¤ì¹­ ì‹¤íŒ¨: player1, player2 re enqueue
                                let failed_match = [player1.clone(), player2.clone()];
                                re_enqueue_candidates(
                                    queue_suffix,
                                    settings.game_mode,
                                    &failed_match,
                                    &deps,
                                )
                                .await;
                            }
                        }
                    }
                    [single] => {
                        // 1ëª… ë‚¨ìŒ, re enqueue
                        info!("Single player left, re-enqueueing: {}", single.player_id);
                        re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps)
                            .await;
                    }
                    _ => unreachable!("chunks(2) only returns 1 or 2 elements"),
                }
            }
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Stop> for NormalMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "NormalMatchmaker for mode {:?} stopping: {:?}",
            self.mode_settings.game_mode, msg.reason
        );
        ctx.stop();
    }
}
</file>

<file path="src/matchmaker/normal/mod.rs">
use std::{
    ops::{Deref, DerefMut},
    time::Duration,
};

use actix::{Actor, Addr, AsyncContext};
use redis::aio::ConnectionManager;
use tokio_util::sync::CancellationToken;
use tracing::{info, warn};

pub mod handlers;

use crate::{
    env::{MatchModeSettings, MatchmakingSettings},
    matchmaker::{common::MatchmakerInner, messages::TryMatch},
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
};

pub struct NormalMatchmaker {
    inner: MatchmakerInner,
}

impl Deref for NormalMatchmaker {
    type Target = MatchmakerInner;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl DerefMut for NormalMatchmaker {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl NormalMatchmaker {
    pub fn new(
        redis: ConnectionManager,
        settings: MatchmakingSettings,
        mode_settings: MatchModeSettings,
        sub_manager_addr: Addr<SubScriptionManager>,
        metrics: std::sync::Arc<MetricsCtx>,
        shutdown_token: CancellationToken,
    ) -> Self {
        Self {
            inner: MatchmakerInner::new(redis, settings, mode_settings, sub_manager_addr, metrics, shutdown_token),
        }
    }
}

impl Actor for NormalMatchmaker {
    type Context = actix::Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!(
            "NormalMatchmaker actor started for mode {:?}",
            self.mode_settings.game_mode
        );
        let interval = self.settings.try_match_tick_interval_seconds;
        let mode_settings = self.mode_settings.clone();

        ctx.run_interval(Duration::from_secs(interval), move |_actor, ctx| {
            ctx.notify(TryMatch {
                match_mode_settings: mode_settings.clone(),
            });
        });
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> actix::Running {
        info!(
            "NormalMatchmaker for mode {:?} stopping, cancelling futures",
            self.mode_settings.game_mode
        );

        // ëª¨ë“  ì‹¤í–‰ ì¤‘ì¸ futureì—ê²Œ ì¢…ë£Œ ì‹ í˜¸
        self.shutdown_token.cancel();

        // ì™„ë£Œ ëŒ€ê¸° (íƒ€ì„ì•„ì›ƒ 25ì´ˆ)
        if ctx.waiting() {
            info!("Waiting for pending futures to complete");
            ctx.run_later(Duration::from_secs(25), |_act, _ctx| {
                warn!("Graceful shutdown timeout, force stopping");
            });
            actix::Running::Continue
        } else {
            info!("No pending futures, stopping immediately");
            actix::Running::Stop
        }
    }
}
</file>

<file path="src/matchmaker/operations/dequeue.rs">
use backoff::backoff::Backoff;
use redis::{aio::ConnectionManager, RedisResult, Script};
use tokio::time::sleep;
use tracing::{error, info, warn};
use uuid::Uuid;

use crate::{
    matchmaker::{
        operations::notify,
        scripts::{self},
        MatchmakerDeps,
    },
    protocol::{ErrorCode, ServerMessage},
    GameMode, RETRY_CONFIG,
};

async fn invoke_dequeue_script(
    redis: &mut ConnectionManager,
    queue_key: String,
    player_id: Uuid,
) -> RedisResult<Vec<i64>> {
    Script::new(scripts::dequeue_player_script())
        .key(queue_key)
        .arg(player_id.to_string())
        .invoke_async(redis)
        .await
}

pub async fn dequeue(
    queue_suffix: &str,
    game_mode: GameMode,
    player_id: Uuid,
    deps: &MatchmakerDeps,
) {
    let subscription_addr = deps.subscription_addr.clone();
    let mut redis = deps.redis.clone();
    let settings = deps.settings.clone();

    let is_known_mode = settings
        .game_modes
        .iter()
        .any(|mode| mode.game_mode == game_mode);

    if !is_known_mode {
        warn!(
            "Player {} tried to dequeue for unsupported mode {:?}",
            player_id, game_mode
        );
        notify::send_message_to_player(
            subscription_addr,
            &mut redis,
            player_id,
            ServerMessage::Error {
                code: ErrorCode::InvalidGameMode,
                message: "Unsupported game mode".to_string(),
            },
        )
        .await;
        return;
    }

    let suffix = queue_suffix;
    let hash_tag = format!("{{{}}}", suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let mut backoff_state = backoff;
    let dequeue_result = loop {
        let mut redis_clone = redis.clone();

        match invoke_dequeue_script(
            &mut redis_clone,
            queue_key.clone(),
            player_id,
        )
        .await
        {
            Ok(res) => break Ok(res),
            Err(err) => {
                if let Some(delay) = backoff_state.next_backoff() {
                    warn!(
                        "Temporary dequeue failure for player {}: {} (retrying in {:?})",
                        player_id, err, delay
                    );
                    sleep(delay).await;
                    continue;
                } else {
                    break Err(err);
                }
            }
        }
    };

    let result = match dequeue_result {
        Ok(res) => res,
        Err(err) => {
            error!(
                "Failed to dequeue player {} into {}: {}",
                player_id, queue_key, err
            );
            notify::send_message_to_player(
                subscription_addr,
                &mut redis,
                player_id,
                ServerMessage::Error {
                    code: ErrorCode::InternalError,
                    message: "Failed to dequeue".to_string(),
                },
            )
            .await;
            return;
        }
    };

    let removed_flag = result.get(0).copied().unwrap_or_default();
    let current_size = result.get(1).copied().unwrap_or_default();

    let response = if removed_flag == 1 {
        info!(
            "Player {} dequeued for {:?}. queue size = {}",
            player_id, game_mode, current_size
        );
        ServerMessage::DeQueued
    } else {
        warn!("Player {} not found in queue {:?}", player_id, game_mode);
        ServerMessage::Error {
            code: ErrorCode::NotInQueue,
            message: "Not found in queue".to_string(),
        }
    };

    notify::send_message_to_player(subscription_addr, &mut redis, player_id, response).await;
}
</file>

<file path="src/matchmaker/operations/enqueue.rs">
use backoff::backoff::Backoff;
use chrono::Utc;
use redis::{aio::ConnectionManager, RedisResult, Script};
use tokio::time::sleep;
use tracing::{error, info, warn};
use uuid::Uuid;

use crate::{
    matchmaker::{
        operations::{notify, try_match::PlayerCandidate},
        scripts, MatchmakerDeps,
    },
    protocol::{ErrorCode, ServerMessage},
    GameMode, RETRY_CONFIG,
};

async fn invoke_enqueue_script(
    redis: &mut ConnectionManager,
    queue_key: String,
    player_id: Uuid,
    timestamp: String,
    metadata: String,
) -> RedisResult<Vec<i64>> {
    Script::new(scripts::enqueue_player_script())
        .key(queue_key)
        .arg(player_id.to_string())
        .arg(timestamp)
        .arg(metadata)
        .invoke_async(redis)
        .await
}

pub async fn enqueue(
    queue_suffix: &str,
    game_mode: GameMode,
    player_id: Uuid,
    metadata: String,
    deps: &MatchmakerDeps,
) {
    let subscription_addr = deps.subscription_addr.clone();
    let mut redis = deps.redis.clone();
    let settings = deps.settings.clone();

    let is_known_mode = settings
        .game_modes
        .iter()
        .any(|mode| mode.game_mode == game_mode);

    if !is_known_mode {
        warn!(
            "Player {} tried to enqueue for unsupported mode {:?}",
            player_id, game_mode
        );
        notify::send_message_to_player(
            subscription_addr,
            &mut redis,
            player_id,
            ServerMessage::Error {
                code: ErrorCode::InvalidGameMode,
                message: "Unsupported game mode".to_string(),
            },
        )
        .await;
        return;
    }

    let suffix = queue_suffix;
    let hash_tag = format!("{{{}}}", suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let timestamp = Utc::now().timestamp().to_string();

    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let mut backoff_state = backoff;
    let enqueue_result = loop {
        let mut redis_clone = redis.clone();

        match invoke_enqueue_script(
            &mut redis_clone,
            queue_key.clone(),
            player_id,
            timestamp.clone(),
            metadata.clone(),
        )
        .await
        {
            Ok(res) => break Ok(res),
            Err(err) => {
                if let Some(delay) = backoff_state.next_backoff() {
                    warn!(
                        "Temporary enqueue failure for player {}: {} (retrying in {:?})",
                        player_id, err, delay
                    );
                    sleep(delay).await;
                    continue;
                } else {
                    break Err(err);
                }
            }
        }
    };

    let result = match enqueue_result {
        Ok(res) => res,
        Err(err) => {
            error!(
                "Failed to enqueue player {} into {}: {}",
                player_id, queue_key, err
            );
            notify::send_message_to_player(
                subscription_addr,
                &mut redis,
                player_id,
                ServerMessage::Error {
                    code: ErrorCode::InternalError,
                    message: "Failed to enqueue".to_string(),
                },
            )
            .await;
            return;
        }
    };

    let added_flag = result.get(0).copied().unwrap_or_default();
    let current_size = result.get(1).copied().unwrap_or_default();

    let response = if added_flag == 1 {
        info!(
            "Player {} enqueued for {:?}. queue size = {}",
            player_id, game_mode, current_size
        );

        // Metrics: ì‹ ê·œ Enqueue ì¹´ìš´íŠ¸
        metrics::PLAYERS_ENQUEUED_NEW_TOTAL.inc();
        metrics::ENQUEUED_TOTAL_BY_MODE
            .with_label_values(&[&format!("{:?}", game_mode)])
            .inc();

        ServerMessage::EnQueued
    } else {
        warn!("Player {} already in queue {:?}", player_id, game_mode);

        // Metrics: ì¤‘ë³µ Enqueue ì‹œë„
        metrics::ABNORMAL_DUPLICATE_ENQUEUE_TOTAL.inc();

        ServerMessage::Error {
            code: ErrorCode::AlreadyInQueue,
            message: "Already in queue".to_string(),
        }
    };

    notify::send_message_to_player(subscription_addr, &mut redis, player_id, response).await;
}

pub async fn re_enqueue_candidates(
    queue_suffix: &str,
    game_mode: GameMode,
    candidates: &[PlayerCandidate],
    deps: &MatchmakerDeps,
) {
    // Metrics: Re-enqueue ì¹´ìš´íŠ¸
    if !candidates.is_empty() {
        metrics::PLAYERS_REQUEUED_TOTAL.inc_by(candidates.len() as u64);
    }

    for candidate in candidates {
        let player_id = match Uuid::parse_str(&candidate.player_id) {
            Ok(id) => id,
            Err(e) => {
                error!("Invalid player_id during re-enqueue: {}", e);
                continue;
            }
        };

        let metadata_json = match serde_json::to_string(&candidate.metadata) {
            Ok(json) => json,
            Err(e) => {
                error!("Failed to serialize metadata: {}", e);
                continue;
            }
        };

        enqueue(queue_suffix, game_mode, player_id, metadata_json, deps).await;
    }
}
</file>

<file path="src/matchmaker/operations/mod.rs">
pub mod dequeue;
pub mod enqueue;
pub mod notify;
pub mod try_match;
</file>

<file path="src/matchmaker/operations/notify.rs">
use actix::Addr;
use redis::{aio::ConnectionManager, AsyncCommands};
use tracing::warn;
use uuid::Uuid;

use crate::{
    protocol::ServerMessage,
    subscript::{messages::ForwardServerMessage, SubScriptionManager},
    RETRY_CONFIG,
};

/// í”Œë ˆì´ì–´ì—ê²Œ ì§ì ‘ ì „ë‹¬ + Redis ë°œí–‰ìœ¼ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.
/// Redis ë°œí–‰ì€ ì™¸ë¶€ ê´€ì¸¡ì„±ì„ ìœ„í•¨ì…ë‹ˆë‹¤.
pub async fn send_message_to_player(
    subscription_addr: Addr<SubScriptionManager>,
    redis: &mut ConnectionManager,
    player_id: Uuid,
    message: ServerMessage,
) {
    // ì§ì ‘ ì „ë‹¬
    send_direct_message(&subscription_addr, player_id, &message).await;

    // Redisë¡œ ë°œí–‰ (ê´€ì¸¡ì„±ìš©)
    publish_to_redis_with_retry(redis, player_id, message).await;
}

/// í”Œë ˆì´ì–´ì—ê²Œ ì§ì ‘ ë©”ì‹œì§€ ì „ë‹¬ (WebSocket)
async fn send_direct_message(
    subscription_addr: &Addr<SubScriptionManager>,
    player_id: Uuid,
    message: &ServerMessage,
) {
    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let subscription_addr = subscription_addr.clone();
    let message = message.clone();

    let result = backoff::future::retry(backoff, move || {
        let subscription_addr = subscription_addr.clone();
        let message = message.clone();

        async move {
            subscription_addr
                .send(ForwardServerMessage { player_id, message })
                .await
                .map_err(|e| {
                    warn!(
                        "Direct message attempt failed for player {}: {:?}",
                        player_id, e
                    );
                    backoff::Error::Transient {
                        err: "Transient",
                        retry_after: None,
                    }
                })
        }
    })
    .await;

    if let Err(e) = result {
        warn!(
            "Direct message delivery permanently failed for player {}: {:?}",
            player_id, e
        );
    }
}

/// Redisë¡œ ë©”ì‹œì§€ ë°œí–‰ (ì¬ì‹œë„ í¬í•¨)
async fn publish_to_redis_with_retry(
    redis: &mut ConnectionManager,
    player_id: Uuid,
    message: ServerMessage,
) {
    let backoff = RETRY_CONFIG
        .read()
        .unwrap()
        .as_ref()
        .expect("Retry config not initialized")
        .clone();

    let redis_conn = redis.clone();
    let result = backoff::future::retry(backoff, move || {
        let mut redis_conn = redis_conn.clone();
        let message = message.clone();

        async move {
            let channel = format!("notification:{}", player_id);
            let payload = serde_json::to_string(&message).map_err(|e| {
                warn!(
                    "Failed to serialize message for player {}: {}",
                    player_id, e
                );
                backoff::Error::Permanent("Permanent")
            })?;

            redis_conn
                .publish::<_, _, ()>(&channel, &payload)
                .await
                .map_err(|e| {
                    warn!("Failed to publish to Redis for player {}: {}", player_id, e);
                    backoff::Error::Transient {
                        err: "Transient",
                        retry_after: None,
                    }
                })
        }
    })
    .await;

    if let Err(e) = result {
        warn!(
            "Redis publish permanently failed for player {}: {:?}",
            player_id, e
        );
    }
}
</file>

<file path="src/matchmaker/operations/try_match.rs">
use redis::{aio::ConnectionManager, AsyncCommands, ErrorKind, RedisError, RedisResult, Script};

use crate::{
    matchmaker::{scripts, MatchmakerDeps},
    protocol::BattleRequest,
};

async fn invoke_try_match_script(
    redis: &mut ConnectionManager,
    queue_key: String,
    batch_size: usize,
) -> RedisResult<Vec<String>> {
    Script::new(scripts::try_match_pop_script())
        .key(queue_key)
        .arg(batch_size)
        .invoke_async(redis)
        .await
}

pub async fn pop_candidates(
    queue_suffix: &str,
    batch_size: usize,
    deps: &MatchmakerDeps,
) -> RedisResult<Vec<PlayerCandidate>> {
    if batch_size == 0 {
        return Ok(Vec::new());
    }

    let mut redis = deps.redis.clone();
    let hash_tag = format!("{{{}}}", queue_suffix);
    let queue_key = format!("queue:{}", hash_tag);

    let raw: Vec<String> = invoke_try_match_script(&mut redis, queue_key, batch_size).await?;

    if raw.len() % 3 != 0 {
        return Err(RedisError::from((
            ErrorKind::TypeError,
            "unexpected response length in try_match pop script - expected triplets",
        )));
    }

    let mut candidates = Vec::with_capacity(raw.len() / 3);
    let mut iter = raw.chunks_exact(3);
    while let Some(chunk) = iter.next() {
        let player_id = chunk[0].clone();
        let score = chunk[1].parse::<i64>().map_err(|_| {
            RedisError::from((
                ErrorKind::TypeError,
                "invalid score returned from try_match pop script",
            ))
        })?;
        let metadata_json = chunk[2].clone();

        // metadata íŒŒì‹±
        let metadata = serde_json::from_str::<serde_json::Value>(&metadata_json).map_err(|e| {
            RedisError::from((
                ErrorKind::TypeError,
                "failed to parse metadata JSON",
                e.to_string(),
            ))
        })?;

        // metadataì—ì„œ pod_id ì¶”ì¶œ
        let pod_id = metadata
            .get("pod_id")
            .and_then(|p| p.as_str())
            .map(String::from)
            .ok_or_else(|| {
                RedisError::from((ErrorKind::TypeError, "pod_id not found in metadata"))
            })?;
        // TODO: pod_id ê°€ ì—†ì„ ê²½ìš°, ì˜¤ì—¼ëœ í”Œë ˆì´ì–´ë¡œ ê°„ì£¼í•˜ê³  ë¡œê·¸ ì²˜ë¦¬ í•´ë‹¹ match ëŠ” ì‹¤íŒ¨ë¡œ ì²˜ë¦¬.

        candidates.push(PlayerCandidate {
            player_id,
            score,
            pod_id,
            metadata,
        });
    }

    Ok(candidates)
}

/// Battle requestë¥¼ Redisì— publishí•˜ëŠ” í—¬í¼ í•¨ìˆ˜
pub async fn publish_battle_request(
    redis: &mut ConnectionManager,
    channel: &str,
    request: &BattleRequest,
) -> Result<usize, String> {
    let json = serde_json::to_string(request)
        .map_err(|e| format!("Failed to serialize BattleRequest: {}", e))?;

    // TODO: subscriber_count ë¥¼ í™œìš©í•˜ì—¬ Game Server ìƒì¡´ ì—¬ë¶€ í™•ì¸, ì˜¤ë¥˜ ì „íŒŒ ë“± êµ¬í˜„í•´ì•¼í•¨.
    let subscriber_count = redis
        .publish(channel, json)
        .await
        .map_err(|e| format!("Failed to publish battle request: {}", e))?;

    Ok(subscriber_count)
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PlayerCandidate {
    pub player_id: String,
    pub score: i64,
    pub pod_id: String,
    pub metadata: serde_json::Value,
}
</file>

<file path="src/matchmaker/patry/mod.rs">

</file>

<file path="src/matchmaker/rank/handlers.rs">
use actix::{dev::ContextFutureSpawner, ActorContext, Handler, WrapFuture};
use backoff::backoff::Backoff;
use tokio::time::sleep;
use tracing::{error, info, warn};

use crate::{
    matchmaker::{
        messages::{Dequeue, Enqueue, TryMatch},
        operations::{
            dequeue::dequeue,
            enqueue::{enqueue, re_enqueue_candidates},
            notify,
            try_match::{pop_candidates, publish_battle_request},
        },
        rank::RankedMatchmaker,
        MatchmakerDeps,
    },
    protocol::{BattleRequest, ErrorCode, ServerMessage},
    GameMode, Stop, RETRY_CONFIG,
};

impl Handler<Enqueue> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Enqueue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Ranked {
                warn!(
                    "Player {} tried to enqueue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            enqueue(queue_prefix, msg.game_mode, player_id, msg.metadata, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Dequeue> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Dequeue, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let game_mode = msg.game_mode;
        let queue_prefix = self.queue_suffix(game_mode);
        let player_id = msg.player_id;
        let mut redis = deps.redis.clone();

        async move {
            if game_mode != GameMode::Ranked {
                warn!(
                    "Player {} tried to dequeue using mismatched matchmaker for mode {:?}",
                    player_id, game_mode
                );
                notify::send_message_to_player(
                    deps.subscription_addr,
                    &mut redis,
                    player_id,
                    ServerMessage::Error {
                        code: ErrorCode::InvalidGameMode,
                        message: "Invalid game mode".to_string(),
                    },
                )
                .await;
                return;
            }
            dequeue(queue_prefix, msg.game_mode, player_id, &deps).await;
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<TryMatch> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: TryMatch, ctx: &mut Self::Context) -> Self::Result {
        let deps: MatchmakerDeps = (&self.inner).into();
        let settings = msg.match_mode_settings;
        let queue_suffix = self.queue_suffix(settings.game_mode);
        let required_players = settings.required_players;
        let mut redis = deps.redis.clone();
        let shutdown_token = self.shutdown_token.clone();

        async move {
            // ì¢…ë£Œ ì‹ í˜¸ ì²´í¬
            if shutdown_token.is_cancelled() {
                info!("TryMatch cancelled due to shutdown");
                return;
            }
            let mut backoff = RETRY_CONFIG
                .read()
                .unwrap()
                .as_ref()
                .expect("Retry config not initialized")
                .clone();

            let candidates = loop {
                // ì¢…ë£Œ ì‹ í˜¸ ì²´í¬
                if shutdown_token.is_cancelled() {
                    info!("TryMatch cancelled during candidate pop");
                    return;
                }

                match pop_candidates(queue_suffix, required_players as usize * 2, &deps).await {
                    Ok(candidates) => break candidates,
                    Err(err) => {
                        if let Some(delay) = backoff.next_backoff() {
                            warn!(
                                "Failed to pop candidates from queue {}: {} (retrying in {:?})",
                                queue_suffix, err, delay
                            );
                            // ì¢…ë£Œ ì‹ í˜¸ì™€ í•¨ê»˜ ëŒ€ê¸°
                            tokio::select! {
                                _ = sleep(delay) => continue,
                                _ = shutdown_token.cancelled() => {
                                    info!("TryMatch cancelled during backoff");
                                    return;
                                }
                            }
                        } else {
                            error!(
                                "Failed to pop candidates after all retries from queue {}: {}",
                                queue_suffix, err
                            );
                            return; // async move ë¸”ë¡ ì¢…ë£Œ
                        }
                    }
                }
            };

            if candidates.is_empty() {
                warn!("No candidates available");
                return;
            }

            // try_match ì— ì˜í•´ 4ëª…ì´ ìˆ˜ì§‘ë˜ëŠ”ë°, ëª¨ì¢…ì˜ ì´ìœ ë¡œ 0~3ëª…ì´ ìˆ˜ì§‘ë  ìˆ˜ ìˆìŒ.
            // candidates ì—ì„œ 2ëª…ì”© êº¼ë‚´ì–´ ë§¤ì¹­ì„ ì‹œë„í•˜ê³ , ë‚¨ì€ ì¸ì›ì€ Re enqueue
            // 2ëª…ì”© ë¬¶ì–´ì„œ ì²˜ë¦¬
            for chunk in candidates.chunks(2) {
                // ì¢…ë£Œ ì‹ í˜¸ ì²´í¬ - ì´ë¯¸ popí•œ candidatesëŠ” re-enqueue
                if shutdown_token.is_cancelled() {
                    warn!("Shutdown requested, re-enqueueing remaining candidates");
                    re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps).await;
                    continue;
                }

                match chunk {
                    [player1, player2] => {
                        // 2ëª… ë§¤ì¹­
                        let request = BattleRequest {
                            player1: player1.clone(),
                            player2: player2.clone(),
                        };

                        match publish_battle_request(
                            &mut redis,
                            &deps.settings.battle_request_channel,
                            &request,
                        )
                        .await
                        {
                            Ok(subscriber_count) => {
                                if subscriber_count == 0 {
                                    // TODO: Game Server ê°€ êµ¬ë…ì¤‘ì´ì§€ ì•ŠìŒ. -> Game Server ê°€ ì£½ì–´ìˆì„ ê°€ëŠ¥ì„±ì´ ì¡´ì¬í•¨.
                                    // ìì„¸í•˜ê²Œ ì˜¤ë¥˜ íŒŒì•…í•˜ê³  ê´€ë¦¬ ì‹œìŠ¤í…œì—ê²Œ ë³´ê³  í•´ì•¼í•¨ ( Orchestrator )
                                    warn!("No Game Server is subscribed to battle:request channel");
                                    // ë§¤ì¹­ ì‹¤íŒ¨: player1, player2 re enqueue
                                    let failed_match = [player1.clone(), player2.clone()];
                                    re_enqueue_candidates(
                                        queue_suffix,
                                        settings.game_mode,
                                        &failed_match,
                                        &deps,
                                    )
                                    .await;
                                } else {
                                    // Metrics: ë§¤ì¹­ ì„±ê³µ
                                    metrics::MATCHES_CREATED_TOTAL.inc();
                                    metrics::MATCHED_PLAYERS_TOTAL_BY_MODE
                                        .with_label_values(&[&format!("{:?}", settings.game_mode)])
                                        .inc_by(2);

                                    info!(
                                        "Battle request sent to {} Game Server(s) for players {} and {}",
                                        subscriber_count, player1.player_id, player2.player_id
                                    );
                                }
                            }
                            Err(err) => {
                                error!("Failed to publish battle request: {}", err);
                                // ë§¤ì¹­ ì‹¤íŒ¨: player1, player2 re enqueue
                                let failed_match = [player1.clone(), player2.clone()];
                                re_enqueue_candidates(
                                    queue_suffix,
                                    settings.game_mode,
                                    &failed_match,
                                    &deps,
                                )
                                .await;
                            }
                        }
                    }
                    [single] => {
                        // 1ëª… ë‚¨ìŒ, re enqueue
                        info!("Single player left, re-enqueueing: {}", single.player_id);
                        re_enqueue_candidates(queue_suffix, settings.game_mode, chunk, &deps)
                            .await;
                    }
                    _ => unreachable!("chunks(2) only returns 1 or 2 elements"),
                }
            }
        }
        .into_actor(self)
        .wait(ctx);
    }
}

impl Handler<Stop> for RankedMatchmaker {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "RankedMatchmaker for mode {:?} stopping: {:?}",
            self.mode_settings.game_mode, msg.reason
        );
        ctx.stop();
    }
}
</file>

<file path="src/matchmaker/rank/mod.rs">
use std::{
    ops::{Deref, DerefMut},
    time::Duration,
};

use actix::{Actor, Addr, AsyncContext};
use redis::aio::ConnectionManager;
use tokio_util::sync::CancellationToken;
use tracing::{info, warn};

pub mod handlers;

use crate::{
    env::{MatchModeSettings, MatchmakingSettings},
    matchmaker::{common::MatchmakerInner, messages::TryMatch},
    metrics::MetricsCtx,
    subscript::SubScriptionManager,
};

pub struct RankedMatchmaker {
    inner: MatchmakerInner,
}

impl Deref for RankedMatchmaker {
    type Target = MatchmakerInner;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl DerefMut for RankedMatchmaker {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl RankedMatchmaker {
    pub fn new(
        redis: ConnectionManager,
        settings: MatchmakingSettings,
        mode_settings: MatchModeSettings,
        sub_manager_addr: Addr<SubScriptionManager>,
        metrics: std::sync::Arc<MetricsCtx>,
        shutdown_token: CancellationToken,
    ) -> Self {
        Self {
            inner: MatchmakerInner::new(redis, settings, mode_settings, sub_manager_addr, metrics, shutdown_token),
        }
    }
}

impl Actor for RankedMatchmaker {
    type Context = actix::Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!(
            "RankedMatchmaker actor started for mode {:?}",
            self.mode_settings.game_mode
        );
        let interval = self.settings.try_match_tick_interval_seconds;
        let mode_settings = self.mode_settings.clone();

        ctx.run_interval(Duration::from_secs(interval), move |_actor, ctx| {
            ctx.notify(TryMatch {
                match_mode_settings: mode_settings.clone(),
            });
        });
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> actix::Running {
        info!(
            "RankedMatchmaker for mode {:?} stopping, cancelling futures",
            self.mode_settings.game_mode
        );

        // ëª¨ë“  ì‹¤í–‰ ì¤‘ì¸ futureì—ê²Œ ì¢…ë£Œ ì‹ í˜¸
        self.shutdown_token.cancel();

        // ì™„ë£Œ ëŒ€ê¸° (íƒ€ì„ì•„ì›ƒ 25ì´ˆ)
        if ctx.waiting() {
            info!("Waiting for pending futures to complete");
            ctx.run_later(Duration::from_secs(25), |_act, _ctx| {
                warn!("Graceful shutdown timeout, force stopping");
            });
            actix::Running::Continue
        } else {
            info!("No pending futures, stopping immediately");
            actix::Running::Stop
        }
    }
}
</file>

<file path="src/matchmaker/scripts.rs">
const ENQUEUE_PLAYER_SCRIPT: &str = include_str!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/scripts/ENQUEUE_PLAYER.lua"
));
const DEQUEUE_PLAYER_SCRIPT: &str = include_str!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/scripts/DEQUEUE_PLAYER.lua"
));
const TRY_MATCH_POP_SCRIPT: &str = include_str!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/scripts/TRY_MATCH_POP.lua"
));

pub fn enqueue_player_script() -> &'static str {
    ENQUEUE_PLAYER_SCRIPT
}

pub fn dequeue_player_script() -> &'static str {
    DEQUEUE_PLAYER_SCRIPT
}

pub fn try_match_pop_script() -> &'static str {
    TRY_MATCH_POP_SCRIPT
}
</file>

<file path="src/metrics.rs">
pub struct MetricsCtx;

impl MetricsCtx {
    pub fn new() -> Self {
        Self
    }
    pub fn inc_redis_connection_failure(&self) {
        metrics::REDIS_CONNECTION_FAILURES_TOTAL.inc();
    }
}
</file>

<file path="src/protocol.rs">
use actix::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{matchmaker::operations::try_match::PlayerCandidate, GameMode};

// --- Client to Server Messages ---

#[derive(Deserialize, Message)]
#[rtype(result = "()")]
#[serde(tag = "type")]
pub enum ClientMessage {
    /// í”Œë ˆì´ì–´ê°€ ë§¤ì¹­ ëŒ€ê¸°ì—´ì— ë“¤ì–´ê°€ê¸°ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤.
    #[serde(rename = "enqueue")]
    Enqueue {
        player_id: Uuid,
        game_mode: GameMode,
        metadata: String,
    },

    /// í”Œë ˆì´ì–´ê°€ ë§¤ì¹­ ëŒ€ê¸°ì—´ì—ì„œ ë‚˜ê°€ê¸°ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤.
    #[serde(rename = "dequeue")]
    Dequeue {
        player_id: Uuid,
        game_mode: GameMode,
    },
}

// --- Server to Client Messages ---
#[derive(Serialize, Deserialize, Message, Clone)]
#[rtype(result = "()")]
#[serde(tag = "type")]
pub enum ServerMessage {
    /// ëŒ€ê¸°ì—´ì— ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŒì„ ì•Œë¦½ë‹ˆë‹¤.
    #[serde(rename = "enqueued")]
    EnQueued,

    /// ëŒ€ê¸°ì—´ì—ì„œ ì„±ê³µì ìœ¼ë¡œ ì œê±°ë˜ì—ˆìŒì„ ì•Œë¦½ë‹ˆë‹¤.
    #[serde(rename = "dequeued")]
    DeQueued,

    /// ìµœì¢…ì ìœ¼ë¡œ ë§¤ì¹­ì´ ì„±ì‚¬ë˜ì—ˆê³ , ê²Œì„ ì„œë²„ ì ‘ì† ì •ë³´ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
    #[serde(rename = "match_found")]
    MatchFound {
        session_id: Uuid, // dedicated_serverì˜ ê²Œì„ ì„¸ì…˜ ID
        server_address: String,
    },

    /// ì—ëŸ¬ê°€ ë°œìƒí–ˆìŒì„ ì•Œë¦½ë‹ˆë‹¤.
    /// codeëŠ” ì„ íƒì ì´ë©°, êµ¬ í´ë¼ì´ì–¸íŠ¸ì™€ì˜ í˜¸í™˜ì„ ìœ„í•´ ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    #[serde(rename = "error")]
    Error { code: ErrorCode, message: String },
}

#[derive(Serialize, Deserialize, Message, Clone, Debug)]
#[rtype(result = "()")]
#[serde(rename_all = "snake_case")]
pub enum ErrorCode {
    InvalidGameMode,
    AlreadyInQueue,
    InternalError,
    NotInQueue,
    InvalidMessageFormat,
    WrongSessionId,
    TemporaryAllocationError,
    DedicatedServerTimeout,
    DedicatedServerErrorResponse,
    MaxRetriesExceeded,
    MatchmakingTimeout,
    PlayerTemporarilyBlocked,
    RateLimitExceeded,
}

// --- Battle Request Messages ---

/// Match Serverê°€ Game Serverë¡œ ì „ì†¡í•˜ëŠ” ì „íˆ¬ ìš”ì²­
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BattleRequest {
    pub player1: PlayerCandidate,
    pub player2: PlayerCandidate,
}

/*
  ---
  ğŸ“‹ ì „ì²´ ìš”ì•½í‘œ

  | ìœ„ì¹˜                     | Metric                                 | íƒ€ì…         | ì¤‘ìš”ë„ |
  |------------------------|----------------------------------------|------------|-----|
  | session/mod.rs:113     | ACTIVE_WS_CONNECTIONS.inc()            | Gauge      | â­â­â­ |
  | session/mod.rs:120     | ACTIVE_WS_CONNECTIONS.dec()            | Gauge      | â­â­â­ |
  | enqueue.rs:133         | PLAYERS_ENQUEUED_NEW_TOTAL.inc()       | Counter    | â­â­â­ |
  | enqueue.rs:133         | ENQUEUED_TOTAL_BY_MODE                 | CounterVec | â­â­â­ |
  | enqueue.rs:140         | ABNORMAL_DUPLICATE_ENQUEUE_TOTAL.inc() | Counter    | â­â­  |
  | enqueue.rs:150         | PLAYERS_REQUEUED_TOTAL.inc_by(n)       | Counter    | â­â­  |
  | rank/handlers.rs:196   | MATCHES_CREATED_TOTAL.inc()            | Counter    | â­â­â­ |
  | rank/handlers.rs:196   | MATCHED_PLAYERS_TOTAL_BY_MODE          | CounterVec | â­â­â­ |
  | normal/handlers.rs:196 | (ë™ì¼)                                   | -          | â­â­â­ |
  | session/mod.rs:61      | STATE_VIOLATIONS_TOTAL.inc()           | Counter    | â­â­  |
  | session/helper.rs:12   | MATCHMAKING_ERRORS_TOTAL.inc()         | Counter    | â­   |

  ---
  ğŸ¯ ìš°ì„ ìˆœìœ„ë³„ ì¶”ê°€ ìˆœì„œ

  Phase 1: í•„ìˆ˜ (5ë¶„)

  1. âœ… ACTIVE_WS_CONNECTIONS (Session ìƒëª…ì£¼ê¸°)
  2. âœ… PLAYERS_ENQUEUED_NEW_TOTAL (Enqueue)
  3. âœ… MATCHES_CREATED_TOTAL (ë§¤ì¹­ ì„±ê³µ)

  Phase 2: ì¤‘ìš” (10ë¶„)

  4. âœ… ENQUEUED_TOTAL_BY_MODE (ëª¨ë“œë³„ ë¶„ì„)
  5. âœ… MATCHED_PLAYERS_TOTAL_BY_MODE (ëª¨ë“œë³„ ë§¤ì¹­)
  6. âœ… PLAYERS_REQUEUED_TOTAL (ì¬ì‹œë„ ì¶”ì )

  Phase 3: ë¶€ê°€ (5ë¶„)

  7. âœ… ABNORMAL_DUPLICATE_ENQUEUE_TOTAL (ì´ìƒ í–‰ë™)
  8. âœ… STATE_VIOLATIONS_TOTAL (í”„ë¡œí† ì½œ ìœ„ë°˜)
  9. âœ… MATCHMAKING_ERRORS_TOTAL (ì—ëŸ¬ ì¶”ì )

  ---
  ğŸ’¡ ì‚¬ìš©í•˜ì§€ ì•Šì„ Metrics (Game Serverìš©)

  ë‹¤ìŒ metricsëŠ” Match Serverê°€ ì•„ë‹Œ Game Serverì—ì„œ ì‚¬ìš©:
  - âŒ LOADING_COMPLETED_TOTAL_BY_MODE
  - âŒ DEDICATED_ALLOCATION_SUCCESS_TOTAL_BY_MODE
  - âŒ LOADING_DURATION_SECONDS
  - âŒ PLAYERS_ALLOCATED_TOTAL
  - âŒ LOADING_SESSION_TIMEOUT_PLAYERS_TOTAL

  ---
  ì „ë¶€ ì¶”ê°€í•´ë“œë¦´ê¹Œìš”? ì•„ë‹ˆë©´ Phase 1ë§Œ ë¨¼ì € êµ¬í˜„í• ê¹Œìš”?

*/
</file>

<file path="src/session/handlers.rs">
use crate::{
    protocol::{ClientMessage, ErrorCode, ServerMessage},
    session::{
        helper::{send_err, SessionState},
        Session,
    },
    Stop,
};
use actix::{ActorContext, Handler, StreamHandler};
use actix_web_actors::ws::{self, Message, ProtocolError};
use tracing::{info, warn};

impl Handler<Stop> for Session {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "Stop message received in Session actor. Stopping actor. {:?}",
            msg.reason
        );
        ctx.stop();
    }
}

// SubScription, Matchmaker ( í•˜ìœ„ ì•¡í„° ) ëŠ” Session ì„ ê±°ì³ì„œ Client ì™€ í†µì‹ í•¨.
impl Handler<ServerMessage> for Session {
    type Result = ();

    fn handle(&mut self, msg: ServerMessage, ctx: &mut Self::Context) -> Self::Result {
        match &msg {
            ServerMessage::EnQueued => {
                // í•˜ìœ„ ì•¡í„°ì—ì„œ Client ì—ê²Œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ë‹¤ëŠ” ê²ƒì€, Queue ì— ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë˜ì—ˆìŒì„ ì˜ë¯¸í•¨.
                self.transition_to(SessionState::InQueue, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::EnQueued");
                }
            }
            ServerMessage::DeQueued => {
                self.transition_to(SessionState::Dequeued, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::DeQueued");
                }
            }
            ServerMessage::MatchFound {
                session_id: _,
                server_address: _,
            } => {
                self.transition_to(SessionState::Completed, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::MatchFound");
                }
                ctx.close(Some(ws::CloseCode::Normal.into()));
                ctx.stop();
            }
            ServerMessage::Error {
                code: _,
                message: _,
            } => {
                self.transition_to(SessionState::Error, ctx);
                if let Ok(json) = serde_json::to_string(&msg) {
                    ctx.text(json);
                } else {
                    warn!("Failed to serialize ServerMessage::Error");
                }
                ctx.stop();
            }
        }
    }
}

impl StreamHandler<Result<Message, ProtocolError>> for Session {
    fn handle(&mut self, msg: Result<Message, ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {}
            Ok(ws::Message::Text(text)) => match serde_json::from_str::<ClientMessage>(&text) {
                Ok(ClientMessage::Enqueue {
                    player_id,
                    game_mode,
                    metadata,
                }) => {
                    self.handle_enqueue(ctx, player_id, game_mode, metadata);
                }
                Ok(ClientMessage::Dequeue {
                    player_id,
                    game_mode,
                }) => {
                    self.handle_dequeue(ctx, player_id, game_mode);
                }
                Err(e) => {
                    warn!("Failed to parse client message: {}", e);
                    send_err(
                        ctx,
                        ErrorCode::InvalidMessageFormat,
                        "Invalid message format",
                    );
                }
            },
            Ok(ws::Message::Close(reason)) => {
                ctx.close(reason);
                ctx.stop();
            }
            _ => ctx.stop(),
        }
    }
}
</file>

<file path="src/session/helper.rs">
use crate::{
    protocol::{ErrorCode, ServerMessage},
    session::Ctx,
};

pub enum TransitionViolation {
    Minor,
    Major,
    Critical,
}

pub fn send_err(ctx: &mut Ctx, code: ErrorCode, message: &str) {
    // Metrics: ì—ëŸ¬ ë©”ì‹œì§€ ì¹´ìš´íŠ¸
    metrics::MATCHMAKING_ERRORS_TOTAL.inc();

    if let Ok(text) = serde_json::to_string(&ServerMessage::Error {
        code: code,
        message: message.to_string(),
    }) {
        ctx.text(text);
    }
}

pub fn classify_violation(from: SessionState, to: SessionState) -> TransitionViolation {
    use SessionState::*;
    match (from, to) {
        // í´ë¼ì´ì–¸íŠ¸ íƒ€ì´ë° ì´ìŠˆ (ê²½ë¯¸í•¨)
        (InQueue, Enqueuing) => TransitionViolation::Minor,
        (InQueue, Dequeuing) if from == to => TransitionViolation::Minor,

        // ë…¼ë¦¬ì  ëª¨ìˆœ (ì‹¬ê°í•¨)
        (Completed, Enqueuing) => TransitionViolation::Major,
        (Completed, Dequeuing) => TransitionViolation::Major,

        // ëª…ë°±í•œ í”„ë¡œí† ì½œ ìœ„ë°˜ (ì¹˜ëª…ì )
        (Error, InQueue) => TransitionViolation::Critical,
        (Error, Enqueuing) => TransitionViolation::Critical,

        _ => TransitionViolation::Major,
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum SessionState {
    Idle,          // ì´ˆê¸° ìƒíƒœ. ì„¸ì…˜ ìƒì„± ì§í›„.
    Enqueuing,     // Enqueue ìš”ì²­ì„ ë°›ê³  ëŒ€ê¸°ì—´ì— ë“±ë¡ ì¤‘.
    InQueue,       // íì— ì„±ê³µì ìœ¼ë¡œ ë“±ë¡ë¨.
    Dequeuing,     // Dequeue ìš”ì²­ì„ ë°›ê³  ëŒ€ê¸°ì—´ì—ì„œ ì œê±° ì¤‘.
    Dequeued,      // íì—ì„œ ì„±ê³µì ìœ¼ë¡œ ì œê±°ë¨.
    Completed,     // ì •ìƒì ìœ¼ë¡œ ë§¤ì¹­ì´ ì„±ì‚¬ë¨.
    Disconnecting, // ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë¨.
    Error,         // ì˜¤ë¥˜ ë°œìƒìœ¼ë¡œ ì¸í•œ ì„¸ì…˜ ì¢…ë£Œ ìƒíƒœ.
}

impl SessionState {
    pub fn can_transition_to(&self, new_state: SessionState) -> bool {
        use SessionState::*;
        match (self, new_state) {
            // From Idle
            (Idle, Enqueuing) => true,
            (Idle, Error) => true,

            // From Enqueuing
            (Enqueuing, InQueue) => true,
            (Enqueuing, Error) => true,
            (Enqueuing, Disconnecting) => true,

            // From InQueue
            (InQueue, Dequeuing) => true,
            (InQueue, Completed) => true,
            (InQueue, Error) => true,
            (InQueue, Disconnecting) => true,

            // From Dequeuing
            (Dequeuing, Dequeued) => true,
            (Dequeuing, Error) => true,
            (Dequeuing, Disconnecting) => true,

            // From Dequeued
            (Dequeued, Enqueuing) => true,
            (Dequeued, Error) => true,
            (Dequeued, Disconnecting) => true,

            // From Completed
            (Completed, Disconnecting) => true,
            (Completed, Error) => true,

            // Disconnecting, Error ì—ì„œ State ì „í™˜ ë¶ˆê°€.
            _ => false,
        }
    }

    /// Get human-readable description of the state
    pub fn description(&self) -> &'static str {
        match self {
            SessionState::Idle => "Waiting for player input",
            SessionState::Enqueuing => "Processing enqueue request",
            SessionState::InQueue => "Waiting for match",
            SessionState::Dequeuing => "Processing dequeue request",
            SessionState::Dequeued => "Dequeued from queue",
            SessionState::Completed => "Match completed successfully",
            SessionState::Disconnecting => "Cleaning up connection",
            SessionState::Error => "Error occurred, cleaning up",
        }
    }
}
</file>

<file path="src/session/mod.rs">
use crate::matchmaker::messages::{Dequeue, Enqueue};
use crate::protocol::ErrorCode;
use crate::session::helper::{classify_violation, send_err, SessionState, TransitionViolation};
use crate::subscript::messages::{Deregister, Register};
use crate::{matchmaker::MatchmakerAddr, subscript::SubScriptionManager, AppState, GameMode};
use crate::{Stop, StopReason};
use actix::dev::ContextFutureSpawner;
use actix::ActorContext;
use actix::{Actor, Addr, WrapFuture};
use actix::{AsyncContext, Running};
use actix_web::web;
use actix_web_actors::ws::{self};
use std::cell::OnceCell;
use std::time::Instant;
use std::{net::IpAddr, time::Duration};
use tracing::{info, warn};
use uuid::Uuid;

pub mod handlers;
pub mod helper;

type Ctx = ws::WebsocketContext<Session>;

pub struct Session {
    state: SessionState,
    matchmaker_addr: OnceCell<MatchmakerAddr>,
    subscript_addr: Addr<SubScriptionManager>,
    app_state: web::Data<AppState>,
    player_id: Uuid,
    game_mode: GameMode,
    heartbeat_interval: Duration,
    heartbeat_timeout: Duration,
    last_heartbeat: Instant,
    cleanup_started: bool,
    client_ip: IpAddr,
}

impl Session {
    pub fn new(
        subscript_addr: Addr<SubScriptionManager>,
        heartbeat_interval: Duration,
        heartbeat_timeout: Duration,
        app_state: web::Data<AppState>,
        client_ip: IpAddr,
    ) -> Self {
        Self {
            state: SessionState::Idle,
            matchmaker_addr: OnceCell::new(),
            subscript_addr,
            app_state,
            player_id: Uuid::new_v4(),
            game_mode: GameMode::None,
            heartbeat_interval,
            heartbeat_timeout,
            last_heartbeat: Instant::now(),
            cleanup_started: false,
            client_ip,
        }
    }

    fn transition_to(&mut self, new_state: SessionState, ctx: &mut ws::WebsocketContext<Self>) {
        // ìœ íš¨í•œ ìƒíƒœ ì „í™˜ì¸ì§€ í™•ì¸. ë§Œì•½ ìœ íš¨í•˜ì§€ ì•Šë‹¤ë©´ Error ìƒíƒœë¡œ ì „í™˜ í›„ error ë©”ì‹œì§€ ì „ì†¡.
        if !self.state.can_transition_to(new_state) {
            let violation = classify_violation(self.state, new_state);

            // Metrics: ìƒíƒœ ì „í™˜ ìœ„ë°˜
            metrics::STATE_VIOLATIONS_TOTAL.inc();

            match violation {
                TransitionViolation::Minor => {
                    warn!("Minor state violation, ignoring transition");
                    return; // í˜„ì¬ ìƒíƒœ ìœ ì§€
                }

                TransitionViolation::Major => {
                    self.state = SessionState::Error;
                    send_err(ctx, ErrorCode::InternalError, "Invalid state transition");
                    return;
                }

                TransitionViolation::Critical => {
                    send_err(ctx, ErrorCode::InternalError, "Critical protocol violation");
                    // ë©”ì‹œì§€ ì „ì†¡ í›„ ì•½ê°„ ëŒ€ê¸° í›„ ìš°ì•„í•˜ê²Œ ì¢…ë£Œ
                    ctx.run_later(Duration::from_millis(100), |_act, ctx| {
                        ctx.close(Some(ws::CloseCode::Protocol.into()));
                        ctx.stop();
                    });
                    return;
                }
            }
        }
        let old_state = self.state;
        self.state = new_state;

        info!(
            "Player {:?} transitioned: {} -> {}",
            self.player_id,
            old_state.description(),
            new_state.description()
        );
    }

    fn hb(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_interval(self.heartbeat_interval, |act, ctx| {
            if act.last_heartbeat.elapsed() > act.heartbeat_timeout {
                info!("Websocket Client heartbeat failed, disconnecting!");
                ctx.stop();
                return;
            }
            ctx.ping(b"");
        });
    }
}

impl Actor for Session {
    type Context = Ctx;

    fn started(&mut self, ctx: &mut Self::Context) {
        info!("Session started for player {:?}", self.player_id);

        // Metrics: WebSocket ì—°ê²° ì¦ê°€
        metrics::ACTIVE_WS_CONNECTIONS.inc();

        self.transition_to(SessionState::Idle, ctx);

        self.hb(ctx);
    }

    fn stopping(&mut self, ctx: &mut Self::Context) -> Running {
        info!("Session stopping for player {:#?}", self.player_id);

        // Metrics: WebSocket ì—°ê²° ê°ì†Œ
        metrics::ACTIVE_WS_CONNECTIONS.dec();

        if self.cleanup_started {
            return Running::Stop;
        }

        self.cleanup_started = true;

        ctx.run_later(Duration::from_secs(10), |_act, ctx| {
            warn!("Cleanup wachdog triggered - forcing shutdown");
            ctx.stop();
        });

        let matchmaker_addr = self.matchmaker_addr.get().cloned();
        let subscription_addr = self.subscript_addr.clone();
        let ctx_clone = ctx.address();
        let player_id = self.player_id.clone();
        let game_mode = self.game_mode.clone();

        async move {
            let res_match = if let Some(addr) = matchmaker_addr {
                addr.dequeue(Dequeue {
                    player_id,
                    game_mode,
                })
                .await
            } else {
                Ok(())
            };
            let res_sub = subscription_addr.send(Deregister { player_id }).await;

            match (res_match, res_sub) {
                (Ok(()), Ok(())) => {
                    info!("Successfully sent message to matchmaker and subscription manager.")
                }
                (Ok(()), Err(e)) => {
                    warn!("Failed to send Dequeue to matchmaker manager. : {:?}", e)
                }
                (Err(e), Ok(())) => warn!(
                    "Failed to send Deregister to subscription manager. : {:?}",
                    e
                ),
                (Err(e), Err(_e)) => warn!(
                    "Failed to send message to matchmaker and subscription manager. {:?}, {:?}",
                    e, _e
                ),
            }

            ctx_clone.do_send(Stop {
                reason: StopReason::GracefulShutdown,
            });
        }
        .into_actor(self)
        .wait(ctx);

        Running::Continue
    }
}

impl Session {
    fn handle_enqueue(
        &mut self,
        ctx: &mut Ctx,
        player_id: Uuid,
        game_mode: GameMode,
        metadata: String,
    ) {
        // Rate limiting check
        if !self.app_state.rate_limiter.check(&self.client_ip) {
            warn!("Rate limit exceeded for IP: {}", self.client_ip);
            send_err(
                ctx,
                ErrorCode::RateLimitExceeded,
                "Too many requests. Please slow down.",
            );
            return;
        }

        // Session ê°ì²´ ìƒíƒœê°€ Idle ì—ì„œë§Œ Enqueue í—ˆìš©
        if self.state != SessionState::Idle && self.state != SessionState::Error {
            warn!(
                "Player {:?} sent Enqueue request in invalid state: {:?}. Ignoring.",
                self.player_id, self.state
            );
            return;
        }

        let matchmaker = match self.resolve_matchmaker(game_mode) {
            Ok(handle) => handle,
            Err(code) => {
                send_err(ctx, code, "Unsupported game mode");
                return;
            }
        };

        self.transition_to(SessionState::Enqueuing, ctx);

        self.player_id = player_id;
        self.game_mode = game_mode;
        matchmaker.do_send_enqueue(Enqueue {
            player_id: self.player_id,
            game_mode: self.game_mode,
            metadata,
        });

        self.subscript_addr.do_send(Register {
            player_id,
            addr: ctx.address(),
        });
    }

    fn handle_dequeue(&mut self, ctx: &mut Ctx, player_id: Uuid, game_mode: GameMode) {
        // InQueue ìƒíƒœì—ì„œë§Œ Dequeue í—ˆìš©
        if self.state != SessionState::InQueue {
            warn!(
                "Player {:?} sent Dequeue request in invalid state: {:?}. Ignoring.",
                self.player_id, self.state
            );
            return;
        }

        // player_id ê²€ì¦
        if self.player_id != player_id {
            send_err(ctx, ErrorCode::WrongSessionId, "Player ID mismatch");
            return;
        }

        let matchmaker = match self.resolve_matchmaker(game_mode) {
            Ok(handle) => handle,
            Err(code) => {
                send_err(ctx, code, "Unsupported game mode");
                return;
            }
        };

        self.transition_to(SessionState::Dequeuing, ctx);

        matchmaker.do_send_dequeue(Dequeue {
            player_id: self.player_id,
            game_mode: self.game_mode,
        });
    }
}

impl Session {
    fn resolve_matchmaker(&mut self, game_mode: GameMode) -> Result<MatchmakerAddr, ErrorCode> {
        if let Some(existing) = self.matchmaker_addr.get() {
            return Ok(existing.clone());
        }

        let handle = self
            .app_state
            .matchmakers
            .get(&game_mode)
            .cloned()
            .ok_or(ErrorCode::InvalidGameMode)?;

        let _ = self.matchmaker_addr.set(handle.clone());

        Ok(handle)
    }
}
</file>

<file path="src/subscript/handlers.rs">
use actix::{ActorContext, Context, Handler};
use tracing::{info, warn};

use crate::{
    subscript::{
        messages::{Deregister, ForwardServerMessage, Register},
        SubScriptionManager,
    },
    Stop,
};

impl Handler<ForwardServerMessage> for SubScriptionManager {
    type Result = ();
    fn handle(&mut self, msg: ForwardServerMessage, _ctx: &mut Context<Self>) -> Self::Result {
        if let Some(session_addr) = self.sessions.get(&msg.player_id) {
            session_addr.do_send(msg.message);
        } else {
            warn!(
                "Could not find session for player {} to forward message.",
                msg.player_id
            );
        }
    }
}

impl Handler<Register> for SubScriptionManager {
    type Result = ();
    fn handle(&mut self, msg: Register, _ctx: &mut Context<Self>) -> Self::Result {
        info!("Player {} registered for notifications.", msg.player_id);
        self.sessions.insert(msg.player_id, msg.addr);
    }
}

impl Handler<Deregister> for SubScriptionManager {
    type Result = ();
    fn handle(&mut self, msg: Deregister, _ctx: &mut Context<Self>) -> Self::Result {
        info!("Player {} deregistered.", msg.player_id);
        let _ = self.sessions.remove(&msg.player_id);
    }
}

impl Handler<Stop> for SubScriptionManager {
    type Result = ();

    fn handle(&mut self, msg: Stop, ctx: &mut Self::Context) -> Self::Result {
        info!(
            "Stop message received in SubScriptionManager actor. Stopping actor. {:?}",
            msg.reason
        );
        self.sessions.clear();
        ctx.stop();
    }
}
</file>

<file path="src/subscript/messages.rs">
use actix::{Addr, Message};
use uuid::Uuid;

use crate::{protocol::ServerMessage, session::Session};

#[derive(Message)]
#[rtype(result = "()")]
pub struct Register {
    pub player_id: Uuid,
    pub addr: Addr<Session>,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct Deregister {
    pub player_id: Uuid,
}

#[derive(Message)]
#[rtype(result = "()")]
pub struct ForwardServerMessage {
    pub player_id: Uuid,
    pub message: ServerMessage,
}
</file>

<file path="src/subscript/mod.rs">
use std::collections::HashMap;

use actix::{Actor, Addr, Context};
use uuid::Uuid;

use crate::session::Session;

pub mod handlers;
pub mod messages;

pub struct SubScriptionManager {
    pub sessions: HashMap<Uuid, Addr<Session>>,
}

impl Actor for SubScriptionManager {
    type Context = Context<Self>;
}

impl SubScriptionManager {
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
        }
    }
}
</file>

</files>
